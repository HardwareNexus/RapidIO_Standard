#!/usr/bin/env python
# -*- coding: latin-1 -*-
"""
    Merge the outlines of the RapidIO standards.

    Takes the "outline" output generated by parse_rapidio_standard.py
    and merges them into a single outline. 
    Creates schema based on:
    Part Number (1-13)
    Chapter Number (H2)
    Section Number (H3-H6)
    (list of revisions)

"""

from optparse import OptionParser
from collections import OrderedDict
import re
import sys
import os
import logging

class RapidIOOutlineMerger(object):
    def _init_translations(self):
        self.trans = {}
        self.trans_revs = []
        for trans in sorted(self.translations):
            line1_errmsg = ("Translation file '" + trans +
                      "' line 1 does not contain two revision numbers:")
            trans_file = open(trans)
            trans_lines = trans_file.readlines()
            trans_file.close()

            # first line should contain two specification revision numbers
            revs = [rev.strip() for rev in trans_lines[0].split(',')]
            if not len(revs) == 2:
                raise ValueError(line1_errmsg + str(revs))
            try:
                first_rev = float(revs[0])
                second_rev = float(revs[1])
            except ValueError:
                raise ValueError(line1_errmsg + str(revs))

            if not self.trans_revs:
                self.trans_revs.append(revs[0])
                self.trans_revs.append(revs[1])
            elif revs[0] == self.trans_revs[-1]:
                self.trans_revs.append(revs[1])
            else:
                raise ValueError("Incomplete translation support, trans_revs " +
                                  str(self.trans_revs) + " revisions " +
                                  str(revs))

            rev_key = revs[1] + "->" + revs[0]

            for i, line in enumerate(trans_lines[1:]):
                lineN_errmsg = ("Translation file '" + trans +
                                "' Line " + str(i + 1) + " invalid format.")
                tokens = [token.strip() for token in line.split(',')]
                if not len(tokens) == 4:
                    raise ValueError(LineN_errmsg)
                tokens = [re.sub("'", "", token) for token in tokens]
                part = tokens[0]
                chapter = tokens[1]
                sect_rev0 = tokens[2]
                sect_rev1 = tokens[3]

                if rev_key not in self.trans:
                   self.trans.update({rev_key:{}})
                if part not in self.trans[rev_key]:
                    self.trans[rev_key].update({part:{}})
                if chapter not in self.trans[rev_key][part]:
                    self.trans[rev_key][part].update({chapter:{}})
                if sect_rev1 in self.trans[rev_key][part][chapter]:
                    duplN_errmsg = ("Translation file '" + trans +
                                "' Line " + str(i + 1) + " duplicate section.")
                    raise ValueError(duplN_errmsg)
                else:
                    self.trans[rev_key][part][chapter].update({sect_rev1:sect_rev0})

    # Recurse backwards through revision translations to find
    # equivalent section name.
    def _translate(self, revision, part, chapter, section):
        try:
            rev_idx = self.trans_revs.index(revision)
        except:
            return part, chapter, section

        if  rev_idx == 0:
            return part, chapter, section

        prev_rev = self.trans_revs[rev_idx - 1];
        trans_key = str(revision) + "->" + str(prev_rev)
        try:
            old_sect = self.trans[trans_key][part][chapter][section]
        except:
            return part, chapter, section

        return self._translate(prev_rev, part, chapter, old_sect)
        
    def __init__(self, outlines, translations):
        self.outlines = outlines
        self.translations = translations
        self.first_rev = None

        self._init_translations()
           
        self.merged = OrderedDict()
        for outline in sorted(outlines):
            outline_file = open(outline)
            outline_lines = [line.strip() for line in outline_file]
            outline_file.close()

            for i, line in enumerate(outline_lines):
                tokens = [token.strip() for token in line.split(',')]
                tokens = [re.sub("'", "", token) for token in tokens]
                try:
                    revision = tokens[0]
                    part = tokens[1]
                    chapter = tokens[2]
                    section = tokens[3]
                except ValueError:
                    raise ValueError(outline + " file, line #" + str(i) +
                                     " bad format: " + line)
                if self.first_rev is None:
                    self.first_rev = revision

                part, chapter, old_section = self._translate(revision, part,
                                                        chapter, section)
                if part not in self.merged:
                    self.merged.update({part:OrderedDict()})
                if chapter not in self.merged[part]:
                    self.merged[part].update({chapter:OrderedDict()})
                if old_section not in self.merged[part][chapter]:
                    self.merged[part][chapter].update({old_section:[]})
                self.merged[part][chapter][old_section].append(revision)

    def print_outline(self):
        if self.merged == {}:
            print "Nothing in merged outline."

        print "Part, Chapter, Section, Revision"
        for part_key in self.merged.keys():
            for chap_key in self.merged[part_key].keys():
                for sec_key in self.merged[part_key][chap_key].keys():
                    line = part_key + ", " + chap_key + ", " + sec_key + ", "
                    line += str(self.merged[part_key][chap_key][sec_key])
                    print line

def create_parser():
    parser = OptionParser()
    parser.add_option('-f', '--file',
            dest = 'outline_filenames',
            action = 'append', type = 'string', default = [],
            help = 'Outline file(s) created by parse_rapidio_standard.py',
            metavar = 'FILE')
    parser.add_option('-t', '--translate',
            dest = 'translation_filenames',
            action = 'append', type = 'string', default = [],
            help = 'Translation files map one standards to new names in another specification',
            metavar = 'FILE')
    return parser

def validate_options(options):
    if not len(options.outline_filenames):
        print "Must enter at least one outline filename."
        sys.exit()

    for outline in options.outline_filenames:
        if not os.path.isfile(outline):
            print "File '" + outline +"' does not exist."
            sys.exit()

    for trans in options.translation_filenames:
        if not os.path.isfile(trans):
            print "File '" + trans +"' does not exist."
            sys.exit()

    return options

def main(argv = None):
    logging.basicConfig(level=logging.DEBUG)
    parser = create_parser()
    if argv is None:
        argv = sys.argv[1:]

    (options, argv) = parser.parse_args(argv)
    if len(argv) != 0:
        print 'Invalid argument!'
        print
        parser.print_help()
        return -1

    options = validate_options(options)

    merger = RapidIOOutlineMerger(options.outline_filenames,
                                  options.translation_filenames)
    merger.print_outline()

if __name__ == '__main__':
    sys.exit(main())
