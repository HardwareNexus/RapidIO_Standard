#!/usr/bin/env python
# -*- coding: latin-1 -*-
"""
    Merge the checklists, updating references from the outlines provided.

    - Merge the "checklist" files generated by parse_checklist.py
    - Sort by specification revision, chapter, and section
    - Output for each checklist item:
      - statement/sentence that defines the checklist item
      - type (REQUIREMENT/RECOMMENDATION)
      - Array of specification references, where each reference is:
        - Specification revision
        - Part name/number
        - Chapter number and heading
        - Section number and heading
"""

from optparse import OptionParser
from collections import OrderedDict
import operator
import re
import sys
import os
import logging

class ChecklistMerger(object):
    OUTLINE_HEADER = "Revision, Part, Chapter, Section"
    CHECKLIST_HEADER = "Sentence, Type, Revision, Part, Chapter, Section, FileName, Table_Name, Checklist_ID, Optional"
    def __init__(self, checklists, outlines):
        self.checklists = checklists
        self.outlines = outlines

        self._read_outlines()
        self._read_checklists()

    def _read_outlines(self):
        self.outline_lines = []
        self.outline_reference = []
        for outline_path in self.outlines:
            logging.info("Processing outline '%s'." % outline_path)
            outline_file = open(outline_path)
            lines = [line.strip() for line in outline_file.readlines()]
            outline_file.close()

            if not lines[0] == self.OUTLINE_HEADER:
                raise ValueError("Bad format: File %s first line is not %s"
                             % (outline_path, self.OUTLINE_HEADER))

            tokenized_lines = []
            for x, line in enumerate(lines[1:]):
                line_num = x + 1
                tokenized_line = [re.sub("'", "", tok.strip()).strip() for tok in line.split("', ")]
                if not len(tokenized_line) == 4:
                    raise ValueError("Bad format: File %s line %d: %s"
                                 % (outline_path, line_num, tokenized_line))
                logging.debug("%s: %d Outline: %s" % (outline_path, x, tokenized_line))
                self.outline_lines.append(tokenized_line)

                # Parts have the format "Part <part_num>: <Part Title>"
                # Checklist part references have the form "Part <part_num>"
                # Lines below should create a Checklist part_name from the outline
                part_tokens = [tok.strip() for tok in tokenized_line[1].split(" ")]
                part_name = part_tokens[3] + " " + part_tokens[4][:-1]
                # Chapters have the format "Chapter <chapter_number> <Chapter_Title>"
                # Checklist chapter references have the form "Chapter <chapter_num>"
                # Lines below should create a Checklist chapter_name from the outline
                chapter_tokens = [tok.strip() for tok in tokenized_line[2].split(" ")]
                chapter_name = chapter_tokens[0] + " " + chapter_tokens[1]
                # Sections have the format "<section_number> <section_title>"
                # Checklist section references have the form "<section_num>"
                # Lines below should create a Checklist section_number from the outline
                section_tokens = [tok.strip() for tok in tokenized_line[3].split(" ")]
                section_number = section_tokens[0]

                reference = [tokenized_line[0], part_name, chapter_name, section_number]
                try:
                    dup_idx = self.outline_reference.index(reference)
                    raise ValueError("Duplicate reference: File %s lines %d and %d: %s"
                                 % (outline_path, dup_idx, line_num, reference))
                except ValueError:
                    pass
                self.outline_reference.append(reference)
                logging.debug("%s: %d Ref: %s" % (outline_path, x, reference))

    def _read_checklists(self):
        self.merge = []
        self.headings = None
        for checklist_path in self.checklists:
            checklist_file = open(checklist_path)
            lines = [line.strip() for line in checklist_file.readlines()]
            checklist_file.close()

            if not lines[1] == self.CHECKLIST_HEADER:
                raise ValueError("Bad format: File %s first line is not %s"
                             % (checklist_path, self.CHECKLIST_HEADER))
            for x, line in enumerate(lines[2:]):
                line_num = x + 1
                tokens = [re.sub("'", "", tok.strip()) for tok in line.split("', ")]
                if not len(tokens) == 10:
                    raise ValueError("Bad format: File %s line %d: %s"
                                 % (checklist_path, line_num, tokens))
                if len(self.outline_lines) and not tokens[3] == "Part 4":
                    # Try to translate checklist references to complete references
                    if tokens[5].startswith("Sec. "):
                        tokens[5] = tokens[5][len("Sec. "):].strip()
                        if len(tokens[5]) == 1:
                            tokens[5] += ".1"

                    reference = [tokens[2], tokens[3], tokens[4], tokens[5]]
                    try:
                        outline_idx = self.outline_reference.index(reference)
                        tokens[3] = self.outline_lines[outline_idx][1] # Part title
                        tokens[4] = self.outline_lines[outline_idx][2] # Chapter title
                        tokens[5] = self.outline_lines[outline_idx][3] # Section title
                    except ValueError:
                        logging.warn("Checklist %s:%d reference '%s' not found in outlines."
                                      % (checklist_path, line_num, reference))
                self.merge.append(tokens)
        self.sorted_merge = sorted(self.merge, key=operator.itemgetter(3, 4, 5, 2))


    def print_checklist(self):
        if self.sorted_merge == []:
            print "Nothing in sorted checklist."

        print self.CHECKLIST_HEADER
        for item in self.sorted_merge:
            print "'" + "', '".join(item) + "'"

def create_parser():
    parser = OptionParser(description="Merge parsed checklist text files into a single checklist sorted by part, chapter, section, and revision")
    parser.add_option('-c', '--checklist',
            dest = 'checklist_filenames',
            action = 'append', type = 'string', default = [],
            help = 'Checklist file(s) created by parse_checklist.py',
            metavar = 'FILE')
    parser.add_option('-o', '--outlines',
            dest = 'outline_filenames',
            action = 'append', type = 'string', default = [],
            help = 'Outline file(s) created by parse_rapidio_standard.py',
            metavar = 'FILE')
    return parser

def validate_options(options):
    if not len(options.checklist_filenames):
        raise ValueError("Must enter at least one checklist filename.")

    for checklist in options.checklist_filenames:
        if not os.path.isfile(checklist):
            raise ValueError("Checklist file '%s' does not exist." % checklist)

    for outline in options.outline_filenames:
        if not os.path.isfile(outline):
            raise ValueError("Outline file '%s' does not exist." % outline)

def main(argv = None):
    logging.basicConfig(level=logging.WARN)
    parser = create_parser()
    if argv is None:
        argv = sys.argv[1:]

    (options, argv) = parser.parse_args(argv)
    if len(argv) != 0:
        print 'Invalid argument!'
        print
        parser.print_help()
        return -1

    try:
        validate_options(options)
    except ValueError as e:
        print e
        sys.exit(-1)

    merger = ChecklistMerger(options.checklist_filenames, options.outline_filenames)
    merger.print_checklist()

if __name__ == '__main__':
    sys.exit(main())
