#!/usr/bin/env python
# -*- coding: latin-1 -*-
"""
    Merge the outlines of the RapidIO standards.

    Takes the "outline" output generated by parse_rapidio_standard.py
    and merges them into a single outline.
    Creates schema based on:
    Part Number (1-13)
    Chapter Number (H2)
    Section Number (H3-H6)
    (list of revisions)

"""

from optparse import OptionParser
from collections import OrderedDict
import operator
import re
import sys
import os
import logging
from constants import *

class RapidIOOutlineDiffMerger(object):
    part_match = "RapidIO Interconnect Specification Part "
    pmidx = len(part_match) + 3

    def __init__(self, diff_file, new_sections, manual_trans, confidence):
        self.diff = diff_file
        self._new_sections_file = new_sections
        self._manual_trans_file = manual_trans
        self._del_items = []
        self._conf = confidence
        self._merge_diff()

    def _merge_diff(self):
        self._base = []
        self._merge = []
        self._versions = {'>':None, '<':None}

        self._read_new_sections_file()
        self._read_manual_trans_file()
        self._read_diff()
        self._mark_diff_with_base()
        self._merge_lines()

    def _read_new_sections_file(self):
        if self._new_sections_file is None:
            return
        new_sections = open(self._new_sections_file)
        lines = [line.strip() for line in new_sections.readlines()]
        new_sections.close()

        header_items = [item.strip() for item in OUTLINE_HEADER.split(",")]
        line_items = [item.strip() for item in lines[0][1:-1].split("', '")]
        if not header_items == line_items:
            raise ValueError("Bad format: File %s first line is %s not %s"
                         % (self._new_sections_file, line_items, header_items))

        for x, line in enumerate(lines[1:]):
            tokens = [tok.strip() for tok in line.split("',")]
            tokens = [re.sub("'", "", tok) for tok in tokens]
            if not len(tokens) == len(header_items):
                raise ValueError("File %s Line %d %d bad format: '%s'"
                            % (self._new_sections_file, x, len(tokens), line))
            logging.info("New Section: %s" % tokens)
            self._del_items.append(tokens)

    def _read_manual_trans_file(self):
        if self._manual_trans_file is None:
            return
        manual_trans = open(self._manual_trans_file)
        lines = [line.strip() for line in manual_trans.readlines()]
        manual_trans.close()

        exp_toks = [tok.strip() for tok in OUTLINE_HEADER.split(",")]
        act_toks = [tok.strip() for tok in lines[0][1:-1].split("', '")]
        if ((exp_toks != act_toks[0:len(exp_toks)]) or
            (exp_toks != act_toks[len(exp_toks):])):
            raise ValueError("Bad format: File %s first line is %s not %s"
                         % (self._manual_trans_file, act_toks, exp_toks))
        for x, line in enumerate(lines[1:]):
            tokens = [tok.strip() for tok in line[1:-1].split("', '")]
            if not len(tokens) == len(exp_toks)*2:
                raise ValueError(
                      "File %s Line %d %d not %d bad format: '%s' '%s'"
                    % (self._manual_trans_file, x, len(tokens),
                       2*len(exp_toks), line, tokens))
            logging.info("New Section: %s" % tokens)
            self._merge.append(tokens)

    def _read_diff(self):
        diff_file = open(self.diff)
        lines = [line.strip() for line in diff_file.readlines()]
        diff_file.close()

        # Get version numbers, sort '<' and '>' lines, drop all other lines
        self._old_lines = []
        self._new_lines = []
        for line in lines:
            if line[0] == ">" or line[0] == "<":
                tokens = [tok.strip() for tok in line[1:].split("',")]
                tokens = [re.sub("'", "", tok) for tok in tokens]
                self._versions[line[0]] = tokens[0]
                if not len(tokens) == 4:
                    logging.debug("Skipping line '%s'" % line)
                    continue
                if line[0] == '<':
                    self._old_lines.append(tokens)
                else:
                    self._new_lines.append(tokens)

    def _mark_diff_with_base(self):
        # Remove all sections that are new from the diff file,
        # as these will not have any translation.
        for base_idx, base in enumerate(self._del_items):
            try:
                b = self._new_lines.index(base)
                del self._new_lines[b]
            except:
                logging.error("Base line %d NEW not found: %s"
                                 % (base_idx, base))
                raise

        # At this stage _merge contains only manual_trans translations.
        #
        # For each manual_trans line, ensure that the "new" line in the diff
        # is set to already have a translation i.e. do not attempt to translate
        # twice...
        #
        # Also, confirm that the manual_trans references exist in the old and
        # new diff lines.  It is an error if the new reference does not exist.
        # The translation to the old section is a warning, as the old section
        # title may exist unchanged in the new and old.
        for b, base in enumerate(self._merge):
            found_new = False
            logging.info(base[0:4])
            for n, new in enumerate(self._new_lines):
                logging.info(new)
                diff = False
                for x, tok in enumerate(base[0:4]):
                    if not new[x] == tok:
                        diff = True
                        break
                if diff:
                    continue
                self._new_lines[n].extend(base[4:])
                found_new = True
            if not found_new:
                raise ValueError("Manual translation reference to new specification not found in diff: %s" % base[0:4])
            found_old = False
            for o, old in enumerate(self._old_lines):
                diff = False
                for x, tok in enumerate(base[4:]):
                    if not old[x] == tok:
                        diff = True
                        break
                if diff:
                    continue
                self._old_lines[o].extend(base[0:4])
                found_old = True
            if not found_old:
                logging.warn("Manual translation reference to old specification not found in diff: %s" % base[4:8])

    def _merge_lines(self):
        for n, new in enumerate(self._new_lines):
            # If line already has a match from _mark_diff_with_base, continue...
            if len(new) > 4:
                continue
            best_old_pct = 0.0
            best_new_pct = 0.0
            best_old_idx = -1
            for o, old in enumerate(self._old_lines):
                old_pct = 0.0
                new_pct = 0.0
                for i, tok in enumerate(new):
                    # Skip compare of revision numbers
                    if i == 0:
                        continue
                    old_pct, new_pct = self._custom_match(tok, old[i])
                    if (old_pct < self._conf) and (new_pct < self._conf):
                        break
                # If the last token did not match, try the next old line.
                if (old_pct < self._conf) and (new_pct < self._conf):
                    continue
                # All tokens matched well enough.
                # If this is a better match than the last, keep it.
                if (old_pct >= best_old_pct) and (new_pct >= best_new_pct):
                    best_old_idx = o
                    best_old_pct = old_pct
                    best_new_pct = new_pct
            if best_old_idx >= 0:
                self._merge.append(new + self._old_lines[best_old_idx][0:4])
                self._old_lines[best_old_idx].extend(new)
                self._new_lines[n].extend(self._old_lines[best_old_idx][0:4])

    def _custom_match(self, old, new):
        if old.startswith(self.part_match) and new.startswith(self.part_match):
            return 1.0, 1.0
            
        # Increase number of tokens to make it easier to match...
        old = re.sub("-", " ", old)
        old_toks = [tok.strip() for tok in old.split(' ')]
        new = re.sub("-", " ", new)
        new_toks = [tok.strip() for tok in new.split(' ')]

        logging.debug("old toks: %s" % old_toks)
        logging.debug("new toks: %s" % new_toks)
        old_in_new = 0.0
        new_in_old = 0.0
        len_old = len(old_toks)
        len_new = len(new_toks)
        # Automatically match numeric values, otherwise 
        # comparing Chapter 6 Blah Blah Blah to Chapter 7 Blah Blah Blah  
        # might fail.
        for tok in old_toks:
            if not len(tok):
               continue
            if tok[0] in ('0123456789'):
               if 0 not in [c in ('0123456789.') for c in tok]:
                   len_old -= 1.0
                   continue
            if tok in new_toks:
               logging.debug('%s in new' % tok)
               old_in_new += 1.0
               continue
        for tok in new_toks:
            if not len(tok):
               continue
            if tok[0] in ('0123456789'):
               if 0 not in [c in ('0123456789.') for c in tok]:
                   len_new -= 1.0
                   continue
            if tok in old_toks:
               logging.debug('%s in old' % tok)
               new_in_old += 1.0

        rc =((new_in_old/len_new) >= self._conf) or ((old_in_new/len_old) >= self._conf)
        logging.debug("Match '%s' '%s' %f %f %f %f %s'"
                      % (old, new, old_in_new, old_in_new/len_old,
                        new_in_old, new_in_old/len_new, str(rc)))
        return old_in_new/len_old, new_in_old/len_new
            
    def print_outline(self, filepath):
        output = open(filepath, "w")

        logging.info("Versions: %s %s" % (self._versions["<"], self._versions[">"]))
        logging.info("Merge: %d" % len(self._merge))
        for line in self._merge:
            logging.debug("Merge: %s" % line)
            output.write("'" + "', '".join(line) + "'" + "\n")
            #output.write("'" + "', '".join(line[4:]) + "'" + "\n")

        output.write("Unmatched new items, interleaved with old\n")
        part = None
        logging.debug("First part: %s" % part)
        for line in self._new_lines:
            logging.debug("New: %s" % line)
            if len(line) > 4:
                continue
            if part is None:
                part = line[1]
            if part != line[1]:
                logging.debug("New part: %s" % line[1])
                for o, old in enumerate(self._old_lines):
                    if len(old) > 4:
                        continue
                    if old[1].startswith(part[0:self.pmidx]):
                        output.write("< '" + "', '".join(old) + "'" + "\n")
                        self._old_lines[o].extend(["Printed"])
                         
                part = line[1]
            output.write("> '" + "', '".join(line) + "'" + "\n")

        output.write("Unmatched old items\n")
        for line in self._old_lines:
            logging.debug("Old: %s" % line)
            if len(line) > 4:
                continue
            output.write("< '" + "', '".join(line) + "'" + "\n")
        output.close()

def create_parser():
    parser = OptionParser(description="Merge the differences between two outlines into a translation file.")
    parser.add_option('-f', '--file',
            dest = 'outline_diff_filename',
            action = 'store', type = 'string', default = None,
            help = 'Outline diff file(s) created by check_all_outlines',
            metavar = 'FILE')
    parser.add_option('-n', '--new',
            dest = 'new_sections_file',
            action = 'store', type = 'string', default = None,
            help = 'List of sections that appeared for the first time in a specification revision.',
            metavar = 'FILE')
    parser.add_option('-m', '--manual_translation',
            dest = 'manual_trans_file',
            action = 'store', type = 'string', default = None,
            help = 'Hard coded translations from an older specification revision to a newer specification revision.  These translations cannot be correctly determined by the matching algorithm, as the section names may have changed.',
            metavar = 'FILE')
    parser.add_option('-c', '--confidence',
            dest = 'confidence',
            action = 'store', type = 'float', default = 0.8,
            help = 'Percentage of tokens required to achieve a match',
            metavar = 'PCT')
    return parser

def validate_options(options):
    if options.outline_diff_filename is None:
        print "Must enter at least one outline diff filename."
        sys.exit()

    if not os.path.isfile(options.outline_diff_filename):
        print "File '" + options.outline_diff_filename +"' does not exist."
        sys.exit()

    if options.new_sections_file is not None:
        if not os.path.isfile(options.new_sections_file):
            print "File '" + options.new_sections_file +"' does not exist."
            sys.exit()

    if options.manual_trans_file is not None:
        if not os.path.isfile(options.manual_trans_file):
            print "File '" + options.manual_trans_file +"' does not exist."
            sys.exit()

    if (options.confidence > 1.0) or (options.confidence < 0.0):
        print "Confidence must be between 0.0 and 1.0."
        sys.exit()

def main(argv = None):
    logging.basicConfig(level=logging.WARN)
    parser = create_parser()
    if argv is None:
        argv = sys.argv[1:]

    (options, argv) = parser.parse_args(argv)
    if len(argv) != 0:
        print 'Invalid argument!'
        print
        parser.print_help()
        return -1

    validate_options(options)

    merger = RapidIOOutlineDiffMerger(options.outline_diff_filename,
                                      options.new_sections_file,
                                      options.manual_trans_file,
                                      options.confidence)
    name = os.path.basename(os.path.normpath(options.outline_diff_filename))
    path = os.path.dirname(options.outline_diff_filename)
    name = "translate_" + name
    output_file = os.path.join(path, name)
    merger.print_outline(output_file)

if __name__ == '__main__':
    sys.exit(main())
