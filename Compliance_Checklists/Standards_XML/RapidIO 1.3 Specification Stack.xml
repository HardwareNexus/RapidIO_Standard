<?xml version="1.0" encoding="UTF-8" ?>
<!-- Created from PDF via Acrobat SaveAsXML -->
<!-- Mapping Table version: 28-February-2003 -->
<TaggedPDF-doc>
<?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?>
<?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.2-c001 63.139439, 2010/09/27-13:37:26        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/">
         <xmp:ModifyDate>2017-12-10T18:06:33-05:00</xmp:ModifyDate>
         <xmp:CreateDate>2017-12-10T18:06:33-05:00</xmp:CreateDate>
         <xmp:MetadataDate>2017-12-10T18:06:33-05:00</xmp:MetadataDate>
         <xmp:CreatorTool>FrameMaker 5.5.6p145</xmp:CreatorTool>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
         <dc:creator>
            <rdf:Seq>
               <rdf:li>ra3341</rdf:li>
            </rdf:Seq>
         </dc:creator>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/">
         <xmpMM:DocumentID>uuid:8935df9d-f4fb-4f3e-a3c2-62cee1479c64</xmpMM:DocumentID>
         <xmpMM:InstanceID>uuid:bd28129a-1ef8-4f75-815c-e1504d6a8b07</xmpMM:InstanceID>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>Acrobat Distiller 5.0.5 (Windows)</pdf:Producer>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?>
<?xpacket end='r'?>
<bookmark-tree>
<bookmark title="IO_logical">
<destination structID="LinkTarget_8324"/>
<bookmark title="RapidIO™ Interconnect Specification Part 1: Input/Output Logical Specification">
<destination structID="LinkTarget_30411"/>
<bookmark title="Chapter&#17;1 Overview">
<destination structID="LinkTarget_30412"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_30413"/>
</bookmark>
<bookmark title="1.2 Overview">
<destination structID="LinkTarget_30414"/>
</bookmark>
<bookmark title="1.3 Features of the Input/Output Specification">
<destination structID="LinkTarget_30415"/>
<bookmark title="1.3.1 Functional Features">
<destination structID="LinkTarget_30416"/>
</bookmark>
<bookmark title="1.3.2 Physical Features">
<destination structID="LinkTarget_30417"/>
</bookmark>
<bookmark title="1.3.3 Performance Features">
<destination structID="LinkTarget_30418"/>
</bookmark>
</bookmark>
<bookmark title="1.4 Contents">
<destination structID="LinkTarget_30419"/>
</bookmark>
<bookmark title="1.5 Terminology">
<destination structID="LinkTarget_30420"/>
</bookmark>
<bookmark title="1.6 Conventions">
<destination structID="LinkTarget_30421"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 System Models">
<destination structID="LinkTarget_30422"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_30423"/>
</bookmark>
<bookmark title="2.2 Processing Element Models">
<destination structID="LinkTarget_30424"/>
<bookmark title="2.2.1 Processor-Memory Processing Element Model">
<destination structID="LinkTarget_30425"/>
</bookmark>
<bookmark title="2.2.2 Integrated Processor-Memory Processing Element Model">
<destination structID="LinkTarget_30426"/>
</bookmark>
<bookmark title="2.2.3 Memory-Only Processing Element Model">
<destination structID="LinkTarget_30427"/>
</bookmark>
<bookmark title="2.2.4 Processor-Only Processing Element">
<destination structID="LinkTarget_30428"/>
</bookmark>
<bookmark title="2.2.5 I/O Processing Element">
<destination structID="LinkTarget_30429"/>
</bookmark>
<bookmark title="2.2.6 Switch Processing Element">
<destination structID="LinkTarget_30430"/>
</bookmark>
</bookmark>
<bookmark title="2.3 System Issues">
<destination structID="LinkTarget_30431"/>
<bookmark title="2.3.1 Operation Ordering">
<destination structID="LinkTarget_30432"/>
</bookmark>
<bookmark title="2.3.2 Transaction Delivery">
<destination structID="LinkTarget_30433"/>
<bookmark title="2.3.2.1 Unordered Delivery System Issues">
<destination structID="LinkTarget_30434"/>
</bookmark>
<bookmark title="2.3.2.2 Ordered Delivery System Issues">
<destination structID="LinkTarget_30435"/>
</bookmark>
</bookmark>
<bookmark title="2.3.3 Deadlock Considerations">
<destination structID="LinkTarget_30436"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 Operation Descriptions">
<destination structID="LinkTarget_30437"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_30438"/>
</bookmark>
<bookmark title="3.2 I/O Operations Cross Reference">
<destination structID="LinkTarget_30439"/>
</bookmark>
<bookmark title="3.3 I/O Operations">
<destination structID="LinkTarget_30440"/>
<bookmark title="3.3.1 Read Operations">
<destination structID="LinkTarget_30441"/>
</bookmark>
<bookmark title="3.3.2 Write and Streaming-Write Operations">
<destination structID="LinkTarget_30442"/>
</bookmark>
<bookmark title="3.3.3 Write-With-Response Operations">
<destination structID="LinkTarget_30443"/>
</bookmark>
<bookmark title="3.3.4 Atomic (Read-Modify-Write) Operations">
<destination structID="LinkTarget_30444"/>
</bookmark>
</bookmark>
<bookmark title="3.4 System Operations">
<destination structID="LinkTarget_30445"/>
<bookmark title="3.4.1 Maintenance Operations">
<destination structID="LinkTarget_30446"/>
</bookmark>
</bookmark>
<bookmark title="3.5 Endian, Byte Ordering, and Alignment">
<destination structID="LinkTarget_30447"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;4 Packet Format Descriptions">
<destination structID="LinkTarget_30448"/>
<bookmark title="4.1 Request Packet Formats">
<destination structID="LinkTarget_30449"/>
<bookmark title="4.1.1 Addressing and Alignment">
<destination structID="LinkTarget_30450"/>
</bookmark>
<bookmark title="4.1.2 Field Definitions for All Request Packet Formats">
<destination structID="LinkTarget_30451"/>
</bookmark>
<bookmark title="4.1.3 Type 0 Packet Format (Implementation-Defined)">
<destination structID="LinkTarget_30452"/>
</bookmark>
<bookmark title="4.1.4 Type 1 Packet Format (Reserved)">
<destination structID="LinkTarget_30453"/>
</bookmark>
<bookmark title="4.1.5 Type 2 Packet Format (Request Class)">
<destination structID="LinkTarget_30454"/>
</bookmark>
<bookmark title="4.1.6 Type 3–4 Packet Formats (Reserved)">
<destination structID="LinkTarget_30455"/>
</bookmark>
<bookmark title="4.1.7 Type 5 Packet Format (Write Class)">
<destination structID="LinkTarget_30456"/>
</bookmark>
<bookmark title="4.1.8 Type 6 Packet Format (Streaming-Write Class)">
<destination structID="LinkTarget_30457"/>
</bookmark>
<bookmark title="4.1.9 Type 7 Packet Format (Reserved)">
<destination structID="LinkTarget_30458"/>
</bookmark>
<bookmark title="4.1.10 Type 8 Packet Format (Maintenance Class)">
<destination structID="LinkTarget_30459"/>
</bookmark>
<bookmark title="4.1.11 Type 9–11 Packet Formats (Reserved)">
<destination structID="LinkTarget_30460"/>
</bookmark>
</bookmark>
<bookmark title="4.2 Response Packet Formats">
<destination structID="LinkTarget_30461"/>
<bookmark title="4.2.1 Field Definitions for All Response Packet Formats">
<destination structID="LinkTarget_30462"/>
</bookmark>
<bookmark title="4.2.2 Type 12 Packet Format (Reserved)">
<destination structID="LinkTarget_30463"/>
</bookmark>
<bookmark title="4.2.3 Type 13 Packet Format (Response Class)">
<destination structID="LinkTarget_30464"/>
</bookmark>
<bookmark title="4.2.4 Type 14 Packet Format (Reserved)">
<destination structID="LinkTarget_30465"/>
</bookmark>
<bookmark title="4.2.5 Type 15 Packet Format (Implementation-Defined)">
<destination structID="LinkTarget_30466"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;5 Input/Output Registers">
<destination structID="LinkTarget_30467"/>
<bookmark title="5.1 Register Summary">
<destination structID="LinkTarget_30468"/>
</bookmark>
<bookmark title="5.2 Reserved Register and Bit Behavior">
<destination structID="LinkTarget_30469"/>
</bookmark>
<bookmark title="5.3 Extended Features Data Structure">
<destination structID="LinkTarget_30470"/>
</bookmark>
<bookmark title="5.4 Capability Registers (CARs)">
<destination structID="LinkTarget_30471"/>
<bookmark title="5.4.1 Device Identity CAR (Configuration Space Offset 0x0)">
<destination structID="LinkTarget_30472"/>
</bookmark>
<bookmark title="5.4.2 Device Information CAR (Configuration Space Offset 0x4)">
<destination structID="LinkTarget_30473"/>
</bookmark>
<bookmark title="5.4.3 Assembly Identity CAR (Configuration Space Offset 0x8)">
<destination structID="LinkTarget_30474"/>
</bookmark>
<bookmark title="5.4.4 Assembly Information CAR (Configuration Space Offset 0xC)">
<destination structID="LinkTarget_30475"/>
</bookmark>
<bookmark title="5.4.5 Processing Element Features CAR (Configuration Space Offset 0x10)">
<destination structID="LinkTarget_30476"/>
</bookmark>
<bookmark title="5.4.6 Switch Port Information CAR (Configuration Space Offset 0x14)">
<destination structID="LinkTarget_30477"/>
</bookmark>
<bookmark title="5.4.7 Source Operations CAR (Configuration Space Offset 0x18)">
<destination structID="LinkTarget_30478"/>
</bookmark>
<bookmark title="5.4.8 Destination Operations CAR (Configuration Space Offset 0x1C)">
<destination structID="LinkTarget_30479"/>
</bookmark>
</bookmark>
<bookmark title="5.5 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_30480"/>
<bookmark title="5.5.1 Processing Element Logical Layer Control CSR (Configuration Space Offset 0x4C)">
<destination structID="LinkTarget_30481"/>
</bookmark>
<bookmark title="5.5.2 Local Configuration Space Base Address 0 CSR (Configuration Space Offset 0x58)">
<destination structID="LinkTarget_30482"/>
</bookmark>
<bookmark title="5.5.3 Local Configuration Space Base Address 1 CSR (Configuration Space Offset 0x5C)">
<destination structID="LinkTarget_30483"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Glossary of Terms and Abbreviations">
<destination structID="LinkTarget_30484"/>
</bookmark>
</bookmark>
<bookmark title="msg_logical">
<destination structID="LinkTarget_8206"/>
<bookmark title="RapidIO™ Interconnect Specification Part 2: Message Passing Logical Specification">
<destination structID="LinkTarget_30485"/>
<bookmark title="Chapter&#17;1 Overview">
<destination structID="LinkTarget_30486"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_30487"/>
</bookmark>
<bookmark title="1.2 Overview">
<destination structID="LinkTarget_30488"/>
</bookmark>
<bookmark title="1.3 Features of the Message Passing Specification">
<destination structID="LinkTarget_30489"/>
<bookmark title="1.3.1 Functional Features">
<destination structID="LinkTarget_30490"/>
</bookmark>
<bookmark title="1.3.2 Physical Features">
<destination structID="LinkTarget_30491"/>
</bookmark>
<bookmark title="1.3.3 Performance Features">
<destination structID="LinkTarget_30492"/>
</bookmark>
</bookmark>
<bookmark title="1.4 Contents">
<destination structID="LinkTarget_30493"/>
</bookmark>
<bookmark title="1.5 Terminology">
<destination structID="LinkTarget_30494"/>
</bookmark>
<bookmark title="1.6 Conventions">
<destination structID="LinkTarget_30495"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 System Models">
<destination structID="LinkTarget_30496"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_30497"/>
</bookmark>
<bookmark title="2.2 Processing Element Models">
<destination structID="LinkTarget_30498"/>
<bookmark title="2.2.1 Processor-Memory Processing Element Model">
<destination structID="LinkTarget_30499"/>
</bookmark>
<bookmark title="2.2.2 Integrated Processor-Memory Processing Element Model">
<destination structID="LinkTarget_30500"/>
</bookmark>
<bookmark title="2.2.3 Memory-Only Processing Element Model">
<destination structID="LinkTarget_30501"/>
</bookmark>
<bookmark title="2.2.4 Processor-Only Processing Element">
<destination structID="LinkTarget_30502"/>
</bookmark>
<bookmark title="2.2.5 I/O Processing Element">
<destination structID="LinkTarget_30503"/>
</bookmark>
<bookmark title="2.2.6 Switch Processing Element">
<destination structID="LinkTarget_30504"/>
</bookmark>
</bookmark>
<bookmark title="2.3 Message Passing System Model">
<destination structID="LinkTarget_30505"/>
<bookmark title="2.3.1 Data Message Operations">
<destination structID="LinkTarget_30506"/>
</bookmark>
<bookmark title="2.3.2 Doorbell Message Operations">
<destination structID="LinkTarget_30507"/>
</bookmark>
</bookmark>
<bookmark title="2.4 System Issues">
<destination structID="LinkTarget_30508"/>
<bookmark title="2.4.1 Operation Ordering">
<destination structID="LinkTarget_30509"/>
</bookmark>
<bookmark title="2.4.2 Transaction Delivery">
<destination structID="LinkTarget_30510"/>
</bookmark>
<bookmark title="2.4.3 Deadlock Considerations">
<destination structID="LinkTarget_30511"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 Operation Descriptions">
<destination structID="LinkTarget_30512"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_30513"/>
</bookmark>
<bookmark title="3.2 Message Passing Operations Cross Reference">
<destination structID="LinkTarget_30514"/>
</bookmark>
<bookmark title="3.3 Message Passing Operations">
<destination structID="LinkTarget_30515"/>
<bookmark title="3.3.1 Doorbell Operations">
<destination structID="LinkTarget_30516"/>
</bookmark>
<bookmark title="3.3.2 Data Message Operations">
<destination structID="LinkTarget_30517"/>
</bookmark>
</bookmark>
<bookmark title="3.4 Endian, Byte Ordering, and Alignment">
<destination structID="LinkTarget_30518"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;4 Packet Format Descriptions">
<destination structID="LinkTarget_30519"/>
<bookmark title="4.1 Introduction">
<destination structID="LinkTarget_30520"/>
</bookmark>
<bookmark title="4.2 Request Packet Formats">
<destination structID="LinkTarget_30521"/>
<bookmark title="4.2.1 Field Definitions for All Request Packet Formats">
<destination structID="LinkTarget_30522"/>
</bookmark>
<bookmark title="4.2.2 Type 0 Packet Format (Implementation-Defined)">
<destination structID="LinkTarget_30523"/>
</bookmark>
<bookmark title="4.2.3 Type 1–9 Packet Formats (Reserved)">
<destination structID="LinkTarget_30524"/>
</bookmark>
<bookmark title="4.2.4 Type 10 Packet Formats (Doorbell Class)">
<destination structID="LinkTarget_30525"/>
</bookmark>
<bookmark title="4.2.5 Type 11 Packet Format (Message Class)">
<destination structID="LinkTarget_30526"/>
</bookmark>
</bookmark>
<bookmark title="4.3 Response Packet Formats">
<destination structID="LinkTarget_30527"/>
<bookmark title="4.3.1 Field Definitions for All Response Packet Formats">
<destination structID="LinkTarget_30528"/>
</bookmark>
<bookmark title="4.3.2 Type 12 Packet Format (Reserved)">
<destination structID="LinkTarget_30529"/>
</bookmark>
<bookmark title="4.3.3 Type 13 Packet Format (Response Class)">
<destination structID="LinkTarget_30530"/>
</bookmark>
<bookmark title="4.3.4 Type 14 Packet Format (Reserved)">
<destination structID="LinkTarget_30531"/>
</bookmark>
<bookmark title="4.3.5 Type 15 Packet Format (Implementation-Defined)">
<destination structID="LinkTarget_30532"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;5 Message Passing Registers">
<destination structID="LinkTarget_30533"/>
<bookmark title="5.1 Introduction">
<destination structID="LinkTarget_30534"/>
</bookmark>
<bookmark title="5.2 Register Summary">
<destination structID="LinkTarget_30535"/>
</bookmark>
<bookmark title="5.3 Reserved Register and Bit Behavior">
<destination structID="LinkTarget_30536"/>
</bookmark>
<bookmark title="5.4 Capability Registers (CARs)">
<destination structID="LinkTarget_30537"/>
<bookmark title="5.4.1 Source Operations CAR (Configuration Space Offset 0x18)">
<destination structID="LinkTarget_30538"/>
</bookmark>
<bookmark title="5.4.2 Destination Operations CAR (Configuration Space Offset 0x1C)">
<destination structID="LinkTarget_30539"/>
</bookmark>
</bookmark>
<bookmark title="5.5 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_30540"/>
</bookmark>
</bookmark>
<bookmark title="Annex&#17;A Message Passing Interface">
<destination structID="LinkTarget_30541"/>
<bookmark title="A.1 Introduction">
<destination structID="LinkTarget_30542"/>
</bookmark>
<bookmark title="A.2 Definitions and Goals">
<destination structID="LinkTarget_30543"/>
</bookmark>
<bookmark title="A.3 Message Operations">
<destination structID="LinkTarget_30544"/>
</bookmark>
<bookmark title="A.4 Inbound Mailbox Structure">
<destination structID="LinkTarget_30545"/>
<bookmark title="A.4.1 Simple Inbox">
<destination structID="LinkTarget_30546"/>
</bookmark>
<bookmark title="A.4.2 Extended Inbox">
<destination structID="LinkTarget_30547"/>
</bookmark>
<bookmark title="A.4.3 Received Messages">
<destination structID="LinkTarget_30548"/>
</bookmark>
</bookmark>
<bookmark title="A.5 Outbound Message Queue Structure">
<destination structID="LinkTarget_30549"/>
<bookmark title="A.5.1 Simple Outbox">
<destination structID="LinkTarget_30550"/>
</bookmark>
<bookmark title="A.5.2 Extended Outbox">
<destination structID="LinkTarget_30551"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Glossary of Terms and Abbreviations">
<destination structID="LinkTarget_30552"/>
</bookmark>
</bookmark>
<bookmark title="cmn_trnspt">
<destination structID="LinkTarget_8138"/>
<bookmark title="RapidIO™ Interconnect Specification Part 3: Common Transport Specification">
<destination structID="LinkTarget_30553"/>
<bookmark title="Chapter&#17;1 Overview">
<destination structID="LinkTarget_30554"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_30555"/>
</bookmark>
<bookmark title="1.2 Overview">
<destination structID="LinkTarget_30556"/>
</bookmark>
<bookmark title="1.3 Transport Layer Features">
<destination structID="LinkTarget_30557"/>
<bookmark title="1.3.1 Functional Features">
<destination structID="LinkTarget_30558"/>
</bookmark>
<bookmark title="1.3.2 Physical Features">
<destination structID="LinkTarget_30559"/>
</bookmark>
<bookmark title="1.3.3 Performance Features">
<destination structID="LinkTarget_30560"/>
</bookmark>
</bookmark>
<bookmark title="1.4 Contents">
<destination structID="LinkTarget_30561"/>
</bookmark>
<bookmark title="1.5 Terminology">
<destination structID="LinkTarget_30562"/>
</bookmark>
<bookmark title="1.6 Conventions">
<destination structID="LinkTarget_30563"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 Transport Format Description">
<destination structID="LinkTarget_30564"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_30565"/>
</bookmark>
<bookmark title="2.2 System Topology">
<destination structID="LinkTarget_30566"/>
<bookmark title="2.2.1 Switch-Based Systems">
<destination structID="LinkTarget_30567"/>
</bookmark>
<bookmark title="2.2.2 Ring-Based Systems">
<destination structID="LinkTarget_30568"/>
</bookmark>
</bookmark>
<bookmark title="2.3 System Packet Routing">
<destination structID="LinkTarget_30569"/>
</bookmark>
<bookmark title="2.4 Field Alignment and Definition">
<destination structID="LinkTarget_30570"/>
</bookmark>
<bookmark title="2.5 Routing Maintenance Packets">
<destination structID="LinkTarget_30571"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 Common Transport Registers">
<destination structID="LinkTarget_30572"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_30573"/>
</bookmark>
<bookmark title="3.2 Register Summary">
<destination structID="LinkTarget_30574"/>
</bookmark>
<bookmark title="3.3 Reserved Register and Bit Behavior">
<destination structID="LinkTarget_30575"/>
</bookmark>
<bookmark title="3.4 Capability Registers (CARs)">
<destination structID="LinkTarget_30576"/>
<bookmark title="3.4.1 Processing Element Features CAR (Configuration Space Offset 0x10)">
<destination structID="LinkTarget_30577"/>
</bookmark>
<bookmark title="3.4.2 Switch Route Table Destination ID Limit CAR (Configuration Space Offset 0x34)">
<destination structID="LinkTarget_30578"/>
</bookmark>
</bookmark>
<bookmark title="3.5 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_30579"/>
<bookmark title="3.5.1 Base Device ID CSR (Configuration Space Offset 0x60)">
<destination structID="LinkTarget_30580"/>
</bookmark>
<bookmark title="3.5.2 Host Base Device ID Lock CSR (Configuration Space Offset 0x68)">
<destination structID="LinkTarget_30581"/>
</bookmark>
<bookmark title="3.5.3 Component Tag CSR (Configuration Space Offset 0x6C)">
<destination structID="LinkTarget_30582"/>
</bookmark>
<bookmark title="3.5.4 Standard Route Configuration Destination ID Select CSR (Configuration Space Offset 0x70)">
<destination structID="LinkTarget_30583"/>
</bookmark>
<bookmark title="3.5.5 Standard Route Configuration Port Select CSR (Configuration Space Offset 0x74)">
<destination structID="LinkTarget_30584"/>
</bookmark>
<bookmark title="3.5.6 Standard Route Default Port CSR (Configuration Space Offset 0x78)">
<destination structID="LinkTarget_30585"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Glossary of Terms and Abbreviations">
<destination structID="LinkTarget_30586"/>
</bookmark>
</bookmark>
<bookmark title="gsmlspec">
<destination structID="LinkTarget_7890"/>
<bookmark title="RapidIO™ Interconnect Specification Part 5: Globally Shared Memory Logical Specification">
<destination structID="LinkTarget_30587"/>
<bookmark title="Chapter&#17;1 Overview">
<destination structID="LinkTarget_30588"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_30589"/>
</bookmark>
<bookmark title="1.2 Overview">
<destination structID="LinkTarget_30590"/>
<bookmark title="1.2.1 Memory System">
<destination structID="LinkTarget_30591"/>
</bookmark>
</bookmark>
<bookmark title="1.3 Features of the Globally Shared Memory Specification">
<destination structID="LinkTarget_30592"/>
<bookmark title="1.3.1 Functional Features">
<destination structID="LinkTarget_30593"/>
</bookmark>
<bookmark title="1.3.2 Physical Features">
<destination structID="LinkTarget_30594"/>
</bookmark>
<bookmark title="1.3.3 Performance Features">
<destination structID="LinkTarget_30595"/>
</bookmark>
</bookmark>
<bookmark title="1.4 Contents">
<destination structID="LinkTarget_30596"/>
</bookmark>
<bookmark title="1.5 Terminology">
<destination structID="LinkTarget_30597"/>
</bookmark>
<bookmark title="1.6 Conventions">
<destination structID="LinkTarget_30598"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 System Models">
<destination structID="LinkTarget_30599"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_30600"/>
</bookmark>
<bookmark title="2.2 Processing Element Models">
<destination structID="LinkTarget_30601"/>
<bookmark title="2.2.1 Processor-Memory Processing Element Model">
<destination structID="LinkTarget_30602"/>
</bookmark>
<bookmark title="2.2.2 Integrated Processor-Memory Processing Element Model">
<destination structID="LinkTarget_30603"/>
</bookmark>
<bookmark title="2.2.3 Memory-Only Processing Element Model">
<destination structID="LinkTarget_30604"/>
</bookmark>
<bookmark title="2.2.4 Processor-Only Processing Element">
<destination structID="LinkTarget_30605"/>
</bookmark>
<bookmark title="2.2.5 I/O Processing Element">
<destination structID="LinkTarget_30606"/>
</bookmark>
<bookmark title="2.2.6 Switch Processing Element">
<destination structID="LinkTarget_30607"/>
</bookmark>
</bookmark>
<bookmark title="2.3 Programming Models">
<destination structID="LinkTarget_30608"/>
<bookmark title="2.3.1 Globally Shared Memory System Model">
<destination structID="LinkTarget_30609"/>
<bookmark title="2.3.1.1 Software-Managed Cache Coherence Programming Model">
<destination structID="LinkTarget_30610"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="2.4 System Issues">
<destination structID="LinkTarget_30611"/>
<bookmark title="2.4.1 Operation Ordering">
<destination structID="LinkTarget_30612"/>
</bookmark>
<bookmark title="2.4.2 Transaction Delivery">
<destination structID="LinkTarget_30613"/>
</bookmark>
<bookmark title="2.4.3 Deadlock Considerations">
<destination structID="LinkTarget_30614"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 Operation Descriptions">
<destination structID="LinkTarget_30615"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_30616"/>
</bookmark>
<bookmark title="3.2 GSM Operations Cross Reference">
<destination structID="LinkTarget_30617"/>
</bookmark>
<bookmark title="3.3 GSM Operations">
<destination structID="LinkTarget_30618"/>
<bookmark title="3.3.1 Read Operations">
<destination structID="LinkTarget_30619"/>
</bookmark>
<bookmark title="3.3.2 Instruction Read Operations">
<destination structID="LinkTarget_30620"/>
</bookmark>
<bookmark title="3.3.3 Read-for-Ownership Operations">
<destination structID="LinkTarget_30621"/>
</bookmark>
<bookmark title="3.3.4 Data Cache Invalidate Operations">
<destination structID="LinkTarget_30622"/>
</bookmark>
<bookmark title="3.3.5 Castout Operations">
<destination structID="LinkTarget_30623"/>
</bookmark>
<bookmark title="3.3.6 TLB Invalidate-Entry Operations">
<destination structID="LinkTarget_30624"/>
</bookmark>
<bookmark title="3.3.7 TLB Invalidate-Entry Synchronization Operations">
<destination structID="LinkTarget_30625"/>
</bookmark>
<bookmark title="3.3.8 Instruction Cache Invalidate Operations">
<destination structID="LinkTarget_30626"/>
</bookmark>
<bookmark title="3.3.9 Data Cache Flush Operations">
<destination structID="LinkTarget_30627"/>
</bookmark>
<bookmark title="3.3.10 I/O Read Operations">
<destination structID="LinkTarget_30628"/>
</bookmark>
</bookmark>
<bookmark title="3.4 Endian, Byte Ordering, and Alignment">
<destination structID="LinkTarget_30629"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;4 Packet Format Descriptions">
<destination structID="LinkTarget_30630"/>
<bookmark title="4.1 Introduction">
<destination structID="LinkTarget_30631"/>
</bookmark>
<bookmark title="4.2 Request Packet Formats">
<destination structID="LinkTarget_30632"/>
<bookmark title="4.2.1 Addressing and Alignment">
<destination structID="LinkTarget_30633"/>
</bookmark>
<bookmark title="4.2.2 Data Payloads">
<destination structID="LinkTarget_30634"/>
</bookmark>
<bookmark title="4.2.3 Field Definitions for All Request Packet Formats">
<destination structID="LinkTarget_30635"/>
</bookmark>
<bookmark title="4.2.4 Type 0 Packet Format (Implementation-Defined)">
<destination structID="LinkTarget_30636"/>
</bookmark>
<bookmark title="4.2.5 Type 1 Packet Format (Intervention-Request Class)">
<destination structID="LinkTarget_30637"/>
</bookmark>
<bookmark title="4.2.6 Type 2 Packet Format (Request Class)">
<destination structID="LinkTarget_30638"/>
</bookmark>
<bookmark title="4.2.7 Type 3–4 Packet Formats (Reserved)">
<destination structID="LinkTarget_30639"/>
</bookmark>
<bookmark title="4.2.8 Type 5 Packet Format (Write Class)">
<destination structID="LinkTarget_30640"/>
</bookmark>
<bookmark title="4.2.9 Type 6–11 Packet Formats (Reserved)">
<destination structID="LinkTarget_30641"/>
</bookmark>
</bookmark>
<bookmark title="4.3 Response Packet Formats">
<destination structID="LinkTarget_30642"/>
<bookmark title="4.3.1 Field Definitions for All Response Packet Formats">
<destination structID="LinkTarget_30643"/>
</bookmark>
<bookmark title="4.3.2 Type 12 Packet Format (Reserved)">
<destination structID="LinkTarget_30644"/>
</bookmark>
<bookmark title="4.3.3 Type 13 Packet Format (Response Class)">
<destination structID="LinkTarget_30645"/>
</bookmark>
<bookmark title="4.3.4 Type 14 Packet Format (Reserved)">
<destination structID="LinkTarget_30646"/>
</bookmark>
<bookmark title="4.3.5 Type 15 Packet Format (Implementation-Defined)">
<destination structID="LinkTarget_30647"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;5 Globally Shared Memory Registers">
<destination structID="LinkTarget_30648"/>
<bookmark title="5.1 Introduction">
<destination structID="LinkTarget_30649"/>
</bookmark>
<bookmark title="5.2 Register Summary">
<destination structID="LinkTarget_30650"/>
</bookmark>
<bookmark title="5.3 Reserved Register and Bit Behavior">
<destination structID="LinkTarget_30651"/>
</bookmark>
<bookmark title="5.4 Capability Registers (CARs)">
<destination structID="LinkTarget_30652"/>
<bookmark title="5.4.1 Source Operations CAR (Configuration Space Offset 0x18)">
<destination structID="LinkTarget_30653"/>
</bookmark>
<bookmark title="5.4.2 Destination Operations CAR (Configuration Space Offset 0x1C)">
<destination structID="LinkTarget_30654"/>
</bookmark>
</bookmark>
<bookmark title="5.5 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_30655"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;6 Communication Protocols">
<destination structID="LinkTarget_30656"/>
<bookmark title="6.1 Introduction">
<destination structID="LinkTarget_30657"/>
</bookmark>
<bookmark title="6.2 Definitions">
<destination structID="LinkTarget_30658"/>
<bookmark title="6.2.1 General Definitions">
<destination structID="LinkTarget_30659"/>
</bookmark>
<bookmark title="6.2.2 Request and Response Definitions">
<destination structID="LinkTarget_30660"/>
<bookmark title="6.2.2.1 System Request">
<destination structID="LinkTarget_30661"/>
</bookmark>
<bookmark title="6.2.2.2 Local Request">
<destination structID="LinkTarget_30662"/>
</bookmark>
<bookmark title="6.2.2.3 System Response">
<destination structID="LinkTarget_30663"/>
</bookmark>
<bookmark title="6.2.2.4 Local Response">
<destination structID="LinkTarget_30664"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="6.3 Operation to Protocol Cross Reference">
<destination structID="LinkTarget_30665"/>
</bookmark>
<bookmark title="6.4 Read Operations">
<destination structID="LinkTarget_30666"/>
<bookmark title="6.4.1 Internal Request State Machine">
<destination structID="LinkTarget_30667"/>
</bookmark>
<bookmark title="6.4.2 Response State Machine">
<destination structID="LinkTarget_30668"/>
</bookmark>
<bookmark title="6.4.3 External Request State Machine">
<destination structID="LinkTarget_30669"/>
</bookmark>
</bookmark>
<bookmark title="6.5 Instruction Read Operations">
<destination structID="LinkTarget_30670"/>
<bookmark title="6.5.1 Internal Request State Machine">
<destination structID="LinkTarget_30671"/>
</bookmark>
<bookmark title="6.5.2 Response State Machine">
<destination structID="LinkTarget_30672"/>
</bookmark>
<bookmark title="6.5.3 External Request State Machine">
<destination structID="LinkTarget_30673"/>
</bookmark>
</bookmark>
<bookmark title="6.6 Read for Ownership Operations">
<destination structID="LinkTarget_30674"/>
<bookmark title="6.6.1 Internal Request State Machine">
<destination structID="LinkTarget_30675"/>
</bookmark>
<bookmark title="6.6.2 Response State Machine">
<destination structID="LinkTarget_30676"/>
</bookmark>
<bookmark title="6.6.3 External Request State Machine">
<destination structID="LinkTarget_30677"/>
</bookmark>
</bookmark>
<bookmark title="6.7 Data Cache and Instruction Cache Invalidate Operations">
<destination structID="LinkTarget_30678"/>
<bookmark title="6.7.1 Internal Request State Machine">
<destination structID="LinkTarget_30679"/>
</bookmark>
<bookmark title="6.7.2 Response State Machine">
<destination structID="LinkTarget_30680"/>
</bookmark>
<bookmark title="6.7.3 External Request State Machine">
<destination structID="LinkTarget_30681"/>
</bookmark>
</bookmark>
<bookmark title="6.8 Castout Operations">
<destination structID="LinkTarget_30682"/>
<bookmark title="6.8.1 Internal Request State Machine">
<destination structID="LinkTarget_30683"/>
</bookmark>
<bookmark title="6.8.2 Response State Machine">
<destination structID="LinkTarget_30684"/>
</bookmark>
<bookmark title="6.8.3 External Request State Machine">
<destination structID="LinkTarget_30685"/>
</bookmark>
</bookmark>
<bookmark title="6.9 TLB Invalidate Entry, TLB Invalidate Entry Synchronize Operations">
<destination structID="LinkTarget_30686"/>
<bookmark title="6.9.1 Internal Request State Machine">
<destination structID="LinkTarget_30687"/>
</bookmark>
<bookmark title="6.9.2 Response State Machine">
<destination structID="LinkTarget_30688"/>
</bookmark>
<bookmark title="6.9.3 External Request State Machine">
<destination structID="LinkTarget_30689"/>
</bookmark>
</bookmark>
<bookmark title="6.10 Data Cache Flush Operations">
<destination structID="LinkTarget_30690"/>
<bookmark title="6.10.1 Internal Request State Machine">
<destination structID="LinkTarget_30691"/>
</bookmark>
<bookmark title="6.10.2 Response State Machine">
<destination structID="LinkTarget_30692"/>
</bookmark>
<bookmark title="6.10.3 External Request State Machine">
<destination structID="LinkTarget_30693"/>
</bookmark>
</bookmark>
<bookmark title="6.11 I/O Read Operations">
<destination structID="LinkTarget_30694"/>
<bookmark title="6.11.1 Internal Request State Machine">
<destination structID="LinkTarget_30695"/>
</bookmark>
<bookmark title="6.11.2 Response State Machine">
<destination structID="LinkTarget_30696"/>
</bookmark>
<bookmark title="6.11.3 External Request State Machine">
<destination structID="LinkTarget_30697"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;7 Address Collision Resolution Tables">
<destination structID="LinkTarget_30698"/>
<bookmark title="7.1 Introduction">
<destination structID="LinkTarget_30699"/>
</bookmark>
<bookmark title="7.2 Resolving an Outstanding READ_HOME Transaction">
<destination structID="LinkTarget_30700"/>
</bookmark>
<bookmark title="7.3 Resolving an Outstanding IREAD_HOME Transaction">
<destination structID="LinkTarget_30701"/>
</bookmark>
<bookmark title="7.4 Resolving an Outstanding READ_OWNER Transaction">
<destination structID="LinkTarget_30702"/>
</bookmark>
<bookmark title="7.5 Resolving an Outstanding READ_TO_OWN_HOME Transaction">
<destination structID="LinkTarget_30703"/>
</bookmark>
<bookmark title="7.6 Resolving an Outstanding READ_TO_OWN_OWNER Transaction">
<destination structID="LinkTarget_30704"/>
</bookmark>
<bookmark title="7.7 Resolving an Outstanding DKILL_HOME Transaction">
<destination structID="LinkTarget_30705"/>
</bookmark>
<bookmark title="7.8 Resolving an Outstanding DKILL_SHARER Transaction">
<destination structID="LinkTarget_30706"/>
</bookmark>
<bookmark title="7.9 Resolving an Outstanding IKILL_HOME Transaction">
<destination structID="LinkTarget_30707"/>
</bookmark>
<bookmark title="7.10 Resolving an Outstanding IKILL_SHARER Transaction">
<destination structID="LinkTarget_30708"/>
</bookmark>
<bookmark title="7.11 Resolving an Outstanding CASTOUT Transaction">
<destination structID="LinkTarget_30709"/>
</bookmark>
<bookmark title="7.12 Resolving an Outstanding TLBIE or TLBSYNC Transaction">
<destination structID="LinkTarget_30710"/>
</bookmark>
<bookmark title="7.13 Resolving an Outstanding FLUSH Transaction">
<destination structID="LinkTarget_30711"/>
</bookmark>
<bookmark title="7.14 Resolving an Outstanding IO_READ_HOME Transaction">
<destination structID="LinkTarget_30712"/>
</bookmark>
<bookmark title="7.15 Resolving an Outstanding IO_READ_OWNER Transaction">
<destination structID="LinkTarget_30713"/>
</bookmark>
</bookmark>
<bookmark title="Glossary of Terms and Abbreviations">
<destination structID="LinkTarget_30714"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="serial_book">
<destination structID="LinkTarget_7556"/>
<bookmark title="RapidIOTM Interconnect Specification Part 6: 1x/4x LP-Serial Physical Layer Specification">
<destination structID="LinkTarget_30715"/>
<bookmark title="Chapter&#17;1 Overview">
<destination structID="LinkTarget_30716"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_30717"/>
</bookmark>
<bookmark title="1.2 Packets">
<destination structID="LinkTarget_30718"/>
</bookmark>
<bookmark title="1.3 Control Symbols">
<destination structID="LinkTarget_30719"/>
</bookmark>
<bookmark title="1.4 PCS and PMA Layers">
<destination structID="LinkTarget_30720"/>
</bookmark>
<bookmark title="1.5 LP-Serial Protocol">
<destination structID="LinkTarget_30721"/>
</bookmark>
<bookmark title="1.6 LP-Serial Registers">
<destination structID="LinkTarget_30722"/>
</bookmark>
<bookmark title="1.7 Signal Descriptions">
<destination structID="LinkTarget_30723"/>
</bookmark>
<bookmark title="1.8 AC Electrical Specifications">
<destination structID="LinkTarget_30724"/>
</bookmark>
<bookmark title="1.9 Interface Management">
<destination structID="LinkTarget_30725"/>
</bookmark>
<bookmark title="1.10 System Resources">
<destination structID="LinkTarget_30726"/>
</bookmark>
<bookmark title="1.11 Manufacturability and Testability">
<destination structID="LinkTarget_30727"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 Packets">
<destination structID="LinkTarget_30728"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_30729"/>
</bookmark>
<bookmark title="2.2 Packet Field Definitions">
<destination structID="LinkTarget_30730"/>
</bookmark>
<bookmark title="2.3 Packet Format">
<destination structID="LinkTarget_30731"/>
</bookmark>
<bookmark title="2.4 Packet Protection">
<destination structID="LinkTarget_30732"/>
<bookmark title="2.4.1 Packet CRC Operation">
<destination structID="LinkTarget_30733"/>
</bookmark>
<bookmark title="2.4.2 16-Bit Packet CRC Code">
<destination structID="LinkTarget_30734"/>
</bookmark>
</bookmark>
<bookmark title="2.5 Maximum Packet Size">
<destination structID="LinkTarget_30735"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 Control Symbols">
<destination structID="LinkTarget_30736"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_30737"/>
</bookmark>
<bookmark title="3.2 Control Symbol Field Definitions">
<destination structID="LinkTarget_30738"/>
</bookmark>
<bookmark title="3.3 Control Symbol Format">
<destination structID="LinkTarget_30739"/>
</bookmark>
<bookmark title="3.4 Stype0 Control Symbols">
<destination structID="LinkTarget_30740"/>
<bookmark title="3.4.1 Packet-Accepted Control Symbol">
<destination structID="LinkTarget_30741"/>
</bookmark>
<bookmark title="3.4.2 Packet-Retry Control Symbol">
<destination structID="LinkTarget_30742"/>
</bookmark>
<bookmark title="3.4.3 Packet-Not-Accepted Control Symbol">
<destination structID="LinkTarget_30743"/>
</bookmark>
<bookmark title="3.4.4 Status Control Symbol">
<destination structID="LinkTarget_30744"/>
</bookmark>
<bookmark title="3.4.5 Link-Response Control Symbol">
<destination structID="LinkTarget_30745"/>
</bookmark>
</bookmark>
<bookmark title="3.5 Stype1 Control Symbols">
<destination structID="LinkTarget_30746"/>
<bookmark title="3.5.1 Start-of-Packet Control Symbol">
<destination structID="LinkTarget_30747"/>
</bookmark>
<bookmark title="3.5.2 Stomp Control Symbol">
<destination structID="LinkTarget_30748"/>
</bookmark>
<bookmark title="3.5.3 End-of-Packet Control Symbol">
<destination structID="LinkTarget_30749"/>
</bookmark>
<bookmark title="3.5.4 Restart-From-Retry Control Symbol">
<destination structID="LinkTarget_30750"/>
</bookmark>
<bookmark title="3.5.5 Link-Request Control Symbol">
<destination structID="LinkTarget_30751"/>
<bookmark title="3.5.5.1 Reset-Device Command">
<destination structID="LinkTarget_30752"/>
</bookmark>
<bookmark title="3.5.5.2 Input-Status Command">
<destination structID="LinkTarget_30753"/>
</bookmark>
</bookmark>
<bookmark title="3.5.6 Multicast-Event Control Symbol">
<destination structID="LinkTarget_30754"/>
</bookmark>
</bookmark>
<bookmark title="3.6 Control Symbol Protection">
<destination structID="LinkTarget_30755"/>
<bookmark title="3.6.1 CRC-5 Code">
<destination structID="LinkTarget_30756"/>
</bookmark>
<bookmark title="3.6.2 CRC-5 Parallel Code Generation">
<destination structID="LinkTarget_30757"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;4 PCS and PMA Layers">
<destination structID="LinkTarget_30758"/>
<bookmark title="4.1 Introduction">
<destination structID="LinkTarget_30759"/>
</bookmark>
<bookmark title="4.2 PCS Layer Functions">
<destination structID="LinkTarget_30760"/>
</bookmark>
<bookmark title="4.3 PMA Layer Functions">
<destination structID="LinkTarget_30761"/>
</bookmark>
<bookmark title="4.4 Definitions">
<destination structID="LinkTarget_30762"/>
</bookmark>
<bookmark title="4.5 8B/10B Transmission Code">
<destination structID="LinkTarget_30763"/>
<bookmark title="4.5.1 Character and Code-Group Notation">
<destination structID="LinkTarget_30764"/>
</bookmark>
<bookmark title="4.5.2 Running Disparity">
<destination structID="LinkTarget_30765"/>
</bookmark>
<bookmark title="4.5.3 Running Disparity Rules">
<destination structID="LinkTarget_30766"/>
</bookmark>
<bookmark title="4.5.4 8B/10B Encoding">
<destination structID="LinkTarget_30767"/>
</bookmark>
<bookmark title="4.5.5 Transmission Order">
<destination structID="LinkTarget_30768"/>
</bookmark>
<bookmark title="4.5.6 8B/10B Decoding">
<destination structID="LinkTarget_30769"/>
</bookmark>
<bookmark title="4.5.7 Special Characters and Columns">
<destination structID="LinkTarget_30770"/>
<bookmark title="4.5.7.1 Packet Delimiter Control Symbol (/PD/)">
<destination structID="LinkTarget_30771"/>
</bookmark>
<bookmark title="4.5.7.2 Start of Control Symbol (/SC/)">
<destination structID="LinkTarget_30772"/>
</bookmark>
<bookmark title="4.5.7.3 Idle (/I/)">
<destination structID="LinkTarget_30773"/>
</bookmark>
<bookmark title="4.5.7.4 Sync (/K/)">
<destination structID="LinkTarget_30774"/>
</bookmark>
<bookmark title="4.5.7.5 Skip (/R/)">
<destination structID="LinkTarget_30775"/>
</bookmark>
<bookmark title="4.5.7.6 Align (/A/)">
<destination structID="LinkTarget_30776"/>
</bookmark>
</bookmark>
<bookmark title="4.5.8 Effect of Single Bit Code-Group Errors">
<destination structID="LinkTarget_30777"/>
</bookmark>
<bookmark title="4.5.9 Idle Sequence">
<destination structID="LinkTarget_30778"/>
<bookmark title="4.5.9.1 Idle Sequence Generation">
<destination structID="LinkTarget_30779"/>
</bookmark>
</bookmark>
<bookmark title="4.5.10 1x Link Transmission Rules">
<destination structID="LinkTarget_30780"/>
</bookmark>
<bookmark title="4.5.11 4x Link Striping and Transmission Rules">
<destination structID="LinkTarget_30781"/>
</bookmark>
</bookmark>
<bookmark title="4.6 Retimers and Repeaters">
<destination structID="LinkTarget_30782"/>
<bookmark title="4.6.1 Retimers">
<destination structID="LinkTarget_30783"/>
</bookmark>
<bookmark title="4.6.2 Repeaters">
<destination structID="LinkTarget_30784"/>
</bookmark>
</bookmark>
<bookmark title="4.7 Port Initialization">
<destination structID="LinkTarget_30785"/>
<bookmark title="4.7.1 1x Mode Initialization">
<destination structID="LinkTarget_30786"/>
</bookmark>
<bookmark title="4.7.2 1x/4x Mode Initialization">
<destination structID="LinkTarget_30787"/>
</bookmark>
<bookmark title="4.7.3 State Machines">
<destination structID="LinkTarget_30788"/>
<bookmark title="4.7.3.1 State Machine Conventions">
<destination structID="LinkTarget_30789"/>
</bookmark>
<bookmark title="4.7.3.2 State Machine Variables and Functions">
<destination structID="LinkTarget_30790"/>
</bookmark>
<bookmark title="4.7.3.3 Lane Synchronization State Machine">
<destination structID="LinkTarget_30791"/>
</bookmark>
<bookmark title="4.7.3.4 Lane Alignment State Machine">
<destination structID="LinkTarget_30792"/>
</bookmark>
<bookmark title="4.7.3.5 1x Mode Initialization State Machine">
<destination structID="LinkTarget_30793"/>
</bookmark>
<bookmark title="4.7.3.6 1x/4x Mode Initialization State Machine">
<destination structID="LinkTarget_30794"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;5 LP-Serial Protocol">
<destination structID="LinkTarget_30795"/>
<bookmark title="5.1 Introduction">
<destination structID="LinkTarget_30796"/>
</bookmark>
<bookmark title="5.2 Packet Exchange Protocol">
<destination structID="LinkTarget_30797"/>
</bookmark>
<bookmark title="5.3 Control Symbols">
<destination structID="LinkTarget_30798"/>
<bookmark title="5.3.1 Control Symbol Delimiting">
<destination structID="LinkTarget_30799"/>
</bookmark>
<bookmark title="5.3.2 Control Symbol Transmission">
<destination structID="LinkTarget_30800"/>
</bookmark>
<bookmark title="5.3.3 Embedded Control Symbols">
<destination structID="LinkTarget_30801"/>
</bookmark>
<bookmark title="5.3.4 Multicast-Event Control Symbols">
<destination structID="LinkTarget_30802"/>
</bookmark>
</bookmark>
<bookmark title="5.4 Packets">
<destination structID="LinkTarget_30803"/>
<bookmark title="5.4.1 Packet Delimiting">
<destination structID="LinkTarget_30804"/>
<bookmark title="5.4.1.1 Packet Start">
<destination structID="LinkTarget_30805"/>
</bookmark>
<bookmark title="5.4.1.2 Packet Termination">
<destination structID="LinkTarget_30806"/>
</bookmark>
</bookmark>
<bookmark title="5.4.2 Acknowledgment Identifier">
<destination structID="LinkTarget_30807"/>
</bookmark>
<bookmark title="5.4.3 Packet Priority and Transaction Request Flows">
<destination structID="LinkTarget_30808"/>
</bookmark>
</bookmark>
<bookmark title="5.5 Link Maintenance Protocol">
<destination structID="LinkTarget_30809"/>
</bookmark>
<bookmark title="5.6 Packet Transmission Protocol">
<destination structID="LinkTarget_30810"/>
</bookmark>
<bookmark title="5.7 Flow Control">
<destination structID="LinkTarget_30811"/>
<bookmark title="5.7.1 Receiver-Controlled Flow Control">
<destination structID="LinkTarget_30812"/>
</bookmark>
<bookmark title="5.7.2 Transmitter-Controlled Flow Control">
<destination structID="LinkTarget_30813"/>
<bookmark title="5.7.2.1 Input Retry-Stopped Recovery Process">
<destination structID="LinkTarget_30814"/>
</bookmark>
<bookmark title="5.7.2.2 Output Retry-Stopped Recovery Process">
<destination structID="LinkTarget_30815"/>
</bookmark>
<bookmark title="5.7.2.3 Receive Buffer Management">
<destination structID="LinkTarget_30816"/>
</bookmark>
<bookmark title="5.7.2.4 Effective Number of Free Receive Buffers">
<destination structID="LinkTarget_30817"/>
</bookmark>
<bookmark title="5.7.2.5 Speculative Packet Transmission">
<destination structID="LinkTarget_30818"/>
</bookmark>
</bookmark>
<bookmark title="5.7.3 Flow Control Mode Negotiation">
<destination structID="LinkTarget_30819"/>
</bookmark>
</bookmark>
<bookmark title="5.8 Canceling Packets">
<destination structID="LinkTarget_30820"/>
</bookmark>
<bookmark title="5.9 Transaction and Packet Delivery Ordering Rules">
<destination structID="LinkTarget_30821"/>
</bookmark>
<bookmark title="5.10 Deadlock Avoidance">
<destination structID="LinkTarget_30822"/>
</bookmark>
<bookmark title="5.11 Error Detection and Recovery">
<destination structID="LinkTarget_30823"/>
<bookmark title="5.11.1 Lost Packet Detection">
<destination structID="LinkTarget_30824"/>
</bookmark>
<bookmark title="5.11.2 Link Behavior Under Error">
<destination structID="LinkTarget_30825"/>
<bookmark title="5.11.2.1 Recoverable Errors">
<destination structID="LinkTarget_30826"/>
</bookmark>
<bookmark title="5.11.2.2 Idle Sequence Errors">
<destination structID="LinkTarget_30827"/>
</bookmark>
<bookmark title="5.11.2.3 Control Symbol Errors">
<destination structID="LinkTarget_30828"/>
<bookmark title="5.11.2.3.1 Link Protocol Violations">
<destination structID="LinkTarget_30829"/>
</bookmark>
<bookmark title="5.11.2.3.2 Corrupted Control symbols">
<destination structID="LinkTarget_30830"/>
</bookmark>
</bookmark>
<bookmark title="5.11.2.4 Packet Errors">
<destination structID="LinkTarget_30831"/>
</bookmark>
<bookmark title="5.11.2.5 Link Time-Out">
<destination structID="LinkTarget_30832"/>
</bookmark>
<bookmark title="5.11.2.6 Input Error-Stopped Recovery Process">
<destination structID="LinkTarget_30833"/>
</bookmark>
<bookmark title="5.11.2.7 Output Error-Stopped Recovery Process">
<destination structID="LinkTarget_30834"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="5.12 Power Management">
<destination structID="LinkTarget_30835"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;6 LP-Serial Registers">
<destination structID="LinkTarget_30836"/>
<bookmark title="6.1 Introduction">
<destination structID="LinkTarget_30837"/>
</bookmark>
<bookmark title="6.2 Register Map">
<destination structID="LinkTarget_30838"/>
</bookmark>
<bookmark title="6.3 Reserved Register and Bit Behavior">
<destination structID="LinkTarget_30839"/>
</bookmark>
<bookmark title="6.4 Capability Registers (CARs)">
<destination structID="LinkTarget_30840"/>
<bookmark title="6.4.1 Processing Element Features CAR (Configuration Space Offset 0x10)">
<destination structID="LinkTarget_30841"/>
</bookmark>
</bookmark>
<bookmark title="6.5 Generic End Point Devices">
<destination structID="LinkTarget_30842"/>
<bookmark title="6.5.1 Register Map">
<destination structID="LinkTarget_30843"/>
</bookmark>
<bookmark title="6.5.2 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_30844"/>
<bookmark title="6.5.2.1 1x/4x LP-Serial Register Block Header (Block Offset 0x0)">
<destination structID="LinkTarget_30845"/>
</bookmark>
<bookmark title="6.5.2.2 Port Link Time-out Control CSR (Block Offset 0x20)">
<destination structID="LinkTarget_30846"/>
</bookmark>
<bookmark title="6.5.2.3 Port Response Time-out Control CSR (Block Offset 0x24)">
<destination structID="LinkTarget_30847"/>
</bookmark>
<bookmark title="6.5.2.4 Port General Control CSR (Block Offset 0x3C)">
<destination structID="LinkTarget_30848"/>
</bookmark>
<bookmark title="6.5.2.5 Port n Error and Status CSRs (Block Offsets 0x58, 78, ..., 238)">
<destination structID="LinkTarget_30849"/>
</bookmark>
<bookmark title="6.5.2.6 Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C)">
<destination structID="LinkTarget_30850"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="6.6 Generic End Point Devices, software assisted error recovery option">
<destination structID="LinkTarget_30851"/>
<bookmark title="6.6.1 Register Map">
<destination structID="LinkTarget_30852"/>
</bookmark>
<bookmark title="6.6.2 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_30853"/>
<bookmark title="6.6.2.1 1x/4x LP-Serial Register Block Header (Block Offset 0x0)">
<destination structID="LinkTarget_30854"/>
</bookmark>
<bookmark title="6.6.2.2 Port Link Time-out Control CSR (Block Offset 0x20)">
<destination structID="LinkTarget_30855"/>
</bookmark>
<bookmark title="6.6.2.3 Port Response Time-out Control CSR (Block Offset 0x24)">
<destination structID="LinkTarget_30856"/>
</bookmark>
<bookmark title="6.6.2.4 Port General Control CSR (Block Offset 0x3C)">
<destination structID="LinkTarget_30857"/>
</bookmark>
<bookmark title="6.6.2.5 Port n Link Maintenance Request CSRs (Block Offsets 0x40, 60, ..., 220)">
<destination structID="LinkTarget_30858"/>
</bookmark>
<bookmark title="6.6.2.6 Port n Link Maintenance Response CSRs (Block Offsets 0x44, 64, ..., 224)">
<destination structID="LinkTarget_30859"/>
</bookmark>
<bookmark title="6.6.2.7 Port n Local ackID CSRs (Block Offsets 0x48, 68, ..., 228)">
<destination structID="LinkTarget_30860"/>
</bookmark>
<bookmark title="6.6.2.8 Port n Error and Status CSRs (Block Offset 0x58, 78, ..., 238)">
<destination structID="LinkTarget_30861"/>
</bookmark>
<bookmark title="6.6.2.9 Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C)">
<destination structID="LinkTarget_30862"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="6.7 Generic End Point Free Devices">
<destination structID="LinkTarget_30863"/>
<bookmark title="6.7.1 Register Map">
<destination structID="LinkTarget_30864"/>
</bookmark>
<bookmark title="6.7.2 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_30865"/>
<bookmark title="6.7.2.1 1x/4x LP-Serial Register Block Header (Block Offset 0x0)">
<destination structID="LinkTarget_30866"/>
</bookmark>
<bookmark title="6.7.2.2 Port Link Time-out Control CSR (Block Offset 0x20)">
<destination structID="LinkTarget_30867"/>
</bookmark>
<bookmark title="6.7.2.3 Port General Control CSR (Block Offset 0x3C)">
<destination structID="LinkTarget_30868"/>
</bookmark>
<bookmark title="6.7.2.4 Port n Error and Status CSRs (Block Offsets 0x58, 78, .., 238)">
<destination structID="LinkTarget_30869"/>
</bookmark>
<bookmark title="6.7.2.5 Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C)">
<destination structID="LinkTarget_30870"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="6.8 Generic End Point Free Devices, software assisted error recovery option">
<destination structID="LinkTarget_30871"/>
<bookmark title="6.8.1 Register Map">
<destination structID="LinkTarget_30872"/>
</bookmark>
<bookmark title="6.8.2 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_30873"/>
<bookmark title="6.8.2.1 1x/4x LP-Serial Register Block Header (Block Offset 0x0)">
<destination structID="LinkTarget_30874"/>
</bookmark>
<bookmark title="6.8.2.2 Port Link Time-out Control CSR (Block Offset 0x20)">
<destination structID="LinkTarget_30875"/>
</bookmark>
<bookmark title="6.8.2.3 Port General Control CSR (Block Offset 0x3C)">
<destination structID="LinkTarget_30876"/>
</bookmark>
<bookmark title="6.8.2.4 Port n Link Maintenance Request CSRs (Block Offsets 0x40, 60, ..., 220)">
<destination structID="LinkTarget_30877"/>
</bookmark>
<bookmark title="6.8.2.5 Port n Link Maintenance Response CSRs (Block Offsets 0x44, 64, ..., 224)">
<destination structID="LinkTarget_30878"/>
</bookmark>
<bookmark title="6.8.2.6 Port n Local ackID CSRs (Block Offsets 0x48, 68, ..., 228)">
<destination structID="LinkTarget_30879"/>
</bookmark>
<bookmark title="6.8.2.7 Port n Error and Status CSRs (Block Offset 0x58, 78, ..., 238)">
<destination structID="LinkTarget_30880"/>
</bookmark>
<bookmark title="6.8.2.8 Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C)">
<destination structID="LinkTarget_30881"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;7 Signal Descriptions">
<destination structID="LinkTarget_30882"/>
<bookmark title="7.1 Introduction">
<destination structID="LinkTarget_30883"/>
</bookmark>
<bookmark title="7.2 Signal Definitions">
<destination structID="LinkTarget_30884"/>
</bookmark>
<bookmark title="7.3 Serial RapidIO Interface Diagrams">
<destination structID="LinkTarget_30885"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;8 Electrical Specifications">
<destination structID="LinkTarget_30886"/>
<bookmark title="8.1 Introduction">
<destination structID="LinkTarget_30887"/>
</bookmark>
<bookmark title="8.2 Signal Definitions">
<destination structID="LinkTarget_30888"/>
</bookmark>
<bookmark title="8.3 Equalization">
<destination structID="LinkTarget_30889"/>
</bookmark>
<bookmark title="8.4 Explanatory Note on Transmitter and Receiver Specifications">
<destination structID="LinkTarget_30890"/>
</bookmark>
<bookmark title="8.5 Transmitter Specifications">
<destination structID="LinkTarget_30891"/>
</bookmark>
<bookmark title="8.6 Receiver Specifications">
<destination structID="LinkTarget_30892"/>
</bookmark>
<bookmark title="8.7 Receiver Eye Diagrams">
<destination structID="LinkTarget_30893"/>
</bookmark>
<bookmark title="8.8 Measurement and Test Requirements">
<destination structID="LinkTarget_30894"/>
<bookmark title="8.8.1 Eye template measurements">
<destination structID="LinkTarget_30895"/>
</bookmark>
<bookmark title="8.8.2 Jitter test measurements">
<destination structID="LinkTarget_30896"/>
</bookmark>
<bookmark title="8.8.3 Transmit jitter">
<destination structID="LinkTarget_30897"/>
</bookmark>
<bookmark title="8.8.4 Jitter tolerance">
<destination structID="LinkTarget_30898"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Annex&#17;A Interface Management (Informative)">
<destination structID="LinkTarget_30899"/>
<bookmark title="A.1 Introduction">
<destination structID="LinkTarget_30900"/>
</bookmark>
<bookmark title="A.2 Packet Retry Mechanism">
<destination structID="LinkTarget_30901"/>
<bookmark title="A.2.1 Input port retry recovery state machine">
<destination structID="LinkTarget_30902"/>
</bookmark>
<bookmark title="A.2.2 Output port retry recovery state machine">
<destination structID="LinkTarget_30903"/>
</bookmark>
</bookmark>
<bookmark title="A.3 Error Recovery">
<destination structID="LinkTarget_30904"/>
<bookmark title="A.3.1 Input port error recovery state machine">
<destination structID="LinkTarget_30905"/>
</bookmark>
<bookmark title="A.3.2 Output port error recovery state machine">
<destination structID="LinkTarget_30906"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Annex&#17;B Critical Resource Performance Limits (Informative)">
<destination structID="LinkTarget_30907"/>
</bookmark>
<bookmark title="Annex&#17;C Manufacturability and Testability (Informative)">
<destination structID="LinkTarget_30908"/>
</bookmark>
<bookmark title="Glossary of Terms and Abbreviations">
<destination structID="LinkTarget_30909"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="inter-op">
<destination structID="LinkTarget_7418"/>
<bookmark title="RapidIOTM Interconnect Specification Part 7: System and Device Inter-operability Specification">
<destination structID="LinkTarget_30910"/>
<bookmark title="Chapter&#17;1 Overview">
<destination structID="LinkTarget_30911"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_30912"/>
</bookmark>
<bookmark title="1.2 Overview">
<destination structID="LinkTarget_30913"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 System Exploration and Initialization">
<destination structID="LinkTarget_30914"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_30915"/>
</bookmark>
<bookmark title="2.2 Boot code access">
<destination structID="LinkTarget_30916"/>
</bookmark>
<bookmark title="2.3 Exploration and initialization">
<destination structID="LinkTarget_30917"/>
<bookmark title="2.3.1 Exploration and initialization rules">
<destination structID="LinkTarget_30918"/>
</bookmark>
<bookmark title="2.3.2 Exploration and initialization algorithm">
<destination structID="LinkTarget_30919"/>
</bookmark>
<bookmark title="2.3.3 Exploration and initialization example">
<destination structID="LinkTarget_30920"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 RapidIO Device Class Requirements">
<destination structID="LinkTarget_30921"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_30922"/>
</bookmark>
<bookmark title="3.2 Class Partitioning">
<destination structID="LinkTarget_30923"/>
<bookmark title="3.2.1 Generic: All devices">
<destination structID="LinkTarget_30924"/>
<bookmark title="3.2.1.1 General requirements">
<destination structID="LinkTarget_30925"/>
</bookmark>
<bookmark title="3.2.1.2 Operation support as target">
<destination structID="LinkTarget_30926"/>
</bookmark>
<bookmark title="3.2.1.3 Operation support as source">
<destination structID="LinkTarget_30927"/>
</bookmark>
</bookmark>
<bookmark title="3.2.2 Class 1: Simple target device">
<destination structID="LinkTarget_30928"/>
<bookmark title="3.2.2.1 General requirements">
<destination structID="LinkTarget_30929"/>
</bookmark>
<bookmark title="3.2.2.2 Operation support as target">
<destination structID="LinkTarget_30930"/>
</bookmark>
<bookmark title="3.2.2.3 Operation support as source">
<destination structID="LinkTarget_30931"/>
</bookmark>
</bookmark>
<bookmark title="3.2.3 Class 2: Simple mastering device">
<destination structID="LinkTarget_30932"/>
<bookmark title="3.2.3.1 General requirements">
<destination structID="LinkTarget_30933"/>
</bookmark>
<bookmark title="3.2.3.2 Operation support as target">
<destination structID="LinkTarget_30934"/>
</bookmark>
<bookmark title="3.2.3.3 Operation support as source">
<destination structID="LinkTarget_30935"/>
</bookmark>
</bookmark>
<bookmark title="3.2.4 Class 3: Complex mastering device">
<destination structID="LinkTarget_30936"/>
<bookmark title="3.2.4.1 General requirements">
<destination structID="LinkTarget_30937"/>
</bookmark>
<bookmark title="3.2.4.2 Operation support as target">
<destination structID="LinkTarget_30938"/>
</bookmark>
<bookmark title="3.2.4.3 Operation support as source">
<destination structID="LinkTarget_30939"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;4 PCI Considerations">
<destination structID="LinkTarget_30940"/>
<bookmark title="4.1 Introduction">
<destination structID="LinkTarget_30941"/>
</bookmark>
<bookmark title="4.2 Address Map Considerations">
<destination structID="LinkTarget_30942"/>
</bookmark>
<bookmark title="4.3 Transaction Flow">
<destination structID="LinkTarget_30943"/>
<bookmark title="4.3.1 PCI 2.2 Transaction Flow">
<destination structID="LinkTarget_30944"/>
</bookmark>
<bookmark title="4.3.2 PCI-X Transaction Flow">
<destination structID="LinkTarget_30945"/>
</bookmark>
</bookmark>
<bookmark title="4.4 RapidIO to PCI Transaction Mapping">
<destination structID="LinkTarget_30946"/>
</bookmark>
<bookmark title="4.5 Operation Ordering and Transaction Delivery">
<destination structID="LinkTarget_30947"/>
<bookmark title="4.5.1 Operation Ordering">
<destination structID="LinkTarget_30948"/>
</bookmark>
<bookmark title="4.5.2 Transaction Delivery Ordering">
<destination structID="LinkTarget_30949"/>
</bookmark>
<bookmark title="4.5.3 PCI-X Relaxed Ordering Considerations">
<destination structID="LinkTarget_30950"/>
</bookmark>
</bookmark>
<bookmark title="4.6 Interactions with Globally Shared Memory">
<destination structID="LinkTarget_30951"/>
<bookmark title="4.6.1 I/O Read Operation Details">
<destination structID="LinkTarget_30952"/>
<bookmark title="4.6.1.1 Internal Request State Machine">
<destination structID="LinkTarget_30953"/>
</bookmark>
<bookmark title="4.6.1.2 Response State Machine">
<destination structID="LinkTarget_30954"/>
</bookmark>
</bookmark>
<bookmark title="4.6.2 Data Cache Flush Operation Details">
<destination structID="LinkTarget_30955"/>
<bookmark title="4.6.2.1 Internal Request State Machine">
<destination structID="LinkTarget_30956"/>
</bookmark>
<bookmark title="4.6.2.2 Response State Machine">
<destination structID="LinkTarget_30957"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="4.7 Byte Lane and Byte Enable Usage">
<destination structID="LinkTarget_30958"/>
</bookmark>
<bookmark title="4.8 Error Management">
<destination structID="LinkTarget_30959"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;5 Globally Shared Memory Devices">
<destination structID="LinkTarget_30960"/>
<bookmark title="5.1 Introduction">
<destination structID="LinkTarget_30961"/>
</bookmark>
<bookmark title="5.2 Processing Element Behavior">
<destination structID="LinkTarget_30962"/>
<bookmark title="5.2.1 Processor-Memory Processing Element">
<destination structID="LinkTarget_30963"/>
<bookmark title="5.2.1.1 I/O Read Operations">
<destination structID="LinkTarget_30964"/>
<bookmark title="5.2.1.1.1 Response State Machine">
<destination structID="LinkTarget_30965"/>
</bookmark>
<bookmark title="5.2.1.1.2 External Request State Machine">
<destination structID="LinkTarget_30966"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="5.2.2 Memory-only Processing Element">
<destination structID="LinkTarget_30967"/>
<bookmark title="5.2.2.1 Read Operations">
<destination structID="LinkTarget_30968"/>
<bookmark title="5.2.2.1.1 Response State Machine">
<destination structID="LinkTarget_30969"/>
</bookmark>
<bookmark title="5.2.2.1.2 External Request State Machine">
<destination structID="LinkTarget_30970"/>
</bookmark>
</bookmark>
<bookmark title="5.2.2.2 Instruction Read Operations">
<destination structID="LinkTarget_30971"/>
<bookmark title="5.2.2.2.1 Response State Machine">
<destination structID="LinkTarget_30972"/>
</bookmark>
<bookmark title="5.2.2.2.2 External Request State Machine">
<destination structID="LinkTarget_30973"/>
</bookmark>
</bookmark>
<bookmark title="5.2.2.3 Read for Ownership Operations">
<destination structID="LinkTarget_30974"/>
<bookmark title="5.2.2.3.1 Response State Machine">
<destination structID="LinkTarget_30975"/>
</bookmark>
<bookmark title="5.2.2.3.2 External Request State Machine">
<destination structID="LinkTarget_30976"/>
</bookmark>
</bookmark>
<bookmark title="5.2.2.4 Data Cache and Instruction Cache Invalidate Operations">
<destination structID="LinkTarget_30977"/>
<bookmark title="5.2.2.4.1 Response State Machine">
<destination structID="LinkTarget_30978"/>
</bookmark>
<bookmark title="5.2.2.4.2 External Request State Machine">
<destination structID="LinkTarget_30979"/>
</bookmark>
</bookmark>
<bookmark title="5.2.2.5 Castout Operations">
<destination structID="LinkTarget_30980"/>
<bookmark title="5.2.2.5.1 External Request State Machine">
<destination structID="LinkTarget_30981"/>
</bookmark>
</bookmark>
<bookmark title="5.2.2.6 Data Cache Flush Operations">
<destination structID="LinkTarget_30982"/>
<bookmark title="5.2.2.6.1 Response State Machine">
<destination structID="LinkTarget_30983"/>
</bookmark>
<bookmark title="5.2.2.6.2 External Request State Machine">
<destination structID="LinkTarget_30984"/>
</bookmark>
</bookmark>
<bookmark title="5.2.2.7 I/O Read Operations">
<destination structID="LinkTarget_30985"/>
<bookmark title="5.2.2.7.1 Response State Machine">
<destination structID="LinkTarget_30986"/>
</bookmark>
<bookmark title="5.2.2.7.2 External Request State Machine">
<destination structID="LinkTarget_30987"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="5.2.3 Processor-only Processing Element">
<destination structID="LinkTarget_30988"/>
<bookmark title="5.2.3.1 Read Operations">
<destination structID="LinkTarget_30989"/>
<bookmark title="5.2.3.1.1 Internal Request State Machine">
<destination structID="LinkTarget_30990"/>
</bookmark>
<bookmark title="5.2.3.1.2 Response State Machine">
<destination structID="LinkTarget_30991"/>
</bookmark>
<bookmark title="5.2.3.1.3 External Request State Machine">
<destination structID="LinkTarget_30992"/>
</bookmark>
</bookmark>
<bookmark title="5.2.3.2 Instruction Read Operations">
<destination structID="LinkTarget_30993"/>
<bookmark title="5.2.3.2.1 Internal Request State Machine">
<destination structID="LinkTarget_30994"/>
</bookmark>
<bookmark title="5.2.3.2.2 Response State Machine">
<destination structID="LinkTarget_30995"/>
</bookmark>
<bookmark title="5.2.3.2.3 External Request State Machine">
<destination structID="LinkTarget_30996"/>
</bookmark>
</bookmark>
<bookmark title="5.2.3.3 Read for Ownership Operations">
<destination structID="LinkTarget_30997"/>
<bookmark title="5.2.3.3.1 Internal Request State Machine">
<destination structID="LinkTarget_30998"/>
</bookmark>
<bookmark title="5.2.3.3.2 Response State Machine">
<destination structID="LinkTarget_30999"/>
</bookmark>
<bookmark title="5.2.3.3.3 External Request State Machine">
<destination structID="LinkTarget_31000"/>
</bookmark>
</bookmark>
<bookmark title="5.2.3.4 Data Cache and Instruction Cache Invalidate Operations">
<destination structID="LinkTarget_31001"/>
<bookmark title="5.2.3.4.1 Internal Request State Machine">
<destination structID="LinkTarget_31002"/>
</bookmark>
<bookmark title="5.2.3.4.2 Response State Machine">
<destination structID="LinkTarget_31003"/>
</bookmark>
<bookmark title="5.2.3.4.3 External Request State Machine">
<destination structID="LinkTarget_31004"/>
</bookmark>
</bookmark>
<bookmark title="5.2.3.5 Castout Operations">
<destination structID="LinkTarget_31005"/>
<bookmark title="5.2.3.5.1 Internal Request State Machine">
<destination structID="LinkTarget_31006"/>
</bookmark>
<bookmark title="5.2.3.5.2 Response State Machine">
<destination structID="LinkTarget_31007"/>
</bookmark>
</bookmark>
<bookmark title="5.2.3.6 TLB Invalidate Entry, TLB Invalidate Entry Synchronize Operations">
<destination structID="LinkTarget_31008"/>
<bookmark title="5.2.3.6.1 Internal Request State Machine">
<destination structID="LinkTarget_31009"/>
</bookmark>
<bookmark title="5.2.3.6.2 Response State Machine">
<destination structID="LinkTarget_31010"/>
</bookmark>
<bookmark title="5.2.3.6.3 External Request State Machine">
<destination structID="LinkTarget_31011"/>
</bookmark>
</bookmark>
<bookmark title="5.2.3.7 Data Cache Flush Operations">
<destination structID="LinkTarget_31012"/>
<bookmark title="5.2.3.7.1 Internal Request State Machine">
<destination structID="LinkTarget_31013"/>
</bookmark>
<bookmark title="5.2.3.7.2 Response State Machine">
<destination structID="LinkTarget_31014"/>
</bookmark>
<bookmark title="5.2.3.7.3 External Request State Machine">
<destination structID="LinkTarget_31015"/>
</bookmark>
</bookmark>
<bookmark title="5.2.3.8 I/O Read Operations">
<destination structID="LinkTarget_31016"/>
<bookmark title="5.2.3.8.1 External Request State Machine">
<destination structID="LinkTarget_31017"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="5.2.4 I/O Processing Element">
<destination structID="LinkTarget_31018"/>
<bookmark title="5.2.4.1 I/O Read Operations">
<destination structID="LinkTarget_31019"/>
<bookmark title="5.2.4.1.1 Internal Request State Machine">
<destination structID="LinkTarget_31020"/>
</bookmark>
<bookmark title="5.2.4.1.2 Response State Machine">
<destination structID="LinkTarget_31021"/>
</bookmark>
</bookmark>
<bookmark title="5.2.4.2 Data Cache Flush Operations">
<destination structID="LinkTarget_31022"/>
<bookmark title="5.2.4.2.1 Internal Request State Machine">
<destination structID="LinkTarget_31023"/>
</bookmark>
<bookmark title="5.2.4.2.2 Response State Machine">
<destination structID="LinkTarget_31024"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="5.2.5 Switch Processing Element">
<destination structID="LinkTarget_31025"/>
</bookmark>
</bookmark>
<bookmark title="5.3 Transaction to Priority Mappings">
<destination structID="LinkTarget_31026"/>
</bookmark>
</bookmark>
<bookmark title="Glossary of Terms and Abbreviations">
<destination structID="LinkTarget_31027"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="errspec">
<destination structID="LinkTarget_7314"/>
<bookmark title="RapidIO™ Interconnect Specification Part 8: Error Management Extensions Specification">
<destination structID="LinkTarget_31028"/>
<bookmark title="Chapter&#17;1 Error Management Extensions">
<destination structID="LinkTarget_31029"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_31030"/>
</bookmark>
<bookmark title="1.2 Physical Layer Extensions">
<destination structID="LinkTarget_31031"/>
<bookmark title="1.2.1 Port Error Detect, Enable and Capture CSRs">
<destination structID="LinkTarget_31032"/>
</bookmark>
<bookmark title="1.2.2 Error Reporting Thresholds">
<destination structID="LinkTarget_31033"/>
</bookmark>
<bookmark title="1.2.3 Error Rate Control and Status">
<destination structID="LinkTarget_31034"/>
</bookmark>
<bookmark title="1.2.4 Port Behavior When Error Rate Failed Threshold is Reached">
<destination structID="LinkTarget_31035"/>
</bookmark>
<bookmark title="1.2.5 Packet Timeout Mechanism in a Switch Device">
<destination structID="LinkTarget_31036"/>
</bookmark>
</bookmark>
<bookmark title="1.3 Logical and Transport Layer Extensions">
<destination structID="LinkTarget_31037"/>
<bookmark title="1.3.1 Logical/Transport Error Detect, Enable and Capture CSRs">
<destination structID="LinkTarget_31038"/>
</bookmark>
<bookmark title="1.3.2 Message Passing Error Detection">
<destination structID="LinkTarget_31039"/>
</bookmark>
</bookmark>
<bookmark title="1.4 System Software Notification of Error">
<destination structID="LinkTarget_31040"/>
</bookmark>
<bookmark title="1.5 Mechanisms for Software Debug">
<destination structID="LinkTarget_31041"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 Error Management Registers">
<destination structID="LinkTarget_31042"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_31043"/>
</bookmark>
<bookmark title="2.2 Additions to Existing Registers">
<destination structID="LinkTarget_31044"/>
</bookmark>
<bookmark title="2.3 New Error Management Registers">
<destination structID="LinkTarget_31045"/>
<bookmark title="2.3.1 Register Map">
<destination structID="LinkTarget_31046"/>
</bookmark>
<bookmark title="2.3.2 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_31047"/>
<bookmark title="2.3.2.1 Error Management Extensions Block Header (Block Offset 0x0)">
<destination structID="LinkTarget_31048"/>
</bookmark>
<bookmark title="2.3.2.2 Logical/Transport Layer Error Detect CSR (Block Offset 0x08)">
<destination structID="LinkTarget_31049"/>
</bookmark>
<bookmark title="2.3.2.3 Logical/Transport Layer Error Enable CSR (Block Offset 0x0C)">
<destination structID="LinkTarget_31050"/>
</bookmark>
<bookmark title="2.3.2.4 Logical/Transport Layer High Address Capture CSR (Block Offset 0x10)">
<destination structID="LinkTarget_31051"/>
</bookmark>
<bookmark title="2.3.2.5 Logical/Transport Layer Address Capture CSR (Block Offset 0x14)">
<destination structID="LinkTarget_31052"/>
</bookmark>
<bookmark title="2.3.2.6 Logical/Transport Layer Device ID Capture CSR (Block Offset 0x18)">
<destination structID="LinkTarget_31053"/>
</bookmark>
<bookmark title="2.3.2.7 Logical/Transport Layer Control Capture CSR (Block Offset 0x1C)">
<destination structID="LinkTarget_31054"/>
</bookmark>
<bookmark title="2.3.2.8 Port-write Target deviceID CSR (Block Offset 0x28)">
<destination structID="LinkTarget_31055"/>
</bookmark>
<bookmark title="2.3.2.9 Packet Time-to-live CSR (Block Offset 0x2C)">
<destination structID="LinkTarget_31056"/>
</bookmark>
<bookmark title="2.3.2.10 Port n Error Detect CSR (Block Offset 0x40, 80,..., 400)">
<destination structID="LinkTarget_31057"/>
</bookmark>
<bookmark title="2.3.2.11 Port n Error Rate Enable CSR (Block Offset 0x44, 84,..., 404)">
<destination structID="LinkTarget_31058"/>
</bookmark>
<bookmark title="2.3.2.12 Port n Attributes Capture CSR (Block Offset 0x48, 88,..., 408)">
<destination structID="LinkTarget_31059"/>
</bookmark>
<bookmark title="2.3.2.13 Port n Packet/Control Symbol Capture 0 CSR (Block Offset 0x4C, 8C,..., 40C)">
<destination structID="LinkTarget_31060"/>
</bookmark>
<bookmark title="2.3.2.14 Port n Packet Capture 1 CSR (Block Offset 0x50, 90,..., 410)">
<destination structID="LinkTarget_31061"/>
</bookmark>
<bookmark title="2.3.2.15 Port n Packet Capture 2 CSR (Block Offset 0x54, 94,..., 414)">
<destination structID="LinkTarget_31062"/>
</bookmark>
<bookmark title="2.3.2.16 Port n Packet Capture 3 CSR (Block Offset 0x58, 98,..., 418)">
<destination structID="LinkTarget_31063"/>
</bookmark>
<bookmark title="2.3.2.17 Port n Error Rate CSR (Block Offset 0x68, A8,..., 428)">
<destination structID="LinkTarget_31064"/>
</bookmark>
<bookmark title="2.3.2.18 Port n Error Rate Threshold CSR (Block Offset 0x6C, AC,..., 42C)">
<destination structID="LinkTarget_31065"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Annex&#17;A Error Management Discussion (Informative)">
<destination structID="LinkTarget_31066"/>
<bookmark title="A.1 Introduction">
<destination structID="LinkTarget_31067"/>
</bookmark>
<bookmark title="A.2 Limitations of Error Management Discussion">
<destination structID="LinkTarget_31068"/>
</bookmark>
<bookmark title="A.3 Hot-insertion/extraction Discussion">
<destination structID="LinkTarget_31069"/>
</bookmark>
<bookmark title="A.4 Port-write Discussion">
<destination structID="LinkTarget_31070"/>
</bookmark>
<bookmark title="A.5 Physical Layer Fatal Error Recovery Discussion">
<destination structID="LinkTarget_31071"/>
</bookmark>
<bookmark title="A.6 Persistence of Error Management Registers">
<destination structID="LinkTarget_31072"/>
</bookmark>
</bookmark>
<bookmark title="Glossary of Terms and Abbreviations">
<destination structID="LinkTarget_31073"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="fcspec">
<destination structID="LinkTarget_7248"/>
<bookmark title="RapidIO™ Interconnect Specification Part 9: Flow Control Logical Layer Extensions Specification">
<destination structID="LinkTarget_31074"/>
<bookmark title="Chapter&#17;1 Flow Control Overview">
<destination structID="LinkTarget_31075"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_31076"/>
</bookmark>
<bookmark title="1.2 Requirements">
<destination structID="LinkTarget_31077"/>
</bookmark>
<bookmark title="1.3 Problem Illustration">
<destination structID="LinkTarget_31078"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 Logical Layer Flow Control Operation">
<destination structID="LinkTarget_31079"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_31080"/>
</bookmark>
<bookmark title="2.2 Fabric Link Congestion">
<destination structID="LinkTarget_31081"/>
</bookmark>
<bookmark title="2.3 Flow Control Operation">
<destination structID="LinkTarget_31082"/>
</bookmark>
<bookmark title="2.4 Physical Layer Requirements">
<destination structID="LinkTarget_31083"/>
<bookmark title="2.4.1 Fabric Topology">
<destination structID="LinkTarget_31084"/>
</bookmark>
<bookmark title="2.4.2 Flow Control Transaction Transmission">
<destination structID="LinkTarget_31085"/>
<bookmark title="2.4.2.1 Orphaned XOFF Mechanism">
<destination structID="LinkTarget_31086"/>
</bookmark>
<bookmark title="2.4.2.2 Controlled Flow List">
<destination structID="LinkTarget_31087"/>
</bookmark>
<bookmark title="2.4.2.3 XOFF/XON Counters">
<destination structID="LinkTarget_31088"/>
</bookmark>
</bookmark>
<bookmark title="2.4.3 Priority to Transaction Request Flow Mapping">
<destination structID="LinkTarget_31089"/>
</bookmark>
<bookmark title="2.4.4 Flow Control Transaction Ordering Rules">
<destination structID="LinkTarget_31090"/>
</bookmark>
<bookmark title="2.4.5 End Point Flow Control Rules">
<destination structID="LinkTarget_31091"/>
</bookmark>
<bookmark title="2.4.6 Switch Flow Control Rules">
<destination structID="LinkTarget_31092"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 Packet Format Descriptions">
<destination structID="LinkTarget_31093"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_31094"/>
</bookmark>
<bookmark title="3.2 Logical Layer Packet Format">
<destination structID="LinkTarget_31095"/>
</bookmark>
<bookmark title="3.3 Transport and Physical Layer Packet Format">
<destination structID="LinkTarget_31096"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;4 Logical Layer Flow Control Extensions Register Bits">
<destination structID="LinkTarget_31097"/>
<bookmark title="4.1 Introduction">
<destination structID="LinkTarget_31098"/>
</bookmark>
<bookmark title="4.2 Processing Elements Features CAR (Configuration Space Offset 0x10)">
<destination structID="LinkTarget_31099"/>
</bookmark>
<bookmark title="4.3 Port n Control CSR (Block Offset 0x08)">
<destination structID="LinkTarget_31100"/>
</bookmark>
</bookmark>
<bookmark title="Annex&#17;A Flow Control Examples (Informative)">
<destination structID="LinkTarget_31101"/>
<bookmark title="A.1 Congestion Detection and Remediation">
<destination structID="LinkTarget_31102"/>
</bookmark>
<bookmark title="A.2 Orphaned XOFF Mechanism Description">
<destination structID="LinkTarget_31103"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="encapspec">
<destination structID="LinkTarget_7166"/>
<bookmark title="RapidIO™ Interconnect Specification Part 10: Data Streaming Logical Specification">
<destination structID="LinkTarget_31104"/>
<bookmark title="Chapter&#17;1 Overview">
<destination structID="LinkTarget_31105"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_31106"/>
</bookmark>
<bookmark title="1.2 Overview">
<destination structID="LinkTarget_31107"/>
</bookmark>
<bookmark title="1.3 Features of the Data Streaming Specification">
<destination structID="LinkTarget_31108"/>
<bookmark title="1.3.1 Functional Features">
<destination structID="LinkTarget_31109"/>
</bookmark>
<bookmark title="1.3.2 Physical Features">
<destination structID="LinkTarget_31110"/>
</bookmark>
<bookmark title="1.3.3 Performance Features">
<destination structID="LinkTarget_31111"/>
</bookmark>
</bookmark>
<bookmark title="1.4 Contents">
<destination structID="LinkTarget_31112"/>
</bookmark>
<bookmark title="1.5 Terminology">
<destination structID="LinkTarget_31113"/>
</bookmark>
<bookmark title="1.6 Conventions">
<destination structID="LinkTarget_31114"/>
</bookmark>
<bookmark title="1.7 Useful References">
<destination structID="LinkTarget_31115"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 Data Streaming Systems">
<destination structID="LinkTarget_31116"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_31117"/>
</bookmark>
<bookmark title="2.2 System Example">
<destination structID="LinkTarget_31118"/>
</bookmark>
<bookmark title="2.3 Traffic Streams">
<destination structID="LinkTarget_31119"/>
</bookmark>
<bookmark title="2.4 Operation Ordering">
<destination structID="LinkTarget_31120"/>
</bookmark>
<bookmark title="2.5 Class of Service and Virtual Queues">
<destination structID="LinkTarget_31121"/>
</bookmark>
<bookmark title="2.6 Deadlock Considerations">
<destination structID="LinkTarget_31122"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 Operation Descriptions">
<destination structID="LinkTarget_31123"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_31124"/>
</bookmark>
<bookmark title="3.2 Data Streaming Protocol">
<destination structID="LinkTarget_31125"/>
<bookmark title="3.2.1 Data Streaming Operation">
<destination structID="LinkTarget_31126"/>
</bookmark>
<bookmark title="3.2.2 Virtual Streams">
<destination structID="LinkTarget_31127"/>
</bookmark>
<bookmark title="3.2.3 PDU Sequences Within Streams">
<destination structID="LinkTarget_31128"/>
</bookmark>
<bookmark title="3.2.4 Segments within a PDU">
<destination structID="LinkTarget_31129"/>
</bookmark>
<bookmark title="3.2.5 Rules for Segmentation and Reassembly">
<destination structID="LinkTarget_31130"/>
</bookmark>
</bookmark>
<bookmark title="3.3 Class of Service and Traffic Streams">
<destination structID="LinkTarget_31131"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;4 Packet Format Descriptions">
<destination structID="LinkTarget_31132"/>
<bookmark title="4.1 Introduction">
<destination structID="LinkTarget_31133"/>
</bookmark>
<bookmark title="4.2 Type 9 Packet Format (Data-Streaming Class)">
<destination structID="LinkTarget_31134"/>
</bookmark>
<bookmark title="4.3 Type 9 Extended Packet Format (Extended Data-Streaming Class)">
<destination structID="LinkTarget_31135"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;5 Data Streaming Registers">
<destination structID="LinkTarget_31136"/>
<bookmark title="5.1 Introduction">
<destination structID="LinkTarget_31137"/>
</bookmark>
<bookmark title="5.2 Register Summary">
<destination structID="LinkTarget_31138"/>
</bookmark>
<bookmark title="5.3 Reserved Register and Bit Behavior">
<destination structID="LinkTarget_31139"/>
</bookmark>
<bookmark title="5.4 Capability Registers (CARs)">
<destination structID="LinkTarget_31140"/>
<bookmark title="5.4.1 Source Operations CAR (Configuration Space Offset 0x18)">
<destination structID="LinkTarget_31141"/>
</bookmark>
<bookmark title="5.4.2 Destination Operations CAR (Configuration Space Offset 0x1C)">
<destination structID="LinkTarget_31142"/>
</bookmark>
<bookmark title="5.4.3 Data Streaming Information CAR (Configuration Space Offset 0x3C)">
<destination structID="LinkTarget_31143"/>
</bookmark>
</bookmark>
<bookmark title="5.5 Command and Status Registers (CSRs)">
<destination structID="LinkTarget_31144"/>
<bookmark title="5.5.1 Data Streaming Logical Layer Control CSR (Configuration Space Offset 0x48)">
<destination structID="LinkTarget_31145"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Annex&#17;A VSID Usage Examples">
<destination structID="LinkTarget_31146"/>
<bookmark title="A.1 Introduction">
<destination structID="LinkTarget_31147"/>
</bookmark>
<bookmark title="A.2 Background">
<destination structID="LinkTarget_31148"/>
</bookmark>
<bookmark title="A.3 Packet Classification">
<destination structID="LinkTarget_31149"/>
<bookmark title="A.3.1 Sub-port Addressing at the Destination">
<destination structID="LinkTarget_31150"/>
<bookmark title="A.3.1.1 DSLAM application">
<destination structID="LinkTarget_31151"/>
</bookmark>
<bookmark title="A.3.1.2 VOIP application">
<destination structID="LinkTarget_31152"/>
</bookmark>
</bookmark>
<bookmark title="A.3.2 Virtual Output Queuing - Fabric On-ramp">
<destination structID="LinkTarget_31153"/>
</bookmark>
</bookmark>
<bookmark title="A.4 System Requirements">
<destination structID="LinkTarget_31154"/>
<bookmark title="A.4.1 UTOPIA to RapidIO ATM bridge">
<destination structID="LinkTarget_31155"/>
</bookmark>
<bookmark title="A.4.2 Network processor">
<destination structID="LinkTarget_31156"/>
</bookmark>
<bookmark title="A.4.3 CSIX to RapidIO interface">
<destination structID="LinkTarget_31157"/>
</bookmark>
<bookmark title="A.4.4 10Gb Metropolitan Area Network interface">
<destination structID="LinkTarget_31158"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="mcspec">
<destination structID="LinkTarget_7048"/>
<bookmark title="RapidIO™ Interconnect Specification Part 11: Multicast Extensions Specification">
<destination structID="LinkTarget_31159"/>
<bookmark title="Chapter&#17;1 Overview">
<destination structID="LinkTarget_31160"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_31161"/>
</bookmark>
<bookmark title="1.1 Overview">
<destination structID="LinkTarget_31162"/>
</bookmark>
<bookmark title="1.2 Requirements">
<destination structID="LinkTarget_31163"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 Multicast Extensions Behavior">
<destination structID="LinkTarget_31164"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_31165"/>
</bookmark>
<bookmark title="2.2 Packet Replication">
<destination structID="LinkTarget_31166"/>
</bookmark>
<bookmark title="2.3 Multicast Operation">
<destination structID="LinkTarget_31167"/>
</bookmark>
<bookmark title="2.4 Multicast Transaction Ordering Requirements">
<destination structID="LinkTarget_31168"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 Multicast Extensions Registers">
<destination structID="LinkTarget_31169"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_31170"/>
</bookmark>
<bookmark title="3.2 Processing Elements Features CAR (Configuration Space Offset 0x10)">
<destination structID="LinkTarget_31171"/>
</bookmark>
<bookmark title="3.3 Switch Multicast Support CAR (Configuration Space Offset 0x30)">
<destination structID="LinkTarget_31172"/>
</bookmark>
<bookmark title="3.4 Switch Multicast Information CAR (Configuration Space Offset 0x38)">
<destination structID="LinkTarget_31173"/>
</bookmark>
<bookmark title="3.5 Multicast Mask Port CSR (Configuration Space Offset 0x80)">
<destination structID="LinkTarget_31174"/>
</bookmark>
<bookmark title="3.6 Multicast Associate Select CSR (Configuration Space Offset 0x84)">
<destination structID="LinkTarget_31175"/>
</bookmark>
<bookmark title="3.7 Multicast Associate Operation CSR (Configuration Space Offset 0x88)">
<destination structID="LinkTarget_31176"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;4 Configuration Examples">
<destination structID="LinkTarget_31177"/>
<bookmark title="4.1 Introduction">
<destination structID="LinkTarget_31178"/>
</bookmark>
<bookmark title="4.2 Configuring Multicast Masks">
<destination structID="LinkTarget_31179"/>
<bookmark title="4.2.1 Clearing Multicast Masks">
<destination structID="LinkTarget_31180"/>
</bookmark>
<bookmark title="4.2.2 Assigning Ports to Multicast Masks">
<destination structID="LinkTarget_31181"/>
</bookmark>
<bookmark title="4.2.3 Removing a Port from a Multicast Mask">
<destination structID="LinkTarget_31182"/>
</bookmark>
<bookmark title="4.2.4 Querying a Multicast Mask">
<destination structID="LinkTarget_31183"/>
</bookmark>
</bookmark>
<bookmark title="4.3 Simple Association">
<destination structID="LinkTarget_31184"/>
<bookmark title="4.3.1 Restrictions on Block Size">
<destination structID="LinkTarget_31185"/>
</bookmark>
<bookmark title="4.3.2 Restrictions on Block Associate">
<destination structID="LinkTarget_31186"/>
</bookmark>
<bookmark title="4.3.3 Restrictions on Associations">
<destination structID="LinkTarget_31187"/>
</bookmark>
</bookmark>
<bookmark title="4.4 Configuring Associations">
<destination structID="LinkTarget_31188"/>
<bookmark title="4.4.1 Basic Association">
<destination structID="LinkTarget_31189"/>
</bookmark>
<bookmark title="4.4.2 Using Per-Ingress Port Association">
<destination structID="LinkTarget_31190"/>
</bookmark>
<bookmark title="4.4.3 Using Block Association">
<destination structID="LinkTarget_31191"/>
</bookmark>
<bookmark title="4.4.4 Using Per-Ingress Port and Block Association">
<destination structID="LinkTarget_31192"/>
</bookmark>
<bookmark title="4.4.5 Removing a Destination ID to Multicast Mask Association">
<destination structID="LinkTarget_31193"/>
</bookmark>
<bookmark title="4.4.6 Querying an Association">
<destination structID="LinkTarget_31194"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Annex&#17;A End Point Considerations (Informative)">
<destination structID="LinkTarget_31195"/>
<bookmark title="A.1 Introduction">
<destination structID="LinkTarget_31196"/>
</bookmark>
<bookmark title="A.2 Multicast Destination ID">
<destination structID="LinkTarget_31197"/>
</bookmark>
<bookmark title="A.3 End Point Multicast Channels">
<destination structID="LinkTarget_31198"/>
</bookmark>
</bookmark>
<bookmark title="Annex&#17;B Multicast Applications (Informative)">
<destination structID="LinkTarget_31199"/>
<bookmark title="B.1 Introduction">
<destination structID="LinkTarget_31200"/>
</bookmark>
<bookmark title="B.2 Example 1 - Static Multicast Masks">
<destination structID="LinkTarget_31201"/>
</bookmark>
<bookmark title="B.3 Example 2 - Linking Multicast Masks to Destination IDs">
<destination structID="LinkTarget_31202"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="sbtg">
<destination structID="LinkTarget_6990"/>
<bookmark title="RapidIO™ Interconnect Specification Annex 1: Software/System Bring Up Specification">
<destination structID="LinkTarget_31203"/>
<bookmark title="Chapter&#17;1 Overview">
<destination structID="LinkTarget_31204"/>
<bookmark title="1.1 Introduction">
<destination structID="LinkTarget_31205"/>
</bookmark>
<bookmark title="1.2 Overview">
<destination structID="LinkTarget_31206"/>
</bookmark>
<bookmark title="1.3 Scope">
<destination structID="LinkTarget_31207"/>
</bookmark>
<bookmark title="1.4 System Enumeration API">
<destination structID="LinkTarget_31208"/>
</bookmark>
<bookmark title="1.5 Terminology">
<destination structID="LinkTarget_31209"/>
</bookmark>
<bookmark title="1.6 Software Conventions">
<destination structID="LinkTarget_31210"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;2 Requirements for System Bring Up">
<destination structID="LinkTarget_31211"/>
<bookmark title="2.1 Introduction">
<destination structID="LinkTarget_31212"/>
</bookmark>
<bookmark title="2.2 Boot Requirements">
<destination structID="LinkTarget_31213"/>
</bookmark>
<bookmark title="2.3 Enumeration Completion">
<destination structID="LinkTarget_31214"/>
</bookmark>
<bookmark title="2.4 Enumeration Time-Out">
<destination structID="LinkTarget_31215"/>
</bookmark>
<bookmark title="2.5 Function Return Codes">
<destination structID="LinkTarget_31216"/>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;3 Hardware Abstraction Layer">
<destination structID="LinkTarget_31217"/>
<bookmark title="3.1 Introduction">
<destination structID="LinkTarget_31218"/>
</bookmark>
<bookmark title="3.2 Device Addressing">
<destination structID="LinkTarget_31219"/>
</bookmark>
<bookmark title="3.3 HAL Functions">
<destination structID="LinkTarget_31220"/>
<bookmark title="3.3.1 Types and Definitions">
<destination structID="LinkTarget_31221"/>
</bookmark>
<bookmark title="3.3.2 rioGetNumLocalPorts">
<destination structID="LinkTarget_31222"/>
</bookmark>
<bookmark title="3.3.3 rioConfigurationRead">
<destination structID="LinkTarget_31223"/>
</bookmark>
<bookmark title="3.3.4 rioConfigurationWrite">
<destination structID="LinkTarget_31224"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;4 Standard Bring Up Functions">
<destination structID="LinkTarget_31225"/>
<bookmark title="4.1 Introduction">
<destination structID="LinkTarget_31226"/>
</bookmark>
<bookmark title="4.2 bring up Functions">
<destination structID="LinkTarget_31227"/>
</bookmark>
<bookmark title="4.3 Data Structures">
<destination structID="LinkTarget_31228"/>
<bookmark title="4.3.1 rioInitLib">
<destination structID="LinkTarget_31229"/>
</bookmark>
<bookmark title="4.3.2 rioGetFeatures">
<destination structID="LinkTarget_31230"/>
</bookmark>
<bookmark title="4.3.3 rioGetSwitchPortInfo">
<destination structID="LinkTarget_31231"/>
</bookmark>
<bookmark title="4.3.4 rioGetExtFeaturesPtr">
<destination structID="LinkTarget_31232"/>
</bookmark>
<bookmark title="4.3.5 rioGetNextExtFeaturesPtr">
<destination structID="LinkTarget_31233"/>
</bookmark>
<bookmark title="4.3.6 rioGetSourceOps">
<destination structID="LinkTarget_31234"/>
</bookmark>
<bookmark title="4.3.7 rioGetDestOps">
<destination structID="LinkTarget_31235"/>
</bookmark>
<bookmark title="4.3.8 rioGetAddressMode">
<destination structID="LinkTarget_31236"/>
</bookmark>
<bookmark title="4.3.9 rioGetBaseDeviceId">
<destination structID="LinkTarget_31237"/>
</bookmark>
<bookmark title="4.3.10 rioSetBaseDeviceId">
<destination structID="LinkTarget_31238"/>
</bookmark>
<bookmark title="4.3.11 rioAcquireDeviceLock">
<destination structID="LinkTarget_31239"/>
</bookmark>
<bookmark title="4.3.12 rioReleaseDeviceLock">
<destination structID="LinkTarget_31240"/>
</bookmark>
<bookmark title="4.3.13 rioGetComponentTag">
<destination structID="LinkTarget_31241"/>
</bookmark>
<bookmark title="4.3.14 rioSetComponentTag">
<destination structID="LinkTarget_31242"/>
</bookmark>
<bookmark title="4.3.15 rioGetPortErrStatus">
<destination structID="LinkTarget_31243"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;5 Routing-Table Manipulation Functions">
<destination structID="LinkTarget_31244"/>
<bookmark title="5.1 Introduction">
<destination structID="LinkTarget_31245"/>
</bookmark>
<bookmark title="5.2 Routing Table Functions">
<destination structID="LinkTarget_31246"/>
<bookmark title="5.2.1 rioRouteAddEntry">
<destination structID="LinkTarget_31247"/>
</bookmark>
<bookmark title="5.2.2 rioRouteGetEntry">
<destination structID="LinkTarget_31248"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Chapter&#17;6 Device Access Routine Interface">
<destination structID="LinkTarget_31249"/>
<bookmark title="6.1 Introduction">
<destination structID="LinkTarget_31250"/>
</bookmark>
<bookmark title="6.2 DAR Packaging">
<destination structID="LinkTarget_31251"/>
</bookmark>
<bookmark title="6.3 Execution Environment">
<destination structID="LinkTarget_31252"/>
</bookmark>
<bookmark title="6.4 Type Definitions">
<destination structID="LinkTarget_31253"/>
</bookmark>
<bookmark title="6.5 DAR Functions">
<destination structID="LinkTarget_31254"/>
<bookmark title="6.5.1 rioDar_nameGetFunctionTable">
<destination structID="LinkTarget_31255"/>
</bookmark>
<bookmark title="6.5.2 rioDarInitialize">
<destination structID="LinkTarget_31256"/>
</bookmark>
<bookmark title="6.5.3 rioDarTerminate">
<destination structID="LinkTarget_31257"/>
</bookmark>
<bookmark title="6.5.4 rioDarTestMatch">
<destination structID="LinkTarget_31258"/>
</bookmark>
<bookmark title="6.5.5 rioDarRegister">
<destination structID="LinkTarget_31259"/>
</bookmark>
<bookmark title="6.5.6 rioDarGetMemorySize">
<destination structID="LinkTarget_31260"/>
</bookmark>
<bookmark title="6.5.7 rioDarGetSwitchInfo">
<destination structID="LinkTarget_31261"/>
</bookmark>
<bookmark title="6.5.8 rioDarSetPortRoute">
<destination structID="LinkTarget_31262"/>
</bookmark>
<bookmark title="6.5.9 rioDarGetPortRoute">
<destination structID="LinkTarget_31263"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Annex&#17;A System Bring Up Guidelines">
<destination structID="LinkTarget_31264"/>
<bookmark title="A.1 Introduction">
<destination structID="LinkTarget_31265"/>
</bookmark>
<bookmark title="A.2 Overview of the System Bring Up Process">
<destination structID="LinkTarget_31266"/>
</bookmark>
<bookmark title="A.3 System Enumeration Algorithm">
<destination structID="LinkTarget_31267"/>
<bookmark title="A.3.1 Data Structures, Constants, and Global Variables">
<destination structID="LinkTarget_31268"/>
</bookmark>
<bookmark title="A.3.2 Pseudocode">
<destination structID="LinkTarget_31269"/>
</bookmark>
</bookmark>
<bookmark title="A.4 System Bring Up Example">
<destination structID="LinkTarget_31270"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark>
</bookmark-tree>

<Part>
<H1 id="LinkTarget_30411">RapidIO™ Interconnect SpecificationPart 1: Input/Output LogicalSpecification </H1>

<P>Rev. 1.3, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_0.jpg"/>
</Figure>

<Sect>
<H5>RapidIO Trade Association </H5>

<P>Revision History 
</P>

<Table>
<TR>
<TH/>

<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>

<TH/>
</TR>

<TR>
<TH/>

<TD>1.1 </TD>

<TD>First public release </TD>

<TD>03/08/2001 </TD>
</TR>

<TR>
<TH/>

<TD>1.2 </TD>

<TD>Technical changes: incorporate Rev. 1.1 errata rev. 1.1.1, errata 3 </TD>

<TD>06/26/2002 </TD>
</TR>

<TR>
<TH/>

<TD>1.3 </TD>

<TD>Technical changes: incorporate Rev 1.2 errata 1 as applicable, the following errata showings: 03-05-00006.001, 03-12-00001.001, 04-02-00001.002 and the following new features showings: 04-05-00005.001 Converted to ISO-friendly templates, re-formatted </TD>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TH/>

<TD>1.3 </TD>

<TD>Removed confidentiality markings for public release </TD>

<TD>06/07/2005 </TD>
</TR>

<TR>
<TH>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.  USER AGREES TO ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER SUCH USE OF THE SPECIFICATION. DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: RapidIO Trade Association Suite 325, 3925 W. Braker Lane Austin, TX 78759 512-305-0070 Tel. 512-305-0009 FAX. RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their respective owners. </TH>
</TR>
</Table>

<P>RapidIO Trade Association RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>
</Sect>

<Sect>
<P>Table of Contents </P>

<Sect>
<H4>
<Link>Chapter 1 Overview </Link>
</H4>

<P>
<Link>1.1 Introduction........................................................................................................... 11 
</Link>
</P>

<P>
<Link>1.2 Overview............................................................................................................... 11 
</Link>
</P>

<P>
<Link>1.3 Features of the Input/Output Specification ........................................................... 12 
</Link>
</P>

<P>
<Link>1.3.1 Functional Features ........................................................................................... 12 
</Link>
</P>

<P>
<Link>1.3.2 Physical Features .............................................................................................. 12 
</Link>
</P>

<P>
<Link>1.3.3 Performance Features ....................................................................................... 12 
</Link>
</P>

<P>
<Link>1.4 Contents ................................................................................................................ 13 
</Link>
</P>

<P>
<Link>1.5 Terminology.......................................................................................................... 13 
</Link>
</P>

<P>
<Link>1.6 Conventions .......................................................................................................... 13 
</Link>
</P>
</Sect>

<Sect>
<H4>
<Link>Chapter 2 System Models </Link>
</H4>

<P>
<Link>2.1 Introduction........................................................................................................... 15 
</Link>
</P>

<P>
<Link>2.2 Processing Element Models .................................................................................. 15 
</Link>
</P>

<P>
<Link>2.2.1 Processor-Memory Processing Element Model................................................ 15 
</Link>
</P>

<P>
<Link>2.2.2 Integrated Processor-Memory Processing Element Model .............................. 16 
</Link>
</P>

<P>
<Link>2.2.3 Memory-Only Processing Element Model ....................................................... 16 
</Link>
</P>

<P>
<Link>2.2.4 Processor-Only Processing Element ................................................................. 17 
</Link>
</P>

<P>
<Link>2.2.5 I/O Processing Element .................................................................................... 17 
</Link>
</P>

<P>
<Link>2.2.6 Switch Processing Element............................................................................... 17 
</Link>
</P>

<P>
<Link>2.3 System Issues ........................................................................................................ 18 
</Link>
</P>

<P>
<Link>2.3.1 Operation Ordering ........................................................................................... 18 
</Link>
</P>

<P>
<Link>2.3.2 Transaction Delivery......................................................................................... 20 
</Link>
</P>

<P>
<Link>2.3.2.1 Unordered Delivery System Issues............................................................... 20 
</Link>
</P>

<P>
<Link>2.3.2.2 Ordered Delivery System Issues................................................................... 21 
</Link>
</P>

<P>
<Link>2.3.3 Deadlock Considerations .................................................................................. 21 
</Link>
</P>
</Sect>

<Sect>
<H4>
<Link>Chapter 3 Operation Descriptions </Link>
</H4>

<P>
<Link>3.1 Introduction........................................................................................................... 23 
</Link>
</P>

<P>
<Link>3.2 I/O Operations Cross Reference ........................................................................... 24 
</Link>
</P>

<P>
<Link>3.3 I/O Operations....................................................................................................... 24 
</Link>
</P>

<P>
<Link>3.3.1 Read Operations................................................................................................ 25 
</Link>
</P>

<P>
<Link>3.3.2 Write and Streaming-Write Operations ............................................................ 25 
</Link>
</P>

<P>
<Link>3.3.3 Write-With-Response Operations ..................................................................... 26 
</Link>
</P>

<P>
<Link>3.3.4 Atomic (Read-Modify-Write) Operations ........................................................ 26 
</Link>
</P>

<P>
<Link>3.4 System Operations ................................................................................................ 27 
</Link>
</P>

<P>
<Link>3.4.1 Maintenance Operations ................................................................................... 27 
</Link>
</P>

<P>
<Link>3.5 Endian, Byte Ordering, and Alignment ................................................................ 27 
</Link>
</P>
</Sect>
</Sect>

<Sect>
<H5>RapidIO Trade Association </H5>
</Sect>

<Sect>
<H2>Table of Contents </H2>

<P>
<Link>Chapter 4 Packet Format Descriptions </Link>
</P>

<P>
<Link>4.1 Request Packet Formats ........................................................................................ 31 
</Link>
</P>

<P>
<Link>4.1.1 Addressing and Alignment ............................................................................... 32 
</Link>
</P>

<P>
<Link>4.1.2 Field Definitions for All Request Packet Formats ............................................ 32 
</Link>
</P>

<P>
<Link>4.1.3 Type 0 Packet Format (Implementation-Defined) ............................................ 35 
</Link>
</P>

<P>
<Link>4.1.4 Type 1 Packet Format (Reserved) .................................................................... 35 
</Link>
</P>

<P>
<Link>4.1.5 Type 2 Packet Format (Request Class) ............................................................. 35 
</Link>
</P>

<P>
<Link>4.1.6 Type 3–4 Packet Formats (Reserved) ............................................................... 36 
</Link>
</P>

<P>
<Link>4.1.7 Type 5 Packet Format (Write Class)................................................................. 36 
</Link>
</P>

<P>
<Link>4.1.8 Type 6 Packet Format (Streaming-Write Class) ............................................... 37 
</Link>
</P>

<P>
<Link>4.1.9 Type 7 Packet Format (Reserved) .................................................................... 38 
</Link>
</P>

<P>
<Link>4.1.10 Type 8 Packet Format (Maintenance Class) ..................................................... 38 
</Link>
</P>

<P>
<Link>4.1.11 Type 9–11 Packet Formats (Reserved) ............................................................. 40 
</Link>
</P>

<P>
<Link>4.2 Response Packet Formats ..................................................................................... 40 
</Link>
</P>

<P>
<Link>4.2.1 Field Definitions for All Response Packet Formats ......................................... 40 
</Link>
</P>

<P>
<Link>4.2.2 Type 12 Packet Format (Reserved) .................................................................. 41 
</Link>
</P>

<P>
<Link>4.2.3 Type 13 Packet Format (Response Class) ........................................................ 41 
</Link>
</P>

<P>
<Link>4.2.4 Type 14 Packet Format (Reserved) .................................................................. 41 
</Link>
</P>

<P>
<Link>4.2.5 Type 15 Packet Format (Implementation-Defined) .......................................... 41 
</Link>
</P>

<P>
<Link>Chapter 5 Input/Output Registers </Link>
</P>

<P>
<Link>5.1 Register Summary................................................................................................. 43 
</Link>
</P>

<P>
<Link>5.2 Reserved Register and Bit Behavior ..................................................................... 44 
</Link>
</P>

<P>
<Link>5.3 Extended Features Data Structure......................................................................... 45 
</Link>
</P>

<P>
<Link>5.4 Capability Registers (CARs) ................................................................................ 47 
</Link>
</P>

<P>
<Link>5.4.1 	Device Identity CAR (Configuration Space Offset 0x0)................................................................. 47 </Link>
</P>

<P>
<Link>5.4.2 	Device Information CAR (Configuration Space Offset 0x4)................................................................. 47 </Link>
</P>

<P>
<Link>5.4.3 	Assembly Identity CAR (Configuration Space Offset 0x8)................................................................. 47 </Link>
</P>

<P>
<Link>5.4.4 	Assembly Information CAR (Configuration Space Offset 0xC) ................................................................ 48 </Link>
</P>

<P>
<Link>5.4.5 	Processing Element Features CAR (Configuration Space Offset 0x10)............................................................... 48 </Link>
</P>

<P>
<Link>5.4.6 	Switch Port Information CAR (Configuration Space Offset 0x14)............................................................... 49 </Link>
</P>

<P>
<Link>5.4.7 	Source Operations CAR (Configuration Space Offset 0x18)............................................................... 49 </Link>
</P>

<P>
<Link>5.4.8 	Destination Operations CAR 
<Link>(Configuration Space Offset 0x1C) .............................................................. 50 </Link>
</Link>
</P>

<P>
<Link>5.5 Command and Status Registers (CSRs)................................................................ 52 
</Link>
</P>
</Sect>

<Sect>
<H5>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </H5>

<P>Table of Contents </P>

<P>
<Link>5.5.1 	Processing Element Logical Layer Control CSR (Configuration Space Offset 0x4C) .............................................................. 52 </Link>
</P>

<P>
<Link>5.5.2 	Local Configuration Space Base Address 0 CSR (Configuration Space Offset 0x58)............................................................... 52 </Link>
</P>

<P>5.5.3 	
<Link>Local Configuration Space Base Address 1 CSR </Link>

<Link>(Configuration Space Offset 0x5C) .............................................................. 53 </Link>
</P>

<P>RapidIO Trade Association </P>
</Sect>

<Sect>
<H2>Table of Contents </H2>
</Sect>

<Sect>
<H5>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </H5>

<P>List of Figures 
</P>

<P>
<Link>2-1 A Possible RapidIO-Based Computing System..............................................................15 
</Link>

<Link>2-2 Processor-Memory Processing Element Example ..........................................................16 
</Link>

<Link>2-3 Integrated Processor-Memory Processing Element Example.........................................16 
</Link>

<Link>2-4 Memory-Only Processing Element Example .................................................................17 
</Link>

<Link>2-5 Processor-Only Processing Element Example................................................................17 
</Link>

<Link>2-6 Switch Processing Element Example .............................................................................18 
</Link>

<Link>3-1 Read Operation ...............................................................................................................25 
</Link>

<Link>3-2 Write and Streaming-Write Operations ..........................................................................26 
</Link>

<Link>3-3 Write-With-Response Operation ....................................................................................26 
</Link>

<Link>3-4 Atomic (Read-Modify-Write) Operation ........................................................................27 
</Link>

<Link>3-5 Maintenance Operation ...................................................................................................27 
</Link>

<Link>3-6 Byte Alignment Example................................................................................................28 
</Link>

<Link>3-7 Half-Word Alignment Example......................................................................................28 
</Link>

<Link>3-8 Word Alignment Example ..............................................................................................28 
</Link>

<Link>3-9 Data Alignment Example................................................................................................29 
</Link>

<Link>4-1 Type 2 Packet Bit Stream Format ...................................................................................36 
</Link>

<Link>4-2 Type 5 Packet Bit Stream Format ...................................................................................37 
</Link>

<Link>4-3 Type 6 Packet Bit Stream Format ...................................................................................38 
</Link>

<Link>4-4 Type 8 Request Packet Bit Stream Format .....................................................................39 
</Link>

<Link>4-5 Type 8 Response Packet Bit Stream Format ..................................................................40 
</Link>

<Link>4-6 Type 13 Packet Bit Stream Format .................................................................................41 
</Link>

<Link>5-1 Example Extended Features Data Structure ...................................................................46 
</Link>
</P>

<P>RapidIO Trade Association </P>
</Sect>

<Sect>
<H2>List of Figures </H2>
</Sect>

<Sect>
<H5>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </H5>

<P>List of Tables 
</P>

<P>
<Link>4-1 Request Packet Type to Transaction Type Cross Reference ..........................................31 
</Link>

<Link>4-2 General Field Definitions for All Request Packets.........................................................33 
</Link>

<Link>4-3 Read Size (rdsize) Definitions ........................................................................................33 
</Link>

<Link>4-4 Write Size (wrsize) Definitions ......................................................................................34 
</Link>

<Link>4-5 Transaction Fields and Encodings for Type 2 Packets ...................................................36 
</Link>

<Link>4-6 Transaction Fields and Encodings for Type 5 Packets ...................................................37 
</Link>

<Link>4-7 Specific Field Definitions and Encodings for Type 8 Packets .......................................39 
</Link>

<Link>4-8 Response Packet Type to Transaction Type Cross Reference ........................................40 
</Link>

<Link>4-9 Field Definitions and Encodings for All Response Packets ...........................................40 
</Link>

<Link>5-1 I/O Register Map ............................................................................................................43 
</Link>

<Link>5-2 Configuration Space Reserved Access Behavior............................................................44 
</Link>

<Link>5-3 Bit Settings for Device Identity CAR .............................................................................47 
</Link>

<Link>5-4 Bit Settings for Device Information CAR ......................................................................47 
</Link>

<Link>5-5 Bit Settings for Assembly Identity CAR ........................................................................48 
</Link>

<Link>5-6 Bit Settings for Assembly Information CAR..................................................................48 
</Link>

<Link>5-7 Bit Settings for Processing Element Features CAR........................................................48 
</Link>

<Link>5-8 Bit Settings for Switch Port Information CAR ...............................................................49 
</Link>

<Link>5-9 Bit Settings for Source Operations CAR ........................................................................49 
</Link>

<Link>5-10 Bit Settings for Destination Operations CAR .................................................................50 
</Link>

<Link>5-11 Bit Settings for Processing Element Logical Layer Control CSR ..................................52 
</Link>

<Link>5-12 Bit Settings for Local Configuration Space Base Address 0 CSR .................................52 
</Link>

<Link>5-13 Bit Settings for Local Configuration Space Base Address 1 CSR .................................53 
</Link>
</P>

<P>RapidIO Trade Association </P>
</Sect>

<Sect>
<H2>List of Tables </H2>
</Sect>

<Sect>
<H5>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </H5>

<P id="LinkTarget_30412">Chapter 1 Overview </P>

<Sect>
<H2 id="LinkTarget_30413">1.1 Introduction </H2>

<P>This chapter provides an overview of the RapidIO Part 1: Input/Output Logical Specification, including a description of the relationship between this specification and the other specifications of the RapidIO interconnect. </P>
</Sect>

<Sect>
<H2 id="LinkTarget_30414">1.2 Overview </H2>

<P>The RapidIO Part 1: Input/Output Logical Specification is one of the RapidIO logical layer specifications that define the interconnect’s overall protocol and packet formats. This layer contains the information necessary for end points to process a transaction. Other RapidIO logical layer specifications include RapidIO Part 2: Message Passing Logical Specification and RapidIO Part 5: Globally Shared Memory Logical Specification. </P>

<P>The logical specifications do not imply a specific transport or physical interface, therefore they are specified in a bit stream format. Necessary bits are added to the logical encodings for the transport and physical layers lower in the specification hierarchy. </P>

<P>RapidIO is a definition of a system interconnect. System concepts such as processor programming models, memory coherency models and caching are beyond the scope of the RapidIO architecture. The support of memory coherency models, through caches, memory directories (or equivalent, to hold state and speed up remote memory access) is the responsibility of the end points (processors, memory, and possibly I/O devices), using RapidIO operations. RapidIO provides the operations to construct a wide variety of systems, based on programming models that range from strong consistency through total store ordering to weak ordering. Inter-operability between end points supporting different coherency/caching/directory models is not guaranteed. However, groups of end-points with conforming models can be linked to others conforming to different models on the same RapidIO fabric. These different groups can communicate through RapidIO messaging or I/O operations. Any reference to these areas within the RapidIO architecture specification are for illustration only. </P>

<P>RapidIO Trade Association </P>
</Sect>

<Sect>
<H2 id="LinkTarget_30415">1.3 Features of the Input/Output Specification </H2>

<P>The following are features of the RapidIO I/O specification designed to satisfy the needs of various applications and systems: </P>

<Sect>
<H3 id="LinkTarget_30416">1.3.1 Functional Features </H3>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> A rich variety of transaction types, such as DMA-style read and writes, that allow efficient I/O systems to be built. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> System sizes from very small to very large are supported in the same or compatible packet formats—RapidIO plans for future expansion and requirements. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Read-modify-write atomic operations are useful for synchronization between processors or other system elements. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The RapidIO architecture supports 50- and 66-bit addresses as well as 34-bit local addresses for smaller systems. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> DMA devices can improve the interconnect efficiency if larger non-coherent data quantities can be encapsulated within a single packet, so RapidIO supports a variety of data sizes within the packet formats. </LI_Title>
</LI>
</L>
</Sect>

<Sect>
<H3 id="LinkTarget_30417">1.3.2 Physical Features </H3>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>RapidIO packet definition is independent of the width of the physical interface to other devices on the interconnect fabric. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>The protocols and packet formats are independent of the physical interconnect topology. The protocols work whether the physical fabric is a point-to-point ring, a bus, a switched multi-dimensional network, a duplex serial connection, and so forth. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> RapidIO is not dependent on the bandwidth or latency of the physical fabric. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The protocols handle out-of-order packet transmission and reception. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Certain devices have bandwidth and latency requirements for proper operation. RapidIO does not preclude an implementation from imposing these constraints within the system. </LI_Title>
</LI>
</L>
</Sect>

<Sect>
<H3 id="LinkTarget_30418">1.3.3 Performance Features </H3>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Packet headers must be as small as possible to minimize the control overhead and be organized for fast, efficient assembly and disassembly. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> 48- and 64-bit addresses are required in the future, and must be supported initially. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Multiple transactions must be allowed concurrently in the system, otherwise a majority of the potential system throughput is wasted. </LI_Title>
</LI>
</L>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>
</Sect>
</Sect>

<Sect>
<H2 id="LinkTarget_30419">1.4 Contents </H2>

<P>Following are the contents of the RapidIO Part 1: Input/Output Logical Specification: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 1, “Overview” (this chapter) provides an overview of the specification </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>
<Link>Chapter 2, “System Models,” introduces some possible devices that could </Link>
participate in a RapidIO system environment. Transaction ordering and deadlock prevention are discussed. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 3, “Operation Descriptions,” describes the set of operations and </Link>
transactions supported by the RapidIO I/O protocols. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 4, “Packet Format Descriptions,” contains the packet format </Link>
definitions for the I/O specification. The two basic types, request and response packets, with their sub-types and fields are defined. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>
<Link>Chapter 5, “Input/Output Registers,” describes the visible register set that </Link>
allows an external processing element to determine the I/O capabilities, configuration, and status of a processing element using this logical specification. Only registers or register bits specific to the I/O logical specification are explained. Refer to the other RapidIO logical, transport, and physical specifications of interest to determine a complete list of registers and bit definitions. </LI_Title>
</LI>
</L>
</Sect>

<Sect>
<Div>
<H2 id="LinkTarget_30420">1.5 Terminology </H2>

<P>Refer to the Glossary at the back of this document. </P>

<Table>
<TR>
<TH id="LinkTarget_30421">1.6 Conventions </TH>
</TR>

<TR>
<TH>|| </TH>

<TD>Concatenation, used to indicate that two fields are physically associated as consecutive bits </TD>
</TR>

<TR>
<TH>ACTIVE_HIGH </TH>

<TD>Names of active high signals are shown in uppercase text with no overbar. Active-high signals are asserted when high and not asserted when low. </TD>
</TR>

<TR>
<TH>ACTIVE_LOW </TH>

<TD>Names of active low signals are shown in uppercase text with an overbar. Active low signals are asserted when low and not asserted when high. </TD>
</TR>

<TR>
<TH>italics </TH>

<TD>Book titles in text are set in italics. </TD>
</TR>

<TR>
<TH>REG[FIELD] </TH>

<TD>Abbreviations or acronyms for registers are shown in uppercase text. Specific bits, fields, or ranges appear in brackets. </TD>
</TR>

<TR>
<TH>TRANSACTION </TH>

<TD>Transaction types are expressed in all caps. </TD>
</TR>

<TR>
<TH>operation </TH>

<TD>Device operation types are expressed in plain text. </TD>
</TR>

<TR>
<TH>n </TH>

<TD>A decimal value. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>[n-m] 	Used to express a numerical range from n to m. </P>

<P>0bnn 	A binary value, the number of bits is determined by the number of digits. </P>

<P>0xnn 	A hexadecimal value, the number of bits is determined by the number of digits or from the surrounding context; for example, 0xnn may be a 5, 6, 7, or 8 bit value. </P>

<P>x This value is a don’t care </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30422">Chapter 2 System Models </P>

<P id="LinkTarget_30423">2.1 Introduction </P>

<P>This overview introduces some possible devices in a RapidIO system. </P>

<P id="LinkTarget_30424">2.2 Processing Element Models </P>

<P>
<Link>Figure 2-1 describes a possible RapidIO-based computing system. The processing </Link>
element is a computer device such as a processor attached to a local memory and to a RapidIO system interconnect. The bridge part of the system provides I/O subsystem services such as high-speed PCI interfaces and gigabit ethernet ports, interrupt control, and other system support functions. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_1.jpg"/>
Processing Element A Memory Processing Element B Memory Processing Element C Memory Processing Element D Memory RapidIO System Interconnect Fabric </Figure>

<Table>
<TR>
<TD>PCI A PCI B </TD>

<TD>Bridge </TD>

<TD>XBUS MPIC </TD>
</TR>

<TR>
<TD/>

<TD>Firewire </TD>

<TD/>
</TR>
</Table>

<P>Figure 2-1. A Possible RapidIO-Based Computing System </P>

<P>The following sections describe several possible processing elements. </P>

<P id="LinkTarget_30425">2.2.1 Processor-Memory Processing Element Model </P>

<P>
<Link>Figure 2-2 shows an example of a processing element consisting of a processor </Link>
connected to an agent device. The agent carries out several services on behalf of the processor. Most importantly, it provides access to a local memory that has much lower latency than memory that is local to another processing element (remote memory accesses). It also provides an interface to the RapidIO interconnect to </P>

<P>RapidIO Trade Association </P>

<P>service those remote memory accesses. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_2.jpg"/>
Agent Memory Processor 
<Caption>
<P>RapidIO-basedSystem Interconnect</P>
</Caption>
</Figure>

<P>Local Interconnect </P>

<P>Figure 2-2. Processor-Memory Processing Element Example </P>

<P id="LinkTarget_30426">2.2.2 Integrated Processor-Memory Processing Element Model </P>

<P>Another form of a processor-memory processing element is a fully integrated component that is designed specifically to connect to a RapidIO interconnect system 
<Link>as shown in Figure 2-3. This type of device integrates a memory system and other </Link>
support logic with a processor on the same piece of silicon or within the same package. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_3.jpg"/>
Processor Memory </Figure>

<P>RapidIO-based System Interconnect </P>

<P>Figure 2-3. Integrated Processor-Memory Processing Element Example </P>

<P id="LinkTarget_30427">2.2.3 Memory-Only Processing Element Model </P>

<P>A different processing element may not contain a processor at all, but may be a 
<Link>memory-only device as shown in Figure 2-4. This type of device is much simpler </Link>
than a processor; it only responds to requests from the external system, not to local requests as in the processor-based model. As such, its memory is remote for all processors in the system. </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_4.jpg"/>
Memory Memory Control </Figure>

<P>RapidIO-based System Interconnect </P>

<P>Figure 2-4. Memory-Only Processing Element Example </P>

<P id="LinkTarget_30428">2.2.4 Processor-Only Processing Element </P>

<P>Similar to a memory-only element, a processor-only element has no local memory. 
<Link>A processor-only processing element is shown in Figure 2-5. </Link>
</P>

<Table>
<TR>
<TH/>
</TR>

<TR>
<TH>Processor </TH>
</TR>

<TR>
<TH/>
</TR>

<TR>
<TH/>

<TD/>
</TR>

<TR>
<TH/>
</TR>

<TR>
<TH>Agent </TH>
</TR>

<TR>
<TH/>
</TR>
</Table>

<P>Local Interconnect </P>

<P>RapidIO-based System Interconnect </P>

<P>Figure 2-5. Processor-Only Processing Element Example </P>

<P id="LinkTarget_30429">2.2.5 I/O Processing Element </P>

<P>
<Link>This type of processing element is shown as the bridge in Figure 2-1. This device </Link>
has distinctly different behavior than a processor or a memory device. An I/O device only needs to move data into and out of local or remote memory. </P>

<P id="LinkTarget_30430">2.2.6 Switch Processing Element </P>

<P>A switch processing element is a device that allows communication with other processing elements through the switch. A switch may be used to connect a variety of RapidIO-compliant processing elements. A hybrid processing element may combine a switch with end point functionality. A possible switch is shown in 
<Link>Figure 2-6. Behavior of the switches, and the interconnect fabric in general, is </Link>
addressed in the RapidIO Common Transport Specification. </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_5.jpg"/>
Switch </Figure>

<P>Figure 2-6. Switch Processing Element Example </P>

<P id="LinkTarget_30431">2.3 System Issues </P>

<P>The following sections describe transaction ordering and system deadlock considerations in a RapidIO system. </P>

<P id="LinkTarget_30432">2.3.1 Operation Ordering </P>

<P>Most operations in an I/O system do not have any requirements as far as completion ordering. There are, however, several tasks that require events to occur in a specific order. As an example, a processing element may wish to write a set of registers in another processing element. The sequence in which those writes are carried out may be critical to the operation of the target processing element. Without some specific system rules there would be no guarantee of completion ordering of these operations. Ordering is mostly a concern for operations between a specific source and destination pair. </P>

<P>In certain cases a processing element may communicate with another processing element or set of processing elements in different contexts. A set or sequence of operations issued by a processing element may have requirements for completing in order at the target processing element. That same processing element may have another sequence of operations that also requires a completion order at the target processing element. However, the issuing processing element has no requirements for completion order between the two sequences of operations. Further, it may be desirable for one of the sequences of operations to complete at a higher priority than the other sequence. The term “transaction request flow” is defined as one of these sequences of operations. </P>

<P>A transaction request flow is defined as a ordered sequence of non-maintenance request transactions from a given source (as indicated by the source identifier) to a given destination (as indicated by the transaction destination identifier), where a maintenance request is a special system support request. Each packet in a transaction request flow has the same source identifier and the same destination identifier. </P>

<P>There may be multiple transaction request flows between a given source and destination pair. When multiple flows exist between a source and destination pair, </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P>the flows are distinguished by a flow indicator (flowID). RapidIO allows multiple transaction request flows between any source and destination pair. The flows between each source and destination pair are identified with alphabetic characters beginning with A. </P>

<P>The flows between each source and destination pair are prioritized. The flow priority increases alphabetically with flowID A having the lowest priority, flowID B having the next to lowest priority, etc. When multiple transaction request flows exist between a given source and destination pair, transactions of a higher priority flow may pass transactions of a lower priority flow, but transactions of a lower priority flow may not pass transactions of a higher priority flow. </P>

<P>Maintenance transactions are not part of any transaction request flow. However, within a RapidIO fabric, maintenance transactions may not pass other maintenance transactions of the same or higher priority taking the same path through the fabric. </P>

<P>Response transactions are not part of any transaction request flow. There is no ordering between any pair of response transactions and there is no ordering between any response transaction and any request transaction that did not cause the generation of the response. </P>

<P>To support transaction request flows, all devices that support the RapidIO logical specification shall comply as applicable with the following Fabric Delivering Ordering and End point Completion Ordering rules. </P>

<P>Fabric Delivery Ordering Rules </P>

<L>
<LI>
<LI_Label>1. </LI_Label>

<LI_Title>Non-maintenance request transactions within a transaction request flow (same source identifier, same destination identifier, and same flowID) shall be delivered to the logical layer of the destination in the same order that they were issued by the logical layer of the source. </LI_Title>
</LI>

<L>
<LI>
<LI_Label>2.</LI_Label>

<LI_Title> Non-maintenance request transactions that have the same source (same source identifier) and the same destination (same destination identifier) but different flowIDs shall be delivered to the logical layer of the destination as follows. </LI_Title>
</LI>

<L>
<LI>
<LI_Label>– </LI_Label>

<LI_Title>A transaction of a higher priority transaction request flow that was issued by the logical layer of the source before a transaction of a lower priority transaction request flow shall be delivered to the logical layer of the destination before the lower priority transaction. </LI_Title>
</LI>

<LI>
<LI_Label>– </LI_Label>

<LI_Title>A transaction of a higher priority transaction request flow that was issued by the logical layer of the source after a transaction of a lower priority transaction request flow may be delivered to the logical layer of the destination before the lower priority transaction. </LI_Title>
</LI>
</L>
</L>
</L>

<P>RapidIO Trade Association </P>

<P>3. Request transactions that have different sources (different source identifiers) or different destinations (different destination identifiers) are unordered with respect to each other. </P>

<P>End point Completion Ordering Rules </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> Write request transactions in a transaction request flow shall be completed at the logical layer of the destination in the same order that the transactions were delivered to the logical layer of the destination. </LI_Title>
</LI>

<LI>
<LI_Label>2. </LI_Label>

<LI_Title>A read request transaction with source A and destination B shall force the completion at the logical layer of B of all write requests in the same transaction request flow that were received by the logical layer of B before the read request transaction. </LI_Title>
</LI>
</L>

<P>Read request transactions need not be completed in the same order that they were received by the logical layer of the destination. As a consequence, read response transactions need not be issued by the logical layer of the destination in the same order that the associated read request transactions were received. </P>

<P>Write response transactions will likely be issued at the logical level in the order that the associated write request was received. However, since response transactions are not part of any flow, they are not ordered relative to one another and may not arrive at the logical level their destination in the same order as the associated write transactions were issued. Therefore, write response transactions need not be issued by the logical layer in the same order as the associated write request was received. </P>

<P>It may be necessary to impose additional rules in order to provide for inter operability with other interface standards or programming models. However, such additional rules are beyond the scope of this specification. </P>

<P id="LinkTarget_30433">2.3.2 Transaction Delivery </P>

<P>There are two basic types of delivery schemes that can be built using RapidIO processing elements: unordered and ordered. The RapidIO logical protocols assume that all outstanding transactions to another processing element are delivered in an arbitrary order. In other words, the logical protocols do not rely on transaction interdependencies for operation. RapidIO also allows completely ordered delivery systems to be constructed. Each type of system puts different constraints on the implementation of the source and destination processing elements and any intervening hardware. The specific mechanisms and definitions of how RapidIO enforces transaction ordering are discussed in the appropriate physical layer specification. </P>

<P id="LinkTarget_30434">2.3.2.1 Unordered Delivery System Issues </P>

<P>An unordered delivery system is defined as an interconnect fabric where transactions between a source and destination pair can arbitrarily pass each other during transmission through the intervening fabric. </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P>Operations in the unordered system that are required to complete in a specific order shall be properly managed at the source processing element. For example, enforcing a specific sequence for writing a series of configuration registers, or preventing a subsequent read from bypassing a preceding write to a specific address are cases of ordering that may need to be managed at the source. The source of these transactions shall issue them in a purely serial sequence, waiting for completion notification for a write before issuing the next transaction to the interconnect fabric. The destination processing element shall guarantee that all outstanding non-coherent operations from that source are completed before servicing a subsequent non-coherent request from that source. </P>

<P id="LinkTarget_30435">2.3.2.2 Ordered Delivery System Issues </P>

<P>Ordered delivery systems place additional implementation constraints on both the source and destination processing elements as well as any intervening hardware. Typically an ordered system requires that all transactions between a source/destination pair be completed in the order generated, not necessarily the order in which they can be accepted by the destination or an intermediate device. In one example, if several requests are sent before proper receipt is acknowledged the destination or intermediate device shall retry all following transactions until the first retried packet is retransmitted and accepted. In this case, the source shall “unroll” its outstanding transaction list and retransmit the first one to maintain the proper system ordering. In another example, an interface may make use of explicit transaction tags which allow the destination to place the transactions in the proper order upon receipt. </P>

<P id="LinkTarget_30436">2.3.3 Deadlock Considerations </P>

<P>A deadlock can occur if a dependency loop exists. A dependency loop is a situation where a loop of buffering devices is formed, in which forward progress at each device is dependent upon progress at the next device. If no device in the loop can make progress then the system is deadlocked. </P>

<P>The simplest solution to the deadlock problem is to discard a packet. This releases resources in the network and allows forward progress to be made. RapidIO is designed to be a reliable fabric for use in real time tightly coupled systems, therefore discarding packets is not an acceptable solution. </P>

<P>In order to produce a system with no chance of deadlock it is required that a deadlock free topology be provided for response-less operations. Dependency loops to single direction packets can exist in unconstrained switch topologies. Often the dependency loop can be avoided with simple routing rules. Topologies like hypercubes or three-dimensional meshes physically contain loops. In both cases, routing is done in several dimensions (x,y,z). If routing is constrained to the x dimension, then y, then z (dimension ordered routing), topology related dependency loops are avoided in these structures. </P>

<P>RapidIO Trade Association </P>

<P>In addition, a processing element design shall not form dependency links between its input and output ports. A dependency link between input and output ports occurs if a processing element is unable to accept an input packet until a waiting packet can be issued from the output port. </P>

<P>RapidIO supports operations, such as read operations, that require responses to complete. These operations can lead to a dependency link between a processing element’s input port and output port. </P>

<P>As an example of a input to output port dependency, consider a processing element where the output port queue is full. The processing element can not accept a new request at its input port since there is no place to put the response in the output port queue. No more transactions can be accepted at the input port until the output port is able to free entries in the output queue by issuing packets to the system. </P>

<P>The method by which a RapidIO system maintains a deadlock free environment is described in the appropriate Physical Layer specification. </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30437">Chapter 3 Operation Descriptions </P>

<P id="LinkTarget_30438">3.1 Introduction </P>

<P>This chapter describes the set of operations and their associated transactions supported by the I/O protocols of RapidIO. The transaction types, packet formats, 
<Link>and other necessary transaction information are described in Chapter 4, “Packet </Link>

<Link>Format Descriptions.” </Link>
</P>

<P>The I/O operation protocols work using request/response transaction pairs through the interconnect fabric. A processing element sends a request transaction to another processing element if it requires an activity to be carried out. The receiving processing element responds with a response transaction when the request has been completed or if an error condition is encountered. Each transaction is sent as a packet through the interconnect fabric. For example, a processing element that requires data from another processing element sends an NREAD transaction in a request packet to that processing element, which reads its local memory at the requested address and returns the data in a DONE transaction in a response packet. Note that not all requests require responses; some requests assume that the desired activity will complete properly. </P>

<P>Two possible response transactions can be received by a requesting processing element: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> A DONE response indicates to the requestor that the desired transaction has completed and it also returns data for read-type transactions as described above. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> An ERROR response means that the target of the transaction encountered an unrecoverable error and could not complete the transaction. </LI_Title>
</LI>
</L>

<P>Packets may contain additional information that is interpreted by the interconnect fabric to route the packets through the fabric from the source to the destination, such as a device number. These requirements are described in the appropriate RapidIO transport layer specification, and are beyond the scope of this specification. </P>

<P>Depending upon the interconnect fabric, other packets may be generated as part of the physical layer protocol to manage flow control, errors, etc. Flow control and other fabric-specific communication requirements are described in the appropriate RapidIO transport and physical layer specifications and are beyond the scope of this document. </P>

<P>RapidIO Trade Association </P>

<P>For most transaction types, a request transaction sent into the system is marked with a transaction ID that is unique for each requestor and responder processing element pair. This transaction ID allows a response to be easily matched to the original request when it is returned to the requestor. An end point cannot reuse a transaction ID value to the same destination until the response from the original transaction has been received by the requestor. The number of outstanding transactions that may be supported is implementation dependent. </P>

<P>Transaction IDs may also be used to indicate sequence information if ordered reception of transactions is required by the destination processing element and the interconnect fabric can reorder packets. The receiving device must accept and not complete the subsequent out-of-order requests until the missing transactions in the sequence have been received and completed. </P>

<P id="LinkTarget_30439">3.2 I/O Operations Cross Reference </P>

<P>
<Link>Table</Link>
 contains a cross reference of the I/O operations defined in this RapidIO specification and their system usage. </P>

<Table>
<Caption>
<P>Table 2-1. I/O Operations Cross Reference </P>
</Caption>

<TR>
<TH>Operation </TH>

<TH>Transactions Used </TH>

<TH>Possible System Usage </TH>

<TH>Request Transaction Classification for Completion Ordering Rules </TH>

<TH>Description </TH>

<TH>Packet Format </TH>
</TR>

<TR>
<TD>Read </TD>

<TD>NREAD, RESPONSE </TD>

<TD>Read operation </TD>

<TD>Read </TD>

<TD>
<Link>Section 3.3.1 </Link>
</TD>

<TD>
<Link>Type 2 Section 4.1.5 </Link>
</TD>
</TR>

<TR>
<TD>Write </TD>

<TD>NWRITE </TD>

<TD>Write operation </TD>

<TD>Write </TD>

<TD>
<Link>Section 3.3.2 </Link>
</TD>

<TD>
<Link>Type 5 Section 4.1.7 </Link>
</TD>
</TR>

<TR>
<TD>Write-with-response </TD>

<TD>NWRITE_R, RESPONSE </TD>

<TD>Write operation </TD>

<TD>Write </TD>

<TD>
<Link>Section 3.3.3 </Link>
</TD>

<TD>
<Link>Type 5 Section 4.1.7 </Link>
</TD>
</TR>

<TR>
<TD>Streaming-write </TD>

<TD>SWRITE </TD>

<TD>Write operation </TD>

<TD>Write </TD>

<TD>
<Link>Section 3.3.2 </Link>
</TD>

<TD>
<Link>Type 6 Section 4.1.8 </Link>
</TD>
</TR>

<TR>
<TD>Atomic (read-modify-write) </TD>

<TD>ATOMIC, RESPONSE </TD>

<TD>Read-modify-write operation </TD>

<TD>Write </TD>

<TD>
<Link>Section 3.3.4</Link>
</TD>

<TD>
<Link> Type 2 Section 4.1.5 Type 5 Section 4.1.7 </Link>
</TD>
</TR>

<TR>
<TD>Maintenance </TD>

<TD>MAINTENANCE </TD>

<TD>System exploration, initialization, and maintenance operation </TD>

<TD>not applicable </TD>

<TD>
<Link>Section 3.4.1 </Link>
</TD>

<TD>
<Link>Type 8 Section 4.1.10 </Link>
</TD>
</TR>
</Table>

<P id="LinkTarget_30440">3.3 I/O Operations </P>

<P>The operations described in this section are used for I/O accesses to physical addresses in the target of the operation. Examples are accesses to non-coherent memory, ROM boot code, or to configuration registers that do not participate in any globally shared system memory protocol. These accesses may be of any specifiable size allowed by the system. </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P>All data payloads that are less than 8 bytes shall be padded and have their bytes aligned to their proper byte position within the double-word, as in the examples 
<Link>shown in Figure 3-6 through Figure 3-8. </Link>
</P>

<P>The described behaviors are the same regardless of the actual target physical address. </P>

<P id="LinkTarget_30441">3.3.1 Read Operations </P>

<P>The read operation, consisting of the NREAD and RESPONSE transactions 
<Link>(typically a DONE response) as shown in Figure 3-1, is used by a processing </Link>
element that needs to read data from the specified address. The data returned is of the size requested. </P>

<P>If the read operation is to memory, data is returned from the memory regardless of the state of any system-wide cache coherence mechanism for the specified cache line or lines, although it may cause a snoop of any caches local to the memory controller. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_6.jpg"/>
DONE, data 2 NREAD 1 Requestor Destination </Figure>

<P>Figure 3-1. Read Operation </P>

<P id="LinkTarget_30442">3.3.2 Write and Streaming-Write Operations </P>

<P>The write and streaming-write operations, consisting of the NWRITE and SWRITE 
<Link>transactions as shown in Figure 3-2, are used by a processing element that needs to </Link>
write data to the specified address. The NWRITE transaction allows multiple double-word, word, half-word and byte writes with properly padded and aligned (to the 8-byte boundary) data payload. The SWRITE transaction is a double-word-only version of the NWRITE that has less header overhead. The write size and alignment 
<Link>for the NWRITE transaction are specified in Table 4-4. Non-contiguous and </Link>
unaligned writes are not supported. It is the requestor’s responsibility to break up a write operation into multiple transactions if the block is not aligned. </P>

<P>NWRITE and SWRITE transactions do not receive responses, so there is no notification to the sender when the transaction has completed at the destination. </P>

<P>If the write operation is to memory, data is written to the memory regardless of the state of any system-wide cache coherence mechanism for the specified cache line or lines, although it may cause a snoop of any caches local to the memory controller. </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_7.jpg"/>
NWRITE or SWRITE, data 1 Requestor Destination </Figure>

<P>Figure 3-2. Write and Streaming-Write Operations </P>

<P id="LinkTarget_30443">3.3.3 Write-With-Response Operations </P>

<P>The write-with-response operation, consisting of the NWRITE_R and RESPONSE 
<Link>transactions (typically a DONE response) as shown in Figure 3-3, is identical to the </Link>
write operation except that it receives a response to notify the sender that the write has completed at the destination. This operation is useful for guaranteeing read-after-write and write-after-write ordering through a system that can reorder transactions and for enforcing other required system behaviors. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_8.jpg"/>
NWRITE_R, data 1 Requestor DONE 2 Destination </Figure>

<P>Figure 3-3. Write-With-Response Operation </P>

<P id="LinkTarget_30444">3.3.4 Atomic (Read-Modify-Write) Operations </P>

<P>The read-modify-write operation, consisting of the ATOMIC and RESPONSE 
<Link>transactions (typically a DONE response) as shown in Figure 3-4, is used by a </Link>
number of cooperating processing elements to perform synchronization using non-coherent memory. The allowed specified data sizes are one word (4 bytes), one half-word (2 bytes) or one byte, with the size of the transaction specified in the same way as for an NWRITE transaction. Double-word (8-byte) and 3, 5, 6, and 7 byte ATOMIC transactions may not be specified. </P>

<P>The atomic operation is a combination read and write operation. The destination reads the data at the specified address, returns the read data to the requestor, performs the required operation to the data, and then writes the modified data back to the specified address without allowing any intervening activity to that address. Defined operations are increment, decrement, test-and-swap, set, and clear (See bit settings in 
<Link>Table 5-9 </Link>
and 
<Link>Table 5-10). </Link>
Of these, only test-and-swap, compare-and-swap, and swap require the requesting processing element to supply data. The target data of an atomic operation may be initialized using an NWRITE transaction. </P>

<P>If the atomic operation is to memory, data is written to the memory regardless of the state of any system-wide cache coherence mechanism for the specified cache line or </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P>lines, although it may cause a snoop of any caches local to the memory controller. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_9.jpg"/>
DONE, data 2 ATOMIC, data (opt.) 1 Requestor Destination </Figure>

<P>Figure 3-4. Atomic (Read-Modify-Write) Operation </P>

<P id="LinkTarget_30445">3.4 System Operations </P>

<P>All data payloads that are less than 8 bytes shall be padded and have their bytes aligned to their proper byte position within the double-word, as in the examples 
<Link>shown in Figure 3-6 through Figure 3-8. </Link>
</P>

<P id="LinkTarget_30446">3.4.1 Maintenance Operations </P>

<P>The maintenance operation, which can consist of more than one MAINTENANCE 
<Link>transaction as shown in Figure 3-5, is used by a processing element that needs to </Link>
read or write data to the specified CARs, CSRs, or locally-defined registers or data structures. If a response is required, MAINTENANCE requests receive a MAINTENANCE response rather than a normal response for both read and write operations. Supported accesses are in 32 bit quantities and may optionally be in double-word and multiple double-word quantities to a maximum of 64 bytes. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_10.jpg"/>
opt. MAINTENANCE, opt. data 2 MAINTENANCE, opt. data 1 Requestor Destination </Figure>

<P>Figure 3-5. Maintenance Operation </P>

<P id="LinkTarget_30447">3.5 Endian, Byte Ordering, and Alignment </P>

<P>RapidIO has double-word (8-byte) aligned big-endian data payloads. This means that the RapidIO interface to devices that are little-endian shall perform the proper endian transformation to format a data payload. </P>

<P>Operations that specify data quantities that are less than 8 bytes shall have the bytes aligned to their proper byte position within the big-endian double-word, as in the 
<Link>examples shown in Figure 3-6 through Figure 3-8. </Link>
</P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_11.jpg"/>
Byte 0 1 2 3 4 5 6 7 </Figure>

<P>Byte address 0x0000_0002, the proper byte position is shaded. </P>

<P>Figure 3-6. Byte Alignment Example </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_12.jpg"/>
Byte 0 1 2 3 4 5 6 7 MSB LSB </Figure>

<P>Half-word address 0x0000_0002, the proper byte positions are shaded. </P>

<P>Figure 3-7. Half-Word Alignment Example </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_13.jpg"/>
Byte 0 1 2 3 4 5 6 7 MSB LSB </Figure>

<P>Word address 0x0000_0004, the proper byte positions are shaded. </P>

<P>Figure 3-8. Word Alignment Example </P>

<P>For write operations, a processing element shall properly align data transfers to a double-word boundary for transmission to the destination. This alignment may require breaking up a data stream into multiple transactions if the data is not naturally aligned. A number of data payload sizes and double-word alignments are 
<Link>defined to minimize this burden. Figure 3-9 shows a 48-byte data stream that a </Link>
processing element wishes to write to another processing element through the interconnect fabric. The data displayed in the figure is big-endian and double-word aligned with the bytes to be written shaded in grey. Because the start of the stream and the end of the stream are not aligned to a double-word boundary, the sending processing element shall break the stream into three transactions as shown in the figure. </P>

<P>The first transaction sends the first three bytes (in byte lanes 5, 6, and 7) and indicates a byte lane 5, 6, and 7 three-byte write. The second transaction sends all of the remaining data except for the final sub-double-word. The third transaction sends the final 5 bytes in byte lanes 0, 1, 2, 3, and 4 indicating a five-byte write in byte lanes 0, 1, 2, 3, and 4. </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<Table>
<TR>
<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>
</TR>

<TR>
<TD>0 </TD>

<TD>1 </TD>

<TD>2 </TD>

<TD>3 </TD>

<TD>4 </TD>

<TD>5 </TD>

<TD>6 </TD>

<TD>7 </TD>
</TR>
</Table>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_14.jpg"/>
MSB LSB </Figure>

<P>Double-Word Boundary </P>

<P>First transaction sends these three bytes with this double-word alignment </P>

<P>Second transaction sends these five double-words </P>

<P>Third transaction sends these five bytes with this double-word alignment </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_15.jpg"/>
</Figure>

<P>Figure 3-9. Data Alignment Example </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30448">Chapter 4 Packet Format Descriptions </P>

<P>This chapter contains the packet format definitions for the RapidIO Part 1: Input/Output Logical Specification. Four types of I/O packet formats exist: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Request </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Response </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Implementation-defined </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Reserved </LI_Title>
</LI>
</L>

<P>The packet formats are intended to be interconnect fabric independent so the system interconnect can be anything required for a particular application. Reserved formats, unless defined in another logical specification, shall not be used by a device. </P>

<P id="LinkTarget_30449">4.1 Request Packet Formats </P>

<P>A request packet is issued by a processing element that needs a remote processing element to accomplish some activity on its behalf, such as a memory read operation. The request packet format types and their transactions for the I/O Logical 
<Link>Specification are shown in Table 4-1 below. </Link>
</P>

<Table>
<Caption>
<P>Table 4-1. Request Packet Type to Transaction Type Cross Reference </P>
</Caption>

<TR>
<TH>Request Packet Format Type </TH>

<TH>Transaction Type </TH>

<TH>Definition </TH>

<TH>Document Section No. </TH>
</TR>

<TR>
<TD>Type 0 </TD>

<TD>Implementation-defined </TD>

<TD>Defined by the device implementation </TD>

<TD>
<Link>Section 4.1.3 </Link>
</TD>
</TR>

<TR>
<TD>Type 1 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.1.4 </Link>
</TD>
</TR>

<TR>
<TD>Type 2 </TD>

<TD>ATOMIC set </TD>

<TD>Read-write 1’s to specified address </TD>

<TD>
<Link>Section 4.1.5 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>ATOMIC clear </TD>

<TD>Read-write 0’s to specified address </TD>
</TR>

<TR>
<TD/>

<TD>ATOMIC increment </TD>

<TD>Read-increment-write to specified address </TD>
</TR>

<TR>
<TD/>

<TD>ATOMIC decrement </TD>

<TD>Read-decrement-write to specified address </TD>
</TR>

<TR>
<TD/>

<TD>NREAD </TD>

<TD>Read specified address </TD>
</TR>

<TR>
<TD>Type 3-4 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.1.6 </Link>
</TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Request Packet Format Type </TH>

<TH>Transaction Type </TH>

<TH>Definition </TH>

<TH>Document Section No. </TH>
</TR>

<TR>
<TD>Type 5 </TD>

<TD>ATOMIC test-and-swap </TD>

<TD>Read-test=0-swap-write to specified address </TD>

<TD>
<Link>Section 4.1.7 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>ATOMIC swap </TD>

<TD>Read-write to specified address </TD>
</TR>

<TR>
<TD/>

<TD>ATOMIC compare-and-swap </TD>

<TD>Read-test=first data-write second data to specified address </TD>
</TR>

<TR>
<TD/>

<TD>NWRITE </TD>

<TD>Write specified address </TD>
</TR>

<TR>
<TD/>

<TD>NWRITE_R </TD>

<TD>Write specified address, notify source of completion </TD>
</TR>

<TR>
<TD>Type 6 </TD>

<TD>SWRITE </TD>

<TD>Write specified address </TD>

<TD>
<Link>Section 4.1.8 </Link>
</TD>
</TR>

<TR>
<TD>Type 7 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.1.9 </Link>
</TD>
</TR>

<TR>
<TD>Type 8 </TD>

<TD>MAINTENANCE </TD>

<TD>Read or write device configuration registers and perform other system maintenance tasks </TD>

<TD>
<Link>Section 4.1.10 </Link>
</TD>
</TR>

<TR>
<TD>Type 9-11 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.1.11 </Link>
</TD>
</TR>
</Table>

<P id="LinkTarget_30450">4.1.1 Addressing and Alignment </P>

<P>The size of the address is defined as a system-wide parameter; thus the packet formats do not support mixed local physical address fields simultaneously. The least three significant bits of all addresses are not specified and are assumed to be logic 0. </P>

<P>All transactions are aligned to a byte, half-word, word, or double-word boundary. Read and write request addresses are aligned to any specifiable double-word boundary and are not aligned to the size of the data written or requested. Data payloads start at the first double-word and proceed linearly through the address space. Sub-double-word data payloads shall be padded and properly aligned within the 8-byte boundary. Non-contiguous or unaligned transactions that would ordinarily require a byte mask are not supported. A sending device that requires this behavior shall break the operation into multiple request transactions. An example of 
<Link>this is shown in Section 3.5, “Endian, Byte Ordering, and Alignment.” </Link>
</P>

<P id="LinkTarget_30451">4.1.2 Field Definitions for All Request Packet Formats </P>

<P>
<Link>Table 4-2 through Table 4-4 describe the field definitions for all request packet </Link>
formats. Bit fields that are defined as “reserved” shall be assigned to logic 0s when generated and ignored when received. Bit field encodings that are defined as “reserved” shall not be assigned when the packet is generated. A received reserved encoding is regarded as an error if a meaningful encoding is required for the transaction and function, otherwise it is ignored. Implementation-defined fields shall be ignored unless the encoding is understood by the receiving device. All packets described are bit streams from the first bit to the last bit, represented in the </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P>figures from left to right respectively. </P>

<Table>
<Caption>
<P>Table 4-2. General Field Definitions for All Request Packets </P>
</Caption>

<TR>
<TD>Field </TD>

<TD>Definition </TD>
</TR>

<TR>
<TD>ftype </TD>

<TD>Format type, represented as a 4-bit value; is always the first four bits in the logical packet stream. </TD>
</TR>

<TR>
<TD>wdptr </TD>

<TD>
<Link>Word pointer, used in conjunction with the data size (rdsize and wrsize) fields—see Table 4-3, Table 4-4 and Section 3.5. </Link>
</TD>
</TR>

<TR>
<TD>rdsize </TD>

<TD>
<Link>Data size for read transactions, used in conjunction with the word pointer (wdptr) bit—see Table 4-3 and Section 3.5. </Link>
</TD>
</TR>

<TR>
<TD>wrsize </TD>

<TD>
<Link>Write data size for sub-double-word transactions, used in conjunction with the word pointer (wdptr) bit—see Table 4-4 and Section 3.5. For writes greater than one double-word, the size is the maximum payload that should be expected by the receiver. </Link>
</TD>
</TR>

<TR>
<TD>rsrv </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>srcTID </TD>

<TD>The packet’s transaction ID </TD>
</TR>

<TR>
<TD>transaction </TD>

<TD>The specific transaction within the format class to be performed by the recipient; also called type or ttype. </TD>
</TR>

<TR>
<TD>extended address </TD>

<TD>Optional. Specifies the most significant 16 bits of a 50-bit physical address or 32 bits of a 66-bit physical address. </TD>
</TR>

<TR>
<TD>xamsbs </TD>

<TD>Extended address most significant bits. Further extends the address specified by the address and extended address fields by 2 bits. This field provides 34-, 50-, and 66-bit addresses to be specified in a packet with the xamsbs as the most significant bits in the address. </TD>
</TR>

<TR>
<TD>address </TD>

<TD>Bits [0-28] of byte address [0-31] of the double-word physical address </TD>
</TR>
</Table>

<P>Table 4-3. Read Size (rdsize) Definitions </P>

<Table>
<TR>
<TH>wdptr </TH>

<TH>rdsize </TH>

<TH>Number of Bytes </TH>

<TH>Byte Lanes </TH>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0000 </TD>

<TD>1 </TD>

<TD>0b10000000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0001 </TD>

<TD>1 </TD>

<TD>0b01000000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0010 </TD>

<TD>1 </TD>

<TD>0b00100000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0011 </TD>

<TD>1 </TD>

<TD>0b00010000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0000 </TD>

<TD>1 </TD>

<TD>0b00001000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0001 </TD>

<TD>1 </TD>

<TD>0b00000100 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0010 </TD>

<TD>1 </TD>

<TD>0b00000010 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0011 </TD>

<TD>1 </TD>

<TD>0b00000001 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0100 </TD>

<TD>2 </TD>

<TD>0b11000000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0101 </TD>

<TD>3 </TD>

<TD>0b11100000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0110 </TD>

<TD>2 </TD>

<TD>0b00110000 </TD>
</TR>

<TR>
<TD>0b0</TD>

<TD> 0b0111 </TD>

<TD>5 </TD>

<TD>0b11111000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0100 </TD>

<TD>2 </TD>

<TD>0b00001100 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0101 </TD>

<TD>3 </TD>

<TD>0b00000111 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0110 </TD>

<TD>2 </TD>

<TD>0b00000011 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0111 </TD>

<TD>5 </TD>

<TD>0b00011111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1000 </TD>

<TD>4 </TD>

<TD>0b11110000 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>wdptr </TH>

<TH>rdsize </TH>

<TH>Number of Bytes </TH>

<TH>Byte Lanes </TH>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1000 </TD>

<TD>4 </TD>

<TD>0b00001111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1001 </TD>

<TD>6 </TD>

<TD>0b11111100 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1001 </TD>

<TD>6 </TD>

<TD>0b00111111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1010 </TD>

<TD>7 </TD>

<TD>0b11111110 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1010 </TD>

<TD>7 </TD>

<TD>0b01111111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1011 </TD>

<TD>8 </TD>

<TD>0b11111111 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1011 </TD>

<TD>16 </TD>

<TD/>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1100 </TD>

<TD>32 </TD>

<TD/>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1100 </TD>

<TD>64 </TD>

<TD/>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1101 </TD>

<TD>96 </TD>

<TD/>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1101 </TD>

<TD>128 </TD>

<TD/>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1110 </TD>

<TD>160 </TD>

<TD/>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1110 </TD>

<TD>192 </TD>

<TD/>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1111 </TD>

<TD>224 </TD>

<TD/>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1111 </TD>

<TD>256 </TD>

<TD/>
</TR>

<Caption>
<P>Table 4-4. Write Size (wrsize) Definitions </P>
</Caption>
</Table>

<Table>
<TR>
<TH>wdptr </TH>

<TH>wrsize </TH>

<TH>Number of Bytes </TH>

<TH>Byte Lanes </TH>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0000 </TD>

<TD>1 </TD>

<TD>0b10000000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0001 </TD>

<TD>1 </TD>

<TD>0b01000000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0010 </TD>

<TD>1 </TD>

<TD>0b00100000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0011 </TD>

<TD>1 </TD>

<TD>0b00010000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0000 </TD>

<TD>1 </TD>

<TD>0b00001000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0001 </TD>

<TD>1 </TD>

<TD>0b00000100 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0010 </TD>

<TD>1 </TD>

<TD>0b00000010 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0011 </TD>

<TD>1 </TD>

<TD>0b00000001 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0100 </TD>

<TD>2 </TD>

<TD>0b11000000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0101 </TD>

<TD>3 </TD>

<TD>0b11100000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0110 </TD>

<TD>2 </TD>

<TD>0b00110000 </TD>
</TR>

<TR>
<TD>0b0</TD>

<TD> 0b0111 </TD>

<TD>5 </TD>

<TD>0b11111000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0100 </TD>

<TD>2 </TD>

<TD>0b00001100 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0101 </TD>

<TD>3 </TD>

<TD>0b00000111 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0110 </TD>

<TD>2 </TD>

<TD>0b00000011 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0111 </TD>

<TD>5 </TD>

<TD>0b00011111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1000 </TD>

<TD>4 </TD>

<TD>0b11110000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1000 </TD>

<TD>4 </TD>

<TD>0b00001111 </TD>
</TR>
</Table>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 Table 4-4. Write Size (wrsize) Definitions (Continued) </P>

<Table>
<TR>
<TH>wdptr </TH>

<TH>wrsize </TH>

<TH>Number of Bytes </TH>

<TH>Byte Lanes </TH>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1001 </TD>

<TD>6 </TD>

<TD>0b11111100 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1001 </TD>

<TD>6 </TD>

<TD>0b00111111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1010 </TD>

<TD>7 </TD>

<TD>0b11111110 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1010 </TD>

<TD>7 </TD>

<TD>0b01111111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1011 </TD>

<TD>8 </TD>

<TD>0b11111111 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1011 </TD>

<TD>16 maximum </TD>

<TD/>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1100 </TD>

<TD>32 maximum </TD>

<TD/>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1100 </TD>

<TD>64 maximum </TD>

<TD/>
</TR>

<TR>
<TD>00b </TD>

<TD>0b1101 </TD>

<TD>reserved </TD>

<TD/>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1101 </TD>

<TD>128 maximum </TD>

<TD/>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1110 </TD>

<TD>reserved </TD>

<TD/>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1110 </TD>

<TD>reserved </TD>

<TD/>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1111 </TD>

<TD>reserved </TD>

<TD/>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1111 </TD>

<TD>256 maximum </TD>

<TD/>
</TR>
</Table>

<P id="LinkTarget_30452">4.1.3 Type 0 Packet Format (Implementation-Defined) </P>

<P>The type 0 packet format is reserved for implementation-defined functions such as flow control. </P>

<P id="LinkTarget_30453">4.1.4 Type 1 Packet Format (Reserved) </P>

<P>The type 1 packet format is reserved. </P>

<P id="LinkTarget_30454">4.1.5 Type 2 Packet Format (Request Class) </P>

<P>The type 2 format is used for the NREAD and ATOMIC transactions as specified in 
<Link>the transaction field defined in Table 4-5. Type 2 packets never contain a data </Link>
payload. </P>

<P>The data payload size for the response to an ATOMIC transaction is 8 bytes. The addressing scheme defined for the read portion of the ATOMIC transaction also controls the size of the atomic operation in memory so the bytes shall be contiguous and shall be of size byte, half-word (2 bytes), or word (4 bytes), and be aligned to that boundary and byte lane as with a regular read transaction. Double-word (8-byte), 3, 5, 6, and 7 byte ATOMIC transactions are not allowed. </P>

<P>RapidIO Trade Association </P>

<P>Note that type 2 packets don’t have any special fields. </P>

<P>Table 4-5. Transaction Fields and Encodings for Type 2 Packets </P>

<Table>
<TR>
<TD>Encoding </TD>

<TD>Transaction Field </TD>
</TR>

<TR>
<TD>0b0000–0011 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b0100 </TD>

<TD>NREAD transaction </TD>
</TR>

<TR>
<TD>0b0101–1011 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b1100 </TD>

<TD>ATOMIC inc: post-increment the data </TD>
</TR>

<TR>
<TD>0b1101 </TD>

<TD>ATOMIC dec: post-decrement the data </TD>
</TR>

<TR>
<TD>0b1110 </TD>

<TD>ATOMIC set: set the data (write 0b11111...’) </TD>
</TR>

<TR>
<TD>0b1111 </TD>

<TD>ATOMIC clr: clear the data (write 0b00000...’) </TD>
</TR>
</Table>

<P>
<Link>Figure 4-1 displays the type 2 packet with all its fields. The field value 0b0010 in </Link>

<Link>Figure 4-1 specifies that the packet format is of type 2. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_16.jpg"/>
0 0 1 0 4 4 4 8 transaction rdsize srcTID addressextended address wdptr xamsbs </Figure>

<P>0, 16, 32 29 1 2 </P>

<P>Figure 4-1. Type 2 Packet Bit Stream Format </P>

<P id="LinkTarget_30455">4.1.6 Type 3–4 Packet Formats (Reserved) </P>

<P>The type 3–4 packet formats are reserved. </P>

<P id="LinkTarget_30456">4.1.7 Type 5 Packet Format (Write Class) </P>

<P>Type 5 packets always contain a data payload. A data payload that consists of a 
<Link>single double-word or less has sizing information as defined in Table 4-4. The </Link>
wrsize field specifies the maximum size of the data payload for multiple double-word transactions. The data payload may not exceed that size but may be smaller if desired. The ATOMIC, NWRITE, and NWRITE_R transactions use the 
<Link>type 5 format as defined in Table 4-6. NWRITE request packets do not require a </Link>
response. Therefore, the transaction ID (srcTID) field for a NWRITE request is undefined and may have an arbitrary value. </P>

<P>The ATOMIC test-and-swap transaction is limited to one double-word (8 bytes) of data payload. The addressing scheme defined for the write transactions also controls the size of the atomic operation in memory so the bytes shall be contiguous and shall be of size byte, half-word (2 bytes), or word (4 bytes), and be aligned to that boundary and byte lane as with a regular write transaction. Double-word (8-byte) and 3, 5, 6, and 7 byte ATOMIC test-and-swap transactions are not allowed. </P>

<P>The ATOMIC swap transaction has the same addressing scheme and data payload </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P>restrictions as the ATOMIC test-and-swap transaction. </P>

<P>The ATOMIC compare-and-swap operation is different from the other ATOMIC operations in that it requires two double-words (16 bytes) of data payload. Note that type 5 packets don’t have any special fields. </P>

<P>Table 4-6. Transaction Fields and Encodings for Type 5 Packets </P>

<Table>
<TR>
<TD>Encoding </TD>

<TD>Transaction Field </TD>
</TR>

<TR>
<TD>0b0000–0011 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b0100 </TD>

<TD>NWRITE transaction </TD>
</TR>

<TR>
<TD>0b0101 </TD>

<TD>NWRITE_R transaction </TD>
</TR>

<TR>
<TD>0b0110–1011 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b1100 </TD>

<TD>ATOMIC swap: read and return the data, unconditionally write with supplied data. </TD>
</TR>

<TR>
<TD>0b1101 </TD>

<TD>ATOMIC compare-and-swap: read and return the data, if the read data is equal to the first 8 bytes of data payload, write the second 8 bytes of data to the memory location. </TD>
</TR>

<TR>
<TD>0b1110 </TD>

<TD>ATOMIC test-and-swap: read and return the data, compare to 0, write with supplied data if compare is true </TD>
</TR>

<TR>
<TD>0b1111 </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>
<Link>Figure 4-2 displays the type 5 packet with all its fields. The field value 0b0101 in </Link>

<Link>Figure 4-2 specifies that the packet format is of type 5. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_17.jpg"/>
0 1 0 1 4 4 4 8 transaction wrsize srcTID address extended address 0, 16, 32 wdptr xamsbs 1 229 double-word 0 64 double-word 1 64 • • • </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_18.jpg"/>
</Figure>

<P>double-word n </P>

<P>64 </P>

<P>Figure 4-2. Type 5 Packet Bit Stream Format </P>

<P id="LinkTarget_30457">4.1.8 Type 6 Packet Format (Streaming-Write Class) </P>

<P>The type 6 packet is a special-purpose type that always contains data. The data payload always contains a minimum of one complete double-word. Sub-double-word data payloads shall use the type 5 NWRITE transaction. Type 6 transactions may contain any number of double-words up to the maximum defined in 
<Link>Table 4-4. </Link>
</P>

<P>RapidIO Trade Association </P>

<P>Because the SWRITE transaction is the only transaction to use format type 6, there is no need for the transaction field within the packet. There are also no size or transaction ID fields. </P>

<P>
<Link>Figure 4-3 displays the type 6 packet with all its fields. The field value 0b0110 in </Link>

<Link>Figure 4-3 specifies that the packet format is of type 6. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_19.jpg"/>
0 1 1 0 4 double-word 0 64 double-word 1 64 • • • address extended address 0, 16, 32 rsrv xamsbs 1 229 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_20.jpg"/>
</Figure>

<P>double-word n </P>

<P>64 </P>

<P>Figure 4-3. Type 6 Packet Bit Stream Format </P>

<P id="LinkTarget_30458">4.1.9 Type 7 Packet Format (Reserved) </P>

<P>The type 7 packet format is reserved. </P>

<P id="LinkTarget_30459">4.1.10 Type 8 Packet Format (Maintenance Class) </P>

<P>The type 8 MAINTENANCE packet format is used to access the RapidIO capability and status registers (CARs and CSRs) and data structures. Unlike other request formats, the type 8 packet format serves as both the request and the response format for maintenance operations. Type 8 packets contain no addresses and only contain data payloads for write requests and read responses. All configuration register read accesses are performed in word (4-byte), and optionally double-word (8-byte) or specifiable multiple double-word quantities up to a limit of 64 bytes. All register write accesses are also performed in word (4-byte), and optionally double-word (8-byte) or multiple double-word quantities up to a limit of 64 bytes. </P>

<P>
<Link>Read and write data sizes are specified as shown in Table 4-3 and Table 4-4. The </Link>
wrsize field specifies the maximum size of the data payload for multiple double-word transactions. The data payload may not exceed that size but may be smaller if desired. Both the maintenance read and the maintenance write request generate the appropriate maintenance response. </P>

<P>The maintenance port-write operation is a write operation that does not have guaranteed delivery and does not have an associated response. This maintenance operation is useful for sending messages such as error indicators or status information from a device that does not contain an end point, such as a switch. The data payload is typically placed in a queue in the targeted end point and an interrupt is typically generated to a local processor. A port-write request to a queue that is full or busy servicing another request may be discarded. </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P>Definitions and encodings of fields specific to type 8 packets are provided in 
<Link>Table 4-7. Fields that are not specific to type 8 packets are described in Table 4-2. </Link>
</P>

<Table>
<Caption>
<P>Table 4-7. Specific Field Definitions and Encodings for Type 8 Packets </P>
</Caption>

<TR>
<TH>Type 8 Fields </TH>

<TH>Encoding </TH>

<TH>Definition </TH>
</TR>

<TR>
<TH>transaction </TH>

<TD>0b0000 </TD>

<TD>Specifies a maintenance read request </TD>
</TR>

<TR>
<TH/>

<TD>0b0001 </TD>

<TD>Specifies a maintenance write request </TD>
</TR>

<TR>
<TH/>

<TD>0b0010 </TD>

<TD>Specifies a maintenance read response </TD>
</TR>

<TR>
<TH/>

<TD>0b0011 </TD>

<TD>Specifies a maintenance write response </TD>
</TR>

<TR>
<TH/>

<TD>0b0100 </TD>

<TD>Specifies a maintenance port-write request </TD>
</TR>

<TR>
<TH/>

<TD>0b0101–1111 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TH>config_offset </TH>

<TD>— </TD>

<TD>Double-word offset into the CAR/CSR register block for reads and writes </TD>
</TR>

<TR>
<TH>srcTID </TH>

<TD>— </TD>

<TD>The type 8 request packet’s transaction ID (reserved for port-write requests) </TD>
</TR>

<TR>
<TH>targetTID </TH>

<TD>— </TD>

<TD>The corresponding type 8 response packet’s transaction ID </TD>
</TR>

<TR>
<TH>status </TH>

<TD>0b0000 </TD>

<TD>DONE—Requested transaction has completed successfully </TD>
</TR>

<TR>
<TD>0b0001–0110 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b0111 </TD>

<TD>ERROR—Unrecoverable error detected </TD>
</TR>

<TR>
<TD>0b1000–1011 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b1100–1111 </TD>

<TD>Implementation-defined—Can be used for additional information such as an error code </TD>
</TR>
</Table>

<P>
<Link>Figure 4-4 displays a type 8 request (read or write) packet with all its fields. The </Link>

<Link>field value 0b1000 in Figure 4-4 specifies that the packet format is of type 8. The </Link>
srcTID and config_offset fields are reserved for port-write requests. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_21.jpg"/>
1 0 0 0 4 4 4 8 transaction rdsize/wrsize srcTID config_offset 21 wdptr rsrv 1 2 • • • 64 double-word 0 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_22.jpg"/>
</Figure>

<P>double-word n </P>

<P>64 </P>

<P>Figure 4-4. Type 8 Request Packet Bit Stream Format </P>

<P>RapidIO Trade Association </P>

<P>
<Link>Figure 4-5 displays a type 8 response packet with all its fields. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_23.jpg"/>
1 0 0 0 4 4 4 8 transaction status targetTID reserved 24 • • • 64 double-word 0 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_24.jpg"/>
</Figure>

<P>double-word n </P>

<P>64 </P>

<P>Figure 4-5. Type 8 Response Packet Bit Stream Format </P>

<P id="LinkTarget_30460">4.1.11  Type 9–11 Packet Formats (Reserved) </P>

<P>The type 9–11 packet formats are reserved. </P>

<P id="LinkTarget_30461">4.2 Response Packet Formats </P>

<P>A response transaction is issued by a processing element when it has completed a request made to it by a remote processing element. Response packets are always directed and are transmitted in the same way as request packets. Currently two 
<Link>packet format types exist, as shown in Table 4-8. </Link>
</P>

<Table>
<Caption>
<P>Table 4-8. Response Packet Type to Transaction Type Cross Reference </P>
</Caption>

<TR>
<TH>Response Packet Format Type </TH>

<TH>Transaction Type </TH>

<TH>Definition </TH>

<TH>Document Section Number </TH>
</TR>

<TR>
<TD>Type 12 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.2.2 </Link>
</TD>
</TR>

<TR>
<TD>Type 13 </TD>

<TD>RESPONSE </TD>

<TD>Issued by a processing element when it completes a request by a remote element. </TD>

<TD>
<Link>Section 4.2.3 </Link>
</TD>
</TR>

<TR>
<TD>Type 14 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.2.4 </Link>
</TD>
</TR>

<TR>
<TD>Type 15 </TD>

<TD>Implementation-defined </TD>

<TD>Defined by the device implementation </TD>

<TD>
<Link>Section 4.2.5 </Link>
</TD>
</TR>
</Table>

<P id="LinkTarget_30462">4.2.1 Field Definitions for All Response Packet Formats </P>

<P>The field definitions in 
<Link>Table 4-9 apply to more than one of the response packet </Link>
formats. </P>

<Table>
<Caption>
<P>Table 4-9. Field Definitions and Encodings for All Response Packets </P>
</Caption>

<TR>
<TH>Field </TH>

<TH>Encoding </TH>

<TH>Sub-Field </TH>

<TH>Definition </TH>
</TR>

<TR>
<TH>transaction </TH>

<TD>0b0000 </TD>

<TD/>

<TD>RESPONSE transaction with no data payload </TD>
</TR>

<TR>
<TD>0b0001–0111 </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b1000 </TD>

<TD/>

<TD>RESPONSE transaction with data payload </TD>
</TR>

<TR>
<TD>0b1001–1111 </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<Table>
<TR>
<TH>targetTID </TH>

<TH>— </TH>

<TH>The corresponding request packet’s transaction ID </TH>
</TR>

<TR>
<TH>status </TH>

<TD>Type of status and encoding </TD>

<TD/>
</TR>

<TR>
<TD>0b0000 </TD>

<TD>DONE </TD>

<TD>Requested transaction has been successfully completed </TD>
</TR>

<TR>
<TD>0b0001–0110 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b0111 </TD>

<TD>ERROR </TD>

<TD>Unrecoverable error detected </TD>
</TR>

<TR>
<TD>0b1000–1011 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b1100–1111 </TD>

<TD>Implementation </TD>

<TD>Implementation defined—Can be used for additional information such as an error code </TD>
</TR>
</Table>

<P id="LinkTarget_30463">4.2.2 Type 12 Packet Format (Reserved) </P>

<P>The type 12 packet format is reserved. </P>

<P id="LinkTarget_30464">4.2.3 Type 13 Packet Format (Response Class) </P>

<P>The type 13 packet format returns status, data (if required), and the requestor’s transaction ID. A RESPONSE packet with an “ERROR” status or a response that is not expected to have a data payload never has a data payload. The type 13 format is used for response packets to all request packets except maintenance and response-less writes. </P>

<P>Note that type 13 packets do not have any special fields. </P>

<P>
<Link>Figure 4-6 illustrates the format and fields of type 13 packets. The field value </Link>

<Link>0b1101 in Figure 4-6 specifies that the packet format is of type 13. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_25.jpg"/>
1 1 0 1 4 4 4 8 transaction status targetTID double-word 0 64 double-word 1 64 •  • • </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_26.jpg"/>
</Figure>

<P>double-word n </P>

<P>64 </P>

<P>Figure 4-6. Type 13 Packet Bit Stream Format </P>

<P id="LinkTarget_30465">4.2.4 Type 14 Packet Format (Reserved) </P>

<P>The type 14 packet format is reserved. </P>

<P id="LinkTarget_30466">4.2.5 Type 15 Packet Format (Implementation-Defined) </P>

<P>The type 15 packet format is reserved for implementation-defined functions such as flow control. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30467">Chapter 5 Input/Output Registers </P>

<P>This chapter describes the visible register set that allows an external processing element to determine the capabilities, configuration, and status of a processing element using this logical specification. This chapter only describes registers or register bits defined by this specification. Refer to the other RapidIO logical, transport, and physical specifications of interest to determine a complete list of registers and bit definitions. All registers are 32-bits and aligned to a 32-bit boundary. </P>

<P id="LinkTarget_30468">5.1 Register Summary </P>

<P>
<Link>Table 5-1 shows the register map for this RapidIO specification. These capability </Link>
registers (CARs) and command and status registers (CSRs) can be accessed using RapidIO maintenance operations. Any register offsets not defined are considered reserved for this specification unless otherwise stated. Other registers required for a processing element are defined in other applicable RapidIO specifications and by the requirements of the specific device and are beyond the scope of this specification. Read and write accesses to reserved register offsets shall terminate normally and not cause an error condition in the target device. Writes to CAR (read-only) space shall terminate normally and not cause an error condition in the target device. </P>

<P>Register bits defined as reserved are considered reserved for this specification only. Bits that are reserved in this specification may be defined in another RapidIO specification. </P>

<Table>
<Caption>
<P>Table 5-1. I/O Register Map </P>
</Caption>

<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x0 </TD>

<TD>Device Identity CAR </TD>
</TR>

<TR>
<TD>0x4 </TD>

<TD>Device Information CAR </TD>
</TR>

<TR>
<TD>0x8 </TD>

<TD>Assembly Identity CAR </TD>
</TR>

<TR>
<TD>0xC </TD>

<TD>Assembly Information CAR </TD>
</TR>

<TR>
<TD>0x10 </TD>

<TD>Processing Element Features CAR </TD>
</TR>

<TR>
<TD>0x14 </TD>

<TD>Switch Port Information CAR </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x18 </TD>

<TD>Source Operations CAR </TD>
</TR>

<TR>
<TD>0x1C </TD>

<TD>Destination Operations CAR </TD>
</TR>

<TR>
<TD>0x20–48 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x4C </TD>

<TD>Processing Element Logical Layer Control CSR </TD>
</TR>

<TR>
<TD>0x50 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x58 </TD>

<TD>Local Configuration Space Base Address 0 CSR </TD>
</TR>

<TR>
<TD>0x5C </TD>

<TD>Local Configuration Space Base Address 1 CSR </TD>
</TR>

<TR>
<TD>0x60–FC </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x100– FFFC </TD>

<TD>Extended Features Space </TD>
</TR>

<TR>
<TD>0x10000– FFFFFC </TD>

<TD>Implementation-defined Space </TD>
</TR>

<Caption>
<P>
<Link>Table 5-2 describes the required behavior for accesses to reserved register bits and </Link>
reserved registers for the RapidIO register space, </P>
</Caption>
</Table>

<P id="LinkTarget_30469">5.2 Reserved Register and Bit Behavior </P>

<Table>
<Caption>
<P>Table 5-2. Configuration Space Reserved Access Behavior </P>
</Caption>

<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x0–3C </TH>

<TD>Capability Register Space (CAR Space - this space is read-only) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value1 </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored</TD>
</TR>

<TR>
<TD> Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>
</Table>

<Table>
<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x40–FC </TH>

<TD>Command and Status Register Space (CSR Space) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value2 </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write - implementation-defined </TD>
</TR>

<TR>
<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x100– FFFC </TH>

<TD>Extended Features Space </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write - implementation-defined </TD>
</TR>

<TR>
<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x10000– FFFFFC </TH>

<TD>Implementation-defined Space </TD>

<TD>Reserved bit and register </TD>

<TD>All behavior implementation-defined </TD>
</TR>
</Table>

<P>1Do not depend on reserved bits being a particular value; use appropriate masks to extract defined bits from the read value. </P>

<P>2All register writes shall be in the form: read the register to obtain the values of all reserved bits, merge in the desired values for defined bits to be modified, and write the register, thus preserving the value of all reserved bits. </P>

<P id="LinkTarget_30470">5.3 Extended Features Data Structure </P>

<P>The RapidIO capability and command and status registers implement an extended capability data structure. If the extended features bit (bit 28) in the processing element features register is set, the extended features pointer is valid and points to the first entry in the extended features data structure. This pointer is an offset into the standard 16 Mbyte capability register (CAR) and command and status register (CSR) space and is accessed with a maintenance read operation in the same way as when accessing CARs and CSRs. </P>

<P>The extended features data structure is a singly linked list of double-word structures. Each of these contains a pointer to the next structure (EF_PTR) and an extended feature type identifier (EF_ID). The end of the list is determined when the next extended feature pointer has a value of logic 0. All pointers and extended features </P>

<P>RapidIO Trade Association </P>

<P>blocks shall index completely into the extended features space of the CSR space, and all shall be aligned to a double-word boundary so the three least significant bits shall equal logic 0. Pointer values not in extended features space or improperly aligned 
<Link>are illegal and shall be treated as the end of the data structure. Figure 5-1 shows an </Link>
example of an extended features data structure. It is required that the extended features bit is set to logic 1 in the processing element features register. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_27.jpg"/>
ExtendedFeaturesPtr ExtendedFeatureID 0 15 16 31 32 NextExtendedFeaturePtr reserved 47 48 reserved ExtendedFeatureID 0 15 16 31 32 NextExtendedFeaturePtr reserved 47 48 reserved ExtendedFeatureID 0 15 16 31 32 0b0000000000000000 reserved 47 48 reserved 63 63 63 </Figure>

<P>Figure 5-1. Example Extended Features Data Structure </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30471">5.4 	Capability Registers (CARs) </P>

<P>Every processing element shall contain a set of registers that allows an external processing element to determine its capabilities through maintenance read operations. All registers are 32 bits wide and are organized and accessed in 32-bit (4 byte) quantities, although some processing elements may optionally allow larger accesses. CARs are read-only. 
<Link>Refer to Table 5-2 for the required behavior for </Link>
accesses to reserved registers and register bits. </P>

<P>CARs are big-endian with bit 0 the most significant bit. </P>

<P id="LinkTarget_30472">5.4.1 	Device Identity CAR 
(Configuration Space Offset 0x0) 
</P>

<P>The DeviceVendorIdentity field identifies the vendor that manufactured the device containing the processing element. A value for the DeviceVendorIdentity field is uniquely assigned to a device vendor by the registration authority of the RapidIO Trade Association. </P>

<P>The DeviceIdentity field is intended to uniquely identify the type of device from the vendor specified by the DeviceVendorIdentity field. The values for the DeviceIdentity field are assigned and managed by the respective vendor. See 
<Link>Table 5-3. </Link>
</P>

<Table>
<Caption>
<P>Table 5-3. Bit Settings for Device Identity CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–15 </TD>

<TD>DeviceIdentity </TD>

<TD>Device identifier </TD>
</TR>

<TR>
<TD>16–31 </TD>

<TD>DeviceVendorIdentity </TD>

<TD>Device vendor identifier </TD>
</TR>
</Table>

<P id="LinkTarget_30473">5.4.2 	Device Information CAR (Configuration Space Offset 0x4) </P>

<P>The DeviceRev field is intended to identify the revision level of the device. The value for the DeviceRev field is assigned and managed by the vendor specified by the DeviceVendorIdentity field. See 
<Link>Table 5-4. </Link>
</P>

<Table>
<Caption>
<P>Table 5-4. Bit Settings for Device Information CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-31 </TD>

<TD>DeviceRev </TD>

<TD>Device revision level </TD>
</TR>
</Table>

<P id="LinkTarget_30474">5.4.3 	Assembly Identity CAR (Configuration Space Offset 0x8) </P>

<P>The AssyVendorIdentity field identifies the vendor that manufactured the assembly or subsystem containing the device. A value for the AssyVendorIdentity field is </P>

<P>RapidIO Trade Association </P>

<P>uniquely assigned to a assembly vendor by the registration authority of the RapidIO Trade Association. </P>

<P>The AssyIdentity field is intended to uniquely identify the type of assembly from the vendor specified by the AssyVendorIdentity field. The values for the AssyIdentity 
<Link>field are assigned and managed by the respective vendor. See Table 5-5. </Link>
</P>

<Table>
<Caption>
<P>Table 5-5. Bit Settings for Assembly Identity CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–15 </TD>

<TD>AssyIdentity </TD>

<TD>Assembly identifier </TD>
</TR>

<TR>
<TD>16–31 </TD>

<TD>AssyVendorIdentity </TD>

<TD>Assembly vendor identifier </TD>
</TR>
</Table>

<P id="LinkTarget_30475">5.4.4 	Assembly Information CAR (Configuration Space Offset 0xC) </P>

<P>
<Link>This register contains additional information about the assembly; see Table 5-6. </Link>
</P>

<Table>
<Caption>
<P>Table 5-6. Bit Settings for Assembly Information CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–15 </TD>

<TD>AssyRev </TD>

<TD>Assembly revision level </TD>
</TR>

<TR>
<TD>16–31 </TD>

<TD>ExtendedFeaturesPtr </TD>

<TD>Pointer to the first entry in the extended features list </TD>
</TR>
</Table>

<P id="LinkTarget_30476">5.4.5 	Processing Element Features CAR (Configuration Space Offset 0x10) </P>

<P>This register identifies the major functionality provided by the processing element; see 
<Link>Table 5-7. </Link>
</P>

<Table>
<Caption>
<P>Table 5-7. Bit Settings for Processing Element Features CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Bridge </TD>

<TD>PE can bridge to another interface. Examples are PCI, proprietary processor buses, DRAM, etc. </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Memory </TD>

<TD>PE has physically addressable local address space and can be accessed as an end point through non-maintenance (i.e. non-coherent read and write) operations. This local address space may be limited to local configuration registers, or could be on-chip SRAM, etc. </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>Processor </TD>

<TD>PE physically contains a local processor or similar device that executes code. A device that bridges to an interface that connects to a processor does not count (see bit 0 above). </TD>
</TR>

<TR>
<TD>3 </TD>

<TD>Switch </TD>

<TD>PE can bridge to another external RapidIO interface - an internal port to a local end point does not count as a switch port. For example, a device with two RapidIO ports and a local end point is a two port switch, not a three port switch, regardless of the internal architecture. </TD>
</TR>

<TR>
<TD>4–27 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>
</Table>

<Table>
<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>28 </TD>

<TD>Extended features </TD>

<TD>PE has extended features list; the extended features pointer is valid </TD>
</TR>

<TR>
<TD>29-31 </TD>

<TD>Extended addressing support </TD>

<TD>Indicates the number address bits supported by the PE both as a source and target of an operation. All PEs shall at minimum support 34 bit addresses. 0b111 - PE supports 66, 50, and 34 bit addresses 0b101 - PE supports 66 and 34 bit addresses 0b011 - PE supports 50 and 34 bit addresses 0b001 - PE supports 34 bit addresses All other encodings reserved </TD>
</TR>
</Table>

<P id="LinkTarget_30477">5.4.6 	Switch Port Information CAR (Configuration Space Offset 0x14) </P>

<P>This register defines the switching capabilities of a processing element. This register 
<Link>is only valid if bit 3 is set in the processing element features CAR; see Table 5-8. </Link>
</P>

<Table>
<Caption>
<P>Table 5-8. Bit Settings for Switch Port Information CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–15 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>16–23 </TD>

<TD>PortTotal </TD>

<TD>The total number of RapidIO ports on the processing element 0b00000000 - Reserved 0b00000001 - 1 port 0b00000010 - 2 ports 0b00000011 - 3 ports 0b00000100 - 4 ports ... 0b11111111 - 255 ports </TD>
</TR>

<TR>
<TD>24–31 </TD>

<TD>PortNumber </TD>

<TD>This is the port number from which the maintenance read operation accessed this register. Ports are numbered starting with 0x00. </TD>
</TR>
</Table>

<P id="LinkTarget_30478">5.4.7 	Source Operations CAR (Configuration Space Offset 0x18) </P>

<P>This register defines the set of RapidIO IO logical operations that can be issued by 
<Link>this processing element; see Table 5-9. It is assumed that a processing element can </Link>
generate I/O logical maintenance read and write requests if it is required to access CARs and CSRs in other processing elements. For devices that have only switch functionality only bit 29 is valid. RapidIO switches shall be able to route any packet. </P>

<Table>
<Caption>
<P>Table 5-9. Bit Settings for Source Operations CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–13 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14–15 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>

<TR>
<TD>16 </TD>

<TD>Read </TD>

<TD>PE can support a read operation </TD>
</TR>

<TR>
<TD>17 </TD>

<TD>Write </TD>

<TD>PE can support a write operation </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>18 </TD>

<TD>Streaming-write </TD>

<TD>PE can support a streaming-write operation </TD>
</TR>

<TR>
<TD>19 </TD>

<TD>Write-with-response </TD>

<TD>PE can support a write-with-response operation </TD>
</TR>

<TR>
<TD>20-21 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>22 </TD>

<TD>Atomic (compare-and-swap) </TD>

<TD>PE can support an atomic compare-and-swap operation </TD>
</TR>

<TR>
<TD>23 </TD>

<TD>Atomic (test-and-swap) </TD>

<TD>PE can support an atomic test-and-swap operation </TD>
</TR>

<TR>
<TD>24 </TD>

<TD>Atomic (increment) </TD>

<TD>PE can support an atomic increment operation </TD>
</TR>

<TR>
<TD>25 </TD>

<TD>Atomic (decrement) </TD>

<TD>PE can support an atomic decrement operation </TD>
</TR>

<TR>
<TD>26 </TD>

<TD>Atomic (set) </TD>

<TD>PE can support an atomic set operation </TD>
</TR>

<TR>
<TD>27 </TD>

<TD>Atomic (clear) </TD>

<TD>PE can support an atomic clear operation </TD>
</TR>

<TR>
<TD>28 </TD>

<TD>Atomic (swap) </TD>

<TD>PE can support an atomic swap operation </TD>
</TR>

<TR>
<TD>29 </TD>

<TD>Port-write </TD>

<TD>PE can support a port-write operation </TD>
</TR>

<TR>
<TD>30–31 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>
</Table>

<P id="LinkTarget_30479">5.4.8 	Destination Operations CAR (Configuration Space Offset 0x1C) </P>

<P>This register defines the set of RapidIO I/O operations that can be supported by this 
<Link>processing element; see Table 5-10. It is required that all processing elements can </Link>
respond to maintenance read and write requests in order to access these registers. The Destination Operations CAR is applicable for end point devices only. RapidIO switches shall be able to route any packet. </P>

<Table>
<Caption>
<P>Table 5-10. Bit Settings for Destination Operations CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-13 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14-15 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>

<TR>
<TD>16 </TD>

<TD>Read </TD>

<TD>PE can support a read operation </TD>
</TR>

<TR>
<TD>17 </TD>

<TD>Write </TD>

<TD>PE can support a write operation </TD>
</TR>

<TR>
<TD>18 </TD>

<TD>Streaming-write </TD>

<TD>PE can support a streaming-write operation </TD>
</TR>

<TR>
<TD>19 </TD>

<TD>Write-with-response </TD>

<TD>PE can support a write-with-response operation </TD>
</TR>

<TR>
<TD>20-21 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>22 </TD>

<TD>Atomic (compare-and-swap) </TD>

<TD>PE can support an atomic compare-and-swap operation </TD>
</TR>

<TR>
<TD>23 </TD>

<TD>Atomic (test-and-swap) </TD>

<TD>PE can support an atomic test-and-swap operation </TD>
</TR>

<TR>
<TD>24 </TD>

<TD>Atomic (increment) </TD>

<TD>PE can support an atomic increment operation </TD>
</TR>

<TR>
<TD>25 </TD>

<TD>Atomic (decrement) </TD>

<TD>PE can support an atomic decrement operation </TD>
</TR>

<TR>
<TD>26 </TD>

<TD>Atomic (set) </TD>

<TD>PE can support an atomic set operation </TD>
</TR>

<TR>
<TD>27 </TD>

<TD>Atomic (clear) </TD>

<TD>PE can support an atomic clear operation </TD>
</TR>

<TR>
<TD>28 </TD>

<TD>Atomic (swap) </TD>

<TD>PE can support an atomic swap operation </TD>
</TR>
</Table>

<Table>
<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>29 </TD>

<TD>Port-write </TD>

<TD>PE can support a port-write operation </TD>
</TR>

<TR>
<TD>30-31 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30480">5.5 	Command and Status Registers (CSRs) </P>

<P>A processing element shall contain a set of command and status registers (CSRs) that allows an external processing element to control and determine the status of its internal hardware. All registers are 32 bits wide and are organized and accessed in 
<Link>the same way as the CARs. Refer to Table 5-2 for the required behavior for accesses </Link>
to reserved registers and register bits. </P>

<P id="LinkTarget_30481">5.5.1 	Processing Element Logical Layer Control CSR 
(Configuration Space Offset 0x4C) 
</P>

<P>The Processing Element Logical Layer Control CSR is used for general command and status information for the logical interface. </P>

<Table>
<Caption>
<P>Table 5-11. Bit Settings for Processing Element Logical Layer Control CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–28 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>29-31 </TD>

<TD>Extended addressing control </TD>

<TD>Controls the number of address bits generated by the PE as a source and processed by the PE as the target of an operation. 0b100 - PE supports 66 bit addresses 0b010 - PE supports 50 bit addresses 0b001 - PE supports 34 bit addresses (default) All other encodings reserved </TD>
</TR>
</Table>

<P id="LinkTarget_30482">5.5.2 	Local Configuration Space Base Address 0 CSR (Configuration Space Offset 0x58) </P>

<P>The local configuration space base address 0 register specifies the most significant bits of the local physical address double-word offset for the processing element’s 
<Link>configuration register space. See Section 5.5.3 below for a detailed description. </Link>
</P>

<Table>
<Caption>
<P>Table 5-12. Bit Settings for Local Configuration Space Base Address 0 CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>1-16 </TD>

<TD>LCSBA </TD>

<TD>Reserved for a 34-bit local physical address Reserved for a 50-bit local physical address Bits 0-15 of a 66-bit local physical address </TD>
</TR>

<TR>
<TD>17-31 </TD>

<TD>LCSBA </TD>

<TD>Reserved for a 34-bit local physical address Bits 0-14 of a 50-bit local physical address Bits 16-30 of a 66-bit local physical address </TD>
</TR>
</Table>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30483">5.5.3 	Local Configuration Space Base Address 1 CSR (Configuration Space Offset 0x5C) </P>

<P>The local configuration space base address 1 register specifies the least significant bits of the local physical address double-word offset for the processing element’s configuration register space, allowing the configuration register space to be physically mapped in the processing element. This register allows configuration and maintenance of a processing element through regular read and write operations rather than maintenance operations. The double-word offset is right-justified in the register. </P>

<Table>
<Caption>
<P>Table 5-13. Bit Settings for Local Configuration Space Base Address 1 CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>LCSBA </TD>

<TD>Reserved for a 34-bit local physical address Bit 15 of a 50-bit local physical address Bit 31 of a 66-bit local physical address </TD>
</TR>

<TR>
<TD>1-31 </TD>

<TD>LCSBA </TD>

<TD>Bits 0-30 of a 34-bit local physical address Bits 16-46 of a 50-bit local physical address Bits 32-62 of a 66-bit local physical address </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30484">Glossary of Terms and Abbreviations 
</P>

<P>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </P>

<Table>
<TR>
<TD>A B </TD>

<TD>Agent. A processing element that provides services to a processor. Big-endian. A byte-ordering method in memory where the address n of a word corresponds to the most significant byte. In an addressed memory word, the bytes are ordered (left to right) 0, 1, 2, 3, with 0 being the most significant byte. Bridge. A processing element that connects one computer bus to another, allowing a processing element on one bus to access an processing element on the other. </TD>
</TR>

<TR>
<TD>C D </TD>

<TD>Cache. High-speed memory containing recently accessed data and/or instructions (subset of main memory) associated with a processor. Cache coherence. Caches are coherent if a processor performing a read from its cache is supplied with data corresponding to the most recent value written to memory or to another processor’s cache. In other words, a write operation to an address in the system is visible to all other caches in the system. Cache line. A contiguous block of data that is the standard memory access size for a processor within a system. Capability registers (CARs). A set of read-only registers that allows a processing element to determine another processing element’s capabilities. Command and status registers (CSRs). A set of registers that allows a processing element to control and determine the status of another processing element’s internal hardware. Deadlock. A situation in which two processing elements that are sharing resources prevent each other from accessing the resources, resulting in a halt of system operation. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 Destination. The termination point of a packet on the RapidIO interconnect, also referred to as a target. Device. A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a processing element. Direct Memory Access (DMA). The process of accessing memory in a device by specifying the memory address directly. Double-word. An eight byte quantity, aligned on eight byte boundaries. </P>

<P>E 
</P>

<P>End point. A processing element which is the source or destination of transactions through a RapidIO fabric. </P>

<P>End point device. A processing element which contains end point functionality. </P>

<P>End point free device. A processing element which does not contain end point functionality. </P>

<P>Ethernet. A common local area network (LAN) technology. </P>

<P>External processing element. A processing element other than the processing element in question. </P>

<Table>
<TR>
<TH>F </TH>

<TD>Field or Field name. A sub-unit of a register, where bits in the register are named and defined. </TD>
</TR>

<TR>
<TH>G </TH>

<TD>Globally shared memory (GSM). Cache coherent system memory that can be shared between multiple processors in a system. </TD>
</TR>

<TR>
<TH>H </TH>

<TD>Half-word. A two byte or 16 bit quantity, aligned on two byte boundaries. </TD>
</TR>

<TR>
<TH>I </TH>

<TD>Initiator. The origin of a packet on the RapidIO interconnect, also referred to as a source. </TD>
</TR>

<TR>
<TH/>

<TD>I/O. Input-output. </TD>
</TR>
</Table>

<P>Little-endian. A byte-ordering method in memory where the address n of a word corresponds to the least significant byte. In an addressed memory word, the bytes are ordered (left to right) 3, 2, 1, 0, with 3 being the most significant byte. </P>

<P>Local memory. Memory associated with the processing element in question. </P>

<P>LSB. Least significant byte. </P>

<P>M 
</P>

<P>RapidIO Part 1: Input/Output Logical Specification Rev. 1.3 </P>

<P>Message passing. An application programming model that allows processing elements to communicate via messages to mailboxes instead of via DMA or GSM. Message senders do not write to a memory address in the receiver. </P>

<P>MSB. Most significant byte. </P>

<Table>
<TR>
<TD>N </TD>

<TD>Non-coherent. A transaction that does not participate in any system globally shared memory cache coherence mechanism. </TD>
</TR>

<TR>
<TD>O </TD>

<TD>Operation. A set of transactions between end point devices in a RapidIO system (requests and associated responses) such as a read or a write. </TD>
</TR>
</Table>

<P>P 
</P>

<P>Packet. 	A set of information transmitted between devices in a RapidIO system. </P>

<P>Peripheral component interface (PCI). A bus commonly used for connecting I/O devices in a system. </P>

<P>Port-write. An address-less maintenance write operation. </P>

<P>Priority. The relative importance of a transaction or packet; in most systems a higher priority transaction or packet will be serviced or transmitted before one of lower priority. </P>

<P>Processing Element (PE). A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a device. </P>

<P>Processor. The logic circuitry that responds to and processes the basic instructions that drive a computer. </P>

<P>R 
</P>

<P>Receiver. The RapidIO interface input port on a processing element. Remote memory. Memory associated with a processing element other than the processing element in question. ROM. Read-only memory. </P>

<P>S 
</P>

<P>Sender. The RapidIO interface output port on a processing element. 
Source. The origin of a packet on the RapidIO interconnect, also referred to 
</P>

<P>as an initiator. SRAM. Static random access memory. Switch. A multiple port processing element that directs a packet received on </P>

<P>one of its input ports to one of its output ports. </P>

<P>RapidIO Trade Association </P>

<P>T 
</P>

<P>Target. The termination point of a packet on the RapidIO interconnect, also referred to as a destination. </P>

<P>Transaction. A specific request or response packet transmitted between end point devices in a RapidIO system. </P>

<P>Transaction request flow. A sequence of transactions between two processing elements that have a required completion order at the destination processing element. There are no ordering requirements between transaction request flows. </P>

<P>Word. A four byte or 32 bit quantity, aligned on four byte boundaries. </P>

<P>W </P>

<P>RapidIO Part 1: Input/Output Logical Layer Specification Rev. 1.3 </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P id="LinkTarget_30485">RapidIO™ Interconnect SpecificationPart 2: Message Passing LogicalSpecification </P>

<P>Rev. 1.3, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_0.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH/>

<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>

<TH/>
</TR>

<TR>
<TH/>

<TD>1.1 </TD>

<TD>First public release </TD>

<TD>03/08/2001 </TD>
</TR>

<TR>
<TH/>

<TD>1.2 </TD>

<TD>No technical changes </TD>

<TD>06/26/2002 </TD>
</TR>

<TR>
<TH/>

<TD>1.3 </TD>

<TD>Technical changes: incorporate Rev 1.2 errata 1 as applicable, the following errata showings: 03-05-00006.001, 03-07-00001.001, 04-02-00001.002, 04-05-00001.002 and the following new features showings: 02-05-00013.001 Converted to ISO-friendly templates; re-formatted </TD>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TH/>

<TD>1.3 </TD>

<TD>Removed confidentiality markings for public release </TD>

<TD>06/07/2005 </TD>
</TR>

<TR>
<TH>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.  USER AGREES TO ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER SUCH USE OF THE SPECIFICATION. DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: RapidIO Trade Association Suite 325, 3925 W. Braker Lane Austin, TX 78759 512-305-0070 Tel. 512-305-0009 FAX. RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their respective owners. </TH>
</TR>
</Table>

<P>RapidIO Trade Association RapidIO Part 9: Flow Control Logical Layer Extensions Specification Rev. 1.3 </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 1 Overview </Link>
</P>

<P>
<Link>1.1 Introduction............................................................................................................. 9 
</Link>
</P>

<P>
<Link>1.2 Overview................................................................................................................. 9 
</Link>
</P>

<P>
<Link>1.3 Features of the Message Passing Specification ...................................................... 9 
</Link>
</P>

<P>
<Link>1.3.1 Functional Features ............................................................................................. 9 
</Link>
</P>

<P>
<Link>1.3.2 Physical Features .............................................................................................. 10 
</Link>
</P>

<P>
<Link>1.3.3 Performance Features ....................................................................................... 10 
</Link>
</P>

<P>
<Link>1.4 Contents ................................................................................................................ 10 
</Link>
</P>

<P>
<Link>1.5 Terminology.......................................................................................................... 11 
</Link>
</P>

<P>
<Link>1.6 Conventions .......................................................................................................... 11 
</Link>
</P>

<P>
<Link>Chapter 2 System Models </Link>
</P>

<P>
<Link>2.1 Introduction........................................................................................................... 13 
</Link>
</P>

<P>
<Link>2.2 Processing Element Models .................................................................................. 13 
</Link>
</P>

<P>
<Link>2.2.1 Processor-Memory Processing Element Model................................................ 13 
</Link>
</P>

<P>
<Link>2.2.2 Integrated Processor-Memory Processing Element Model .............................. 14 
</Link>
</P>

<P>
<Link>2.2.3 Memory-Only Processing Element Model ....................................................... 14 
</Link>
</P>

<P>
<Link>2.2.4 Processor-Only Processing Element ................................................................. 15 
</Link>
</P>

<P>
<Link>2.2.5 I/O Processing Element .................................................................................... 15 
</Link>
</P>

<P>
<Link>2.2.6 Switch Processing Element............................................................................... 15 
</Link>
</P>

<P>
<Link>2.3 Message Passing System Model ........................................................................... 16 
</Link>
</P>

<P>
<Link>2.3.1 Data Message Operations ................................................................................. 17 
</Link>
</P>

<P>
<Link>2.3.2 Doorbell Message Operations........................................................................... 18 
</Link>
</P>

<P>
<Link>2.4 System Issues ........................................................................................................ 18 
</Link>
</P>

<P>
<Link>2.4.1 Operation Ordering ........................................................................................... 18 
</Link>
</P>

<P>
<Link>2.4.2 Transaction Delivery......................................................................................... 18 
</Link>
</P>

<P>
<Link>2.4.3 Deadlock Considerations .................................................................................. 19 
</Link>
</P>

<P>
<Link>Chapter 3 Operation Descriptions </Link>
</P>

<P>
<Link>3.1 Introduction........................................................................................................... 21 
</Link>
</P>

<P>
<Link>3.2 Message Passing Operations Cross Reference ..................................................... 22 
</Link>
</P>

<P>
<Link>3.3 Message Passing Operations................................................................................. 22 
</Link>
</P>

<P>
<Link>3.3.1 Doorbell Operations.......................................................................................... 22 
</Link>
</P>

<P>
<Link>3.3.2 Data Message Operations ................................................................................. 23 
</Link>
</P>

<P>
<Link>3.4 Endian, Byte Ordering, and Alignment ................................................................ 24 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 4 Packet Format Descriptions </Link>
</P>

<P>
<Link>4.1 Introduction........................................................................................................... 27 
</Link>
</P>

<P>
<Link>4.2 Request Packet Formats ........................................................................................ 27 
</Link>
</P>

<P>
<Link>4.2.1 Field Definitions for All Request Packet Formats ............................................ 27 
</Link>
</P>

<P>
<Link>4.2.2 Type 0 Packet Format (Implementation-Defined) ............................................ 28 
</Link>
</P>

<P>
<Link>4.2.3 Type 1–9 Packet Formats (Reserved) ............................................................... 28 
</Link>
</P>

<P>
<Link>4.2.4 Type 10 Packet Formats (Doorbell Class) ........................................................ 28 
</Link>
</P>

<P>
<Link>4.2.5 Type 11 Packet Format (Message Class).......................................................... 28 
</Link>
</P>

<P>
<Link>4.3 Response Packet Formats ..................................................................................... 30 
</Link>
</P>

<P>
<Link>4.3.1 Field Definitions for All Response Packet Formats ......................................... 30 
</Link>
</P>

<P>
<Link>4.3.2 Type 12 Packet Format (Reserved) .................................................................. 31 
</Link>
</P>

<P>
<Link>4.3.3 Type 13 Packet Format (Response Class) ........................................................ 31 
</Link>
</P>

<P>
<Link>4.3.4 Type 14 Packet Format (Reserved) .................................................................. 32 
</Link>
</P>

<P>
<Link>4.3.5 Type 15 Packet Format (Implementation-Defined) .......................................... 32 
</Link>
</P>

<P>
<Link>Chapter 5 Message Passing Registers </Link>
</P>

<P>
<Link>5.1 Introduction........................................................................................................... 33 
</Link>
</P>

<P>
<Link>5.2 Register Summary................................................................................................. 33 
</Link>
</P>

<P>
<Link>5.3 Reserved Register and Bit Behavior ..................................................................... 34 
</Link>
</P>

<P>
<Link>5.4 Capability Registers (CARs) ................................................................................ 36 
</Link>
</P>

<P>
<Link>5.4.1 Source Operations CAR (Configuration Space Offset 0x18) ........................... 36 
</Link>
</P>

<P>
<Link>5.4.2 Destination Operations CAR (Configuration Space Offset 0x1C) ................... 36 
</Link>
</P>

<P>
<Link>5.5 Command and Status Registers (CSRs)................................................................ 38 
</Link>
</P>

<P>Annex A Message Passing Interface </P>

<P>
<Link>A.1 Introduction........................................................................................................... 39 
</Link>
</P>

<P>
<Link>A.2 Definitions and Goals ........................................................................................... 39 
</Link>
</P>

<P>
<Link>A.3 Message Operations .............................................................................................. 40 
</Link>
</P>

<P>
<Link>A.4 Inbound Mailbox Structure ................................................................................... 41 
</Link>
</P>

<P>
<Link>A.4.1 Simple Inbox..................................................................................................... 42 
</Link>
</P>

<P>
<Link>A.4.2 Extended Inbox ................................................................................................. 42 
</Link>
</P>

<P>
<Link>A.4.3 Received Messages ........................................................................................... 43 
</Link>
</P>

<P>
<Link>A.5 Outbound Message Queue Structure .................................................................... 44 
</Link>
</P>

<P>
<Link>A.5.1 Simple Outbox .................................................................................................. 44 
</Link>
</P>

<P>A.5.2 
<Link>Extended Outbox .............................................................................................. 45 
</Link>
</P>

<P>RapidIO Part 2: Message Passing Logical Specification </P>

<P>List of Figures 
</P>

<P>
<Link>2-1 A Possible RapidIO-Based Computing System..............................................................13 
</Link>

<Link>2-2 Processor-Memory Processing Element Example ..........................................................14 
</Link>

<Link>2-3 Integrated Processor-Memory Processing Element Example.........................................14 
</Link>

<Link>2-4 Memory-Only Processing Element Example .................................................................15 
</Link>

<Link>2-5 Processor-Only Processing Element Example................................................................15 
</Link>

<Link>2-6 Switch Processing Element Example .............................................................................16 
</Link>

<Link>3-1 Doorbell Operation .........................................................................................................23 
</Link>

<Link>3-2 Message Operation .........................................................................................................23 
</Link>

<Link>3-3 Byte Alignment Example................................................................................................24 
</Link>

<Link>3-4 Half-Word Alignment Example......................................................................................24 
</Link>

<Link>3-5 Word Alignment Example ..............................................................................................25 
</Link>

<Link>4-1 Type 10 Packet Bit Stream Format .................................................................................28 
</Link>

<Link>4-2 Type 11 Packet Bit Stream Format .................................................................................30 
</Link>

<Link>4-3 target_info Field for Message Responses .......................................................................32 
</Link>

<Link>4-4 Type 13 Packet Bit Stream Format .................................................................................32 
</Link>

<Link>A-1 Simple Inbound Mailbox Port Structure .........................................................................42 
</Link>

<Link>A-2 Inbound Mailbox Structure .............................................................................................43 
</Link>

<Link>A-3 Outbound Message Queue ..............................................................................................44 
</Link>

<Link>A-4 Extended Outbound Message Queue ..............................................................................45 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>Blank page </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>List of Tables </P>

<P>
<Link>3-1 Message Passing Operations Cross Reference ...............................................................22 
</Link>

<Link>4-1 Request Packet Type to Transaction Type Cross Reference ..........................................27 
</Link>

<Link>4-2 General Field Definitions for All Request Packets.........................................................28 
</Link>

<Link>4-3 Specific Field Definitions for Type 10 Packets ..............................................................28 
</Link>

<Link>4-4 Specific Field Definitions and Encodings for Type 11 Packets .....................................29 
</Link>

<Link>4-5 Response Packet Type to Transaction Type Cross Reference ........................................30 
</Link>

<Link>4-6 Field Definitions and Encodings for All Response Packets ...........................................31 
</Link>

<Link>4-7 Specific Field Definitions for Type 13 Packets ..............................................................31 
</Link>

<Link>5-1 Message Passing Register Map.......................................................................................33 
</Link>

<Link>5-2 Configuration Space Reserved Access Behavior............................................................34 
</Link>

<Link>5-3 Bit Settings for Source Operations CAR ........................................................................36 
</Link>

<Link>5-4 Bit Settings for Destination Operations CAR .................................................................36 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>Blank page </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30486">Chapter 1 Overview </P>

<P id="LinkTarget_30487">1.1 Introduction </P>

<P>Part 2 is intended for users who need to understand the message passing architecture of the RapidIO interconnect. </P>

<P id="LinkTarget_30488">1.2 Overview </P>

<P>The RapidIO Part 2: Message Passing Logical Specification is part of RapidIO’s logical layer specifications that define the interconnect’s overall protocol and packet formats. This layer contains the transaction protocols necessary for end points to process a transaction. Other RapidIO logical layer specifications include RapidIO Part 1: Input/Output Logical Specification and RapidIO Part 5: Globally Shared Memory Logical Specification. </P>

<P>The logical specifications do not imply a specific transport or physical interface, therefore they are specified in a bit stream format. Necessary bits are added to the logical encoding for the transport and physical layers lower in the RapidIO three-layer hierarchy. </P>

<P>RapidIO is targeted toward memory mapped distributed memory systems. A message passing programming model is supported to enable distributed I/O processing. </P>

<P id="LinkTarget_30489">1.3 Features of the Message Passing Specification </P>

<P>The following are features of the RapidIO I/O specification designed to satisfy the needs of various applications and systems: </P>

<P id="LinkTarget_30490">1.3.1 Functional Features </P>

<P>• Many embedded systems are multiprocessor systems, not multiprocessing systems, and prefer a message passing or software-based coherency programming model over the traditional computer-style globally shared memory programming model in order to support their distributed I/O and processing requirements, especially in the networking and routing markets. RapidIO supports all of these programming models. </P>

<P>RapidIO Trade Association </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> System sizes from very small to very large are supported in the same or compatible packet formats—RapidIO plans for future expansion and requirements. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Message passing devices can improve the interconnect efficiency if larger non-coherent data quantities can be encapsulated within a single packet, so RapidIO supports a variety of data sizes within the packet formats. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Because the message passing programming model is fundamentally a non-coherent non-shared memory model, RapidIO can assume that portions of the memory space are only directly accessible by a processor or device local to that memory space. A remote device that attempts to access that memory space must do so through a local device controlled message passing interface. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30491">1.3.2 Physical Features </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>RapidIO packet definition is independent of the width of the physical interface to other devices on the interconnect fabric. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>The protocols and packet formats are independent of the physical interconnect topology. The protocols work whether the physical fabric is a point-to-point ring, a bus, a switched multi-dimensional network, a duplex serial connection, and so forth. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> RapidIO is not dependent on the bandwidth or latency of the physical fabric. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The protocols handle out-of-order packet transmission and reception. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Certain devices have bandwidth and latency requirements for proper operation. RapidIO does not preclude an implementation from imposing these constraints within the system. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30492">1.3.3 Performance Features </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Packet headers must be as small as possible to minimize the control overhead and be organized for fast, efficient assembly and disassembly. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Multiple transactions must be allowed concurrently in the system, otherwise a majority of the potential system throughput is wasted. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30493">1.4 Contents </P>

<P>Following are the contents of RapidIO Part 2: Message Passing Logical Specification: </P>

<P>• 
<Link>Chapter 1, “Overview” (this chapter) provides an overview of the specification </Link>
</P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 2, “System Models,” introduces some possible devices that might </Link>
participate in a RapidIO message passing system environment. The chapter also explains the message passing model, detailing the data and doorbell message types used in a RapidIO system. System issues such as the lack of transaction ordering and deadlock prevention are presented. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 3, “Operation Descriptions,” describes the set of operations and </Link>
transactions supported by the RapidIO message passing protocols. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 4, “Packet Format Descriptions,” contains the packet format </Link>
definitions for the message passing specification. The two basic types, request and response packets, and their fields and sub-fields are explained. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>
<Link>Chapter 5, “Message Passing Registers,” displays the RapidIO register map </Link>
that allows an external processing element to determine the message passing capabilities, configuration, and status of a processing element using this logical specification. Only registers or register bits specific to the message passing logical specification are explained. Refer to the other RapidIO logical, transport, and physical specifications of interest to determine a complete list of registers and bit definitions. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>
<Link>Annex A, “Message Passing Interface,” contains an informative discussion on </Link>
possible programming models for the message passing logical layer. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30494">1.5 Terminology </P>

<P>Refer to the Glossary at the back of this document. </P>

<P id="LinkTarget_30495">1.6 Conventions </P>

<P>|| 	Concatenation, used to indicate that two fields are physically associated as consecutive bits </P>

<P>ACTIVE_HIGH 	Names of active high signals are shown in uppercase text with no overbar. Active-high signals are asserted when high and not asserted when low. </P>

<P>ACTIVE_LOW 	Names of active low signals are shown in uppercase text with an overbar. Active low signals are asserted when low and not asserted when high. </P>

<P>italics 	Book titles in text are set in italics. </P>

<P>REG[FIELD] 	Abbreviations or acronyms for registers are shown in uppercase text. Specific bits, fields, or ranges appear in brackets. </P>

<P>TRANSACTION Transaction types are expressed in all caps. operation Device operation types are expressed in plain text. n A decimal value. </P>

<P>RapidIO Trade Association </P>

<P>[n-m] 	Used to express a numerical range from n to m. </P>

<P>0bnn 	A binary value, the number of bits is determined by the number of digits. </P>

<P>0xnn 	A hexadecimal value, the number of bits is determined by the number of digits or from the surrounding context; for example, 0xnn may be a 5, 6, 7, or 8 bit value. </P>

<P>x This value is a don’t care </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30496">Chapter 2 System Models </P>

<P id="LinkTarget_30497">2.1 Introduction </P>

<P>This overview introduces some possible devices in a RapidIO system. </P>

<P id="LinkTarget_30498">2.2 Processing Element Models </P>

<P>
<Link>Figure 2-1 describes a possible RapidIO-based system. The processing element is a </Link>
computer device such as a processor attached to local memory and a RapidIO interconnect. The bridge part of the system provides I/O subsystem services such as high-speed PCI interfaces and Gbit ethernet ports, interrupt control, and other system support functions. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_28.jpg"/>
Processing Element A Memory Processing Element B Memory Processing Element C Memory Processing Element D Memory RapidIO System Interconnect Fabric </Figure>

<Table>
<TR>
<TD>PCI A PCI B </TD>

<TD>Bridge </TD>

<TD>XBUS MPIC </TD>
</TR>

<TR>
<TD/>

<TD>Firewire </TD>

<TD/>
</TR>
</Table>

<P>Figure 2-1. A Possible RapidIO-Based Computing System </P>

<P>The following sections describe several possible processing elements. </P>

<P id="LinkTarget_30499">2.2.1 Processor-Memory Processing Element Model </P>

<P>
<Link>Figure 2-2 shows an example of a processing element consisting of a processor </Link>
connected to an agent device. The agent carries out several services on behalf of the processor. Most importantly, it provides access to local memory. It also provides an interface to the RapidIO interconnect to service message requests that are used for </P>

<P>RapidIO Trade Association </P>

<P>communications with other processing elements. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_29.jpg"/>
Agent Memory Processor 
<Caption>
<P>RapidIO-basedSystem Interconnect</P>
</Caption>
</Figure>

<P>Local Interconnect </P>

<P>Figure 2-2. Processor-Memory Processing Element Example </P>

<P id="LinkTarget_30500">2.2.2 Integrated Processor-Memory Processing Element Model </P>

<P>Another form of a processor-memory processing element is a fully integrated component that is designed specifically to connect to a RapidIO interconnect system, 
<Link>Figure 2-3. This type of device integrates a memory system and other </Link>
support logic with a processor on the same piece of silicon or within the same package. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_30.jpg"/>
Processor Memory </Figure>

<P>RapidIO-Based System Interconnect </P>

<P>Figure 2-3. Integrated Processor-Memory Processing Element Example </P>

<P id="LinkTarget_30501">2.2.3 Memory-Only Processing Element Model </P>

<P>A different processing element may not contain a processor at all, but may be a 
<Link>memory-only device as in Figure 2-4. This type of device is much simpler than a </Link>
processor in that it is only responsible for responding to requests from the external system, not from local requests as in the processor-based model. As such, its </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>memory is remote for all processors in the system. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_31.jpg"/>
Memory Memory Control </Figure>

<P>RapidIO-Based System Interconnect </P>

<P>Figure 2-4. Memory-Only Processing Element Example </P>

<P id="LinkTarget_30502">2.2.4 Processor-Only Processing Element </P>

<P>Similar to a memory-only element, a processor-only element has no local memory. 
<Link>A processor-only processing element is shown in Figure 2-5. </Link>
</P>

<Table>
<TR>
<TH/>
</TR>

<TR>
<TH>Processor </TH>
</TR>

<TR>
<TH/>
</TR>

<TR>
<TH/>

<TD/>
</TR>

<TR>
<TH/>
</TR>

<TR>
<TH>Agent </TH>
</TR>

<TR>
<TH/>
</TR>
</Table>

<P>Local Interconnect </P>

<P>RapidIO-based System Interconnect </P>

<P>Figure 2-5. Processor-Only Processing Element Example </P>

<P id="LinkTarget_30503">2.2.5 I/O Processing Element </P>

<P>
<Link>This type of processing element is shown as the bridge in Figure 2-1. This device </Link>
has distinctly different behavior than a processor or a memory. An I/O device only needs to move data into and out of local or remote memory. </P>

<P id="LinkTarget_30504">2.2.6 Switch Processing Element </P>

<P>A switch processing element is a device that allows communication with other processing elements through the switch. A switch may be used to connect a variety of RapidIO-compliant processing elements. A possible switch is shown in 
<Link>Figure 2-6. Behavior of the switches, and the interconnect fabric in general, is </Link>
</P>

<P>RapidIO Trade Association </P>

<P>addressed in the RapidIO Common Transport Specification. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_32.jpg"/>
Switch </Figure>

<P>Figure 2-6. Switch Processing Element Example </P>

<P id="LinkTarget_30505">2.3 Message Passing System Model </P>

<P>RapidIO supports a message passing programming model. Message passing is a programming model commonly used in distributed memory system machines. In this model, processing elements are only allowed to access memory that is local to themselves, and communication between processing elements is handled through specialized hardware manipulated through application or OS software. For two processors to communicate, the sending processor writes to a local message passing device that reads a section of the sender’s local memory and moves that information to the receiving processor’s local message passing device. The recipient message passing device then stores that information in local memory and informs the recipient processor that a message has arrived, usually via an interrupt. The recipient processor then accesses its local memory to read the message. </P>

<P>
<Link>For example, referring to Figure 2-1, processing element A can only access the </Link>
memory attached to it, and cannot access the memory attached to processing elements B, C, or D. Correspondingly, processing element B can only access the memory attached to it and cannot access the memory attached to processing element A, C, or D, and so on. If processing element A needs to communicate with processing element B, the application software accesses special message passing hardware (also called mailbox hardware) through operating system calls or API libraries and configure it to assemble the message and send it to processing element </P>

<P>B. The message passing hardware for processing element B receives the message and puts it into local memory at a predetermined address, then notifies processing element B. </P>

<P>Many times a message is required to be larger than a single packet allows, so the source needs to break up the message into multiple packets before transmitting it. At times it may also be useful to have more than one message being transmitted at a time. RapidIO has facilities for both of these features. </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30506">2.3.1 Data Message Operations </P>

<P>A source may generate a single message operation of up to 16 individual packets containing as much as 256 data bytes per packet. A variety of data payload sizes exist, allowing a source to choose a smaller size data payload if needed for an application. RapidIO defines all data message packets as containing the same amount of data with the exception of the last one, which can contain a smaller data payload if desired. The packets are formatted with three fields: </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>One field specifies the size of the data payload for all except the last packet for the data message operation. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The second field specifies the size of the data payload for that packet, and </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The third field contains the packet sequence order information. </LI_Title>
</LI>
</L>

<P>
<Link>The actual packet formats are shown in Chapter 4, “Packet Format Descriptions.” </Link>
</P>

<P>Because all packets except the last have the same data payload size, the receiver is able to calculate the local memory storage addresses if the packets are received out of order, allowing operation with an interconnect fabric that does not guarantee packet delivery ordering. </P>

<P>For multiple packet messages, a letter field and a mailbox field allow a source to simultaneously have up to four data message operations (or “letters”) in progress to each of four different mailboxes, allowing up to sixteen concurrent data message operations between a sender and a receiver. The mailbox field can be used to indicate the priority of a data message, allowing a higher priority message to interrupt a lower priority one at the sender, or it can be used as a simple mailbox identifier for a particular receiver if the receiver allows multiple mailbox addresses. If the mailbox number is used as a priority indicator, mailbox number 0 is the highest priority and mailbox 3 is the lowest. </P>

<P>For single packet messages, the letter and mailbox fields instead allow four concurrent letters to sixty-four possible mailboxes. As for multiple packet messages, if the mailbox number is used as a priority indicator, mailbox number 0 is the highest priority and mailbox 63 is the lowest. </P>

<P>The number of packets comprising a data message operation, the maximum data payload size, the number of concurrent letters, and the number of mailboxes that can be sent or received is determined by the implementation of a particular processing element. For example, a processing element could be designed to generate two concurrent letters of at most four packets with a maximum 64-byte data payload. That same processing element could also be designed to receive data messages in two mailboxes with two concurrent letters for each, all with the maximum data payload size and number of packets. </P>

<P>There is further discussion of the data message operation programming model and 
<Link>the necessary hardware support in Annex A, “Message Passing Interface”. </Link>
</P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30507">2.3.2 Doorbell Message Operations </P>

<P>RapidIO supports a second message type, the doorbell message operation. The doorbell message operation sends a small amount of software-defined information to the receiver and the receiver controls all local memory addressing as with the data message operation. It is the responsibility of the processor receiving the doorbell message to determine the action to undertake by examining the ID of the sender and the received data. All information supplied in a doorbell message is embedded in the packet header so the doorbell message never has a data payload. </P>

<P>The generation, transmission, and receipt of a doorbell message packet is handled in a fashion similar to a data message packet. If processing element A wants to send a doorbell message to processing element B, the application software accesses special doorbell message hardware through operating system calls or API libraries and configures it to assemble the doorbell message and send it to processing element B. The doorbell message hardware for processing element B receives the doorbell message and puts it into local memory at a predetermined address, then notifies processing element B, again, usually via an interrupt. </P>

<P>There is further discussion of the doorbell message operation programming model 
<Link>and the necessary hardware support in Annex A, “Message Passing Interface”. </Link>
</P>

<P id="LinkTarget_30508">2.4 System Issues </P>

<P>The following sections describe transaction ordering and system deadlock considerations in a RapidIO system. </P>

<P id="LinkTarget_30509">2.4.1 Operation Ordering </P>

<P>The RapidIO Part 2: Message Passing Logical Specification requires no special system operation ordering. Message operation completion is managed by the overlying system software. </P>

<P>It is important to recognize that systems may contain a mix of transactions that are maintained under the message passing model as well as under another model. As an example, I/O traffic may be interspersed with message traffic. In this case, the shared I/O traffic may require strong ordering rules to maintain coherency. This may set an operation ordering precedence for that implementation, especially in the case where the connection fabric cannot discern between one type of operation and another. </P>

<P id="LinkTarget_30510">2.4.2 Transaction Delivery </P>

<P>There are two basic types of delivery schemes that can be built using RapidIO processing elements: unordered and ordered. The RapidIO logical protocols assume that all outstanding transactions to another processing element are delivered in an arbitrary order. In other words, the logical protocols do not rely on transaction interdependencies for operation. RapidIO also allows completely ordered delivery </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>systems to be constructed. Each type of system puts different constraints on the implementation of the source and destination processing elements and any intervening hardware. </P>

<P>A message operation may consist of several transactions. It is possible for these transactions to arrive at a target mailbox in an arbitrary order. A message transaction contains explicit tagging information to allow the message to be reconstructed as it arrives at the target processing element. </P>

<P id="LinkTarget_30511">2.4.3 Deadlock Considerations </P>

<P>A deadlock can occur if a dependency loop exists. A dependency loop is a situation where a loop of buffering devices is formed, in which forward progress at each device is dependent upon progress at the next device. If no device in the loop can make progress then the system is deadlocked. </P>

<P>The simplest solution to the deadlock problem is to discard a packet. This releases resources in the network and allows forward progress to be made. RapidIO is designed to be a reliable fabric for use in real time tightly coupled systems, therefore discarding packets is not an acceptable solution. </P>

<P>In order to produce a system with no chance of deadlock it is required that a deadlock free topology be provided for response-less operations. Dependency loops to single direction packets can exist in unconstrained switch topologies. Often the dependency loop can be avoided with simple routing rules. Topologies like hypercubes or three-dimensional meshes, physically contain loops. In both cases, routing is done in several dimensions (x,y,z). If routing is constrained to the x dimension, then y, then z (dimension ordered routing) then topology related dependency loops are avoided in these structures. </P>

<P>In addition, a processing element design must not form dependency links between its input and output port. A dependency link between input and output ports occurs if a processing element is unable to accept an input packet until a waiting packet can be issued from the output port. </P>

<P>RapidIO supports operations, such as read operations, that require responses to complete. These operations can lead to a dependency link between an processing element’s input port and output port. </P>

<P>As an example of a input to output port dependency, consider a processing element where the output port queue is full. The processing element cannot accept a new request at its input port since there is no place to put the response in the output port queue. No more transactions can be accepted at the input port until the output port is able to free entries in the output queue by issuing packets to the system. </P>

<P>The method by which a RapidIO system maintains a deadlock free environment is described in the appropriate Physical Layer specification. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30512">Chapter 3 Operation Descriptions </P>

<P id="LinkTarget_30513">3.1 Introduction </P>

<P>This chapter describes the set of operations and transactions supported by the RapidIO message passing protocols. The opcodes and packet formats are described 
<Link>in Chapter 4, “Packet Format Descriptions”. </Link>
</P>

<P>The RapidIO operation protocols use request/response transaction pairs through the interconnect fabric. A processing element sends a request transaction to another processing element if it requires an activity to be carried out. The receiving processing element responds with a response transaction when the request has been completed or if an error condition is encountered. Each transaction is sent as a packet through the interconnect fabric. For example, a processing element that needs to send part of a message operation to another processing element sends a MESSAGE request packet to that processing element, which processes the message packet and returns a DONE response packet. </P>

<P>Three possible response transactions can be received by a requesting processing element: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> A DONE response indicates to the requestor that the desired transaction has completed. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>A RETRY response shall be generated for a message transaction that attempts to access a mailbox that is busy servicing another message operation, as can a doorbell transaction that encounters busy doorbell hardware. A transaction request which receives a RETRY response must be re-transmitted in order to complete the operation. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> An ERROR response means that the target of the transaction encountered an unrecoverable error and could not complete the transaction. </LI_Title>
</LI>
</L>

<P>Packets may contain additional information that is interpreted by the interconnect fabric to route the packets through the fabric from the source to the destination, such as a device number. These requirements are described in the appropriate RapidIO transport layer specification, and are beyond the scope of this specification. </P>

<P>Depending upon the interconnect fabric, other packets may be generated as part of the physical layer protocol to manage flow control, errors, etc. Flow control and other fabric-specific communication requirements are described in the appropriate RapidIO physical layer specification and are beyond the scope of this document. </P>

<P>RapidIO Trade Association </P>

<P>Each request transaction sent into the system is marked with a transaction ID that is unique for each requestor and responder processing element pair. This transaction ID allows a response to be easily matched to the original request when it is returned to the requestor. An end point cannot reuse a transaction ID value to the same destination until the response from the original transaction has been received by the requestor. The number of outstanding transactions that may be supported is implementation dependent. </P>

<P id="LinkTarget_30514">3.2 Message Passing Operations Cross Reference </P>

<P>
<Link>Table 3-1 contains a cross-reference list of the message passing operations defined </Link>
in this RapidIO specification and their system usage. </P>

<Table>
<Caption>
<P>Table 3-1. Message Passing Operations Cross Reference </P>
</Caption>

<TR>
<TH>Operation </TH>

<TH>Transactions Used </TH>

<TH>Possible System Usage </TH>

<TH>Description </TH>

<TH>Packet Format </TH>
</TR>

<TR>
<TD>Doorbell </TD>

<TD>DOORBELL, RESPONSE </TD>

<TD/>

<TD>
<Link>Section 3.3.1</Link>
</TD>

<TD>
<Link> Type 10 Section 4.2.4 </Link>
</TD>
</TR>

<TR>
<TD>Data Message </TD>

<TD>MESSAGE, RESPONSE </TD>

<TD/>

<TD>
<Link>Section 3.3.2</Link>
</TD>

<TD>
<Link> Type 11 Section 4.2.5 </Link>
</TD>
</TR>
</Table>

<P id="LinkTarget_30515">3.3 Message Passing Operations </P>

<P>The two kinds of message passing transactions are described in this section and defined as follows: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Doorbell </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Data Message </LI_Title>
</LI>
</L>

<P id="LinkTarget_30516">3.3.1 Doorbell Operations </P>

<P>The doorbell operation, consisting of the DOORBELL and RESPONSE transactions 
<Link>(typically a DONE response) as shown in Figure 3-1, is used by a processing </Link>
element to send a very short message to another processing element through the interconnect fabric. The DOORBELL transaction contains the info field to hold information and does not have a data payload. This field is software-defined and can 
<Link>be used for any desired purpose; see Section 4.2.4, “Type 10 Packet Formats </Link>

<Link>(Doorbell Class)</Link>
,” for information about the info field. </P>

<P>A processing element that receives a doorbell transaction takes the packet and puts it in a doorbell message queue within the processing element. This queue may be implemented in hardware or in local memory. This behavior is similar to that of typical message passing mailbox hardware. The local processor is expected to read the queue to determine the sending processing element and the info field and </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>determine what action to take based on that information. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_33.jpg"/>
DOORBELL1 Requestor Destination DONE 2 </Figure>

<P>Figure 3-1. Doorbell Operation </P>

<P id="LinkTarget_30517">3.3.2 Data Message Operations </P>

<P>The data message operation, consisting of the MESSAGE and RESPONSE 
<Link>transactions (typically a DONE response) as shown in Figure 3-2, is used by </Link>
a processing element’s message passing support hardware to send a data message to other processing elements. Completing a data message operation can consist of up to 16 individual MESSAGE transactions. MESSAGE transaction data payloads are always multiples of doubleword quantities. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_34.jpg"/>
MESSAGEs, data1 Requestor Destination DONEs 2 </Figure>

<P>Figure 3-2. Message Operation </P>

<P>The processing element’s message passing hardware that is the recipient of a data message operation examines a number of fields in order to place an individual MESSAGE packet data in local memory: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Message length (msglen) field—Specifies the number of transactions that comprise the data message operation. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Message segment (msgseg) field—Identifies which part of the data message operation is contained in this transaction. The message length and segment fields allow the individual packets of a data message to be sent or received out of order. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Mailbox (mbox) field—Specifies which mailbox is the target of the data message. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Letter (letter) field —Allows receipt of multiple concurrent data message operations from the same source to the same mailbox. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Standard size (ssize) field—Specifies the data size of all of the transactions except (possibly) the last transaction in the data message. </LI_Title>
</LI>
</L>

<P>From this information, the message passing hardware of the recipient processing element can calculate to which local memory address the </P>

<P>RapidIO Trade Association </P>

<P>transaction data should be placed. </P>

<P>For example, assume that the mailbox starting addresses for the recipient processing element are at addresses 0x1000 for mailbox 0, 0x2000 for mailbox 1, 0x3000 for mailbox 2, and 0x4000 for mailbox 3, and that the processing element receives a message transaction with the following fields: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> message length of 6 packets </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> message segment is 3rd packet </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> mailbox is mailbox 2 </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> letter is 1 </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> standard size is 32 bytes </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>data payload is 32 bytes (it shall be 32 bytes since this is not the last transaction) </LI_Title>
</LI>
</L>

<P>Using this information, the processing element’s message passing hardware can determine that the 32 bytes contained in this part of the data message shall be put into local memory at address 0x3040. </P>

<P>The message passing hardware may also snoop the local processing element’s caching hierarchy when writing local memory if the mailbox memory is defined as being cacheable by that processing element. </P>

<P id="LinkTarget_30518">3.4 Endian, Byte Ordering, and Alignment </P>

<P>RapidIO has double-word (8-byte) aligned big-endian data payloads. This means that the RapidIO interface to devices that are little-endian shall perform the proper endian transformation at the output to format a data payload. </P>

<P>Operations that specify data quantities that are less than 8 bytes shall have the bytes aligned to their proper byte position within the big-endian double-word, as in the 
<Link>examples shown in Figure 3-3 through Figure 3-5. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_35.jpg"/>
Byte 0 1 2 3 4 5 6 7 </Figure>

<P>Byte address 0x0000_0002, the proper byte position is shaded. </P>

<P>Figure 3-3. Byte Alignment Example </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_36.jpg"/>
Byte 0 1 2 3 4 5 6 7 MSB LSB </Figure>

<P>Half-word address 0x0000_0002, the proper byte positions are shaded. </P>

<P>Figure 3-4. Half-Word Alignment Example </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_37.jpg"/>
Byte 0 1 2 3 4 5 6 7 MSB LSB </Figure>

<P>Word address 0x0000_0004, the proper byte positions are shaded. </P>

<P>Figure 3-5. Word Alignment Example </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30519">Chapter 4 Packet Format Descriptions </P>

<P id="LinkTarget_30520">4.1 Introduction </P>

<P>This chapter contains the packet format definitions for the RapidIO Part 2: Message Passing Logical Specification. There are four types of message passing packet formats: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Request </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Response </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Implementation-defined </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Reserved </LI_Title>
</LI>
</L>

<P>The packet formats are intended to be interconnect fabric independent so the system interconnect can be anything required for a particular application. Reserved formats, unless defined in another logical specification, shall not be used by a device. </P>

<P id="LinkTarget_30521">4.2 Request Packet Formats </P>

<P>A request packet is issued by a processing element that needs a remote processing element to accomplish some activity on its behalf, such as a doorbell operation. The request packet format types and their transactions for the RapidIO Part 2: Message Passing Logical Specification
<Link> are shown in Table 4-1. </Link>
</P>

<Table>
<Caption>
<P>Table 4-1. Request Packet Type to Transaction Type Cross Reference </P>
</Caption>

<TR>
<TH>Request Packet Format Type </TH>

<TH>Transaction Type </TH>

<TH>Definition </TH>

<TH>Document Section Number </TH>
</TR>

<TR>
<TD>Type 0 </TD>

<TD>Implementation-defined </TD>

<TD>Defined by the device implementation </TD>

<TD>
<Link>Section 4.2.2 </Link>
</TD>
</TR>

<TR>
<TD>Type 1–9 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.2.3 </Link>
</TD>
</TR>

<TR>
<TD>Type 10 </TD>

<TD>DOORBELL </TD>

<TD>Send a short message </TD>

<TD>
<Link>Section 4.2.4 </Link>
</TD>
</TR>

<TR>
<TD>Type 11 </TD>

<TD>MESSAGE </TD>

<TD>Send a message </TD>

<TD>
<Link>Section 4.2.5 </Link>
</TD>
</TR>
</Table>

<P id="LinkTarget_30522">4.2.1 Field Definitions for All Request Packet Formats </P>

<P>
<Link>The field definitions in Table 4-2 apply to all of the request packet formats. Fields </Link>
that are unique to type 10 and type 11 formats are defined in the sections that describe each type. Bit fields that are defined as “reserved” shall be assigned to logic 0s when generated and ignored when received. Bit field encodings that are defined </P>

<P>RapidIO Trade Association </P>

<P>as “reserved” shall not be assigned when the packet is generated. A received reserved encoding is regarded as an error if a meaningful encoding is required for the transaction and function, otherwise it is ignored. Implementation-defined fields shall be ignored unless the encoding is understood by the receiving device. All packets described are bit streams from the first bit to the last bit, represented in the figures from left to right respectively. </P>

<Table>
<Caption>
<P>Table 4-2. General Field Definitions for All Request Packets </P>
</Caption>

<TR>
<TH>Field </TH>

<TH>Definition </TH>
</TR>

<TR>
<TD>ftype </TD>

<TD>Format type—Represented as a 4-bit value; is always the first four bits in the logical packet stream. </TD>
</TR>

<TR>
<TD>rsrv </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P id="LinkTarget_30523">4.2.2 Type 0 Packet Format (Implementation-Defined) </P>

<P>The type 0 packet format is reserved for implementation-defined functions such as flow control. </P>

<P id="LinkTarget_30524">4.2.3 Type 1–9 Packet Formats (Reserved) </P>

<P>The type 1–9 formats are reserved. </P>

<P id="LinkTarget_30525">4.2.4 Type 10 Packet Formats (Doorbell Class) </P>

<P>The type 10 packet format is the DOORBELL transaction format. Type 10 packets 
<Link>never have data payloads. The field value 0b1010 in Figure 4-1 specifies that the </Link>
packet format is of type 10. </P>

<P>Definitions and encodings of fields specific to type 10 packets are provided in 
<Link>Table 4-3. Fields that are not specific to type 10 packets are described in Table 4-2. </Link>
</P>

<Table>
<Caption>
<P>Table 4-3. Specific Field Definitions for Type 10 Packets </P>
</Caption>

<TR>
<TH>Field </TH>

<TH>Encoding </TH>

<TH>Definition </TH>
</TR>

<TR>
<TD>info </TD>

<TD>— </TD>

<TD>Software-defined information field </TD>
</TR>
</Table>

<P>
<Link>Figure 4-1 displays a type 10 packet with all its fields. </Link>
</P>

<Table>
<TR>
<TH>1 0 1 0 </TH>

<TH>rsrv </TH>

<TH>srcTID </TH>

<TH>info (msb) </TH>

<TH>info (lsb) </TH>
</TR>
</Table>

<P>488 8 8 </P>

<P>Figure 4-1. Type 10 Packet Bit Stream Format </P>

<P id="LinkTarget_30526">4.2.5 Type 11 Packet Format (Message Class) </P>

<P>The type 11 packet is the MESSAGE transaction format. Type 11 packets always have a data payload. Sub-double-word messages are not specifiable and must be managed in software. </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>Definitions and encodings of fields specific to type 11 packets are provided in 
<Link>Table 4-4. Fields that are not specific to type 11 packets are described in Table 4-2. </Link>
</P>

<Table>
<Caption>
<P>Table 4-4. Specific Field Definitions and Encodings for Type 11 Packets </P>
</Caption>

<TR>
<TH>Field </TH>

<TH>Encoding </TH>

<TH>Definition </TH>
</TR>

<TR>
<TD>msglen </TD>

<TD>— </TD>

<TD>
<Link>Total number of packets comprising this message operation. A value of 0 indicates a single-packet message. A value of 15 (0xF) indicates a 16-packet message, etc. See example in Section 3.3.2, “Data Message Operations”. </Link>
</TD>
</TR>

<TR>
<TD>msgseg </TD>

<TD>— </TD>

<TD>
<Link>For multiple packet data message operations, specifies the part of the message supplied by this packet. A value of 0 indicates that this is the first packet in the message. A value of 15 (0xF) indicates that this is the sixteenth packet in the message, etc. See example in Section 3.3.2, “Data Message Operations”. </Link>
</TD>
</TR>

<TR>
<TD>xmbox </TD>

<TD>— </TD>

<TD>For single packet data message operations, specifies the upper 4 bits of the mailbox targeted by the packet. xmbox || mbox are specified as follows: 0000 00 - mailbox 0 0000 01 - mailbox 1 0000 10 - mailbox 2 0000 11 - mailbox 3 0001 00 - mailbox 4 .... 1111 11 - mailbox 63 </TD>
</TR>

<TR>
<TD>ssize </TD>

<TD>— </TD>

<TD>
<Link>Standard message packet data size. This field informs the receiver of a message the size of the data payload to expect for all of the packets for a single message operations except for the last packet in the message. This prevents the sender from having to pad the data field excessively for the last packet and allows the receiver to properly put the message in local memory. See example in Section 3.3.2, “Data Message Operations”. </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>0b0000–1000 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD/>

<TD>0b1001 </TD>

<TD>8 bytes </TD>
</TR>

<TR>
<TD/>

<TD>0b1010 </TD>

<TD>16 bytes </TD>
</TR>

<TR>
<TD/>

<TD>0b1011 </TD>

<TD>32 bytes </TD>
</TR>

<TR>
<TD/>

<TD>0b1100 </TD>

<TD>64 bytes </TD>
</TR>

<TR>
<TD/>

<TD>0b1101 </TD>

<TD>128 bytes </TD>
</TR>

<TR>
<TD/>

<TD>0b1110 </TD>

<TD>256 bytes </TD>
</TR>

<TR>
<TD/>

<TD>0b1111 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>mbox </TD>

<TD>— </TD>

<TD>Specifies the recipient mailbox in the target processing element </TD>
</TR>

<TR>
<TD>letter </TD>

<TD>— </TD>

<TD>Identifies a slot within a mailbox. This field allows a sending processing element to concurrently send up to four messages to the same mailbox on the same processing element. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>
<Link>Figure 4-2 displays a type 11 packet with all its fields. The value 0b1011 in </Link>

<Link>Figure 4-2 specifies that the packet format is of type 11. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_38.jpg"/>
letter 2 double-word 0 64 double-word 1 64 • • • 1 0 1 1 4 4 4 msglen ssize msgseg/xmbox 4 mbox 2 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_39.jpg"/>
</Figure>

<P>double-word n </P>

<P>64 </P>

<P>Figure 4-2. Type 11 Packet Bit Stream Format </P>

<P>The combination of the letter, mbox, and the msgseg or xmbox fields uniquely identifies the message packet in the system for each requestor and responder processing element pair in the same way as the transaction ID is used for other request types. Care must be taken to prevent aliasing of the combination of these values. </P>

<P id="LinkTarget_30527">4.3 Response Packet Formats </P>

<P>A response transaction is issued by a processing element when it has completed a request made by a remote processing element. Response packets are always directed and are transmitted in the same way as request packets. Currently two response 
<Link>packet format types exist, as shown in Table 4-5. </Link>
</P>

<Table>
<Caption>
<P>Table 4-5. Response Packet Type to Transaction Type Cross Reference </P>
</Caption>

<TR>
<TH>Response Packet Format Type </TH>

<TH>Transaction Type </TH>

<TH>Definition </TH>

<TH>Document Section Number </TH>
</TR>

<TR>
<TD>Type 12 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.3.2 </Link>
</TD>
</TR>

<TR>
<TD>Type 13 </TD>

<TD>RESPONSE </TD>

<TD>Issued by a processing element when it completes a request by a remote element. </TD>

<TD>
<Link>Section 4.3.3 </Link>
</TD>
</TR>

<TR>
<TD>Type 14 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.3.4 </Link>
</TD>
</TR>

<TR>
<TD>Type 15 </TD>

<TD>Implementation-defined </TD>

<TD>Defined by the device implementation </TD>

<TD>
<Link>Section 4.3.5 </Link>
</TD>
</TR>
</Table>

<P id="LinkTarget_30528">4.3.1 Field Definitions for All Response Packet Formats </P>

<P>The field definitions in 
<Link>Table 4-6 apply to more than one of the response packet </Link>

<Link>formats. Fields that are unique to the type 13 format are defined in Section 4.3.3, </Link>
</P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>
<Link>“Type 13 Packet Format (Response Class).” </Link>
</P>

<Table>
<Caption>
<P>Table 4-6. Field Definitions and Encodings for All Response Packets </P>
</Caption>

<TR>
<TH>Field </TH>

<TH>Encoding </TH>

<TH>Sub-Field </TH>

<TH>Definition </TH>
</TR>

<TR>
<TH>transaction </TH>

<TD>0b0000 </TD>

<TD>RESPONSE transaction with no data payload (including DOORBELL RESPONSE) </TD>
</TR>

<TR>
<TD>0b0001 </TD>

<TD>MESSAGE RESPONSE transaction </TD>
</TR>

<TR>
<TD>0b0010–1111 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TH>status </TH>

<TD>Type of status and encoding </TD>

<TD/>
</TR>

<TR>
<TD>0b0000 </TD>

<TD>DONE </TD>

<TD>Requested transaction has been successfully completed </TD>
</TR>

<TR>
<TD>0b0001–0010 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b0011 </TD>

<TD>RETRY </TD>

<TD>Requested transaction is not accepted; re-transmission of the request is needed to complete the transaction </TD>
</TR>

<TR>
<TD>0b0100–0110 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b0111 </TD>

<TD>ERROR </TD>

<TD>Unrecoverable error detected </TD>
</TR>

<TR>
<TD>0b1000–1011 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b1100–1111 </TD>

<TD>Implementation </TD>

<TD>Implementation defined—Can be used for additional information such as an error code </TD>
</TR>
</Table>

<P id="LinkTarget_30529">4.3.2 Type 12 Packet Format (Reserved) </P>

<P>The type 12 packet format is reserved. </P>

<P id="LinkTarget_30530">4.3.3 Type 13 Packet Format (Response Class) </P>

<P>The type 13 packet format returns status and the requestor’s transaction ID or message segment and mailbox information. The type 13 format is used for response packets to all request packets. Responses to message and doorbell packets never contain data. </P>

<P>Definitions and encodings of fields specific to type 13 packets are provided in 
<Link>Table 4-7. Fields that are not specific to type 13 packets are described in Table 4-6. </Link>
</P>

<Table>
<Caption>
<P>Table 4-7. Specific Field Definitions for Type 13 Packets </P>
</Caption>

<TR>
<TH>Field </TH>

<TH>Sub-Field </TH>

<TH>Definition </TH>
</TR>

<TR>
<TD>target_info </TD>

<TD>
<Link>As shown in Figure 4-3, when the response is the target_info field, these three sub-fields are used: </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>msgseg </TD>

<TD>
<Link>Specifies the part of the message supplied by the corresponding message packet. A value of 0 indicates that this is the response for the first packet in the message. A value of 15 (0xF) indicates that this is the response for the sixteenth (and last) packet in the message, etc. </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>mbox </TD>

<TD>Specifies the recipient mailbox from the corresponding message packet. </TD>
</TR>

<TR>
<TD/>

<TD>letter </TD>

<TD>Identifies the slot within the target mailbox. This field allows a sending processing element to concurrently send up to four messages to the same mailbox on the same processing element. </TD>
</TR>

<TR>
<TD>targetTID </TD>

<TD>— </TD>

<TD>
<Link>Transaction ID of the request that caused this response (except for message responses defined in Figure 4-3). </Link>
</TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>
<Link>Figure 4-3 shows the format of the target_info field for message responses. </Link>
</P>

<Table>
<TR>
<TH>letter </TH>

<TH>mbox </TH>

<TH>msgseg </TH>
</TR>
</Table>

<P>22 4 </P>

<P>Figure 4-3. target_info Field for Message Responses </P>

<P>
<Link>Figure 4-4 displays a type 13 packet with all its fields. The value 0b1101 in </Link>

<Link>Figure 4-4 specifies that the packet format is of type 13. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_40.jpg"/>
1 1 0 1 transaction status target_info/targetTID </Figure>

<P>444 8 </P>

<P>Figure 4-4. Type 13 Packet Bit Stream Format </P>

<P id="LinkTarget_30531">4.3.4 Type 14 Packet Format (Reserved) </P>

<P>The type 14 packet format is reserved. </P>

<P id="LinkTarget_30532">4.3.5 Type 15 Packet Format (Implementation-Defined) </P>

<P>The type 15 packet format is reserved for implementation-defined functions such as flow control. </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30533">Chapter 5 Message Passing Registers </P>

<P id="LinkTarget_30534">5.1 Introduction </P>

<P>This chapter describes the visible register set that allows an external processing element to determine the capabilities, configuration, and status of a processing element using this logical specification. This chapter only describes registers or register bits defined by this specification. Refer to the other RapidIO logical, transport, and physical specifications of interest to determine a complete list of registers and bit definitions. All registers are 32-bits and aligned to a 32-bit boundary. </P>

<P id="LinkTarget_30535">5.2 Register Summary </P>

<P>
<Link>Table 5-1 shows the register map for this RapidIO specification. These capability </Link>
registers (CARs) and command and status registers (CSRs) can be accessed using Part 1: Input/Output Logical Specification maintenance operations. Any register offsets not defined are considered reserved for this specification unless otherwise stated. Other registers required for a processing element are defined in other applicable RapidIO specifications and by the requirements of the specific device and are beyond the scope of this specification. Read and write accesses to reserved register offsets shall terminate normally and not cause an error condition in the target device. Writes to CAR (read-only) space shall terminate normally and not cause an error condition in the target device. </P>

<P>Register bits defined as reserved are considered reserved for this specification only. Bits that are reserved in this specification may be defined in another RapidIO specification. </P>

<Table>
<Caption>
<P>Table 5-1. Message Passing Register Map </P>
</Caption>

<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x0-14 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x18 </TD>

<TD>Source Operations CAR </TD>
</TR>

<TR>
<TD>0x1C </TD>

<TD>Destination Operations CAR </TD>
</TR>

<TR>
<TD>0x20–FC </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x100– FFFC </TD>

<TD>Extended Features Space </TD>
</TR>

<TR>
<TD>0x10000– FFFFFC </TD>

<TD>Implementation-defined Space </TD>
</TR>
</Table>

<P id="LinkTarget_30536">5.3 Reserved Register and Bit Behavior </P>

<P>
<Link>Table 5-2 describes the required behavior for accesses to reserved register bits and </Link>
reserved registers for the RapidIO register space, </P>

<Table>
<Caption>
<P>Table 5-2. Configuration Space Reserved Access Behavior </P>
</Caption>

<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x0–3C </TH>

<TD>Capability Register Space (CAR Space - this space is read-only) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value1 </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored</TD>
</TR>

<TR>
<TD> Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x40–FC </TH>

<TD>Command and Status Register Space (CSR Space) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value2 </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write - implementation-defined </TD>
</TR>

<TR>
<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>
</Table>

<Table>
<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x100– FFFC </TH>

<TD>Extended Features Space </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD/>

<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write - implementation-defined </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD/>

<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x10000– FFFFFC </TH>

<TD>Implementation-defined Space </TD>

<TD>Reserved bit and register </TD>

<TD>All behavior implementation-defined </TD>
</TR>
</Table>

<P>1Do not depend on reserved bits being a particular value; use appropriate masks to extract defined bits from the read value. </P>

<P>2All register writes shall be in the form: read the register to obtain the values of all reserved bits, merge in the desired values for defined bits to be modified, and write the register, thus preserving the value of all reserved bits. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30537">5.4 	Capability Registers (CARs) </P>

<P>Every processing element shall contain a set of registers that allows an external processing element to determine its capabilities using the I/O logical maintenance read operation. All registers are 32 bits wide and are organized and accessed in 32-bit (4 byte) quantities, although some processing elements may optionally allow 
<Link>larger accesses. CARs are read-only. Refer to Table 5-2 for the required behavior for </Link>
accesses to reserved registers and register bits. </P>

<P>CARs are big-endian with bit 0 the most significant bit. </P>

<P id="LinkTarget_30538">5.4.1 	Source Operations CAR 
(Configuration Space Offset 0x18) 
</P>

<P>This register defines the set of RapidIO message passing logical operations that can 
<Link>be issued by this processing element; see Table 5-3. It is assumed that a processing </Link>
element can generate I/O logical maintenance read and write requests if it is required to access CARs and CSRs in other processing elements. RapidIO switches shall be able to route any packet. </P>

<Table>
<Caption>
<P>Table 5-3. Bit Settings for Source Operations CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–13 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14–15 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>

<TR>
<TD>16–19 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>20 </TD>

<TD>Data message </TD>

<TD>PE can support a data message operation </TD>
</TR>

<TR>
<TD>21 </TD>

<TD>Doorbell </TD>

<TD>PE can support a doorbell operation </TD>
</TR>

<TR>
<TD>22–29 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>30–31 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>
</Table>

<P id="LinkTarget_30539">5.4.2 	Destination Operations CAR (Configuration Space Offset 0x1C) </P>

<P>This register defines the set of RapidIO message passing operations that can be 
<Link>supported by this processing element; see Table 5-4. It is required that all processing </Link>
elements can respond to I/O logical maintenance read and write requests in order to access these registers. The Destination Operations CAR is applicable for end point devices only. RapidIO switches shall be able to route any packet. </P>

<Table>
<Caption>
<P>Table 5-4. Bit Settings for Destination Operations CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–13 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14–15 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>

<TR>
<TD>16–19 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>
</Table>

<Table>
<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>20 </TD>

<TD>Data message </TD>

<TD>PE can support a data message operation </TD>
</TR>

<TR>
<TD>21 </TD>

<TD>Doorbell </TD>

<TD>PE can support a doorbell operation </TD>
</TR>

<TR>
<TD>22–29 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>30–31 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30540">5.5 Command and Status Registers (CSRs) </P>

<P>A processing element shall contain a set of command and status registers (CSRs) that allows an external processing element to control and determine the status of its internal hardware. All registers are 32 bits wide and are organized and accessed in 
<Link>the same way as the CARs. Refer to Table 5-2 for the required behavior for accesses </Link>
to reserved registers and register bits. </P>

<P>Currently there are no CSRs defined by the message passing logical layer specification. </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30541">Annex A Message Passing Interface </P>

<P id="LinkTarget_30542">A.1 Introduction </P>

<P>The RapidIO Part 2: Message Passing Logical Specification defines several packet formats that are useful for sending messages from a source device to a destination. These formats do not describe a specific programming model but are instantiated as an example packetizing mechanism. Because the actual programming models for message passing can vary greatly in both capability and complexity, they have been deemed beyond the scope of this specification. This appendix is provided as a reference model for message passing and is not intended to be all encompassing. </P>

<P id="LinkTarget_30543">A.2 Definitions and Goals </P>

<P>A system may be made up of several processors and distributed memory elements. These processors may be tightly coupled and operating under a monolithic operating system in certain applications. When this is true the operating system is tasked with managing the pool of processors and memory to solve a set of tasks. In most of these cases, it is most efficient for the processors to work out of a common hardware-maintained coherent memory space. This allows processors to communicate initialization and completion of tasks through the use of semaphores, spin locks, and inter-process interrupts. Memory is managed centrally by the operating system with a paging protection scheme. </P>

<P>In other such distributed systems, processors and memory may be more loosely coupled. Several operating systems or kernels may be coexistent in the system, each kernel being responsible for a small part of the entire system. It is necessary to have a communication mechanism whereby kernels can communicate with other kernels in a system of this nature. Since this is a shared nothing environment, it is also desirable to have a common hardware and software interface mechanism to accomplish this communication. This model is typically called message passing. </P>

<P>In these message passing systems, two mechanisms typically are used to move data from one portion of memory space to another. The first mechanism is called direct memory access (DMA), the second is messaging. The primary difference between the two models is that DMA transactions are steered by the source whereas messages are steered by the target. This means that a DMA source not only requires access to a target but must also have visibility into the target’s address space. The message source only requires access to the target and does not need visibility into the target’s </P>

<P>RapidIO Trade Association </P>

<P>address space. In distributed systems it is common to find a mix of DMA and messaging deployed. </P>

<P>The RapidIO architecture contains a packet transport mechanism that can aid in the distributed shared nothing environment. The RapidIO message passing model meets several goals: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> A message is constructed of one or more transactions that can be sent and received through a possibly unordered interconnect </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A sender can have a number of outstanding messages queued for sending </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A sender can send a higher priority message before a lower priority message and can also preempt a lower priority message to send a higher priority one and have the lower priority message resume when the higher is complete (prioritized concurrency) </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>A sender requires no knowledge of the receiver’s internal structure or memory map </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A receiver of a message has complete control over it’s local address space </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>A receiver can have a number of outstanding messages queued for servicing if desired </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A receiver can receive a number of concurrent multiple-transaction messages if desired </LI_Title>
</LI>
</L>

<P id="LinkTarget_30544">A.3 Message Operations </P>

<P>The RapidIO Part 2: Message Passing Logical Specification defines the type 11 packet as the MESSAGE transaction format. The transaction may be used in a number of different ways dependent on the specific system architecture. The transaction header contains the following field definitions: </P>

<P>mbox Specifies the recipient mailbox in the target processing element. RapidIO allows up to four mailbox ports in each target device. This can be useful for defining blocks of different message frame sizes or different local delivery priority levels. </P>

<P>letter A RapidIO message operation may be made up of several transactions. It may be desirable in some systems to have more than one multi-transaction message concurrently in transit to the target mailbox. The letter identifies the specific message within the mailbox. This field allows a sending of up to four messages to the same mailbox in the same target device. </P>

<P>multi-transaction fieldsIn cases where message operations are made up of multiple transactions, the following fields allow reconstruction of a message transported through an unordered interconnect fabric: </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>msglen Specifies the total number of transactions comprising this message. A value of 0 indicates a single transaction message. A value of 15 (0xF) indicates a 16 transaction message, and so forth. </P>

<P>msgseg Specifies the part of the message operation supplied by this transaction. A value of 0 indicates that this is the first transaction in the message. A value of 15 (0xF) indicates that this is the sixteenth transaction in the message, and so on. </P>

<P>ssize Standard message transaction data size. This field tells the receiver to expect a message the size of the data field for all of the transactions except the last one. This prevents the sender from having to pad the data field excessively for the last transaction and allows the receiver to properly put the message in local memory; otherwise, if the last transaction is the first one received, the address calculations will be in error when writing the transaction to memory. </P>

<P>
<Link>For a more detailed description of the message packet format, refer to Section 4.2.5, </Link>

<Link>“Type 11 Packet Format (Message Class).” </Link>
</P>

<P>The second type of message packet is the type 10 doorbell transaction packet. The doorbell transaction is a lightweight transaction that contains only a 16-bit information field that is completely software defined. The doorbell is intended to be an in-band mechanism to send interrupts between processors. In this usage the information field would be used to convey interrupt level and target information to the recipient. For a more detailed description of the doorbell packet format, refer to 
<Link>Section 4.2.4, “Type 10 Packet Formats (Doorbell Class).” </Link>
</P>

<P>There are two transaction format models described in this appendix, a simple model and an extended model. The simple model is recommended for both the type 10 (doorbell) and type 11 (message) packet format messages. The extended model is only recommended for the type 11 (message) packet format messages. </P>

<P id="LinkTarget_30545">A.4 Inbound Mailbox Structure </P>

<P>RapidIO provides two message transaction packet formats. By nature of having such formats it is possible for one device to pass a message to another device without a specific memory mapped transaction. The transaction allows for the concept of a memory map independent port. As mentioned earlier, how the transactions are generated and what is done with them at the destination is beyond the scope of the RapidIO Part 2: Message Passing Logical Specification. There are, however, a few examples as to how they could be deployed. First, look at the destination of the message. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30546">A.4.1 Simple Inbox </P>

<P>Probably the most simple inbound mailbox structure is that of a single-register port 
<Link>or direct map into local memory space (see Figure A-1). </Link>
</P>

<P>Local Memory </P>

<P>Local Processor Read </P>

<P>Tail Pointer Tail Pointer </P>

<P>Transactions 
from 
RapidIO Interface 
</P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_41.jpg"/>
Inbound Mailbox Port </Figure>
Head Pointer </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_42.jpg"/>
Message Frame Message Frame Message Frame Message Frame Message Frame Message Frame Message Frame Message Frame </Figure>

<P>Figure A-1. Simple Inbound Mailbox Port Structure </P>

<P>In this structure, the inbound single transaction message is posted to either a register, set of registers, or circular queue in local memory. In the case of the circular queue, hardware maintains a head and tail pointer that points at a fixed window of pre-partitioned message frames in memory. Whenever the head pointer equals the tail pointer, no more messages can be accepted and they are retried on the RapidIO interface. When messages are posted, the local processor is interrupted. The interrupt service routine reads the mailbox port that contains the message located at the tail pointer. The message frame is equal to the largest message operation that can be received. </P>

<P>The RapidIO MESSAGE transaction allows up to four such inbound mailbox ports per target address. The DOORBELL transaction is defined as a single mailbox port. </P>

<P id="LinkTarget_30547">A.4.2 Extended Inbox </P>

<P>A second more extensible structure similar to that used in the intelligent I/O (I2O) 
<Link>specification, but managed differently, also works for the receiver (see Figure A-2). </Link>
</P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>Local Memory </P>

<P>Local Memory </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_43.jpg"/>
Message Frame Message Frame Message Frame Message Frame Message Frame Message Frame Message Frame Message Frame Letter Slot Letter Slot Letter Slot Letter Slot MFA MFA MFA MFA MFA MFA MFA MFA Tail Pointer Head Pointer Tail Pointer Head Pointer Inbound Mailbox Port Transactions from RapidIO Interface Inbound Post List FIFO Inbound Free List FIFO Local Processor Write Optional Letter Slots allow multiple multi-transaction messages to arrive in the Inbox concurrently </Figure>

<P>Local Processor </P>

<P>Read </P>

<P>Figure A-2. Inbound Mailbox Structure </P>

<P>One of these structures is required for each priority level supported in an implementation. There are inbound post and free list FIFOs which function as circular queues of a fixed size. The message frames are of a size equal to the maximum message size that can be accepted by the receiver. Smaller messages can be accepted if allowed by the overlaying software. The sender only specifies the mailbox and does not request the frame pointer and perform direct memory access as with I2O, although the I2O model can be supported in software with this structure. All pointers are managed by the inbound hardware and the local processor. Message priority and letter number are managed by software. </P>

<P>The advantage of the extended structure is that it allows local software to service message frames in any order. It also allows memory regions to be moved in and out of the message structure instead of forcing software to copy the message to a different memory location. </P>

<P id="LinkTarget_30548">A.4.3 Received Messages </P>

<P>When a message transaction is received, the inbound mailbox port takes the message frame address (MFA) pointed at by the inbound free list tail pointer and increments that pointer (this may cause a memory read to prefetch the next MFA), effectively taking the MFA from the free list. Subsequent message transactions from a different sender or with a different letter number are now retried until all of the transactions for this message operation have been received, unless there is additional hardware to handle multiple concurrent message operations for the same mailbox, differentiated by the letter slots. </P>

<P>RapidIO Trade Association </P>

<P>The inbound mailbox port uses the MFA to write the transaction data into local memory at that base address with the exact address calculated as described in 
<Link>Section 2.3.1, “Data Message Operations” and Section 3.3.2, “Data Message </Link>

<Link>Operations</Link>
.” When the entire message is received and written into memory, the inbound post list pointer is incremented and the MFA is written into that location. If the queue was previously empty, an interrupt is generated to the local processor to indicate that there is a new message pending. This causes a window where the letter hardware is busy and cannot service a new operation between the receipt of the final transaction and the MFA being committed to the local memory. </P>

<P>When the local processor services a received message, it reads the MFA indicated by the inbound post FIFO tail pointer and increments the tail pointer. When the message has been processed (or possibly deferred), it puts a new MFA in the memory address indicated by the inbound free list head pointer and increments that pointer, adding the new MFA to the free list for use by the inbound message hardware. </P>

<P>If the free list head and tail pointer are the same, the FIFO is empty and there are no more MFAs available and all new messages are retried. If the post list head and tail pointers are the same, there are no outstanding messages awaiting service from the local processor. Underflow conditions are fatal since they indicate improper system behavior. This information can be part of an associated status register. </P>

<P id="LinkTarget_30549">A.5 Outbound Message Queue Structure </P>

<P>Queuing messages in RapidIO is accomplished either through a simple or a more extended outbox. </P>

<P id="LinkTarget_30550">A.5.1 Simple Outbox </P>

<P>Generation of a message can be as simple as writing to a memory-mapped descriptor structure either in local registers or memory. The outbound message queue (see 
<Link>Figure A-3</Link>
) looks similar to the inbox. </P>

<P>Local Memory </P>

<P>Local Processor MessageWrite Frame </P>

<P>Transactions 
to 
RapidIO Interface 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_44.jpg"/>
</Figure>

<P>Outbound 
Mailbox 
Port 
</P>

<P>Head Pointer </P>

<P>Message Frame </P>

<P>Tail Pointer Message Frame </P>

<P>Message 
Frame 
</P>

<P>Figure A-3. Outbound Message Queue </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>The local processor reads a port in the outbound mailbox to obtain the position of a head pointer in local memory. If the read results in a pre-determined pattern the message queue is full. The processor then writes a descriptor structure and message to that location. When it is done, it writes the message port to advance the head point and mark the message as queued. The outbound mailbox hardware then reads the messages pointed to by the tail pointer and transfers them to the target device pointed at by the message descriptor. </P>

<P>One of these structures is required for each priority level of outbound messages supported. </P>

<P id="LinkTarget_30551">A.5.2 Extended Outbox </P>

<P>A more extensible method of queueing messages is again a two-level approach (see 
<Link>Figure A-4). Multiple structures are required if concurrent operation is desired in an </Link>
implementation. The FIFO is a circular queue of some fixed size. The message frames are of a size that is equal to the maximum message operation size that can be accepted by the receivers in the system. Smaller message operations can be sent if allowed by the hardware and the overlaying software. As with the receive side, the outbound slots can be virtual and any letter number can be handled by an arbitrary letter slot. </P>

<P>Local Memory </P>

<P>Local Processor Local Memory Write </P>

<P>Post Transactions Head Pointer List </P>

<P>to FIFO RapidIO Interface </P>

<P>MFD MFD Tail Pointer </P>

<P>MFD MFD MFD </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_45.jpg"/>
Message Frame Message Frame Message Frame Message Frame Letter Slot Letter Slot Letter Slot Letter Slot Outbound Mailbox Port Outbound </Figure>

<P>Figure A-4. Extended Outbound Message Queue </P>

<P>When the local processor wishes to send a message, it stores the message in local memory, writes the message frame descriptor (MFD) to the outbound mailbox port (which in-turn writes it to the location indicated by the outbound post FIFO head pointer), and increments the head pointer. </P>

<P>The advantage of this method is that software can have pre-set messages stored in local memory. Whenever it needs to communicate an event to a specific end point it writes the address of the message frame to the outbound mailbox, and the outbound mailbox generates the message transactions and completes the operation. </P>

<P>If the outbound post list FIFO head and tail pointers are not equal, there is a message waiting to be sent. This causes the outbound mailbox port to read the MFD pointed </P>

<P>RapidIO Trade Association </P>

<P>to by the outbound post list tail pointer and then decrement the pointer (this may cause a memory read to prefetch the next MFD). The hardware then uses the information stored in the MFD to read the message frame, packetize it, and transmit it to the receiver. Multiple messages can be transmitted concurrently if there is 
<Link>hardware to support them, differentiated by the letter slots in Figure A-4. </Link>
</P>

<P>If the free list head and tail pointer are the same, the FIFO is empty and there are no more MFDs to be processed. Underflow conditions are fatal because they indicate improper system behavior. This information can also be part of a status register. </P>

<P>Because the outbound and inbound hardware are independent entities, it is possible for more complex outbound mailboxes to communicate with less complex inboxes by simply reducing the complexity of the message descriptor to match. Likewise simple outboxes can communicate with complex inboxes. Software can determine the capabilities of a device during initial system setup. The capabilities of a devices message hardware are stored in the port configuration registers. </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30552">Glossary of Terms and Abbreviations 
</P>

<P>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </P>

<Table>
<TR>
<TD>A B </TD>

<TD>Agent. A processing element that provides services to a processor. Big-endian. A byte-ordering method in memory where the address n of a word corresponds to the most significant byte. In an addressed memory word, the bytes are ordered (left to right) 0, 1, 2, 3, with 0 being the most significant byte. Bridge. A processing element that connects one computer bus to another, allowing a processing element on one bus to access an processing element on the other. </TD>
</TR>

<TR>
<TD>C D </TD>

<TD>Capability registers (CARs). A set of read-only registers that allows a processing element to determine another processing element’s capabilities. CCITT. Consultive Communication for International Telegraph and Telephone. Command and status registers (CSRs). A set of registers that allows a processing element to control and determine the status of another processing element’s internal hardware. Deadlock. A situation in which two processing elements that are sharing resources prevent each other from accessing the resources, resulting in a halt of system operation. Destination. The termination point of a packet on the RapidIO interconnect, also referred to as a target. Device. A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a processing element. Direct Memory Access (DMA). The process of accessing memory in a device by specifying the memory address directly. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 Distributed memory. System memory that is distributed throughout the system, as opposed to being centrally located. Doorbell. A port on a device that is capable of generating an interrupt to a processor. Double-word. An eight byte quantity, aligned on eight byte boundaries. </P>

<P>E 
</P>

<P>End point. A processing element which is the source or destination of transactions through a RapidIO fabric. </P>

<P>End point device. A processing element which contains end point functionality. </P>

<P>Ethernet. A common local area network (LAN) technology. </P>

<P>External processing element. A processing element other than the processing element in question. </P>

<Table>
<TR>
<TH>F </TH>

<TD>Field or Field name. A sub-unit of a register, where bits in the register are named and defined. FIFO. First in, first out. </TD>
</TR>

<TR>
<TH>G </TH>

<TD>Globally shared memory (GSM). Cache coherent system memory that can be shared between multiple processors in a system. </TD>
</TR>

<TR>
<TH>H </TH>

<TD>Half-word. A two byte or 16 bit quantity, aligned on two byte boundaries. </TD>
</TR>
</Table>

<P>I2O. Intelligent I/O architecture specification. </P>

<P>Initiator. The origin of a packet on the RapidIO interconnect, also referred to as a source. </P>
</Div>

<Div>
<P>I/O. Input-output. </P>

<P>Little-endian. A byte-ordering method in memory where the address n of a word corresponds to the least significant byte. In an addressed memory word, the bytes are ordered (left to right) 3, 2, 1, 0, with 3 being the most significant byte. </P>

<P>Local memory. Memory associated with the processing element in question. </P>

<P>LSB. Least significant byte. </P>

<P>M Mailbox. Dedicated hardware that receives messages. </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 Message passing. An application programming model that allows processing elements to communicate via messages to mailboxes instead of via DMA or GSM. Message senders do not write to a memory address in the receiver. MFA. Message frame address. MFD. Message frame descriptor. MSB. Most significant byte. </P>

<Table>
<TR>
<TD>N </TD>

<TD>Non-coherent. A transaction that does not participate in any system globally shared memory cache coherence mechanism. </TD>
</TR>

<TR>
<TD>O </TD>

<TD>Operation. A set of transactions between end point devices in a RapidIO system (requests and associated responses) such as a read or a write. </TD>
</TR>
</Table>

<P>P 
</P>

<P>Packet. 	A set of information transmitted between devices in a RapidIO system. </P>

<P>PCB. Printed circuit board. </P>

<P>Peripheral component interface (PCI). A bus commonly used for connecting I/O devices in a system. </P>

<P>Priority. The relative importance of a transaction or packet; in most systems a higher priority transaction or packet will be serviced or transmitted before one of lower priority. </P>

<P>Processing Element (PE). A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a device. </P>

<P>Processor. The logic circuitry that responds to and processes the basic instructions that drive a computer. </P>

<P>R Receiver. The RapidIO interface input port on a processing element. </P>

<P>Remote memory. Memory associated with a processing element other than the processing element in question. </P>

<P>S 
</P>

<P>Sender. The RapidIO interface output port on a processing element. </P>

<P>Semaphore. A technique for coordinating activities in which multiple processing elements compete for the same resource, typically requiring atomic operations. </P>

<P>RapidIO Trade Association </P>

<P>Source. The origin of a packet on the RapidIO interconnect, also referred to as an initiator. </P>

<P>Switch. A multiple port processing element that directs a packet received on one of its input ports to one of its output ports. </P>

<P>T 
</P>

<P>Target. The termination point of a packet on the RapidIO interconnect, also referred to as a destination. </P>

<P>Transaction. A specific request or response packet transmitted between end point devices in a RapidIO system. </P>

<P>Word. A four byte or 32 bit quantity, aligned on four byte boundaries. </P>

<P>W </P>

<P>RapidIO Part 2: Message Passing Logical Specification Rev. 1.3 </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P id="LinkTarget_30553">RapidIO™ Interconnect SpecificationPart 3: Common TransportSpecification </P>

<P>Rev. 1.3, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_0.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>
</TR>

<TR>
<TH>1.1 </TH>

<TH>First public release </TH>

<TD>03/08/2001 </TD>
</TR>

<TR>
<TH>1.2 </TH>

<TH>No technical changes </TH>

<TD>06/26/2002 </TD>
</TR>

<TR>
<TH>1.3 </TH>

<TH>Technical changes: the following new features showings: 03-01-00002.006, 03-03-00002.002 Converted to ISO-friendly templates; re-formatted </TH>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TH>1.3 </TH>

<TH>Removed confidentiality markings for public release </TH>

<TD>06/07/2005 </TD>
</TR>
</Table>

<P>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE 
ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND 
CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO 
WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.  USER AGREES TO 
ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE 
GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR 
RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER 
SUCH USE OF THE SPECIFICATION. 
</P>

<P>DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, 
INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST 
PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION 
WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE 
RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. 
</P>

<P>Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: 
RapidIO Trade Association 
Suite 325, 3925 W. Braker Lane 
Austin, TX 78759 
512-305-0070 Tel. 
512-305-0009 FAX. 
</P>

<P>RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their 
respective owners. 
</P>

<P>RapidIO Trade Association RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 1 Overview </Link>
</P>

<P>
<Link>1.1 Introduction........................................................................................................... 11 
</Link>
</P>

<P>
<Link>1.2 Overview............................................................................................................... 11 
</Link>
</P>

<P>
<Link>1.3 Transport Layer Features ...................................................................................... 11 
</Link>
</P>

<P>
<Link>1.3.1 Functional Features ........................................................................................... 11 
</Link>
</P>

<P>
<Link>1.3.2 Physical Features .............................................................................................. 12 
</Link>
</P>

<P>
<Link>1.3.3 Performance Features ....................................................................................... 12 
</Link>
</P>

<P>
<Link>1.4 Contents ................................................................................................................ 12 
</Link>
</P>

<P>
<Link>1.5 Terminology.......................................................................................................... 12 
</Link>
</P>

<P>
<Link>1.6 Conventions .......................................................................................................... 12 
</Link>
</P>

<P>
<Link>Chapter 2 Transport Format Description </Link>
</P>

<P>
<Link>2.1 Introduction........................................................................................................... 15 
</Link>
</P>

<P>
<Link>2.2 System Topology .................................................................................................. 15 
</Link>
</P>

<P>
<Link>2.2.1 Switch-Based Systems ...................................................................................... 15 
</Link>
</P>

<P>
<Link>2.2.2 Ring-Based Systems ......................................................................................... 16 
</Link>
</P>

<P>
<Link>2.3 System Packet Routing ......................................................................................... 17 
</Link>
</P>

<P>
<Link>2.4 Field Alignment and Definition ............................................................................ 17 
</Link>
</P>

<P>
<Link>2.5 Routing Maintenance Packets............................................................................... 18 
</Link>
</P>

<P>
<Link>Chapter 3 Common Transport Registers </Link>
</P>

<P>
<Link>3.1 Introduction........................................................................................................... 21 
</Link>
</P>

<P>
<Link>3.2 Register Summary................................................................................................. 21 
</Link>
</P>

<P>
<Link>3.3 Reserved Register and Bit Behavior ..................................................................... 22 
</Link>
</P>

<P>
<Link>3.4 Capability Registers (CARs) ................................................................................ 24 
</Link>
</P>

<P>
<Link>3.4.1 	Processing Element Features CAR (Configuration Space Offset 0x10)............................................................... 24 </Link>
</P>

<P>
<Link>3.4.2 	Switch Route Table Destination ID Limit CAR (Configuration Space Offset 0x34)............................................................... 24 </Link>
</P>

<P>
<Link>3.5 Command and Status Registers (CSRs)................................................................ 26 
</Link>
</P>

<P>
<Link>3.5.1 	Base Device ID CSR (Configuration Space Offset 0x60)............................................................... 26 </Link>
</P>

<P>
<Link>3.5.2 	Host Base Device ID Lock CSR (Configuration Space Offset 0x68)............................................................... 26 </Link>
</P>

<P>
<Link>3.5.3 	Component Tag CSR (Configuration Space Offset 0x6C) .............................................................. 27 </Link>
</P>

<P>
<Link>3.5.4 	Standard Route Configuration Destination ID Select CSR (Configuration Space Offset 0x70)............................................................... 27 </Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>3.5.5 	Standard Route Configuration Port Select CSR (Configuration Space Offset 0x74)............................................................... 29 </Link>
</P>

<P>
<Link>3.5.6 	Standard Route Default Port CSR (Configuration Space Offset 0x78)............................................................... 30 </Link>
</P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P>Table of Contents </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>RapidIO Part 3: Common Transport Specification </P>

<P>List of Figures </P>

<P>
<Link>2-1 A Small Switch-Based System .......................................................................................16 
</Link>

<Link>2-2 A Small Ring-Based System...........................................................................................17 
</Link>

<Link>2-3 Destination-Source Transport Bit Stream .......................................................................18 
</Link>

<Link>2-4 Maintenance Packet Transport Bit Stream .....................................................................19 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P>List of Tables </P>

<P>
<Link>2-1 tt Field Definition............................................................................................................18 
</Link>

<Link>3-1 Common Transport Register Map ..................................................................................21 
</Link>

<Link>3-2 Configuration Space Reserved Access Behavior............................................................22 
</Link>

<Link>3-3 Bit Settings for Processing Element Features CAR........................................................24 
</Link>

<Link>3-4 Bit Settings for Switch Route Table Destination ID Limit CAR ...................................25 
</Link>

<Link>3-5 Bit Settings for Base Device ID CSR .............................................................................26 
</Link>

<Link>3-6 Bit Settings for Host Base Device ID Lock CSR ...........................................................27 
</Link>

<Link>3-7 Bit Settings for Component ID CSR...............................................................................27 
</Link>

<Link>3-8 Bit Settings for Standard Route Configuration Destination ID Select CSR ...................27 
</Link>

<Link>3-9 Bit Settings for Standard Route Configuration Destination ID Select CSR ...................29 
</Link>

<Link>3-10 Bit Settings for Standard Route Default Port CSR .........................................................30 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P id="LinkTarget_30554">Chapter 1 Overview </P>

<P id="LinkTarget_30555">1.1 Introduction </P>

<P>This chapter provides an overview of the RapidIO Part 3: Common Transport Specification, including a description of the relationship between this specification and the other specifications of the RapidIO interconnect. </P>

<P id="LinkTarget_30556">1.2 Overview </P>

<P>The RapidIO Part 3: Common Transport Specification defines a standard transport mechanism. In doing so, it specifies the header information added to a RapidIO logical packet and the way the header information is interpreted by a switching fabric. The RapidIO interconnect defines this mechanism independent of a physical implementation. The physical features of an implementation using RapidIO are defined by the requirements of the implementation, such as I/O signaling levels, interconnect topology, physical layer protocol, and error detection. These requirements are specified in the appropriate RapidIO physical layer specification. </P>

<P>This transport specification is also independent of any RapidIO logical layer specification. </P>

<P id="LinkTarget_30557">1.3 Transport Layer Features </P>

<P>The transport layer functions of the RapidIO interconnect have been addressed by incorporating the following functional, physical, and performance features. </P>

<P id="LinkTarget_30558">1.3.1 Functional Features </P>

<P>Functional features at the transport layer include the following: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> System sizes from very small to very large are supported in the same or compatible packet formats. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Because RapidIO has only a single transport specification, compatibility among implementations is assured. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The transport specification is flexible, so that it can be adapted to future applications. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Packets are assumed, but not required, to be directed from a single source to a single destination. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30559">1.3.2 Physical Features </P>

<P>The following are physical features of the RapidIO fabric that apply at the transport layer: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> The transport definition is independent of the width of the physical interface between devices in the interconnect fabric. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> No requirement exists in RapidIO for geographical addressing; a device’s identifier does not depend on its location in the address map but can be assigned by other means. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30560">1.3.3 Performance Features </P>

<P>Performance features that apply to the transport layer include the following: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Packet headers are as small as possible to minimize the control overhead and are organized for fast, efficient assembly and disassembly. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Broadcasting and multicasting can be implemented by interpreting the transport information in the interconnect fabric. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Certain devices have bandwidth and latency requirements for proper operation. RapidIO does not preclude an implementation from imposing these constraints within the system. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30561">1.4 Contents </P>

<P>RapidIO Part 3: Common Transport Specification contains three chapters: </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>
<Link>Chapter 1, “Overview” (this chapter) provides an overview of the specification </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>
<Link>Chapter 2, “Transport Format Description,” describes the routing methods used </Link>
in RapidIO for sending packets across the systems of switches described in this chapter. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 3, “Common Transport Registers,” describes the visible register set </Link>
that allows an external processing element to determine the capabilities, configuration, and status of a processing element using this RapidIO transport layer definition. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30562">1.5 Terminology </P>

<P>Refer to the Glossary at the back of this document. </P>

<P id="LinkTarget_30563">1.6 Conventions </P>

<P>|| 	Concatenation, used to indicate that two fields are physically associated as consecutive bits </P>

<P>ACTIVE_HIGH 	Names of active high signals are shown in uppercase text with </P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P>no overbar. Active-high signals are asserted when high and not asserted when low. </P>

<P>ACTIVE_LOW 	Names of active low signals are shown in uppercase text with an overbar. Active low signals are asserted when low and not asserted when high. </P>

<P>italics 	Book titles in text are set in italics. </P>

<P>REG[FIELD] 	Abbreviations or acronyms for registers are shown in uppercase text. Specific bits, fields, or ranges appear in brackets. </P>

<P>TRANSACTION 	Transaction types are expressed in all caps. </P>

<P>operation 	Device operation types are expressed in plain text. </P>

<P>n 	A decimal value. </P>

<P>[n-m] 	Used to express a numerical range from n to m. </P>

<P>0bnn 	A binary value, the number of bits is determined by the </P>

<P>number of digits. </P>

<P>0xnn 	A hexadecimal value, the number of bits is determined by the number of digits or from the surrounding context; for example, 0xnn may be a 5, 6, 7, or 8 bit value. </P>

<P>x 	This value is a don’t care </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P id="LinkTarget_30564">Chapter 2  Transport Format Description </P>

<P id="LinkTarget_30565">2.1 Introduction </P>

<P>This chapter contains the transport format definition for the RapidIO Part 3: Common Transport Specification. Three transport fields are added to the packet formats described in the RapidIO logical specifications. The transport formats are intended to be fabric independent so the system interconnect can be anything required for a particular application; therefore all descriptions of the transport fields and their relationship with the logical packets are shown as bit streams. </P>

<P id="LinkTarget_30566">2.2 System Topology </P>

<P>RapidIO is intended to be interconnect fabric independent. This section describes several of the possible system topologies and routing methodologies allowed by the processing element models described in the Models chapters of the different Logical Specifications. </P>

<P id="LinkTarget_30567">2.2.1 Switch-Based Systems </P>

<P>
<Link>A RapidIO system can be organized around the concept of switches. Figure 2-1 </Link>
shows a small system in which five processing elements are interconnected through two switches. A logical packet sent from one processing element to another is routed through the interconnect fabric by the switches by interpreting the transport fields. Because a request usually requires a response, the transport fields must somehow indicate the return path from the requestor to the responder. </P>

<P>RapidIO Trade Association </P>

<P>Processing 
Element 
</P>

<P>ID=4 </P>

<P>Processing </P>

<P>ID=12 </P>

<P>Element </P>

<P>ID=7 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_46.jpg"/>
Figure 2-1. A Small Switch-Based System Switch Element Switch Element Processing Element Processing Element Processing Element </Figure>

<P>ID=9ID=2 </P>

<P id="LinkTarget_30568">2.2.2 Ring-Based Systems </P>

<P>
<Link>A simplification of the switch structure is a ring as shown in Figure 2-2. A ring is a </Link>
point-to-point version of a common bus; therefore, it is required to have a unique identifier for each processing element in the system. A packet put onto the ring contains the source and destination identifier in the transport fields. Each packet issued is examined by the downstream processing element. If that processing element’s identifier matches that of the destination, it removes the packet from the ring for processing. If the destination identifier does not match the packet, it is passed to the next processing element in the ring. </P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_47.jpg"/>
Figure 2-2. A Small Ring-Based System ID=12 ID=2 Processing Element Processing Element Processing Element Processing Element Processing Element </Figure>
ID=4 </P>

<P>ID=7 </P>

<P>ID=9 </P>

<P id="LinkTarget_30569">2.3 System Packet Routing </P>

<P>There are many algorithms that can be used for routing through a system. The RapidIO Part 3: Common Transport Specification requires device identifier based packet routing. Each directly addressable device in the system shall have one or more unique device identifiers. When a packet is generated, the device ID of the destination of the packet is put in the packet header. The device ID of the source of the packet is also put in the packet header for use by the destination when generating response packets. When the destination of a request packet generates a response packet, it swaps the source and destination fields from the request, making the original source the new destination and itself the new source. Packets are routed through the fabric based on the destination device ID. </P>

<P>One method of routing packets in a switch fabric using device ID information incorporates routing tables. Each switch in the interconnect fabric contains a table that tells the switch how to route every destination ID from an input port to the proper output port. The simplest form of this method allows only a single path from every processing element to every other processing element. More complex forms of this method may allow adaptive routing for redundancy and congestion relief. However, the actual method by which packets are routed between the input of a switch and the output of a switch is implementation dependent. </P>

<P id="LinkTarget_30570">2.4 Field Alignment and Definition </P>

<P>The RapidIO Part 3: Common Transport Specification adds a transport type (tt) field to the logical specification packet that allows four different transport packet types to be specified. The tt field indicates which type of additional transport fields are added </P>

<P>RapidIO Trade Association </P>

<P>to the packet. </P>

<P>The three fields (tt, destinationID, and sourceID) added to the logical packets allow for two different sizes of the device ID fields, a large (16-bit), and a small (8-bit), as 
<Link>shown in Table 2-1. The two sizes of device ID fields allow two different system </Link>
scalability points to optimize packet header overhead, and only affix additional transport field overhead if the additional addressing is required. The small device ID fields allow a maximum of 256 devices to be attached to the fabric. The large device ID fields allow systems with up to 65,536 devices. </P>

<Table>
<Caption>
<P>Table 2-1. tt Field Definition </P>
</Caption>

<TR>
<TD>tt </TD>

<TD>Definition </TD>
</TR>

<TR>
<TD>0b00 </TD>

<TD>8-bit deviceID fields </TD>
</TR>

<TR>
<TD>0b01 </TD>

<TD>16-bit deviceID fields </TD>
</TR>

<TR>
<TD>0b10 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b11 </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>
<Link>Figure 2-3 shows the transport header definition bit stream. The shaded fields are the </Link>
bits associated with the logical packet definition that are related to the transport bits. Specifically, the field labeled “Logical ftype” is the format type field defined in the logical specifications. This field comprises the first four bits of the logical packet. The second logical field shown (“Remainder of logical packet”) is the remainder of the logical packet of a size determined by the logical specifications, not including the logical ftype field which has already been included in the combined bit stream. The unshaded fields (tt=0b00 or tt=0b01 and destinationID and sourceID fields) are the transport fields added to the logical packet by the common transport specification. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_48.jpg"/>
sourceID tt=0m Logical ftype destinationID </Figure>

<P>2 4 8 or 16 8 or 16 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_49.jpg"/>
</Figure>

<P>Remainder of logical packet </P>

<P>n </P>

<P>Figure 2-3. Destination-Source Transport Bit Stream </P>

<P id="LinkTarget_30571">2.5 Routing Maintenance Packets </P>

<P>Routing maintenance packets in a switch-based network may be difficult because a switch processing element may not have its own device ID. An alternative method of addressing for maintenance packets for these devices uses an additional hop_count field in the packet to specify the number of switches (or hops) into the network from the issuing processing element that is being addressed. Whenever a switch processing element that does not have as associated device ID receives a maintenance packet it examines the hop_count field. If the received hop_count is </P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P>zero, the access is for that switch. If the hop_count is not zero, it is decremented and the packet is sent out of the switch according to the destinationID field. This method allows easy access to any intervening switches in the path between two addressable processing elements. However, since maintenance response packets are always targeted at an end point, the hop_count field shall always be assigned a value of 0xFF by the source of the packets to prevent them from being inadvertently accepted 
<Link>by an intervening device. Figure 2-4 shows the transport layer fields added to a </Link>
maintenance logical packet. Maintenance logical packets can be found in the RapidIO Part 1: Input/Output Logical Specification. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_50.jpg"/>
sourceID tt=0m ftype=0b1000 destinationID </Figure>

<P>2 4 8 or 16 8 or 16 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_51.jpg"/>
Logical transaction, dsize/status, TID fields 16 hop_count 8 Remainder of logical packet </Figure>

<P>n </P>

<P>Figure 2-4. Maintenance Packet Transport Bit Stream </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P id="LinkTarget_30572">Chapter 3  Common Transport Registers </P>

<P id="LinkTarget_30573">3.1 Introduction </P>

<P>This chapter describes the visible register set that allows an external processing element to determine the capabilities, configuration, and status of a processing element using this transport layer definition. This chapter only describes registers or register bits defined by this specification. Refer to the other RapidIO logical, transport, and physical specifications of interest to determine a complete list of registers and bit definitions. All registers are 32-bits and aligned to a 32-bit boundary. </P>

<P id="LinkTarget_30574">3.2 Register Summary </P>

<P>
<Link>Table 3-1 shows the register address map for this RapidIO specification. These </Link>
capability registers (CARs) and command and status registers (CSRs) can be accessed using RapidIO Part 1: Input/Output Logical Specification maintenance operations. Any register offsets not defined are considered reserved for this specification unless otherwise stated. Other registers required for a processing element are defined in other applicable RapidIO specifications and by the requirements of the specific device and are beyond the scope of this specification. Read and write accesses to reserved register offsets shall terminate normally and not cause an error condition in the target device. Writes to CAR (read-only) space shall terminate normally and not cause an error condition in the target device. </P>

<P>Register bits defined as reserved are considered reserved for this specification only. Bits that are reserved in this specification may be defined in another RapidIO specification. </P>

<Table>
<Caption>
<P>Table 3-1. Common Transport Register Map </P>
</Caption>

<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x0-C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x10 </TD>

<TD>Processing Element Features CAR </TD>
</TR>

<TR>
<TD>0x14–30 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x34 </TD>

<TD>Switch Route Table Destination ID Limit CAR </TD>
</TR>

<TR>
<TD>0x38-5C </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x60 </TD>

<TD>Base Device ID CSR </TD>
</TR>

<TR>
<TD>0x64 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x68 </TD>

<TD>Host Base Device ID Lock CSR </TD>
</TR>

<TR>
<TD>0x6C </TD>

<TD>Component Tag CSR </TD>
</TR>

<TR>
<TD>0x70 </TD>

<TD>Standard Route Configuration Destination ID Select CSR </TD>
</TR>

<TR>
<TD>0x74 </TD>

<TD>Standard Route Configuration Port Select CSR </TD>
</TR>

<TR>
<TD>0x78 </TD>

<TD>Standard Route Default Port CSR </TD>
</TR>

<TR>
<TD>0x7C–FC </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x100– FFFC </TD>

<TD>Extended Features Space </TD>
</TR>

<TR>
<TD>0x10000– FFFFFC </TD>

<TD>Implementation-defined Space </TD>
</TR>

<Caption>
<P>
<Link>Table 3-2 describes the required behavior for accesses to reserved register bits and </Link>
reserved registers for the RapidIO register space, </P>
</Caption>
</Table>

<P id="LinkTarget_30575">3.3 Reserved Register and Bit Behavior </P>

<Table>
<Caption>
<P>Table 3-2. Configuration Space Reserved Access Behavior </P>
</Caption>

<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x0–3C </TH>

<TD>Capability Register Space (CAR Space - this space is read-only) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value1 </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored</TD>
</TR>

<TR>
<TD> Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>
</Table>

<Table>
<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x40–FC </TH>

<TD>Command and Status Register Space (CSR Space) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value2 </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write - implementation-defined </TD>
</TR>

<TR>
<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x100– FFFC </TH>

<TD>Extended Features Space </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write - implementation-defined </TD>
</TR>

<TR>
<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x10000– FFFFFC </TH>

<TD>Implementation-defined Space </TD>

<TD>Reserved bit and register </TD>

<TD>All behavior implementation-defined </TD>
</TR>
</Table>

<P>1Do not depend on reserved bits being a particular value; use appropriate masks to extract defined bits from the read value. </P>

<P>2All register writes shall be in the form: read the register to obtain the values of all reserved bits, merge in the desired values for defined bits to be modified, and write the register, thus preserving the value of all reserved bits. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30576">3.4 	Capability Registers (CARs) </P>

<P>Every processing element shall contain a set of registers that allows an external processing element to determine its capabilities using the I/O logical maintenance read operation. All registers are 32 bits wide and are organized and accessed in 32-bit (4 byte) quantities, although some processing elements may optionally allow 
<Link>larger accesses. CARs are read-only. Refer to Table 3-2 for the required behavior for </Link>
accesses to reserved registers and register bits. </P>

<P>CARs are big-endian with bit 0 the most significant bit. </P>

<P id="LinkTarget_30577">3.4.1 	Processing Element Features CAR 
(Configuration Space Offset 0x10) 
</P>

<P>The processing element features CAR identifies the major functionality provided by 
<Link>the processing element. The bit settings are shown in Table 3-3. </Link>
</P>

<Table>
<Caption>
<P>Table 3-3. Bit Settings for Processing Element Features CAR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–21 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>22 </TD>

<TD>Extended route table configuration support </TD>

<TD>0b0 - Switch PE does not support the extended route table configuration mechanism 0b1 - Switch PE supports the extended route table configuration mechanism (can only be set if bit 23 is set) </TD>
</TR>

<TR>
<TD>23 </TD>

<TD>Standard route table configuration support </TD>

<TD>0b0 - Switch PE does not support the standard route table configuration mechanism 0b1 - Switch PE supports the standard route table configuration mechanism </TD>
</TR>

<TR>
<TD>22–26 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>27 </TD>

<TD>Common transport large system support </TD>

<TD>0b0 - PE does not support common transport large systems 0b1 - PE supports common transport large systems </TD>
</TR>

<TR>
<TD>28–31 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P id="LinkTarget_30578">3.4.2 Switch Route Table Destination ID Limit CAR (Configuration Space Offset 0x34) </P>

<P>The Switch Route Table Destination ID Limit CAR specifies the maximum destination ID value that can be programmed with the standard route table configuration mechanism, and thereby indirectly defining the size of the route table. A route table access or extended route table access attempt to destination IDs greater than that specified in this register will have undefined results. This register is required if bit 23 of the Processing Element Features CAR is set. The bit settings are 
<Link>shown in Table 3-4. </Link>
</P>

<Table>
<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–15 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>16–31 </TD>

<TD>Max_destID </TD>

<TD>Maximum configurable destination ID 0x00 - 1 destination ID 0x01 - 2 destinations IDs 0x02 - 3 destination IDs ... 0xFF - 65536 destination IDs </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30579">3.5 	Command and Status Registers (CSRs) </P>

<P>A processing element shall contain a set of registers that allows an external processing element to control and determine status of its internal hardware. All registers are 32 bits wide and are organized and accessed in the same way as the CARs. Refer to 
<Link>Table 3-2 for the required behavior for accesses to reserved registers </Link>
and register bits. </P>

<P id="LinkTarget_30580">3.5.1 	Base Device ID CSR 
(Configuration Space Offset 0x60) 
</P>

<P>The base device ID CSR contains the base device ID values for the processing element. A device may have multiple device ID values, but these are not defined in 
<Link>a standard CSR. The bit settings are shown in Table 3-5. </Link>
</P>

<Table>
<Caption>
<P>Table 3-5. Bit Settings for Base Device ID CSR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-7 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>8-15 </TD>

<TD>Base_deviceID </TD>

<TD>see footnote1 </TD>

<TD>This is the base ID of the device in a small common transport system (end point devices only) </TD>
</TR>

<TR>
<TD>16–31 </TD>

<TD>Large_base_deviceID </TD>

<TD>see footnote2 </TD>

<TD>This is the base ID of the device in a large common transport system (only valid for end point device and if bit 27 of the Processing Element Features CAR is set) </TD>
</TR>
</Table>

<P>1The Base_deviceID reset value is implementation dependent 
2The Large_base_deviceID reset value is implementation dependent 
</P>

<P id="LinkTarget_30581">3.5.2 	Host Base Device ID Lock CSR (Configuration Space Offset 0x68) </P>

<P>The host base device ID lock CSR contains the base device ID value for the processing element in the system that is responsible for initializing this processing element. The Host_base_deviceID field is a write-once/reset-able field which provides a lock function. Once the Host_base_deviceID field is written, all subsequent writes to the field are ignored, except in the case that the value written matches the value contained in the field. In this case, the register is re-initialized to 0xFFFF. After writing the Host_base_deviceID field a processing element must then read the Host Base Device ID Lock CSR to verify that it owns the lock before attempting to initialize this processing element. The bit settings are shown in 
<Link>Table 3-6. </Link>
</P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 Table 3-6. Bit Settings for Host Base Device ID Lock CSR </P>

<Table>
<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-15 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>16–31 </TD>

<TD>Host_base_deviceID </TD>

<TD>0xFFFF </TD>

<TD>This is the base device ID for the PE that is initializing this PE. </TD>
</TR>
</Table>

<P id="LinkTarget_30582">3.5.3 	Component Tag CSR (Configuration Space Offset 0x6C) </P>

<P>The component tag CSR contains a component tag value for the processing element and can be assigned by software when the device is initialized. It is especially useful for labeling and identifying devices that are not end points and do not have device 
<Link>ID registers. The bit settings are shown in Table 3-7. </Link>
</P>

<Table>
<Caption>
<P>Table 3-7. Bit Settings for Component ID CSR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–31 </TD>

<TD>component_tag </TD>

<TD>All 0s </TD>

<TD>This is a component tag for the PE. </TD>
</TR>
</Table>

<P id="LinkTarget_30583">3.5.4 	Standard Route Configuration Destination ID Select CSR (Configuration Space Offset 0x70) </P>

<P>The Standard Route Configuration Destination ID Select CSR specifies the destination ID entry in the switch routing table to access when the Standard Route Configuration Port Select CSR is read or written. </P>

<P>The Ext_config_en bit controls whether the extended route table configuration mechanism is enabled. If the extended route table configuration mechanism is enabled, the specified destination ID and the next three sequential destination IDs are written or read when the Standard Route Configuration Port Select CSR accessed. Extended accesses that increment past the maximum specifiable destination ID (for example, starting an extended access at device ID 0xFF in a small transport system), has undefined results. </P>

<P>This register is required if bit 23 of the Processing Element Features CAR is set. The 
<Link>bit settings are shown in Table 3-8. </Link>
</P>

<Table>
<Caption>
<P>Table 3-8. Bit Settings for Standard Route Configuration Destination ID Select CSR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Ext_config_en </TD>

<TD>0b0 </TD>

<TD>Extended Configuration Enable 0b0 - Extended configuration support is disabled 0b1 - Extended configuration support is enabled (only valid if bit 22 of the Processing Element Features CAR is set) </TD>
</TR>

<TR>
<TD>1-15 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>16-23 </TD>

<TD>Config_destID_msb </TD>

<TD>0x00 </TD>

<TD>Configuration destination ID most significant byte (only valid if bit 27 of the Processing Element Features CAR is set and the processing element is configured to operate in large transport mode) </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>Config_destID </TD>

<TD>0x00 </TD>

<TD>Configuration destination ID </TD>
</TR>
</Table>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P id="LinkTarget_30584">3.5.5 	Standard Route Configuration Port Select CSR (Configuration Space Offset 0x74) </P>

<P>When written, the Standard Route Configuration Port Select CSR updates the switch output port configuration for packets with the destination ID selected by the Standard Route Configuration Destination ID Select CSR. When read, the Standard Route Configuration Port Select CSR returns the switch output port configuration for packets with the destination ID selected by the Standard Route Configuration Destination ID Select CSR. </P>

<P>If the extended route table configuration mechanism is enabled, when the Standard Route Configuration Port Select register is written the following route table configurations are carried out: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> destination ID Config_destID is routed to output port Config_output_port </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> destination ID Config_destID+1 is routed to output port Config_output_port1 </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> destination ID Config_destID+2 is routed to output port Config_output_port2 </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> destination ID Config_destID+3 is routed to output port Config_output_port3 </LI_Title>
</LI>
</L>

<P>For reads of the Standard Route Configuration Port Select CSR, the configuration information is returned in the corresponding fashion. </P>

<P>After complete system initialization the switch output port route configuration information read may not be consistant with previously read values due to the capabilities and features of the particular switch. This register is required if bit 23 of 
<Link>the Processing Element Features CAR is set. The bit settings are shown in Table 3-9. </Link>
</P>

<Table>
<Caption>
<P>Table 3-9. Bit Settings for Standard Route Configuration Destination ID Select CSR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-7 </TD>

<TD>Config_output_port3 </TD>

<TD>0x00 </TD>

<TD>Configuration output port3 - This field is reserved if extended route table mechanism is not enabled </TD>
</TR>

<TR>
<TD>8-15 </TD>

<TD>Config_output_port2 </TD>

<TD>0x00 </TD>

<TD>Configuration output port2 - This field is reserved if extended route table mechanism is not enabled </TD>
</TR>

<TR>
<TD>16-23 </TD>

<TD>Config_output_port1 </TD>

<TD>0x00 </TD>

<TD>Configuration output port1 - This field is reserved if extended route table mechanism is not enabled </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>Config_output_port </TD>

<TD>see footnote1 </TD>

<TD>Configuration output port </TD>
</TR>
</Table>

<P>1The Config_output_portn reset values are implementation dependent </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30585">3.5.6 	Standard Route Default Port CSR 
(Configuration Space Offset 0x78) 
</P>

<P>The Standard Route Default Port CSR specifies the port to which packets with destinations IDs that are greater than that specified in the Switch Route Table Destination ID Limit CAR are routed. This register is required if bit 23 of the 
<Link>Processing Element Features CAR is set. The bit settings are shown in Table 3-10. </Link>
</P>

<Table>
<Caption>
<P>Table 3-10. Bit Settings for Standard Route Default Port CSR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-23 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>24–31 </TD>

<TD>Default_output_port </TD>

<TD>0x00 </TD>

<TD>Default output port </TD>
</TR>
</Table>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P id="LinkTarget_30586">Glossary of Terms and Abbreviations 
</P>

<Table>
<TR>
<TH>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </TH>
</TR>

<TR>
<TH>B </TH>

<TD>Big-endian. A byte-ordering method in memory where the address n of a word corresponds to the most significant byte. In an addressed memory word, the bytes are ordered (left to right) 0, 1, 2, 3, with 0 being the most significant byte. Broadcast. The concept of sending a packet to all processing elements in a system. </TD>
</TR>

<TR>
<TH>C </TH>

<TD>Capability registers (CARs). A set of read-only registers that allows a processing element to determine another processing element’s capabilities. Command and status registers (CSRs). A set of registers that allows a processing element to control and determine the status of another processing element’s internal hardware. </TD>
</TR>

<TR>
<TH>D </TH>

<TD>Destination. The termination point of a packet on the RapidIO interconnect, also referred to as a target. Device. A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a processing element. Device ID. The identifier of an end point processing element connected to the RapidIO interconnect. </TD>
</TR>

<TR>
<TH>E </TH>

<TD>End point. A processing element which is the source or destination of transactions through a RapidIO fabric. End point device. A processing element which contains end point functionality. External processing element. A processing element other than the processing element in question. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>Field or Field name. A sub-unit of a register, where bits in the register are </P>

<P>F </P>

<P>named and defined. </P>

<Table>
<TR>
<TH>H </TH>

<TD>Host. A processing element responsible for exploring and initializing all or a portion of a RapidIO based system. </TD>
</TR>

<TR>
<TH>I </TH>

<TD>Initiator. The origin of a packet on the RapidIO interconnect, also referred to as a source. I/O. Input-output. </TD>
</TR>

<TR>
<TH>M </TH>

<TD>MSB. Most significant byte. Multicast. The concept of sending a packet to more than one processing elements in a system. </TD>
</TR>

<TR>
<TH>O </TH>

<TD>Operation. A set of transactions between end point devices in a RapidIO system (requests and associated responses) such as a read or a write. </TD>
</TR>
</Table>

<P>P 
</P>

<P>Packet. 	A set of information transmitted between devices in a RapidIO system. </P>

<P>Processing Element (PE). A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a device. </P>

<P>S 
</P>

<P>Source. The origin of a packet on the RapidIO interconnect, also referred to as an initiator. </P>

<P>Switch. A multiple port processing element that directs a packet received on one of its input ports to one of its output ports. </P>

<P>T 
</P>

<P>Target. The termination point of a packet on the RapidIO interconnect, also referred to as a destination. </P>

<P>Transaction. A specific request or response packet transmitted between end point devices in a RapidIO system. </P>

<P>RapidIO Part 3: Common Transport Specification Rev. 1.3 </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P id="LinkTarget_30587">RapidIO™ Interconnect SpecificationPart 5: Globally Shared MemoryLogical Specification </P>

<P>Rev. 1.3, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_0.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>
</TR>

<TR>
<TH>1.1 </TH>

<TH>Incorporate comment review changes </TH>

<TD>03/08/2001 </TD>
</TR>

<TR>
<TH>1.2 </TH>

<TH>Technical changes: incorporate Rev. 1.1 errata rev. 1.1.1, errata 3 </TH>

<TD>06/26/2002 </TD>
</TR>

<TR>
<TH>1.3 </TH>

<TH>Technical changes: incorporate Rev 1.2 errata 1 as applicable Converted to ISO-friendly templates </TH>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TH>1.3 </TH>

<TH>Removed confidentiality markings for public release </TH>

<TD>06/07/2005 </TD>
</TR>
</Table>

<P>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE 
ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND 
CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO 
WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.  USER AGREES TO 
ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE 
GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR 
RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER 
SUCH USE OF THE SPECIFICATION. 
</P>

<P>DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, 
INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST 
PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION 
WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE 
RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. 
</P>

<P>Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: 
RapidIO Trade Association 
Suite 325, 3925 W. Braker Lane 
Austin, TX 78759 
512-305-0070 Tel. 
512-305-0009 FAX. 
</P>

<P>RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their 
respective owners. 
</P>

<P>RapidIO Trade Association RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>Table of Contents 
</P>

<P>
<Link>Chapter 1 Overview </Link>
</P>

<P>
<Link>1.1 Introduction........................................................................................................... 11 
</Link>
</P>

<P>
<Link>1.2 Overview............................................................................................................... 11 
</Link>
</P>

<P>
<Link>1.2.1 Memory System ................................................................................................ 12 
</Link>
</P>

<P>
<Link>1.3 Features of the Globally Shared Memory Specification....................................... 13 
</Link>
</P>

<P>
<Link>1.3.1 Functional Features ........................................................................................... 13 
</Link>
</P>

<P>
<Link>1.3.2 Physical Features .............................................................................................. 14 
</Link>
</P>

<P>
<Link>1.3.3 Performance Features ....................................................................................... 14 
</Link>
</P>

<P>
<Link>1.4 Contents ................................................................................................................ 14 
</Link>
</P>

<P>
<Link>1.5 Terminology.......................................................................................................... 15 
</Link>
</P>

<P>
<Link>1.6 Conventions .......................................................................................................... 15 
</Link>
</P>

<P>
<Link>Chapter 2 System Models </Link>
</P>

<P>
<Link>2.1 Introduction........................................................................................................... 17 
</Link>
</P>

<P>
<Link>2.2 Processing Element Models .................................................................................. 17 
</Link>
</P>

<P>
<Link>2.2.1 Processor-Memory Processing Element Model................................................ 18 
</Link>
</P>

<P>
<Link>2.2.2 Integrated Processor-Memory Processing Element Model .............................. 19 
</Link>
</P>

<P>
<Link>2.2.3 Memory-Only Processing Element Model ....................................................... 19 
</Link>
</P>

<P>
<Link>2.2.4 Processor-Only Processing Element ................................................................. 20 
</Link>
</P>

<P>
<Link>2.2.5 I/O Processing Element .................................................................................... 20 
</Link>
</P>

<P>
<Link>2.2.6 Switch Processing Element............................................................................... 20 
</Link>
</P>

<P>
<Link>2.3 Programming Models ........................................................................................... 21 
</Link>
</P>

<P>
<Link>2.3.1 Globally Shared Memory System Model ......................................................... 21 
</Link>
</P>

<P>
<Link>2.3.1.1 Software-Managed Cache Coherence Programming Model ........................ 23 
</Link>
</P>

<P>
<Link>2.4 System Issues ........................................................................................................ 23 
</Link>
</P>

<P>
<Link>2.4.1 Operation Ordering ........................................................................................... 23 
</Link>
</P>

<P>
<Link>2.4.2 Transaction Delivery......................................................................................... 23 
</Link>
</P>

<P>
<Link>2.4.3 Deadlock Considerations .................................................................................. 24 
</Link>
</P>

<P>
<Link>Chapter 3 Operation Descriptions </Link>
</P>

<P>
<Link>3.1 Introduction........................................................................................................... 25 
</Link>
</P>

<P>
<Link>3.2 GSM Operations Cross Reference ........................................................................ 26 
</Link>
</P>

<P>
<Link>3.3 GSM Operations ................................................................................................... 27 
</Link>
</P>

<P>
<Link>3.3.1 Read Operations................................................................................................ 28 
</Link>
</P>

<P>
<Link>3.3.2 Instruction Read Operations ............................................................................. 29 
</Link>
</P>

<P>
<Link>3.3.3 Read-for-Ownership Operations....................................................................... 31 
</Link>
</P>

<P>
<Link>3.3.4 Data Cache Invalidate Operations .................................................................... 33 
</Link>
</P>

<P>
<Link>3.3.5 Castout Operations............................................................................................ 34 
</Link>
</P>

<P>
<Link>3.3.6 TLB Invalidate-Entry Operations ..................................................................... 35 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>3.3.7 TLB Invalidate-Entry Synchronization Operations .......................................... 35 
</Link>
</P>

<P>
<Link>3.3.8 Instruction Cache Invalidate Operations........................................................... 35 
</Link>
</P>

<P>
<Link>3.3.9 Data Cache Flush Operations ........................................................................... 36 
</Link>
</P>

<P>
<Link>3.3.10 I/O Read Operations ......................................................................................... 38 
</Link>
</P>

<P>
<Link>3.4 Endian, Byte Ordering, and Alignment ................................................................ 40 
</Link>
</P>

<P>
<Link>Chapter 4 Packet Format Descriptions </Link>
</P>

<P>
<Link>4.1 Introduction........................................................................................................... 43 
</Link>
</P>

<P>
<Link>4.2 Request Packet Formats ........................................................................................ 43 
</Link>
</P>

<P>
<Link>4.2.1 Addressing and Alignment ............................................................................... 44 
</Link>
</P>

<P>
<Link>4.2.2 Data Payloads ................................................................................................... 44 
</Link>
</P>

<P>
<Link>4.2.3 Field Definitions for All Request Packet Formats ............................................ 47 
</Link>
</P>

<P>
<Link>4.2.4 Type 0 Packet Format (Implementation-Defined) ............................................ 50 
</Link>
</P>

<P>
<Link>4.2.5 Type 1 Packet Format (Intervention-Request Class) ........................................ 50 
</Link>
</P>

<P>
<Link>4.2.6 Type 2 Packet Format (Request Class) ............................................................. 51 
</Link>
</P>

<P>
<Link>4.2.7 Type 3–4 Packet Formats (Reserved) ............................................................... 52 
</Link>
</P>

<P>
<Link>4.2.8 Type 5 Packet Format (Write Class)................................................................. 52 
</Link>
</P>

<P>
<Link>4.2.9 Type 6–11 Packet Formats (Reserved) ............................................................. 53 
</Link>
</P>

<P>
<Link>4.3 Response Packet Formats ..................................................................................... 53 
</Link>
</P>

<P>
<Link>4.3.1 Field Definitions for All Response Packet Formats ......................................... 53 
</Link>
</P>

<P>
<Link>4.3.2 Type 12 Packet Format (Reserved) .................................................................. 54 
</Link>
</P>

<P>
<Link>4.3.3 Type 13 Packet Format (Response Class) ........................................................ 54 
</Link>
</P>

<P>
<Link>4.3.4 Type 14 Packet Format (Reserved) .................................................................. 55 
</Link>
</P>

<P>
<Link>4.3.5 Type 15 Packet Format (Implementation-Defined) .......................................... 55 
</Link>
</P>

<P>
<Link>Chapter 5 Globally Shared Memory Registers </Link>
</P>

<P>
<Link>5.1 Introduction........................................................................................................... 57 
</Link>
</P>

<P>
<Link>5.2 Register Summary................................................................................................. 57 
</Link>
</P>

<P>
<Link>5.3 Reserved Register and Bit Behavior ..................................................................... 58 
</Link>
</P>

<P>
<Link>5.4 Capability Registers (CARs) ................................................................................ 60 
</Link>
</P>

<P>
<Link>5.4.1 Source Operations CAR (Configuration Space Offset 0x18) ........................... 60 
</Link>
</P>

<P>
<Link>5.4.2 Destination Operations CAR (Configuration Space Offset 0x1C) ................... 61 
</Link>
</P>

<P>
<Link>5.5 Command and Status Registers (CSRs)................................................................ 62 
</Link>
</P>

<P>
<Link>Chapter 6 Communication Protocols </Link>
</P>

<P>
<Link>6.1 Introduction........................................................................................................... 63 
</Link>
</P>

<P>
<Link>6.2 Definitions ............................................................................................................ 63 
</Link>
</P>

<P>
<Link>6.2.1 General Definitions ........................................................................................... 64 
</Link>
</P>

<P>
<Link>6.2.2 Request and Response Definitions ................................................................... 66 
</Link>
</P>

<P>
<Link>6.2.2.1 System Request............................................................................................. 66 
</Link>
</P>

<P>
<Link>6.2.2.2 Local Request ............................................................................................... 66 
</Link>
</P>

<P>
<Link>6.2.2.3 System Response .......................................................................................... 67 
</Link>
</P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>Table of Contents 
</P>

<P>
<Link>6.2.2.4 Local Response ............................................................................................. 67 
</Link>
</P>

<P>
<Link>6.3 Operation to Protocol Cross Reference ................................................................ 67 
</Link>
</P>

<P>
<Link>6.4 Read Operations.................................................................................................... 68 
</Link>
</P>

<P>
<Link>6.4.1 Internal Request State Machine ........................................................................ 68 
</Link>
</P>

<P>
<Link>6.4.2 Response State Machine ................................................................................... 68 
</Link>
</P>

<P>
<Link>6.4.3 External Request State Machine ....................................................................... 70 
</Link>
</P>

<P>
<Link>6.5 Instruction Read Operations ................................................................................. 72 
</Link>
</P>

<P>
<Link>6.5.1 Internal Request State Machine ........................................................................ 72 
</Link>
</P>

<P>
<Link>6.5.2 Response State Machine ................................................................................... 72 
</Link>
</P>

<P>
<Link>6.5.3 External Request State Machine ....................................................................... 73 
</Link>
</P>

<P>
<Link>6.6 Read for Ownership Operations ........................................................................... 75 
</Link>
</P>

<P>
<Link>6.6.1 Internal Request State Machine ........................................................................ 75 
</Link>
</P>

<P>
<Link>6.6.2 Response State Machine ................................................................................... 75 
</Link>
</P>

<P>
<Link>6.6.3 External Request State Machine ....................................................................... 78 
</Link>
</P>

<P>
<Link>6.7 Data Cache and Instruction Cache Invalidate Operations .................................... 79 
</Link>
</P>

<P>
<Link>6.7.1 Internal Request State Machine ........................................................................ 79 
</Link>
</P>

<P>
<Link>6.7.2 Response State Machine ................................................................................... 79 
</Link>
</P>

<P>
<Link>6.7.3 External Request State Machine ....................................................................... 80 
</Link>
</P>

<P>
<Link>6.8 Castout Operations................................................................................................ 82 
</Link>
</P>

<P>
<Link>6.8.1 Internal Request State Machine ........................................................................ 82 
</Link>
</P>

<P>
<Link>6.8.2 Response State Machine ................................................................................... 82 
</Link>
</P>

<P>
<Link>6.8.3 External Request State Machine ....................................................................... 82 
</Link>
</P>

<P>
<Link>6.9 TLB Invalidate Entry, TLB Invalidate Entry Synchronize Operations ................ 83 
</Link>
</P>

<P>
<Link>6.9.1 Internal Request State Machine ........................................................................ 83 
</Link>
</P>

<P>
<Link>6.9.2 Response State Machine ................................................................................... 83 
</Link>
</P>

<P>
<Link>6.9.3 External Request State Machine ....................................................................... 83 
</Link>
</P>

<P>
<Link>6.10 Data Cache Flush Operations ............................................................................... 84 
</Link>
</P>

<P>
<Link>6.10.1 Internal Request State Machine ........................................................................ 84 
</Link>
</P>

<P>
<Link>6.10.2 Response State Machine ................................................................................... 84 
</Link>
</P>

<P>
<Link>6.10.3 External Request State Machine ....................................................................... 86 
</Link>
</P>

<P>
<Link>6.11 I/O Read Operations ............................................................................................. 88 
</Link>
</P>

<P>
<Link>6.11.1 Internal Request State Machine ........................................................................ 88 
</Link>
</P>

<P>
<Link>6.11.2 Response State Machine ................................................................................... 88 
</Link>
</P>

<P>
<Link>6.11.3 External Request State Machine ....................................................................... 89 
</Link>
</P>

<P>
<Link>Chapter 7 Address Collision Resolution Tables </Link>
</P>

<P>
<Link>7.1 Introduction........................................................................................................... 91 
</Link>
</P>

<P>
<Link>7.2 Resolving an Outstanding READ_HOME Transaction ....................................... 92 
</Link>
</P>

<P>
<Link>7.3 Resolving an Outstanding IREAD_HOME Transaction ...................................... 93 
</Link>
</P>

<P>
<Link>7.4 Resolving an Outstanding READ_OWNER Transaction .................................... 94 
</Link>
</P>

<P>
<Link>7.5 Resolving an Outstanding READ_TO_OWN_HOME Transaction .................... 95 
</Link>
</P>

<P>
<Link>7.6 Resolving an Outstanding READ_TO_OWN_OWNER Transaction.................. 97 
</Link>
</P>

<P>
<Link>7.7 Resolving an Outstanding DKILL_HOME Transaction ...................................... 98 
</Link>
</P>

<P>
<Link>7.8 Resolving an Outstanding DKILL_SHARER Transaction ................................ 100 
</Link>
</P>

<P>
<Link>7.9 Resolving an Outstanding IKILL_HOME Transaction ...................................... 101 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>7.10 Resolving an Outstanding IKILL_SHARER Transaction .................................. 102 
</Link>
</P>

<P>
<Link>7.11 Resolving an Outstanding CASTOUT Transaction............................................ 103 
</Link>
</P>

<P>
<Link>7.12 Resolving an Outstanding TLBIE or TLBSYNC Transaction ........................... 104 
</Link>
</P>

<P>
<Link>7.13 Resolving an Outstanding FLUSH Transaction ................................................. 105 
</Link>
</P>

<P>
<Link>7.14 Resolving an Outstanding IO_READ_HOME Transaction ............................... 107 
</Link>
</P>

<P>7.15 
<Link>Resolving an Outstanding IO_READ_OWNER Transaction ............................ 109 
</Link>
</P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>List of Figures 
</P>

<P>
<Link>1-1 A Snoopy Bus-Based System .........................................................................................12 
</Link>

<Link>1-2 A Distributed Memory System .......................................................................................13 
</Link>

<Link>2-1 A Possible RapidIO-Based Computing System..............................................................17 
</Link>

<Link>2-2 Processor-Memory Processing Element Example ..........................................................18 
</Link>

<Link>2-3 Integrated Processor-Memory Processing Element Example.........................................19 
</Link>

<Link>2-4 Memory-Only Processing Element Example .................................................................19 
</Link>

<Link>2-5 Processor-Only Processing Element Example................................................................20 
</Link>

<Link>2-6 Switch Processing Element Example .............................................................................21 
</Link>

<Link>3-1 Read Operation to Remote Shared Coherence Granule..................................................28 
</Link>

<Link>3-2 Read Operation to Remote Modified Coherence Granule ..............................................28 
</Link>

<Link>3-3 Read Operation to Local Modified Coherence Granule .................................................29 
</Link>

<Link>3-4 Instruction Read Operation to Remote Shared Coherence Granule ...............................30 
</Link>

<Link>3-5 Instruction Read Operation to Remote Modified Coherence Granule ...........................30 
</Link>

<Link>3-6 Instruction Read Operation to Local Modified Coherence Granule ...............................30 
</Link>

<Link>3-7 Instruction Read Operation Paradox Case ......................................................................31 
</Link>

<Link>3-8 Read-for-Ownership Operation to Remote Shared Coherence Granule .........................31 
</Link>

<Link>3-9 Read-for-Ownership Operation to Remote Modified Coherence Granule .....................32 
</Link>

<Link>3-10 Read-for-Ownership Operation to Local Shared Coherence Granule ............................32 
</Link>

<Link>3-11 Read-for-Ownership Operation to Local Modified Coherence Granule ........................32 
</Link>

<Link>3-12 Data Cache Invalidate Operation to Remote Shared Coherence Granule ......................33 
</Link>

<Link>3-13 Data Cache Invalidate Operation to Local Shared Coherence Granule..........................34 
</Link>

<Link>3-14 Castout Operation on Remote Modified Coherence Granule .........................................34 
</Link>

<Link>3-15 TLB Invalidate-Entry Operation.....................................................................................35 
</Link>

<Link>3-16 TLB Invalidate-Entry Synchronization Operation .........................................................35 
</Link>

<Link>3-17 Instruction Cache Invalidate Operation to Remote Sharable Coherence Granule..........36 
</Link>

<Link>3-18 Instruction Cache Invalidate Operation to Local Sharable Coherence Granule .............36 
</Link>

<Link>3-19 Flush Operation to Remote Shared Coherence Granule .................................................37 
</Link>

<Link>3-20 Flush Operation to Remote Modified Coherence Granule .............................................38 
</Link>

<Link>3-21 Flush Operation to Local Shared Coherence Granule ....................................................38 
</Link>

<Link>3-22 Flush Operation to Local Modified Coherence Granule ................................................38 
</Link>

<Link>3-23 I/O Read Operation to Remote Shared Coherence Granule ...........................................39 
</Link>

<Link>3-24 I/O Read Operation to Remote Modified Coherence Granule .......................................39 
</Link>

<Link>3-25 I/O Read Operation to Local Modified Coherence Granule ...........................................39 
</Link>

<Link>3-26 Byte Alignment Example................................................................................................40 
</Link>

<Link>3-27 Half-Word Alignment Example......................................................................................40 
</Link>

<Link>3-28 Word Alignment Example ..............................................................................................40 
</Link>

<Link>3-29 Data Alignment Example................................................................................................41 
</Link>

<Link>4-1 Type 1 Packet Bit Stream Format ...................................................................................51 
</Link>

<Link>4-2 Type 2 Packet Bit Stream Format ...................................................................................52 
</Link>

<Link>4-3 Type 5 Packet Bit Stream Format ...................................................................................53 
</Link>

<Link>4-4 Type 13 Packet Bit Stream Format .................................................................................55 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>Blank page </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>List of Tables 
</P>

<P>
<Link>2-1 RapidIO Memory Directory Definition ..........................................................................22 
</Link>

<Link>3-1 GSM Operations Cross Reference ..................................................................................26 
</Link>

<Link>4-1 Request Packet Type to Transaction Type Cross Reference ..........................................43 
</Link>

<Link>4-2 Coherent 32-Byte Read Data Return Ordering ...............................................................45 
</Link>

<Link>4-3 Coherent 64-Byte Read Data Return Ordering ...............................................................45 
</Link>

<Link>4-4 Coherent 32-Byte Write Data Payload ...........................................................................46 
</Link>

<Link>4-5 Coherent 64-Byte Write Data Payloads ..........................................................................46 
</Link>

<Link>4-6 General Field Definitions for All Request Packets.........................................................47 
</Link>

<Link>4-7 Read Size (rdsize) Definitions ........................................................................................48 
</Link>

<Link>4-8 Write Size (wrsize) Definitions ......................................................................................49 
</Link>

<Link>4-9 Specific Field Definitions and Encodings for Type 1 Packets .......................................50 
</Link>

<Link>4-10 Transaction Field Encodings for Type 2 Packets ...........................................................51 
</Link>

<Link>4-11 Transaction Field Encodings for Type 5 Packets ...........................................................52 
</Link>

<Link>4-12 Request Packet Type to Transaction Type Cross Reference ..........................................53 
</Link>

<Link>4-13 Field Definitions and Encodings for All Response Packets ...........................................53 
</Link>

<Link>5-1 GSM Register Map .........................................................................................................57 
</Link>

<Link>5-2 Configuration Space Reserved Access Behavior............................................................58 
</Link>

<Link>5-3 Bit Settings for Source Operations CAR ........................................................................60 
</Link>

<Link>5-4 Bit Settings for Destination Operations CAR .................................................................61 
</Link>

<Link>6-1 Operation to Protocol Cross Reference ..........................................................................67 
</Link>

<Link>7-1 Address Collision Resolution for READ_HOME ..........................................................92 
</Link>

<Link>7-2 Address Collision Resolution for IREAD_HOME.........................................................93 
</Link>

<Link>7-3 Address Collision Resolution for READ_OWNER .......................................................94 
</Link>

<Link>7-4 Address Collision Resolution for READ_TO_OWN_HOME .......................................95 
</Link>

<Link>7-5 Address Collision Resolution for READ_TO_OWN_OWNER ....................................97 
</Link>

<Link>7-6 Address Collision Resolution for DKILL_HOME .........................................................98 
</Link>

<Link>7-7 Address Collision Resolution for DKILL_SHARER ...................................................100 
</Link>

<Link>7-8 Address Collision Resolution for IKILL_HOME ........................................................101 
</Link>

<Link>7-9 Address Collision Resolution for IKILL_SHARER ....................................................102 
</Link>

<Link>7-10 Address Collision Resolution for CASTOUT ..............................................................103 
</Link>

<Link>7-11 Address Collision Resolution for Software Coherence Operations..............................104 
</Link>

<Link>7-12 Address Collision Resolution for Participant FLUSH..................................................105 
</Link>

<Link>7-13 Address Collision Resolution for Non-participant FLUSH..........................................106 
</Link>

<Link>7-14 Address Collision Resolution for Participant IO_READ_HOME ...............................107 
</Link>

<Link>7-15 Address Collision Resolution for Non-participant IO_READ_HOME .......................108 
</Link>

<Link>7-16 Address Collision Resolution for Participant IO_READ_OWNER.............................109 
</Link>

<Link>7-17 Address Collision Resolution for Non-participant IO_READ_OWNER.....................110 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>Blank page </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30588">Chapter 1 Overview </P>

<P id="LinkTarget_30589">1.1 Introduction </P>

<P>This chapter provides an overview of the RapidIO Part 5: Globally Shared Memory Logical Specification, including a description of the relationship between this specification and the other specifications of the RapidIO interconnect. </P>

<P id="LinkTarget_30590">1.2 Overview </P>

<P>Although RapidIO is targeted toward the message passing programming model, it supports a globally shared distributed memory (GSM) model as defined by this specification. The globally shared memory programming model is the preferred programming model for modern general-purpose multiprocessing computer systems, which requires cache coherency support in hardware. This addition of GSM enables both distributed I/O processing and general purpose multiprocessing to co-exist under the same protocol. </P>

<P>The RapidIO Part 5: Globally Shared Memory Logical Specification is one of the RapidIO logical layer specifications that define the interconnect’s overall protocol and packet formats. This layer contains the information necessary for end points to process a transaction. Other RapidIO logical layer specifications include RapidIO Part 1: Input/Output Logical Specification and RapidIO Part 2: Message Passing Logical Specification. </P>

<P>The logical specifications do not imply a specific transport or physical interface, therefore they are specified in a bit stream format. Necessary bits are added to the logical encodings for the transport and physical layers lower in the specification hierarchy. </P>

<P>RapidIO is a definition of a system interconnect. System concepts such as processor programming models, memory coherency models and caching are beyond the scope of the RapidIO architecture. The support of memory coherency models, through caches, memory directories (or equivalent, to hold state and speed up remote memory access) is the responsibility of the end points (processors, memory, and possibly I/O devices), using RapidIO operations. RapidIO provides the operations to construct a wide variety of systems, based on programming models that range from strong consistency through total store ordering to weak ordering. Inter-operability between end points supporting different coherency/caching/directory models is not guaranteed. However, groups of </P>

<P>RapidIO Trade Association </P>

<P>end-points with conforming models can be linked to others conforming to different models on the same RapidIO fabric. These different groups can communicate through RapidIO messaging or I/O operations. Any reference to these areas within the RapidIO architecture specification are for illustration only. </P>

<P>The RapidIO Interconnect Globally Shared Memory Logical Specification assumes that the reader is familiar with the concepts and terminology of cache coherent systems in general and with CC-NUMA systems in specific. Further information on shared memory concepts can be found in: </P>

<P>Daniel E. Lenoski and Wolf-Dietrich Weber, “Scalable Shared-Memory Multiprocessing”, Morgan Kaufmann, 1995. </P>

<P>and </P>

<P>David Culler, Jaswinder Pal Singh, and Anoop Gupta: “Parallel Computer Architecture: A Hardware/Software Approach”, Morgan Kaufmann, 1998 </P>

<P id="LinkTarget_30591">1.2.1 Memory System </P>

<P>Under the globally shared distributed memory programming model, memory may be physically located in different places in the machine yet may be shared amongst different processing elements. Typically, mainstream system architectures have addressed shared memory using transaction broadcasts sometimes known as bus-based snoopy protocols. These are usually implemented through a centralized 
<Link>memory controller for which all devices have equal or uniform access. Figure 1-1 </Link>
shows a typical bus-based shared memory system. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_52.jpg"/>
Processor A Processor B Processor C Processor D Bridge XBUS MPIC Memory Snoopy-bus </Figure>

<P>PCI </P>

<P>Figure 1-1. A Snoopy Bus-Based System </P>

<P>Super computers, massively parallel, and clustered machines that have distributed memory systems must use a different technique from broadcasting for maintaining memory coherency. Because a broadcast snoopy protocol in these machines is not efficient given the number of devices that must participate and the latency and transaction overhead involved, coherency mechanisms such as memory directories </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>or distributed linked lists are required to keep track of where the most current copy of data resides. These schemes are often referred to as cache coherent non-uniform memory access (CC-NUMA) protocols. A typical distributed memory system 
<Link>architecture is shown in Figure 1-2. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_53.jpg"/>
Processor A Processor B Bridge Memory Snoopy-bus Processor A Processor B Bridge Memory Snoopy-bus Interconnect Fabric </Figure>

<P>PCI PCI </P>

<P>Figure 1-2. A Distributed Memory System </P>

<P>For RapidIO, a relatively simple directory-based coherency scheme is chosen. For this method each memory controller is responsible for tracking where the most current copy of each data element resides in the system. RapidIO furnishes a variety of ISA specific cache control and operating system support operations such as block flushes and TLB synchronization mechanisms. </P>

<P>To reduce the directory overhead required, the architecture is optimized around small clusters of 16 processors known as coherency domains. With the concept of domains, it is possible for multiple coherence groupings to coexist in the interconnect as tightly coupled processing clusters. </P>

<P id="LinkTarget_30592">1.3 Features of the Globally Shared Memory Specification </P>

<P>The following are features of the RapidIO GSM specification designed to satisfy the needs of various applications and systems: </P>

<P id="LinkTarget_30593">1.3.1 Functional Features </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> A cache coherent non-uniform memory access (CC-NUMA) system architecture is supported to provide a globally shared memory model because physics is forcing component interfaces in many high-speed designs to be point-to-point instead of traditional bus-based. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The size of processor memory requests are either in the cache coherence granularity, or smaller. The coherence granule size may be different for different processor families or implementations. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P>• Instruction sets in RapidIO support a variety of cache control and other operations such as block flushes. These functions are supported to run legacy applications and operating systems. </P>

<P id="LinkTarget_30594">1.3.2 Physical Features </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>RapidIO packet definition is independent of the width of the physical interface to other devices on the interconnect fabric. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>The protocols and packet formats are independent of the physical interconnect topology. The protocols work whether the physical fabric is a point-to-point ring, a bus, a switched multi-dimensional network, a duplex serial connection, and so forth. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> RapidIO is not dependent on the bandwidth or latency of the physical fabric. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The protocols handle out-of-order packet transmission and reception. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Certain devices have bandwidth and latency requirements for proper operation. RapidIO does not preclude an implementation from imposing these constraints within the system. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30595">1.3.3 Performance Features </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Packet headers must be as small as possible to minimize the control overhead and be organized for fast, efficient assembly and disassembly. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> 48- and 64-bit addresses are required in the future, and must be supported initially. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> An interventionist (non-memory owner, direct-to-requestor data transfer, analogous to a cache-to-cache transfer) protocol saves a large amount of latency for memory accesses that cause another processing element to provide the requested data. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Multiple transactions must be allowed concurrently in the system, otherwise a majority of the potential system throughput is wasted. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30596">1.4 Contents </P>

<P>Following are the contents of the RapidIO Interconnect Globally Shared Memory Logical Specification: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 1, “Overview,” describes the set of operations and transactions </Link>
supported by the RapidIO globally shared memory protocols. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 2, “System Models,” introduces some possible devices that could </Link>
participate in a RapidIO GSM system environment. The chapter explains the memory directory-based mechanism that tracks memory accesses and maintains cache coherence. Transaction ordering and deadlock prevention are also covered. </LI_Title>
</LI>
</L>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 3, “Operation Descriptions,” describes the set of operations and </Link>
transactions supported by the RapidIO globally-shared memory (GSM) protocols. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 4, “Packet Format Descriptions,” contains the packet format </Link>
definitions for the GSM specification. The two basic types, request and response packets, with their sub-types and fields are defined. The chapter explains how memory read latency is handled by RapidIO. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>
<Link>Chapter 5, “Globally Shared Memory Registers,” describes the visible register </Link>
set that allows an external processing element to determine the globally shared memory capabilities, configuration, and status of a processing element using this logical specification. Only registers or register bits specific to the GSM logical specification are explained. Refer to the other RapidIO logical, transport, and physical specifications of interest to determine a complete list of registers and bit definitions. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>
<Link>Chapter 6, “Communication Protocols,” contains the communications protocol </Link>
definitions for this GSM specification. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 7, “Address Collision Resolution Tables,” explains the actions </Link>
necessary under the RapidIO GSM model to resolve address collisions. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30597">1.5 Terminology </P>

<P>Refer to the Glossary at the back of this document. </P>

<P id="LinkTarget_30598">1.6 Conventions </P>

<P>|| 	Concatenation, used to indicate that two fields are physically associated as consecutive bits </P>

<P>ACTIVE_HIGH 	Names of active high signals are shown in uppercase text with no overbar. Active-high signals are asserted when high and not asserted when low. </P>

<P>ACTIVE_LOW 	Names of active low signals are shown in uppercase text with an overbar. Active low signals are asserted when low and not asserted when high. </P>

<P>italics 	Book titles in text are set in italics. </P>

<P>REG[FIELD] 	Abbreviations or acronyms for registers are shown in uppercase text. Specific bits, fields, or ranges appear in brackets. </P>

<P>TRANSACTION 	Transaction types are expressed in all caps. </P>

<P>operation 	Device operation types are expressed in plain text. </P>

<P>n A decimal value. 
[n-m] Used to express a numerical range from n to m. 
</P>

<P>RapidIO Trade Association </P>

<P>0bnn 	A binary value, the number of bits is determined by the number of digits. </P>

<P>0xnn 	A hexadecimal value, the number of bits is determined by the number of digits or from the surrounding context; for example, 0xnn may be a 5, 6, 7, or 8 bit value. </P>

<P>x This value is a don’t care </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30599">Chapter 2 System Models </P>

<P id="LinkTarget_30600">2.1 Introduction </P>

<P>This overview introduces some possible devices in a RapidIO system. </P>

<P id="LinkTarget_30601">2.2 Processing Element Models </P>

<P>
<Link>Figure 2-1 describes a possible RapidIO-based computing system. The processing </Link>
element is a computer device such as a processor attached to a local memory and also attached to a RapidIO system interconnect. The bridge part of the system provides I/O subsystem services such as high-speed PCI interfaces and gigabit ethernet ports, interrupt control, and other system support functions. Multiple processing elements require cache coherence support in the RapidIO protocol to preserve the traditional globally shared memory programming model (discussed in 
<Link>Section 2.3.1, “Globally Shared Memory System Model”). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_54.jpg"/>
Processing Element A Memory Processing Element B Memory Processing Element C Memory Processing Element D Memory RapidIO System Interconnect Fabric </Figure>

<Table>
<TR>
<TD>PCI A PCI B </TD>

<TD>Bridge </TD>

<TD>XBUS MPIC </TD>
</TR>

<TR>
<TD/>

<TD>Firewire </TD>

<TD/>
</TR>
</Table>

<P>Figure 2-1. A Possible RapidIO-Based Computing System </P>

<P>A processing element containing a processor typically has associated with it a caching hierarchy to improve system performance. The RapidIO protocol supports a set of operations sufficient to fulfill the requirements of a processor with a caching hierarchy and associated support logic such as a processing element. </P>

<P>RapidIO Trade Association </P>

<P>RapidIO is defined so that many types of devices can be designed for specific applications and connected to the system interconnect. These devices may participate in the cache coherency protocol, act as a DMA device, utilize the message passing facilities to communicate with other devices on the interconnect, and so forth. A bridge could be designed, for example, to use the message passing facility to pass ATM packets to and from a processing element for route processing. The following sections describe several possible processing elements. </P>

<P id="LinkTarget_30602">2.2.1 Processor-Memory Processing Element Model </P>

<P>
<Link>Figure 2-2 shows an example of a processing element consisting of a processor </Link>
connected to an agent device. The agent carries out several services on behalf of the processor. Most importantly, it provides access to a local memory that has much lower latency than memory that is local to another processing element (remote memory accesses). It also provides an interface to the RapidIO interconnect to service those remote memory accesses. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_55.jpg"/>
Agent Memory Processor Local Interconnect Remote Cache </Figure>

<P>RapidIO-based System Interconnect </P>

<P>Figure 2-2. Processor-Memory Processing Element Example </P>

<P>In support of the remote accesses, the agent maintains a cache of remote accesses that includes all remote data currently residing in and owned by the local processor. This cache may be either external or internal to the agent device. </P>

<P>Agent caching is necessary due to the construction of the RapidIO cache coherence protocol combined with the cache hierarchy behavior in modern processors. Many modern processors have multiple level non-inclusive caching structures that are maintained independently. This implies that when a coherence granule is cast out of the processor, it may or may not be returning ownership of the granule to the memory system. The RapidIO protocol requires that ownership of a coherence granule be guaranteed to be returned to the system on demand and without ambiguous cache state changes as with the castout behavior. The remote cache can guarantee that a coherence granule requested by the system is owned locally and can be returned to the home memory (the physical memory containing the coherence </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>granule) on demand. A processing element that is fully integrated would also need to support this behavior. </P>

<P id="LinkTarget_30603">2.2.2 Integrated Processor-Memory Processing Element Model </P>

<P>Another form of a processor-memory processing element is a fully integrated component that is designed specifically to connect to a RapidIO interconnect system 
<Link>as shown in Figure 2-3. This type of device integrates a memory system and other </Link>
support logic with a processor on the same piece of silicon or within the same package. Because such a device is designed specifically for RapidIO, a remote cache is not required because the proper support can be designed into the processor and its associated logic rather than requiring an agent to compensate for a stand alone processor’s behavior. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_56.jpg"/>
Processor Memory </Figure>

<P>RapidIO-based System Interconnect </P>

<P>Figure 2-3. Integrated Processor-Memory Processing Element Example </P>

<P id="LinkTarget_30604">2.2.3 Memory-Only Processing Element Model </P>

<P>A different processing element may not contain a processor at all, but may be a 
<Link>memory-only device as in Figure 2-4. This type of device is much simpler than a </Link>
processor as it is only responsible for responding to requests from the external system, not from local requests as in the processor-based model. As such, its memory is remote for all processors in the system. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_57.jpg"/>
Memory Memory Control </Figure>

<P>RapidIO-based System Interconnect </P>

<P>Figure 2-4. Memory-Only Processing Element Example </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30605">2.2.4 Processor-Only Processing Element </P>

<P>Similar to a memory-only element, a processor-only element has no local memory. 
<Link>A processor-only processing element is shown in Figure 2-5. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_58.jpg"/>
Agent Processor Local Interconnect Remote Cache </Figure>

<P>RapidIO-based System Interconnect </P>

<P>Figure 2-5. Processor-Only Processing Element Example </P>

<P id="LinkTarget_30606">2.2.5 I/O Processing Element </P>

<P>
<Link>This type of processing element is shown as the bridge in Figure 2-1. This device </Link>
has distinctly different behavior than a processor or a memory. An I/O device only needs to move data into and out of local or remote memory in a cache coherent fashion. This means that if the I/O device needs to read from memory, it only needs to obtain a known good copy of the data to write to the external device (such as a disk drive or video display). If the I/O device needs to write to memory, it only needs to get ownership of the coherence granule returned to the home memory and not take ownership for itself. Both of these operations have special support in the RapidIO protocol. </P>

<P id="LinkTarget_30607">2.2.6 Switch Processing Element </P>

<P>A switch processing element is a device that allows communication with other processing elements through the switch. A switch may be used to connect a variety of RapidIO compliant processing elements. A possible switch is shown in </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>
<Link>Figure 2-6. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_59.jpg"/>
Switch </Figure>

<P>Figure 2-6. Switch Processing Element Example </P>

<P id="LinkTarget_30608">2.3 Programming Models </P>

<P>RapidIO supports applications developed under globally shared memory and software-managed cache coherence programming models. </P>

<P id="LinkTarget_30609">2.3.1 Globally Shared Memory System Model </P>

<P>The preferred programming model for modern computer systems provides memory that is accessible from all processors in a cache coherent fashion. This model is also known as GSM, or globally shared memory. For traditional bus-based computer systems this is not a difficult technical problem to solve because all participants in the cache coherence mechanism see all memory activity simultaneously, meaning that communication between processors is very fast and handled without explicit software control. However, in a non-uniform memory access system, this simultaneous memory access visibility is not the case. </P>

<P>With a distributed memory system, cache coherence needs to be maintained through some tracking mechanism that keeps records of memory access activity and explicitly notifies specific cache coherence participant processing elements when a cache coherence hazard is detected. For example, if a processing element wishes to write to a memory address, all participant processing elements that have accessed that coherence granule are notified to invalidate that address in their caches. Only when all of the participant processing elements have completed the invalidate operation and replied back to the tracking mechanism is the write allowed to proceed. </P>

<P>The tracking mechanism preferred for the RapidIO protocol is the memory directory based system model. This system model allows efficient, moderate scalability with a reasonable amount of information storage required for the tracking mechanism. </P>

<P>Cache coherence is defined around the concept of domains. The RapidIO protocol assumes a memory directory based cache coherence mechanism. Because the storage requirements for the directory can be high, the protocol was optimized assuming a 16-participant domain size as a reasonable coherence scalability limit. </P>

<P>RapidIO Trade Association </P>

<P>With this limit in mind, a moderately scalable system of 16 participants can be designed, possibly using a multicast mechanism in the transport layer for better efficiency. This size does not limit a system designer from defining a larger or a 
<Link>smaller coherent system such as the four processing element system in Figure 2-1 </Link>

<Link>on page 17 since the number of domains and the number of participants is flexible. </Link>
The total number of coherence domains and the scalability limit are determined by the number of transport bits allowed by the appropriate transport layer specification. </P>

<P>
<Link>Table 2-1 describes an example of the directory states assumed for the RapidIO </Link>
protocol for a small four-processing element cache coherent system (the table assumes that processor 0 is the local processor). Every coherence granule that is accessible by a remote processing element has this 4-bit field associated with it, so some state storage is required for each globally shared granule. The least significant bit (the right most, bit 3) indicates that a processing element has taken ownership of a coherence granule. The remaining three bits indicate that processing elements have accessed that coherence granule, or the current owner if the granule has been modified, with bit 0 corresponding to processor 3, bit 1 corresponding to processor 2, and bit 2 corresponding to processor 1. These bits are also known as the sharing mask or sharing list. </P>

<P>Owing to the encoding of the bits, the local processing element is always assumed to have accessed the granule even if it has not. This definition allows us to know exactly which processing elements have participated in the cache coherency protocol for each shared coherence granule at all times. Other state definitions can be implemented as long as they encompass the MSL (modified, shared, local) state functionality described here. </P>

<Table>
<Caption>
<P>Table 2-1. RapidIO Memory Directory Definition </P>
</Caption>

<TR>
<TD>State </TD>

<TD>Description </TD>
</TR>

<TR>
<TD>0000 </TD>

<TD>Processor 0 (local) shared </TD>
</TR>

<TR>
<TD>0001 </TD>

<TD>Processor 0 (local) modified </TD>
</TR>

<TR>
<TD>0010 </TD>

<TD>Processor 1, 0 shared </TD>
</TR>

<TR>
<TD>0011 </TD>

<TD>Processor 1 modified </TD>
</TR>

<TR>
<TD>0100 </TD>

<TD>Processor 2, 0 shared </TD>
</TR>

<TR>
<TD>0101 </TD>

<TD>Processor 2 modified </TD>
</TR>

<TR>
<TD>0110 </TD>

<TD>Processor 2, 1, 0 shared </TD>
</TR>

<TR>
<TD>0111 </TD>

<TD>Illegal </TD>
</TR>

<TR>
<TD>1000 </TD>

<TD>Processor 3, 0 shared </TD>
</TR>

<TR>
<TD>1001 </TD>

<TD>Processor 3 modified </TD>
</TR>

<TR>
<TD>1010 </TD>

<TD>Processor 3, 1, 0 shared </TD>
</TR>

<TR>
<TD>1011 </TD>

<TD>Illegal </TD>
</TR>

<TR>
<TD>1100 </TD>

<TD>Processor 3, 2, 0 shared </TD>
</TR>

<TR>
<TD>1101 </TD>

<TD>Illegal </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>Table 2-1. RapidIO Memory Directory Definition (Continued) </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_60.jpg"/>
1110 Processor 3, 2, 1, 0 shared 1111 Illegal </Figure>

<P>When a coherence granule is referenced, the corresponding 4-bit coherence state is examined by the memory controller to determine if the access can be handled in memory, or if data must be obtained from the current owner (a shared granule is owned by the home memory). Coherence activity in the system is started using the cache coherence protocol, if it is necessary to do so, to complete the memory operation. </P>

<P id="LinkTarget_30610">2.3.1.1 Software-Managed Cache Coherence Programming Model </P>

<P>The software-managed cache coherence programming model depends upon the application programmer to guarantee that the same coherence granule is not resident in more than one cache in the system simultaneously if it is possible for that coherence granule to be written by one of the processors. The application software allows sharing of written data by using cache manipulation instructions to flush these coherence granules to memory before they are read by another processor. This programming model is useful in transaction and distributed processing types of systems. </P>

<P id="LinkTarget_30611">2.4 System Issues </P>

<P>The following sections describe transaction ordering and system deadlock considerations in a RapidIO GSM system. </P>

<P id="LinkTarget_30612">2.4.1 Operation Ordering </P>

<P>Operation completion ordering in a globally shared memory system is managed by the completion units of the processing elements participating in the coherence protocol and by the coherence protocol itself. </P>

<P id="LinkTarget_30613">2.4.2 Transaction Delivery </P>

<P>There are two basic types of delivery schemes that can be built using RapidIO processing elements: unordered and ordered. The RapidIO logical protocols assume that all outstanding transactions to another processing element are delivered in an arbitrary order. In other words, the logical protocols do not rely on transaction interdependencies for operation. RapidIO also allows completely ordered delivery systems to be constructed. Each type of system puts different constraints on the implementation of the source and destination processing elements and any intervening hardware. The specific mechanisms and definitions of how RapidIO enforces transaction ordering are discussed in the appropriate physical layer specification. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30614">2.4.3 Deadlock Considerations </P>

<P>A deadlock can occur if a dependency loop exists. A dependency loop is a situation where a loop of buffering devices is formed, in which forward progress at each device is dependent upon progress at the next device. If no device in the loop can make progress then the system is deadlocked. </P>

<P>The simplest solution to the deadlock problem is to discard a packet. This releases resources in the network and allows forward progress to be made. RapidIO is designed to be a reliable fabric for use in real time tightly coupled systems, therefore, discarding packets is not an acceptable solution. </P>

<P>In order to produce a system with no chance of deadlock it is required that a deadlock free topology be provided for response-less operations. Dependency loops to single direction packets can exist in unconstrained switch topologies. Often the dependency loop can be avoided with simple routing rules. Topologies like hypercubes or three-dimensional meshes, physically contain loops. In both cases, routing is done in several dimensions (x,y,z). If routing is constrained to the x dimension, then y, then z (dimension ordered routing), then topology related dependency loops are avoided in these structures. </P>

<P>In addition, a processing element design shall not form dependency links between its input and output port. A dependency link between input and output ports occurs if a processing element is unable to accept an input packet until a waiting packet can be issued from the output port. </P>

<P>RapidIO supports operations, such as coherent read-for-ownership operations, that require responses to complete. These operations can lead to a dependency link between an processing element’s input port and output port. </P>

<P>As an example of an input to output port dependency, consider a processing element where the output port queue is full. The processing element can not accept a new request at its input port since there is no place to put the response in the output port queue. No more transactions can be accepted at the input port until the output port is able to free entries in the output queue by issuing packets to the system. </P>

<P>A further consideration is that of the read-for-ownership operation colliding with a castout of the requested memory address by another processing element. In order for the read-for-ownership operation to complete the underlying castout operation must complete. Therefore the castout must be given higher preference in the system in order to move ahead of other operations in order to break up the dependency. </P>

<P>The method by which a RapidIO system maintains a deadlock free environment is described in the appropriate Physical Layer specification. </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30615">Chapter 3 Operation Descriptions </P>

<P id="LinkTarget_30616">3.1 Introduction </P>

<P>This chapter describes the set of operations and transactions supported by the RapidIO globally-shared memory (GSM) protocols. The opcodes and packet 
<Link>formats are described in Chapter 4, “Packet Format Descriptions.” The complete </Link>
protocols are described in 
<Link>Chapter 6, “Communication Protocols.” </Link>
</P>

<P>The RapidIO operation protocols use request/response transaction pairs through the interconnect fabric. A processing element sends a request transaction to another processing element if it requires an activity to be carried out. The receiving processing element responds with a response transaction when the request has been completed or if an error condition is encountered. Each transaction is sent as a packet through the interconnect fabric. For example, a processing element that requires data from home memory in another processing element sends a READ_HOME transaction in a request packet. The receiving element then reads its local memory at the requested address and returns the data in a DONE transaction via a response packet. Note that not all requests require responses; some requests assume that the desired activity will complete properly. </P>

<P>A number of possible response transactions can be received by a requesting processing element: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> A DONE response indicates to the requestor that the desired transaction has completed and also returns data for read-type transactions as described above. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The INTERVENTION, DONE_INTERVENTION, and DATA_ONLY responses are generated as part of the processing element-to-processing element (as opposed to processing element-to-home memory) data transfer mechanism defined by the cache coherence protocol. The INTERVENTION and DONE_INTERVENTION responses are abbreviated as INTERV and DONE_INTERV in this chapter. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>The NOT_OWNER and RETRY responses are received when there are address conflicts within the system that need resolution. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> An ERROR response means that the target of the transaction encountered an unrecoverable error and could not complete the transaction. </LI_Title>
</LI>
</L>

<P>Packets may contain additional information that is interpreted by the interconnect fabric to route the packets through the fabric from the source to the destination, such </P>

<P>RapidIO Trade Association </P>

<P>as a device number. These requirements are described in the appropriate RapidIO transport layer specification and are beyond the scope of this specification. </P>

<P>Depending upon the interconnect fabric, other packets may be generated as part of the physical layer protocol to manage flow control, errors, etc. Flow control and other fabric-specific communication requirements are described in the appropriate RapidIO physical layer specification and are beyond the scope of this document. </P>

<P>Each request transaction sent into the system is marked with a transaction ID that is unique for each requestor and responder processing element pair. This transaction ID allows a response to be easily matched to the original request when it is returned to the requestor. An end point cannot reuse a transaction ID value to the same destination until the response from the original transaction has been received by the requestor. The number of outstanding transactions that may be supported is implementation dependent. </P>

<P>
<Link>The transaction behaviors are also described as state machine behavior in Chapter 6, </Link>

<Link>“Communication Protocols</Link>
”. </P>

<P id="LinkTarget_30617">3.2 GSM Operations Cross Reference </P>

<P>
<Link>Table 3-1 contains a cross reference of the GSM operations defined in this RapidIO </Link>
specification and their system usage. </P>

<Table>
<Caption>
<P>Table 3-1. GSM Operations Cross Reference </P>
</Caption>

<TR>
<TH>Operation </TH>

<TH>Transactions Used </TH>

<TH>Possible System Usage </TH>

<TH>Description </TH>

<TH>Packet Format </TH>

<TH>Protocol </TH>
</TR>

<TR>
<TD>Read </TD>

<TD>READ_HOME, READ_OWNER, RESPONSE </TD>

<TD>CC-NUMA operation </TD>

<TD>
<Link>Section 3.3.1 page 28 </Link>
</TD>

<TD>
<Link>Types 1 and 2: Section 4.2.5 page 50 and Section 4.2.6 </Link>
</TD>

<TD>
<Link>Section 6.4 page 68 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD/>

<TD/>

<TD/>

<TD>
<Link>page 51 </Link>
</TD>

<TD/>
</TR>

<TR>
<TD>Instruction read </TD>

<TD>IREAD_HOME, </TD>

<TD>Combination of CC-NUMA </TD>

<TD>
<Link>Section 3.3.2 </Link>
</TD>

<TD>Type 2 </TD>

<TD>
<Link>Section 6.4 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>READ_OWNER, RESPONSE </TD>

<TD>and software-maintained coherence of instruction </TD>

<TD>
<Link>page 29 </Link>
</TD>

<TD>
<Link>Section 4.2.6 page 51 </Link>
</TD>

<TD>
<Link>page 68 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD/>

<TD>caches </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>Read-forownership </TD>

<TD>READ_TO_OWN_ HOME, READ_TO_OWN_ OWNER, </TD>

<TD>CC-NUMA operation </TD>

<TD>
<Link>Section 3.3.3 page 31 </Link>
</TD>

<TD>
<Link>Types 1 and 2: Section 4.2.5 page 50 and Section 4.2.6 </Link>
</TD>

<TD>
<Link>Section 6.6 page 75 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>DKILL_SHARER RESPONSE </TD>

<TD/>

<TD/>

<TD>
<Link>page 51 </Link>
</TD>

<TD/>
</TR>

<TR>
<TD>Data cache </TD>

<TD>DKILL_HOME, </TD>

<TD>CC-NUMA operation; </TD>

<TD>
<Link>Section 3.3.4 </Link>
</TD>

<TD>Type 2 </TD>

<TD>
<Link>Section 6.7 </Link>
</TD>
</TR>

<TR>
<TD>invalidate </TD>

<TD>DKILL_SHARER, </TD>

<TD>software-maintained </TD>

<TD>
<Link>page 33 </Link>
</TD>

<TD>
<Link>Section 4.2.6 </Link>
</TD>

<TD>
<Link>page 79 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>RESPONSE </TD>

<TD>coherence operation </TD>

<TD/>

<TD>
<Link>page 51 </Link>
</TD>

<TD/>
</TR>

<TR>
<TD>Castout </TD>

<TD>CASTOUT, </TD>

<TD>CC-NUMA operation </TD>

<TD>
<Link>Section 3.3.5 </Link>
</TD>

<TD>Type 5 </TD>

<TD>
<Link>Section 6.8 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>RESPONSE </TD>

<TD/>

<TD>
<Link>page 34 </Link>
</TD>

<TD>
<Link>Section 4.2.8 </Link>
</TD>

<TD>
<Link>page 82 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD/>

<TD/>

<TD/>

<TD>
<Link>page 52 </Link>
</TD>

<TD/>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 Table 3-1. GSM Operations Cross Reference (Continued) </P>

<Table>
<TR>
<TH>Operation </TH>

<TH>Transactions Used </TH>

<TH>Possible System Usage </TH>

<TH>Description </TH>

<TH>Packet Format </TH>

<TH>Protocol </TH>
</TR>

<TR>
<TD>TLB </TD>

<TD>TLBIE, RESPONSE </TD>

<TD>Software-maintained </TD>

<TD>
<Link>Section 3.3.6 </Link>
</TD>

<TD>Type 2 </TD>

<TD>
<Link>Section 6.9 </Link>
</TD>
</TR>

<TR>
<TD>invalidate-entry </TD>

<TD/>

<TD>coherence of page table </TD>

<TD>
<Link>page 35 </Link>
</TD>

<TD>
<Link>Section 4.2.6 </Link>
</TD>

<TD>
<Link>page 83 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD/>

<TD>entries </TD>

<TD/>

<TD>
<Link>page 51 </Link>
</TD>

<TD/>
</TR>

<TR>
<TD>TLB </TD>

<TD>TLBSYNC, </TD>

<TD>Software-maintained </TD>

<TD>
<Link>Section 3.3.7 </Link>
</TD>

<TD>Type 2 </TD>

<TD>
<Link>Section 6.9 </Link>
</TD>
</TR>

<TR>
<TD>invalidate-entry </TD>

<TD>RESPONSE </TD>

<TD>coherence of page table </TD>

<TD>
<Link>page 35 </Link>
</TD>

<TD>
<Link>Section 4.2.6 </Link>
</TD>

<TD>
<Link>page 83 </Link>
</TD>
</TR>

<TR>
<TD>synchronize </TD>

<TD/>

<TD>entries </TD>

<TD/>

<TD>
<Link>page 51 </Link>
</TD>

<TD/>
</TR>

<TR>
<TD>Instruction </TD>

<TD>IKILL_HOME, </TD>

<TD>Software-maintained </TD>

<TD>
<Link>Section 3.3.8 </Link>
</TD>

<TD>Type 2 </TD>

<TD>
<Link>Section 6.7 </Link>
</TD>
</TR>

<TR>
<TD>cache invalidate </TD>

<TD>IKILL_SHARER, </TD>

<TD>coherence of instruction </TD>

<TD>
<Link>page 35 </Link>
</TD>

<TD>
<Link>Section 4.2.6 </Link>
</TD>

<TD>
<Link>page 79 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD>RESPONSE, </TD>

<TD>caches </TD>

<TD/>

<TD>
<Link>page 51 </Link>
</TD>

<TD/>
</TR>

<TR>
<TD>Data cache flush </TD>

<TD>FLUSH, DKILL_SHARER, READ_TO_OWN_ OWNER, RESPONSE </TD>

<TD>CC-NUMA flush instructions; CC-NUMA write-through cache support; CC-NUMA DMA I/O device </TD>

<TD>
<Link>Section 3.3.9 page 36 </Link>
</TD>

<TD>
<Link>Types 2 and 5: Section 4.2.6 page 51 and Section 4.2.8 page 52 </Link>
</TD>

<TD>
<Link>Section 6.10 page 84 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD/>

<TD>support; software-maintained </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD/>

<TD/>

<TD>coherence operation. </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>I/O read </TD>

<TD>IO_READ_HOME, IO_READ_ OWNER, INTERV, RESPONSE </TD>

<TD>CC-NUMA DMA, I/O DMA device support </TD>

<TD>
<Link>Section 3.3.10 page 38 </Link>
</TD>

<TD>
<Link>Types 1 and 2: Section 4.2.5 page 50 and Section 4.2.6 </Link>
</TD>

<TD>
<Link>Section 6.11 page 88 </Link>
</TD>
</TR>

<TR>
<TD/>

<TD/>

<TD/>

<TD/>

<TD>
<Link>page 51 </Link>
</TD>

<TD/>
</TR>
</Table>

<P id="LinkTarget_30618">3.3 GSM Operations </P>

<P>A set of transactions are used to support GSM (cache coherence) operations to cacheable memory space. The following descriptions assume that all requests are to system memory rather than to some other type of device. </P>

<P>GSM operations occur based on the size of the coherence granule. Changes in the coherence granule for a system do not change any of the operation protocols, only the data payload size. The only exceptions to this are flush and I/O read operations, which may request (in the case of an I/O read), or have (in the case of a flush) a sub-coherence granule to support coherent I/O and write-through caches. Flush operations may also have no data payload in order to support cache manipulation instructions. </P>

<P>Some transactions are sent to multiple recipients in the process of completing an operation. These transactions can be sent either as a number of directed transactions or as a single transaction if the transport layer has multicast capability. Multicast capability and operation is defined in the appropriate RapidIO transport layer specification. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30619">3.3.1 Read Operations </P>

<P>The READ_HOME, READ_OWNER, and RESPONSE transactions are used during a read operation by a processing element that needs a shared copy of cache-coherent data from the memory system. A read operation always returns one coherence granule-sized data payload. </P>

<P>The READ_HOME transaction is used by a processing element that needs to read a shared copy of a coherence granule from a remote home memory on another processing element. </P>

<P>The READ_OWNER transaction is used by a home memory processing element that needs to read a shared copy of a coherence granule that is owned by a remote processing element. </P>

<P>The following types of read operations are possible: </P>

<P>• If the requested data exists in the memory directory as shared, the data can be returned immediately from memory with a DONE RESPONSE transaction and the requesting processing element’s device ID is added to the sharing 
<Link>mask as shown in Figure 3-1. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_61.jpg"/>
Requestor Home Memory DONE, data 2 READ_HOME 1 </Figure>

<P>Figure 3-1. Read Operation to Remote Shared Coherence Granule </P>

<P>• If the requested data exists in the memory directory as modified, the up-to-date (current) data must be obtained from the owner. The home memory then sends a READ_OWNER request to the processing element that owns the coherence granule. The owner passes a copy of the data to the original requestor and to memory, memory is updated, and the directory state is changed from modified and owner to shared by the previous owner and the 
<Link>requesting processing element’s device ID as shown in Figure 3-2. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_62.jpg"/>
Requestor Home Memory DONE_INTERV Owner 5 READ_HOME 1 READ_OWNER2 INTERV, data 4 DATA_ONLY, data 3 </Figure>

<P>Figure 3-2. Read Operation to Remote Modified Coherence Granule </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>• If the processing element requesting a modified coherence granule happens to be the home for the memory, some of the transactions can be eliminated as 
<Link>shown in Figure 3-3. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_63.jpg"/>
Requestor, INTERV, data 2 READ_OWNER 1 Owner Home Memory </Figure>

<P>Figure 3-3. Read Operation to Local Modified Coherence Granule </P>

<P id="LinkTarget_30620">3.3.2 Instruction Read Operations </P>

<P>Some processors have instruction caches that do not participate in the system cache coherence mechanism. Additionally, the instruction cache load may also load a shared instruction and data cache lower in the cache hierarchy. This can lead to a situation where the instruction cache issues a shared read operation to the system for a coherence granule that is owned by that processor’s data cache, resulting in a cache coherence paradox to the home memory directory. </P>

<P>Due to this situation, an instruction read operation must behave like a coherent shared read relative to the memory directory and as a non-coherent operation relative to the requestor. Therefore, the behavior of the instruction read operation is nearly identical to a data read operation with the only difference being the way that the apparent coherence paradox is managed. </P>

<P>The IREAD_HOME and RESPONSE transactions are used during an instruction read operation by a processing element that needs a copy of sharable instructions from the memory system. An instruction read operation always returns one coherence granule-sized data payload. Use of the IREAD_HOME transaction rather than the READ_HOME transaction allows the memory directory to properly handle the paradox case without sacrificing coherence error detection in the system. The IREAD_HOME transaction participates in address collision detection at the home memory but does not participate in address collision detection at the requestor. </P>

<P>The following types of instruction read operations are possible: </P>

<P>RapidIO Trade Association </P>

<P>• If the requested instructions exists in the memory directory as shared, the instructions can be returned immediately from memory and the requesting processing element’s device ID is added to the sharing mask as shown in 
<Link>Figure 3-4. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_64.jpg"/>
Requestor Home Memory DONE, data 2 IREAD_HOME1 </Figure>

<P>Figure 3-4. Instruction Read Operation to Remote Shared Coherence Granule </P>

<P>• If the requested data exists in the memory directory as modified, the up-to-date (current) data must be obtained from the owner. The home memory then sends a READ_OWNER request to the processing element that owns the coherence granule. The owner passes a copy of the data to the original requestor and to memory, memory is updated, and the directory state is changed from modified and owner to shared by the previous owner and the 
<Link>requesting processing element’s device ID as shown in Figure 3-5. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_65.jpg"/>
Requestor Home Memory DONE_INTERV Owner 5 IREAD_HOME 1 READ_OWNER2 INTERV, data 4 DATA_ONLY, data 3 </Figure>

<P>Figure 3-5. Instruction Read Operation to Remote Modified Coherence Granule </P>

<P>• If the processing element requesting a modified coherence granule happens to be the home for the memory the READ_OWNER transaction is used to 
<Link>obtain the coherence granule as shown in Figure 3-6. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_66.jpg"/>
Requestor, INTERV, data 2 READ_OWNER 1 Owner Home Memory </Figure>

<P>Figure 3-6. Instruction Read Operation to Local Modified Coherence Granule </P>

<P>• The apparent paradox case is if the requesting processing element is the owner 
<Link>of the coherence granule as shown in Figure 3-7. The home memory sends a </Link>
READ_OWNER transaction back to the requesting processing element with the source and secondary ID set to the home memory ID, which indicates that </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>the response behavior should be an INTERVENTION transaction rather than an INTERVENTION and a DATA_ONLY transaction as shown in 
<Link>Figure 3-5. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_67.jpg"/>
Home Memory Requestor READ_OWNER 2 IREAD_HOME 1 and Owner INTERV, data 3 DONE, data 4 </Figure>

<P>Figure 3-7. Instruction Read Operation Paradox Case </P>

<P id="LinkTarget_30621">3.3.3 Read-for-Ownership Operations </P>

<P>The READ_TO_OWN_HOME, READ_TO_OWN_OWNER, DKILL_SHARER, and RESPONSE transactions are used during read-for-ownership operations by a processing element that needs to write to a coherence granule that does not exist in its caching hierarchy. A read-for-ownership operation always returns one coherence granule-sized data payload. These transactions are used as follows: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> The READ_TO_OWN_HOME transaction is used by a processing element that needs to read a writable copy of a coherence granule from a remote home memory on another processing element. This transaction causes a copy of the data to be returned to the requestor, from memory if the data is shared, or from the owner if it is modified. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The READ_TO_OWN_OWNER transaction is used by a home memory processing element that needs to read a writable copy of a coherence granule that is owned by a remote processing element. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The DKILL_SHARER transaction is used by the home memory processing element to invalidate shared copies of the coherence granule in remote processing elements. </LI_Title>
</LI>
</L>

<P>Following are descriptions of the read-for-ownership operations: </P>

<P>• If the coherence granule is shared, DKILL_SHARER transactions are sent to the participants indicated in the sharing mask, which results in a cache 
<Link>invalidate operation for the recipients as shown in Figure 3-8. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_68.jpg"/>
Requestor Home Memory DONE, data Sharers 4 READ_TO_OWN_HOME 1 DKILL_SHARER 2 DONEs 3 </Figure>

<P>Figure 3-8. Read-for-Ownership Operation to Remote Shared Coherence Granule </P>

<P>RapidIO Trade Association </P>

<P>• If the coherence granule is modified, a READ_TO_OWN_OWNER transaction is sent to the owner, who sends a copy of the data to the requestor 
<Link>(intervention) and marks the address as invalid as shown in Figure 3-9. The </Link>
final memory directory state shows that the coherence granule is modified and owned by the requestor’s device ID. </P>

<P>Because the coherence granule in the memory directory was marked as modified, home memory does not necessarily need to be updated. However, the RapidIO protocol requires that a processing element return the modified data and update the memory, allowing some attempt for data recovery if a coherence problem occurs. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_69.jpg"/>
Requestor Home Memory DONE_INTERV Owner 5 READ_TO_OWN_HOME 1 READ_TO_OWN_OWNER 2 INTERV, data 4 DATA_ONLY, data 3 </Figure>

<P>Figure 3-9. Read-for-Ownership Operation to Remote Modified Coherence Granule </P>

<P>• If the requestor is on the same processing element as the home memory and the coherence granule is shared, a DKILL_SHARER transaction is sent to all 
<Link>sharing processing elements (see Figure 3-10). The final directory state is </Link>
marked as modified and owned by the local requestor. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_70.jpg"/>
Requestor, DONEs 2 DKILL_SHARER 1 SharersHome Memory </Figure>

<P>Figure 3-10. Read-for-Ownership Operation to Local Shared Coherence Granule </P>

<P>• If the requestor is on the same processing element as the home memory and the coherence granule is owned by a remote processing element, a READ_TO_OWN_OWNER transaction is sent to the owner (see 
<Link>Figure 3-11). The final directory state is marked as modified and owned by </Link>
the local requestor. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_71.jpg"/>
Requestor, INTERV, data 2 READ_TO_OWN_OWNER 1 Owner Home Memory </Figure>

<P>Figure 3-11. Read-for-Ownership Operation to Local Modified Coherence Granule </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30622">3.3.4 Data Cache Invalidate Operations </P>

<P>The DKILL_HOME, DKILL_SHARER, and RESPONSE transactions are requests to invalidate a coherence granule in all of the participants in the coherence domain as follows: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> The DKILL_HOME transaction is used by a processing element to invalidate a data coherence granule that has home memory in a remote processing element. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The DKILL_SHARER transaction is used by the home memory processing element to invalidate shared copies of the data coherence granule in remote processing elements. </LI_Title>
</LI>
</L>

<P>Data cache invalidate operations are also useful for systems that implement software-maintained cache coherence. In this case, a requestor may send DKILL_HOME and DKILL_SHARER transactions directly to other processing elements without going through home memory as in a CC-NUMA system. The transactions used for the data cache invalidate operation depend on whether the requestor is on the same processing element as the home memory of the coherence granule as follows: </P>

<P>• If the requestor is not on the same processing element as the home memory of the coherence granule, a DKILL_HOME transaction is sent to the remote home memory processing element. This causes the home memory for the shared coherence granule to send a DKILL_SHARER to all processing elements marked as sharing the granule in the memory directory state except 
<Link>for the requestor (see Figure 3-12). The final memory state shows that the </Link>
coherence granule is modified and owned by the requesting processing element’s device ID. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_72.jpg"/>
Requestor Home Memory DONE Sharers 4 DKILL_HOME 1 DKILL_SHARER 2 DONEs 3 </Figure>

<P>Figure 3-12. Data Cache Invalidate Operation to Remote Shared Coherence Granule </P>

<P>RapidIO Trade Association </P>

<P>• If the requestor is on the same processing element as the home memory of the coherence granule, the home memory sends a DKILL_SHARER transaction to all processing elements marked as sharing the coherence granule in the memory directory. The final memory state shows the coherence granule 
<Link>modified and owned by the local processor (see Figure 3-13). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_73.jpg"/>
Requestor, DONEs 2 DKILL_SHARER 1 SharersHome Memory </Figure>

<P>Figure 3-13. Data Cache Invalidate Operation to Local Shared Coherence Granule </P>

<P id="LinkTarget_30623">3.3.5 Castout Operations </P>

<P>The CASTOUT and RESPONSE transactions are used in a castout operation by a processing element to relinquish its ownership of a coherence granule and return it to the home memory. The CASTOUT can be treated as a low-priority transaction unless there is an address collision with an incoming request, at which time it must become a high-priority transaction. The CASTOUT causes the home memory to be updated with the most recent data and changes the directory state to owned by home memory and shared (or owned, depending upon the default directory state) by the 
<Link>local processing element (see Figure 3-14). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_74.jpg"/>
DONE 2 CASTOUT, data 1 Requestor Home Memory </Figure>

<P>Figure 3-14. Castout Operation on Remote Modified Coherence Granule </P>

<P>A CASTOUT transaction does not participate in address collision detection at the home memory to prevent deadlocks or cache paradoxes caused by packet-to-packet timing in the interconnect fabric. For example, consider a case where processing element A is performing a CASTOUT that collides with an incoming READ_OWNER transaction. If the CASTOUT is not allowed to complete at the home memory, the system will deadlock. If the read operation that caused the READ_OWNER completes (through intervention) before the CASTOUT transaction is received at the home memory, the CASTOUT will appear to be illegal because the directory state will have changed. </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30624">3.3.6 TLB Invalidate-Entry Operations </P>

<P>The TLBIE and RESPONSE transactions are used for TLB invalidate-entry operations. If the processor TLBs do not participate in the cache coherence protocol, the TLB invalidate-entry operation is used when page table translation entries need to be modified. The TLBIE transaction is sent to all participants in the coherence domain except for the original requestor. A TLBIE transaction has no effect on the memory directory state for the specified address and does not participate in address collisions (see 
<Link>Figure 3-15). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_75.jpg"/>
Requestor DONEs All 2 TLBIE 1 Participants </Figure>

<P>Figure 3-15. TLB Invalidate-Entry Operation </P>

<P id="LinkTarget_30625">3.3.7 TLB Invalidate-Entry Synchronization Operations </P>

<P>The TLBSYNC and RESPONSE transactions are used for TLB invalidate-entry synchronization operations. It is used to force the completion of outstanding TLBIE transactions at the participants. The DONE response for a TLBSYNC transaction is only sent when all preceding TLBIE transactions have completed. This operation is necessary due to possible indeterminate completion of individual TLBIE transactions when multiple TLBIE transactions are being executed simultaneously. The TLBSYNC transaction is sent to all participants in the coherence domain except for the original requestor. The transaction has no effect on the memory directory state for the specified address and does not participate in address collisions (see 
<Link>Figure 3-16). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_76.jpg"/>
Requestor DONEs All 2 TLBSYNC 1 Participants </Figure>

<P>Figure 3-16. TLB Invalidate-Entry Synchronization Operation </P>

<P id="LinkTarget_30626">3.3.8 Instruction Cache Invalidate Operations </P>

<P>The IKILL_HOME, IKILL_SHARER, and RESPONSE transactions are used during instruction cache invalidate operations to invalidate shared copies of an instruction coherence granule in remote processing elements. Instruction cache invalidate operations are needed if the processor instruction caches do not participate in the cache coherence protocol, requiring instruction cache coherence to be maintained by software. </P>

<P>RapidIO Trade Association </P>

<P>An instruction cache invalidate operation has no effect on the memory directory state for the specified address and does not participate in address collisions. Following are descriptions of the instruction cache invalidate operations: </P>

<P>• If the requestor is not on the same processing element as the home memory of the coherence granule, an IKILL_HOME transaction is sent to the remote home memory processing element. This causes the home memory for the shared coherence granule to send an IKILL_SHARER to all processing element participants in the coherence domain because the memory directory 
<Link>state only properly tracks data, not instruction, accesses. (See Figure 3-17.) </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_77.jpg"/>
Requestor Home Memory DONE Participants 4 IKILL_HOME1 IKILL_SHARER 2 DONEs 3 </Figure>

<P>Figure 3-17. Instruction Cache Invalidate Operation to Remote Sharable Coherence Granule </P>

<P>• If the requestor is on the same processing element as the home memory of the coherence granule, the home memory sends an IKILL_SHARER transaction to all processing element participants in the coherence domain as shown in 
<Link>Figure 3-18. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_78.jpg"/>
Requestor, DONEs 2 IKILL_SHARER1 Participants Home Memory </Figure>

<P>Figure 3-18. Instruction Cache Invalidate Operation to Local Sharable Coherence Granule </P>

<P id="LinkTarget_30627">3.3.9 Data Cache Flush Operations </P>

<P>The FLUSH, DKILL_SHARER, READ_TO_OWN_OWNER, and RESPONSE transactions are used for data cache flush operations, which return ownership of a coherence granule back to the home memory if it is modified and invalidate all copies if the granule is shared. A flush operation with associated data can be used to implement an I/O system write operation and to implement processor write-through and cache manipulation operations. These transactions are used as follows: </P>

<P>• The FLUSH transaction is used by a processing element to return the ownership and current data of a coherence granule to home memory. The data payload for the FLUSH transaction is typically the size of the coherence granule for the system but may be multiple double-words or one double-word or less. FLUSH transactions without a data payload are used to support cache </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>manipulation operations. The memory directory state is changed to owned by </P>

<P>home memory and shared (or modified, depending upon the processing </P>

<P>element’s normal default state) by the local processing element. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> The DKILL_SHARER transaction is used by the home memory processing element to invalidate shared copies of the data coherence granule in remote processing elements. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The READ_TO_OWN_OWNER transaction is used by a home memory processing element that needs to retrieve ownership of a coherence granule that is owned by a remote processing element. </LI_Title>
</LI>
</L>

<P>The FLUSH transaction is able to specify multiple double-word and sub-double-word data payloads; however, they must be aligned to byte, half-word, word, or double-word boundaries. Multiple double-word FLUSH transactions cannot exceed the number of double-words in the coherence granule. The write size 
<Link>and alignment for the FLUSH transaction are specified in Table 4-8. Unaligned and </Link>
non-contiguous operations are not supported and must be broken into multiple FLUSH transactions by the sending processing element. </P>

<P>A flush operation internal to a processing element that would cause a FLUSH transaction for a remote coherence granule owned by that processing element (for example, attempting a cache write-through operation to a locally owned remote coherence granule) must generate a CASTOUT rather than a FLUSH transaction to properly implement the RapidIO protocol. Issuing a FLUSH under these circumstances generates a memory directory state paradox error in the home memory processing element. </P>

<P>Following are descriptions of the flush operations: </P>

<P>• If a flush operation is to a remote shared coherence granule, the FLUSH transaction is sent to the home memory, which sends a DKILL_SHARER transaction to all of the processing elements marked in the sharing list except for the requesting processing element. The processing elements that receive the DKILL_SHARER transaction invalidate the specified address if it is 
<Link>found shared in their caching hierarchy (see Figure 3-19). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_79.jpg"/>
Requestor Home Memory DONE Sharers 4 FLUSH, data (opt.) 1 DKILL_SHARER 2 DONEs 3 </Figure>

<P>Figure 3-19. Flush Operation to Remote Shared Coherence Granule </P>

<P>RapidIO Trade Association </P>

<P>• If the coherence granule is owned by a remote processing element, the home memory sends a READ_TO_OWN_OWNER transaction to it with the secondary (intervention) ID set to the home memory ID instead of the requestor ID. The owner then invalidates the coherence granule in its caching 
<Link>hierarchy and returns the coherence granule data (see Figure 3-20). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_80.jpg"/>
Requestor Home Memory DONE Owner 4 FLUSH, data (opt.) 1 READ_TO_OWN_OWNER 2 INTERV, data 3 </Figure>

<P>Figure 3-20. Flush Operation to Remote Modified Coherence Granule </P>

<P>• If the requestor and the home memory for the coherence granule are in the same processing element, DKILL_SHARER transactions are sent to all 
<Link>participants marked in the sharing list (see Figure 3-21). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_81.jpg"/>
Requestor, DONEs 2 DKILL_SHARER 1 SharersHome Memory </Figure>

<P>Figure 3-21. Flush Operation to Local Shared Coherence Granule </P>

<P>• If the requestor and the home memory for the coherence granule are in the same processing element but the coherence granule is owned by a remote processing element, a READ_TO_OWN_OWNER transaction is sent to the 
<Link>owner (see Figure 3-22). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_82.jpg"/>
Requestor, INTERV, data 2 READ_TO_OWN_OWNER 1 Owner Home Memory </Figure>

<P>Figure 3-22. Flush Operation to Local Modified Coherence Granule </P>

<P id="LinkTarget_30628">3.3.10 I/O Read Operations </P>

<P>The IO_READ_HOME, IO_READ_OWNER, and RESPONSE transactions are used during I/O read operations by a processing element that needs a current copy of cache-coherent data from the memory system, but does not need to be added to the sharing list in the memory directory state. The I/O read operation is most useful for DMA I/O devices. An I/O read operation always returns the requested size data payload. The requested data payload size can not exceed the size of the coherence </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>granule. These transactions are used as follows: </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>The IO_READ_HOME transaction is used by a requestor that is not in the same processing element as the home memory for the coherence granule. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The IO_READ_OWNER transaction is used by a home memory processing element that needs to read a copy of a coherence granule owned by a remote processing element. </LI_Title>
</LI>
</L>

<P>Following are descriptions of the I/O operations: </P>

<P>• If the requested data exists in the memory directory as shared, the data can be returned immediately from memory and the sharing mask is not modified (see 
<Link>Figure 3-24). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_83.jpg"/>
Requestor Home Memory DONE, data 2 IO_READ_HOME 1 </Figure>

<P>Figure 3-23. I/O Read Operation to Remote Shared Coherence Granule </P>

<P>• If the requested data exists in the memory directory as modified, the home memory sends an IO_READ_OWNER transaction to the processing element that owns the coherence granule. The owner passes a copy of the data to the requesting processing element (intervention) but retains ownership of and 
<Link>responsibility for the coherence granule (see Figure 3-24 and Figure 3-25). </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_84.jpg"/>
Requestor Home Memory DONE_INTERV Owner 5 IO_READ_HOME 1 IO_READ_OWNER 2 INTERV 4 DATA_ONLY, data 3 </Figure>

<P>Figure 3-24. I/O Read Operation to Remote Modified Coherence Granule </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_85.jpg"/>
Requestor, INTERV, data 2 IO_READ_OWNER 1 Owner Home Memory </Figure>

<P>Figure 3-25. I/O Read Operation to Local Modified Coherence Granule </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30629">3.4 Endian, Byte Ordering, and Alignment </P>

<P>RapidIO has double-word (8-byte) aligned big-endian data payloads. This means that the RapidIO interface to devices that are little-endian shall perform the proper endian transformation to format a data payload. </P>

<P>Operations that specify data quantities that are less than 8 bytes shall have the bytes aligned to their proper byte position within the big-endian double-word, as in the 
<Link>examples shown in Figure 3-26 through Figure 3-28. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_86.jpg"/>
Byte 0 1 2 3 4 5 6 7 </Figure>

<P>Byte address 0x0000_0002, the proper byte position is shaded. </P>

<P>Figure 3-26. Byte Alignment Example </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_87.jpg"/>
Byte 0 1 2 3 4 5 6 7 MSB LSB </Figure>

<P>Half-word address 0x0000_0002, the proper byte positions are shaded. </P>

<P>Figure 3-27. Half-Word Alignment Example </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_88.jpg"/>
Byte 0 1 2 3 4 5 6 7 MSB LSB </Figure>

<P>Word address 0x0000_0004, the proper byte positions are shaded. </P>

<P>Figure 3-28. Word Alignment Example </P>

<P>For write operations, a processing element shall properly align data transfers to a double-word boundary for transmission to the destination. This alignment may require breaking up a data stream into multiple transactions if the data is not naturally aligned. A number of data payload sizes and double-word alignments are 
<Link>defined to minimize this burden. Figure 3-29 shows a 48-byte data stream that a </Link>
processing element wishes to write to another processing element through the interconnect fabric. The data displayed in the figure is big-endian and double-word aligned with the bytes to be written shaded in grey. Because the start of the stream and the end of the stream are not aligned to a double-word boundary, the sending processing element shall break the stream into three transactions as shown in the figure. </P>

<P>The first transaction sends the first three bytes (in byte lanes 5, 6, and 7) and indicates a byte lane 5, 6, and 7 three-byte write. The second transaction sends all of the remaining data except for the final sub-double-word. The third transaction sends the final 5 bytes in byte lanes 0, 1, 2, 3, and 4 indicating a five-byte write in byte </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>lanes 0, 1, 2, 3, and 4. </P>

<Table>
<TR>
<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>

<TD>Byte Lane </TD>
</TR>

<TR>
<TD>0 </TD>

<TD>1 </TD>

<TD>2 </TD>

<TD>3 </TD>

<TD>4 </TD>

<TD>5 </TD>

<TD>6 </TD>

<TD>7 </TD>
</TR>
</Table>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_89.jpg"/>
MSB LSB </Figure>

<P>Double-Word Boundary </P>

<P>First transaction sends these three bytes with this double-word alignment </P>

<P>Second transaction sends these five double-words </P>

<P>Third transaction sends these five bytes with this double-word alignment </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_90.jpg"/>
</Figure>

<P>Figure 3-29. Data Alignment Example </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30630">Chapter 4 Packet Format Descriptions </P>

<P id="LinkTarget_30631">4.1 Introduction </P>

<P>This chapter contains the packet format definitions for the RapidIO Interconnect Globally Shared Memory Logical Specification. There are four types of globally shared memory packet formats: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Request </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Response </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Implementation-defined </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Reserved </LI_Title>
</LI>
</L>

<P>The packet formats are intended to be interconnect fabric independent, so the system interconnect can be anything required for a particular application. Reserved formats, unless defined in another logical specification, shall not be used by a device. </P>

<P id="LinkTarget_30632">4.2 Request Packet Formats </P>

<P>A request packet is issued by a processing element that needs a remote processing element to accomplish some activity on its behalf, such as a memory read operation. The request packet format types and their transactions for the RapidIO Interconnect Globally Shared Memory Logical Specification
<Link> are shown in Table 4-1. </Link>
</P>

<Table>
<Caption>
<P>Table 4-1. Request Packet Type to Transaction Type Cross Reference </P>
</Caption>

<TR>
<TH>Request Packet Format Type </TH>

<TH>Transaction Type </TH>

<TH>Definition </TH>

<TH>Document Section No. </TH>
</TR>

<TR>
<TH>Type 0 </TH>

<TD>Implementation-defined </TD>

<TD>Defined by the device implementation </TD>

<TD>
<Link>Section 4.2.4 </Link>
</TD>
</TR>

<TR>
<TH/>

<TD>READ_OWNER </TD>

<TD>Read shared copy of remotely owned coherence granule </TD>

<TD>
<Link>Section 4.2.5 </Link>
</TD>
</TR>

<TR>
<TH>Type 1 </TH>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Read for store of remotely owned coherence granule </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>Read for I/O of remotely owned coherence granule </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Request Packet Format Type </TH>

<TH>Transaction Type </TH>

<TH>Definition </TH>

<TH>Document Section No. </TH>
</TR>

<TR>
<TH>Type 2 </TH>

<TD>READ_TO_OWN_HOME </TD>

<TD>Read for store of home memory for coherence granule </TD>

<TD>
<Link>Section 4.2.6 </Link>
</TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>Read shared copy of home memory for coherence granule </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>Read for I/O of home memory for coherence granule </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>Invalidate to home memory of coherence granule </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>Invalidate to home memory of coherence granule </TD>
</TR>

<TR>
<TD>TLBIE </TD>

<TD>Invalidate TLB entry </TD>
</TR>

<TR>
<TD>TLBSYNC </TD>

<TD>Synchronize TLB invalidates </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>Read shared copy of home memory for instruction cache </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>Force return of ownership of coherence granule to home memory, no update to coherence granule </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>Invalidate cached copy of coherence granule </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>Invalidate cached copy of coherence granule </TD>
</TR>

<TR>
<TH>Type 3–4 </TH>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.2.7 </Link>
</TD>
</TR>

<TR>
<TH>Type 5 </TH>

<TD>CASTOUT </TD>

<TD>Return ownership of coherence granule to home memory </TD>

<TD>
<Link>Section 4.2.8 </Link>
</TD>
</TR>

<TR>
<TD>FLUSH (with data) </TD>

<TD>Force return of ownership of coherence granule to home memory, update returned coherence granule </TD>
</TR>

<TR>
<TH>Type 6–11 </TH>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.2.9 </Link>
</TD>
</TR>
</Table>

<P id="LinkTarget_30633">4.2.1 Addressing and Alignment </P>

<P>The size of the address is defined as a system-wide parameter; thus the packet formats do not support mixed local physical address fields simultaneously. The least three significant bits of all addresses are not specified and are assumed to be logic 0. </P>

<P>The coherence-granule-sized cache-coherent write requests and read responses are aligned to a double-word boundary within the coherence granule, with the specified data payload size matching that of the coherence granule. Sub-double-word data payloads must be padded and properly aligned within the 8-byte boundary. Non-contiguous or unaligned transactions that would ordinarily require a byte mask are not supported. A sending device that requires this behavior must break the operation into multiple request transactions. An example of this is shown in 
<Link>Section 3.4, “Endian, Byte Ordering, and Alignment.” </Link>
</P>

<P id="LinkTarget_30634">4.2.2 Data Payloads </P>

<P>Cache coherent systems are very sensitive to memory read latency. One way of reducing the latency is by returning the requested, or critical, double-word first upon a read request. Subsequent double-words are then returned in a sequential fashion. 
<Link>Table 4-2 and Table 4-3 show the return ordering for 32- and 64-byte coherence </Link>
</P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>granules. Sub-double-word data payloads due to I/O read operations start with the requested size as shown. </P>

<Table>
<Caption>
<P>Table 4-2. Coherent 32-Byte Read Data Return Ordering </P>
</Caption>

<TR>
<TH>Requested Double-word </TH>

<TH>Double-word Return Ordering </TH>
</TR>

<TR>
<TH>0 </TH>

<TD>0, 1, 2, 3 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>1, 2, 3, 0 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>2, 3, 0, 1 </TD>
</TR>

<TR>
<TH>3 </TH>

<TD>3, 0, 1, 2 </TD>
</TR>
</Table>

<P>Table 4-3. Coherent 64-Byte Read Data Return Ordering </P>

<Table>
<TR>
<TH>Requested Double-word </TH>

<TH>Double-word Return Ordering </TH>
</TR>

<TR>
<TH>0 </TH>

<TD>0, 1, 2, 3, 4, 5, 6, 7 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>1, 2, 3, 0, 4, 5, 6, 7 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>2, 3, 0, 1, 4, 5, 6, 7 </TD>
</TR>

<TR>
<TH>3 </TH>

<TD>3, 0, 1, 2, 4, 5, 6, 7 </TD>
</TR>

<TR>
<TH>4 </TH>

<TD>4, 5, 6, 7, 0, 1, 2, 3 </TD>
</TR>

<TR>
<TH>5 </TH>

<TD>5, 6, 7, 4, 0, 1, 2, 3 </TD>
</TR>

<TR>
<TH>6 </TH>

<TD>6, 7, 4, 5, 0, 1, 2, 3 </TD>
</TR>

<TR>
<TH>7 </TH>

<TD>7, 4, 5, 6, 0, 1, 2, 3 </TD>
</TR>
</Table>

<P>Data payloads for cache coherent write-type transactions are always linear starting with the specified address at the first double-word to be written, (including flush transactions that are not the size of the coherence granule). Data payloads that cross the coherence granule boundary can not be specified. This implies that all castout 
<Link>transactions start with the first double-word in the coherence granule. Table 4-4 and </Link>

<Link>Table 4-5 show</Link>
 the cache-coherent write-data ordering for 32- and 64-byte coherence granules, respectively. </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Starting Double-word </TH>

<TH>Number of Double-words </TH>

<TH>Double-word Data Ordering Within Coherence Granule </TH>
</TR>

<TR>
<TH>0 </TH>

<TD>1 </TD>

<TD>0 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>2 </TD>

<TD>0, 1 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>3 </TD>

<TD>0, 1, 2 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>4 </TD>

<TD>0, 1, 2, 3 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>1 </TD>

<TD>1 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>2 </TD>

<TD>1, 2 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>3 </TD>

<TD>1, 2, 3 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>1 </TD>

<TD>2 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>2 </TD>

<TD>2, 3 </TD>
</TR>

<TR>
<TH>3 </TH>

<TD>1 </TD>

<TD>3 </TD>
</TR>

<Caption>
<P>Table 4-5. Coherent 64-Byte Write Data Payloads </P>
</Caption>
</Table>

<Table>
<TR>
<TH>Starting Double-word </TH>

<TH>Number of Double-words </TH>

<TH>Double-word Data Ordering Within Coherence Granule </TH>
</TR>

<TR>
<TH>0 </TH>

<TD>1 </TD>

<TD>0 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>2 </TD>

<TD>0, 1 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>3 </TD>

<TD>0, 1, 2 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>4 </TD>

<TD>0, 1, 2, 3 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>5 </TD>

<TD>0, 1, 2, 3, 4 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>6 </TD>

<TD>0, 1, 2, 3, 4, 5 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>7 </TD>

<TD>0, 1, 2, 3, 4, 5, 6 </TD>
</TR>

<TR>
<TH>0 </TH>

<TD>8 </TD>

<TD>0, 1, 2, 3, 4, 5, 6, 7 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>1 </TD>

<TD>1 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>2 </TD>

<TD>1, 2 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>3 </TD>

<TD>1, 2, 3 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>4 </TD>

<TD>1, 2, 3, 4 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>5 </TD>

<TD>1, 2, 3, 4, 5 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>6 </TD>

<TD>1, 2, 3, 4, 5, 6 </TD>
</TR>

<TR>
<TH>1 </TH>

<TD>7 </TD>

<TD>1, 2, 3, 4, 5, 6, 7 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>1 </TD>

<TD>2 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>2 </TD>

<TD>2, 3 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>3 </TD>

<TD>2, 3, 4 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>4 </TD>

<TD>2, 3, 4, 5 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>5 </TD>

<TD>2, 3, 4, 5, 6 </TD>
</TR>

<TR>
<TH>2 </TH>

<TD>6 </TD>

<TD>2, 3, 4, 5, 6, 7 </TD>
</TR>

<TR>
<TH>3 </TH>

<TD>1 </TD>

<TD>3 </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 Table 4-5. Coherent 64-Byte Write Data Payloads (Continued) </P>

<Table>
<TR>
<TH>Starting Double-word </TH>

<TH>Number of Double-words </TH>

<TH>Double-word Data Ordering Within Coherence Granule </TH>
</TR>

<TR>
<TH>3 </TH>

<TD>2 </TD>

<TD>3, 4 </TD>
</TR>

<TR>
<TH>3 </TH>

<TD>3 </TD>

<TD>3, 4, 5 </TD>
</TR>

<TR>
<TH>3 </TH>

<TD>4 </TD>

<TD>3, 4, 5, 6 </TD>
</TR>

<TR>
<TH>3 </TH>

<TD>5 </TD>

<TD>3, 4, 5, 6, 7 </TD>
</TR>

<TR>
<TH>4 </TH>

<TD>1 </TD>

<TD>4 </TD>
</TR>

<TR>
<TH>4 </TH>

<TD>2 </TD>

<TD>4, 5 </TD>
</TR>

<TR>
<TH>4 </TH>

<TD>3 </TD>

<TD>4, 5, 6 </TD>
</TR>

<TR>
<TH>4 </TH>

<TD>4 </TD>

<TD>4, 5, 6, 7 </TD>
</TR>

<TR>
<TH>5 </TH>

<TD>1 </TD>

<TD>5 </TD>
</TR>

<TR>
<TH>5 </TH>

<TD>2 </TD>

<TD>5, 6 </TD>
</TR>

<TR>
<TH>5 </TH>

<TD>3 </TD>

<TD>5, 6, 7 </TD>
</TR>

<TR>
<TH>6 </TH>

<TD>1 </TD>

<TD>6 </TD>
</TR>

<TR>
<TH>6 </TH>

<TD>2 </TD>

<TD>6, 7 </TD>
</TR>

<TR>
<TH>7 </TH>

<TD>1 </TD>

<TD>7 </TD>
</TR>
</Table>

<P id="LinkTarget_30635">4.2.3 Field Definitions for All Request Packet Formats </P>

<P>Fields that are unique to type 1, type 2, and type 5 formats are defined in their sections. Bit fields that are defined as “reserved” shall be assigned to logic 0s when generated and ignored when received. Bit field encodings that are defined as “reserved” shall not be assigned when the packet is generated. A received reserved encoding is regarded as an error if a meaningful encoding is required for the transaction and function, otherwise it is ignored. Implementation-defined fields shall be ignored unless the encoding is understood by the receiving device. All packets described are bit streams from the first bit to the last bit, represented in the figures from left to right respectively. </P>

<P>
<Link>The following field definitions in Table 4-6 apply to all of the request packet </Link>
formats. </P>

<Table>
<Caption>
<P>Table 4-6. General Field Definitions for All Request Packets </P>
</Caption>

<TR>
<TD>Field </TD>

<TD>Definition </TD>
</TR>

<TR>
<TD>ftype </TD>

<TD>Format type, represented as a 4-bit value; is always the first four bits in the logical packet stream. </TD>
</TR>

<TR>
<TD>wdptr </TD>

<TD>
<Link>Word pointer, used in conjunction with the data size (rdsize and wrsize) fields—see Table 4-7, Table 4-8, and Section 3.4. </Link>
</TD>
</TR>

<TR>
<TD>rdsize </TD>

<TD>
<Link>Data size for read transactions, used in conjunction with the word pointer (wdptr) bit—see Table 4-7 and Section 3.4. </Link>
</TD>
</TR>

<TR>
<TD>wrsize </TD>

<TD>
<Link>Write data size for sub-double-word transactions, used in conjunction with the word pointer (wdptr) bit—see Table 4-8 and Section 3.4. For writes greater than one double-word, the size is the maximum payload. </Link>
</TD>
</TR>

<TR>
<TD>rsrv </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Field </TD>

<TD>Definition </TD>
</TR>

<TR>
<TD>srcTID </TD>

<TD>The packet’s transaction ID. </TD>
</TR>

<TR>
<TD>transaction </TD>

<TD>The specific transaction within the format class to be performed by the recipient; also called type or ttype. </TD>
</TR>

<TR>
<TD>extended address </TD>

<TD>Optional. Specifies the most significant 16 bits of a 50-bit physical address or 32 bits of a 66-bit physical address. </TD>
</TR>

<TR>
<TD>xamsbs </TD>

<TD>Extended address most significant bits. Further extends the address specified by the address and extended address fields by 2 bits. This field provides 34-, 50-, and 66-bit addresses to be specified in a packet with the xamsbs as the most significant bits in the address. </TD>
</TR>

<TR>
<TD>address </TD>

<TD>Least significant 29 bits (bits [0-28] of byte address [0-31]) of the double-word physical address </TD>
</TR>

<Caption>
<P>Table 4-7. Read Size (rdsize) Definitions </P>
</Caption>
</Table>

<Table>
<TR>
<TH>wdptr </TH>

<TH>rdsize </TH>

<TH>Number of Bytes </TH>

<TH>Byte Lanes </TH>

<TH>Comment </TH>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0000 </TD>

<TD>1 </TD>

<TD>0b10000000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0001 </TD>

<TD>1 </TD>

<TD>0b01000000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0010 </TD>

<TD>1 </TD>

<TD>0b00100000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0011 </TD>

<TD>1 </TD>

<TD>0b00010000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0000 </TD>

<TD>1 </TD>

<TD>0b00001000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0001 </TD>

<TD>1 </TD>

<TD>0b00000100 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0010 </TD>

<TD>1 </TD>

<TD>0b00000010 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0011 </TD>

<TD>1 </TD>

<TD>0b00000001 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0100 </TD>

<TD>2 </TD>

<TD>0b11000000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0101 </TD>

<TD>3 </TD>

<TD>0b11100000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0110 </TD>

<TD>2 </TD>

<TD>0b00110000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0111 </TD>

<TD>5 </TD>

<TD>0b11111000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0100 </TD>

<TD>2 </TD>

<TD>0b00001100 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0101 </TD>

<TD>3 </TD>

<TD>0b00000111 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0110 </TD>

<TD>2 </TD>

<TD>0b00000011 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0111 </TD>

<TD>5 </TD>

<TD>0b00011111 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1000 </TD>

<TD>4 </TD>

<TD>0b11110000 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1000 </TD>

<TD>4 </TD>

<TD>0b00001111 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1001 </TD>

<TD>6 </TD>

<TD>0b11111100 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1001 </TD>

<TD>6 </TD>

<TD>0b00111111 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1010 </TD>

<TD>7 </TD>

<TD>0b11111110 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1010 </TD>

<TD>7 </TD>

<TD>0b01111111 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1011 </TD>

<TD>8 </TD>

<TD>0b11111111 </TD>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1011 </TD>

<TD>16 </TD>

<TD/>

<TD>I/O read only </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1100 </TD>

<TD>32 </TD>

<TD/>

<TD/>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 Table 4-7. Read Size (rdsize) Definitions (Continued) </P>

<Table>
<TR>
<TH>wdptr </TH>

<TH>rdsize </TH>

<TH>Number of Bytes </TH>

<TH>Byte Lanes </TH>

<TH>Comment </TH>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1100 </TD>

<TD>64 </TD>

<TD/>

<TD/>
</TR>

<TR>
<TD>0b0-1 </TD>

<TD>0b1101 0b1111 </TD>

<TD/>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<Table>
<Caption>
<P>Table 4-8. Write Size (wrsize) Definitions </P>
</Caption>

<TR>
<TH>wdptr</TH>

<TH> wrsize </TH>

<TH>Number of Bytes </TH>

<TH>Byte Lanes </TH>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0000 </TD>

<TD>1 </TD>

<TD>0b10000000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0001 </TD>

<TD>1 </TD>

<TD>0b01000000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0010 </TD>

<TD>1 </TD>

<TD>0b00100000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0011 </TD>

<TD>1 </TD>

<TD>0b00010000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0000 </TD>

<TD>1 </TD>

<TD>0b00001000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0001 </TD>

<TD>1 </TD>

<TD>0b00000100 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0010 </TD>

<TD>1 </TD>

<TD>0b00000010 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0011 </TD>

<TD>1 </TD>

<TD>0b00000001 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0100 </TD>

<TD>2 </TD>

<TD>0b11000000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0101 </TD>

<TD>3 </TD>

<TD>0b11100000 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0110 </TD>

<TD>2 </TD>

<TD>0b00110000 </TD>
</TR>

<TR>
<TD>0b0</TD>

<TD> 0b0111 </TD>

<TD>5 </TD>

<TD>0b11111000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0100 </TD>

<TD>2 </TD>

<TD>0b00001100 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0101 </TD>

<TD>3 </TD>

<TD>0b00000111 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0110 </TD>

<TD>2 </TD>

<TD>0b00000011 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0111 </TD>

<TD>5 </TD>

<TD>0b00011111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1000 </TD>

<TD>4 </TD>

<TD>0b11110000 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1000 </TD>

<TD>4 </TD>

<TD>0b00001111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1001 </TD>

<TD>6 </TD>

<TD>0b11111100 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1001 </TD>

<TD>6 </TD>

<TD>0b00111111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1010 </TD>

<TD>7 </TD>

<TD>0b11111110 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1010 </TD>

<TD>7 </TD>

<TD>0b01111111 </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1011 </TD>

<TD>8 </TD>

<TD>0b11111111 </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1011 </TD>

<TD>16 maximum </TD>

<TD/>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1100 </TD>

<TD>32 maximum </TD>

<TD/>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1100 </TD>

<TD>64 maximum </TD>

<TD/>
</TR>

<TR>
<TD>0b0-1 </TD>

<TD>0b1101-1111 </TD>

<TD>Reserved </TD>

<TD/>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30636">4.2.4 Type 0 Packet Format (Implementation-Defined) </P>

<P>The type 0 packet format is reserved for implementation-defined functions such as flow control. </P>

<P id="LinkTarget_30637">4.2.5 Type 1 Packet Format (Intervention-Request Class) </P>

<P>Type 1 request packets never include data. They are the only request types that can cause an intervention, so the secondary domain, secondary ID, and secondary transaction ID fields are required. The total number of bits available for the 
<Link>secondary domain and secondary ID fields (shown in Figure 4-1) is determined by </Link>
the size of the transport field defined in the appropriate transport layer specification, so the size (labeled m and n, respectively) of these fields are not specified. The division of the bits between the logical coherence domain and device ID fields is determined by the specific application. For example, an 8 bit transport field allows 16 coherence domains of 16 participants. </P>

<P>The type 1 packet format is used for the READ_OWNER, READ_TO_OWN_OWNER, and IO_READ_OWNER transactions that are 
<Link>specified in the transaction sub-field column defined in Table 4-9. Type 1 packets </Link>
are issued only by a home memory controller to allow the third party intervention data transfer. </P>

<P>Definitions and encodings of fields specific to type 1 packets are displayed in 
<Link>Table 4-9. Fields that are not specific to type 1 packets are described in Table 4-6. </Link>
</P>

<Table>
<Caption>
<P>Table 4-9. Specific Field Definitions and Encodings for Type 1 Packets </P>
</Caption>

<TR>
<TH>Field </TH>

<TH>Encoding </TH>

<TH>Sub-Field </TH>

<TH>Definition </TH>
</TR>

<TR>
<TH>secID </TH>

<TD>— </TD>

<TD/>

<TD>Original requestor’s, or secondary, ID for intervention </TD>
</TR>

<TR>
<TH>secTID </TH>

<TD>— </TD>

<TD/>

<TD>Original requestor’s, or secondary, transaction ID for intervention </TD>
</TR>

<TR>
<TH>sec_domain </TH>

<TD>— </TD>

<TD/>

<TD>Original requestor’s, or secondary, domain for intervention </TD>
</TR>

<TR>
<TH>transaction </TH>

<TD>0b0000 </TD>

<TD>READ_OWNER </TD>

<TD/>
</TR>

<TR>
<TD>0b0001 </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD/>
</TR>

<TR>
<TD>0b0010 </TD>

<TD>IO_READ_OWNER </TD>

<TD/>
</TR>

<TR>
<TD>0b0011–1111 </TD>

<TD>Reserved </TD>

<TD/>
</TR>
</Table>

<P>
<Link>Figure 4-1 displays a type 1 packet with all its fields. The field value 0b0001 in </Link>
</P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>
<Link>Figure 4-1 specifies that the packet format is of type 1. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_91.jpg"/>
0 0 0 1 4 4 4 8 transaction rdsize srcTID sec_domain m n 8 secID secTID address extended address 0, 16, 32 wdptr xamsbs </Figure>

<P>29 1 2 </P>

<P>Figure 4-1. Type 1 Packet Bit Stream Format </P>

<P id="LinkTarget_30638">4.2.6 Type 2 Packet Format (Request Class) </P>

<P>Type 2 request packets never include data. They cannot cause an intervention so the secondary domain and ID fields specified in the intervention-request format are not required. This format is used for the READ_HOME, IREAD_HOME, READ_TO_OWN_HOME, IO_READ_HOME, DKILL_HOME, DKILL_SHARER, IKILL_HOME, IKILL_SHARER, TLBIE, and TLBSYNC 
<Link>transactions as specified in the transaction field defined in Table 4-10.</Link>
 Type 2 packets for READ_HOME, IREAD_HOME, READ_TO_OWN_HOME, IO_READ_HOME, FLUSH without data, DKILL_HOME, and IKILL_HOME transactions are issued to home memory by a processing element. DKILL_SHARER and IKILL_SHARER transactions are issued by a home memory to the sharers of a coherence granule. DKILL_HOME, DKILL_SHARER, IKILL_HOME, IKILL_SHARER, FLUSH without data, and TLBIE are address-only transactions so the rdsize and wdptr fields are ignored and shall be set to logic 0. TLBSYNC is a transaction-type-only transaction so both the address, xamsbs, rdsize, and wdptr fields shall be set to logic 0. </P>

<P>
<Link>The transaction field encodings for type 2 packets are displayed in Table 4-10. </Link>

<Link>Fields that are not specific to type 2 packets are described in Table 4-6. </Link>
</P>

<Table>
<Caption>
<P>Table 4-10. Transaction Field Encodings for Type 2 Packets </P>
</Caption>

<TR>
<TD>Encoding </TD>

<TD>Transaction Field </TD>
</TR>

<TR>
<TD>0b0000 </TD>

<TD>READ_HOME </TD>
</TR>

<TR>
<TD>0b0001 </TD>

<TD>READ_TO_OWN_HOME </TD>
</TR>

<TR>
<TD>0b0010 </TD>

<TD>IO_READ_HOME </TD>
</TR>

<TR>
<TD>0b0011 </TD>

<TD>DKILL_HOME </TD>
</TR>

<TR>
<TD>0b0100 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b0101 </TD>

<TD>IKILL_HOME </TD>
</TR>

<TR>
<TD>0b0110 </TD>

<TD>TLBIE </TD>
</TR>

<TR>
<TD>0b0111 </TD>

<TD>TLBSYNC </TD>
</TR>

<TR>
<TD>0b1000 </TD>

<TD>IREAD_HOME </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Encoding </TD>

<TD>Transaction Field </TD>
</TR>

<TR>
<TD>0b1001 </TD>

<TD>FLUSH without data </TD>
</TR>

<TR>
<TD>0b1010 </TD>

<TD>IKILL_SHARER </TD>
</TR>

<TR>
<TD>0b1011 </TD>

<TD>DKILL_SHARER </TD>
</TR>

<TR>
<TD>0b1100–1111 </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>
<Link>Figure 4-2 displays a type 2 packet with all its fields. The field value 0b0010 in </Link>

<Link>Figure 4-2 specifies that the packet format is of type 2. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_92.jpg"/>
0 0 1 0 4 4 4 8 transaction rdsize srcTID address extended address wdptr xamsbs </Figure>

<P>0, 16, 32 29 1 2 </P>

<P>Figure 4-2. Type 2 Packet Bit Stream Format </P>

<P id="LinkTarget_30639">4.2.7 Type 3–4 Packet Formats (Reserved) </P>

<P>The type 3–4 packet formats are reserved. </P>

<P id="LinkTarget_30640">4.2.8 Type 5 Packet Format (Write Class) </P>

<P>Type 5 packets always contain data. A data payload that consists of a single 
<Link>double-word or less has sizing information as defined in Table 4-8. The wrsize field </Link>
specifies the maximum size of the data payload for multiple double-word transactions. The FLUSH with data and CASTOUT transactions use type 5 packets 
<Link>as defined in Table 4-11. Note that type 5 transactions always contain data. </Link>
</P>

<P>
<Link>Fields that are not specific to type 5 packets are described in Table 4-6. </Link>
</P>

<Table>
<Caption>
<P>Table 4-11. Transaction Field Encodings for Type 5 Packets </P>
</Caption>

<TR>
<TD>Encoding </TD>

<TD>Transaction Field </TD>
</TR>

<TR>
<TD>0b0000 </TD>

<TD>CASTOUT </TD>
</TR>

<TR>
<TD>0b0001 </TD>

<TD>FLUSH with data </TD>
</TR>

<TR>
<TD>0b0010–1111 </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>
<Link>Figure 4-3 displays a type 5 packet with all its fields. The field value 0b0101 in </Link>
</P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>
<Link>Figure 4-3 specifies that the packet format is of type 5. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_93.jpg"/>
0 1 0 1 4 4 4 8 transaction wrsize srcTID address extended address 0, 16, 32 wdptr xamsbs 1 229 double-word 0 64 double-word 1 64 • • • </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_94.jpg"/>
</Figure>

<P>double-word n </P>

<P>64 </P>

<P>Figure 4-3. Type 5 Packet Bit Stream Format </P>

<P id="LinkTarget_30641">4.2.9 Type 6–11 Packet Formats (Reserved) </P>

<P>The type 6–11 packet formats are reserved. </P>

<P id="LinkTarget_30642">4.3 Response Packet Formats </P>

<P>A response transaction is issued by a processing element when it has completed a request made by a remote processing element. Response packets are always directed and are transmitted in the same way as request packets. Currently two response 
<Link>packet format types exist, as shown in Table 4-12. </Link>
</P>

<Table>
<Caption>
<P>Table 4-12. Request Packet Type to Transaction Type Cross Reference </P>
</Caption>

<TR>
<TH>Request Packet Format Type </TH>

<TH>Transaction Type </TH>

<TH>Definition </TH>

<TH>Document Section No. </TH>
</TR>

<TR>
<TD>Type 12 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.3.2 </Link>
</TD>
</TR>

<TR>
<TD>Type 13 </TD>

<TD>RESPONSE </TD>

<TD>Issued by a processing element when it completes a request by a remote element. </TD>

<TD>
<Link>Section 4.3.3 </Link>
</TD>
</TR>

<TR>
<TD>Type 14 </TD>

<TD>— </TD>

<TD>Reserved </TD>

<TD>
<Link>Section 4.3.4 </Link>
</TD>
</TR>

<TR>
<TD>Type 15 </TD>

<TD>Implementation-defined </TD>

<TD>Defined by the device implementation </TD>

<TD>
<Link>Section 4.3.5 </Link>
</TD>
</TR>
</Table>

<P id="LinkTarget_30643">4.3.1 Field Definitions for All Response Packet Formats </P>

<P>
<Link>The field definitions in Table 4-13 apply to more than one of the response packet </Link>
formats. </P>

<P>Table 4-13. Field Definitions and Encodings for All Response Packets </P>

<Table>
<TR>
<TH>Field </TH>

<TH>Encoding </TH>

<TH>Sub-Field </TH>

<TH>Definition </TH>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>transaction </TH>

<TH>0b0000 </TH>

<TH>RESPONSE transaction with no data payload </TH>
</TR>

<TR>
<TD>0b0001–0111 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b1000 </TD>

<TD>RESPONSE transaction with data payload </TD>
</TR>

<TR>
<TD>0b1001–1111 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TH>targetTID </TH>

<TD>— </TD>

<TD>The corresponding request packet’s transaction ID </TD>
</TR>

<TR>
<TH>status </TH>

<TD>Type of status and encoding </TD>

<TD/>
</TR>

<TR>
<TD>0b0000 </TD>

<TD>DONE </TD>

<TD>Requested transaction has been successfully completed </TD>
</TR>

<TR>
<TD>0b0001 </TD>

<TD>DATA_ONLY </TD>

<TD>This is a data only response </TD>
</TR>

<TR>
<TD>0b0010 </TD>

<TD>NOT_OWNER </TD>

<TD>Not owner of requested coherence granule </TD>
</TR>

<TR>
<TD>0b0011 </TD>

<TD>RETRY </TD>

<TD>Requested transaction is not accepted; must retry the request </TD>
</TR>

<TR>
<TD>0b0100 </TD>

<TD>INTERVENTION </TD>

<TD>Update home memory with intervention data </TD>
</TR>

<TR>
<TD>0b0101 </TD>

<TD>DONE_INTERVENTION </TD>

<TD>Done for a transaction that resulted in an intervention </TD>
</TR>

<TR>
<TD>0b0110 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b0111 </TD>

<TD>ERROR </TD>

<TD>Unrecoverable error detected </TD>
</TR>

<TR>
<TD>0b1000–1011 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b1100–1111 </TD>

<TD>Implementation </TD>

<TD>Implementation defined—Can be used for additional information such as an error code </TD>
</TR>
</Table>

<P id="LinkTarget_30644">4.3.2 Type 12 Packet Format (Reserved) </P>

<P>The type 12 packet format is reserved. </P>

<P id="LinkTarget_30645">4.3.3 Type 13 Packet Format (Response Class) </P>

<P>The type 13 packet format returns status, data (if required), and the requestor’s transaction ID. A RESPONSE packet with an “ERROR” status or a response that is not expected to have a data payload never has a data payload. The type 13 format is used for response packets to all request transactions. </P>

<P>Note that type 13 packets do not have any special fields. </P>

<P>
<Link>Figure 4-4 illustrates the format and fields of type 13 packets. The field value </Link>

<Link>0b1101 in Figure 4-4 specifies that the packet format is of type 13. </Link>
</P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_95.jpg"/>
1 1 0 1 4 4 4 8 transaction status targetTID double-word 0 64 double-word 1 64 •  • • </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_96.jpg"/>
</Figure>

<P>double-word n </P>

<P>64 </P>

<P>Figure 4-4. Type 13 Packet Bit Stream Format </P>

<P id="LinkTarget_30646">4.3.4 Type 14 Packet Format (Reserved) </P>

<P>The type 14 packet format is reserved. </P>

<P id="LinkTarget_30647">4.3.5 Type 15 Packet Format (Implementation-Defined) </P>

<P>The type 15 packet format is reserved for implementation-defined functions such as flow control. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30648">Chapter 5  Globally Shared Memory Registers </P>

<P id="LinkTarget_30649">5.1 Introduction </P>

<P>This chapter describes the visible register set that allows an external processing element to determine the capabilities, configuration, and status of a processing element using this logical specification. This chapter only describes registers or register bits defined by this specification. Refer to the other RapidIO logical, transport, and physical specifications of interest to determine a complete list of registers and bit definitions. All registers are 32-bits and aligned to a 32-bit boundary. </P>

<P id="LinkTarget_30650">5.2 Register Summary </P>

<P>
<Link>Table 5-1 shows the register map for this RapidIO specification. These capability </Link>
registers (CARs) and command and status registers (CSRs) can be accessed using the RapidIO Part 1: Input/Output Logical Specification maintenance operations. Any register offsets not defined are considered reserved for this specification unless otherwise stated. Other registers required for a processing element are defined in other applicable RapidIO specifications and by the requirements of the specific device and are beyond the scope of this specification. Read and write accesses to reserved register offsets shall terminate normally and not cause an error condition in the target device. Writes to CAR (read-only) space shall terminate normally and not cause an error condition in the target device. </P>

<P>Register bits defined as reserved are considered reserved for this specification only. Bits that are reserved in this specification may be defined in another RapidIO specification. </P>

<Table>
<Caption>
<P>Table 5-1. GSM Register Map </P>
</Caption>

<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x0-14 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x18 </TD>

<TD>Source Operations CAR </TD>
</TR>

<TR>
<TD>0x1C </TD>

<TD>Destination Operations CAR </TD>
</TR>

<TR>
<TD>0x20-FC </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x100FFFC </TD>

<TD>Extended Features Space </TD>
</TR>

<TR>
<TD>0x10000FFFFFC </TD>

<TD>Implementation-defined Space </TD>
</TR>
</Table>

<P id="LinkTarget_30651">5.3 Reserved Register and Bit Behavior </P>

<P>
<Link>Table 5-2 describes the required behavior for accesses to reserved register bits and </Link>
reserved registers for the RapidIO register space, </P>

<Table>
<Caption>
<P>Table 5-2. Configuration Space Reserved Access Behavior </P>
</Caption>

<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x0-3C </TH>

<TD>Capability Register Space (CAR Space - this space is read-only) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value1 </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored</TD>
</TR>

<TR>
<TD> Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x40-FC </TH>

<TD>Command and Status Register Space (CSR Space) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value2 </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write - implementation-defined </TD>
</TR>

<TR>
<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write -</TD>

<TD>write - ignored </TD>
</TR>
</Table>

<Table>
<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x100FFFC </TH>

<TD>Extended Features Space </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD/>

<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write - implementation-defined </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD/>

<TD>write -</TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x10000FFFFFC </TH>

<TD>Implementation-defined Space </TD>

<TD>Reserved bit and register </TD>

<TD>All behavior implementation-defined </TD>
</TR>
</Table>

<P>1 Do not depend on reserved bits being a particular value; use appropriate masks to extract defined bits from the read value. 2 All register writes shall be in the form: read the register to obtain the values of all reserved bits, merge in the desired values for defined bits to be modified, and write the register, thus preserving the value of all reserved bits. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30652">5.4 	Capability Registers (CARs) </P>
</Div>

<Div>
<P>Every processing element shall contain a set of registers that allows an external processing element to determine its capabilities using the I/O logical maintenance read operation. All registers are 32 bits wide and are organized and accessed in 32-bit (4 byte) quantities, although some processing elements may optionally allow 
<Link>larger accesses. CARs are read-only. Refer to Table 5-2 for the required behavior for </Link>
accesses to reserved registers and register bits. </P>

<P>CARs are big-endian with bit 0 the most significant bit. </P>

<P id="LinkTarget_30653">5.4.1 	Source Operations CAR 
(Configuration Space Offset 0x18) 
</P>

<P>This register defines the set of RapidIO GSM logical operations that can be issued 
<Link>by this processing element; see Table 5-3. It is assumed that a processing element </Link>
can generate I/O logical maintenance read and write requests if it is required to access CARs and CSRs in other processing elements. RapidIO switches shall be able to route any packet.  </P>

<Table>
<Caption>
<P>Table 5-3. Bit Settings for Source Operations CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Read </TD>

<TD>PE can support a read operation </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Instruction read </TD>

<TD>PE can support an instruction read operation </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>Read-for-ownership </TD>

<TD>PE can support a read-for-ownership operation </TD>
</TR>

<TR>
<TD>3 </TD>

<TD>Data cache invalidate </TD>

<TD>PE can support a data cache invalidate operation </TD>
</TR>

<TR>
<TD>4 </TD>

<TD>Castout </TD>

<TD>PE can support a castout operation </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>Data cache flush </TD>

<TD>PE can support a data cache flush operation </TD>
</TR>

<TR>
<TD>6 </TD>

<TD>I/O read </TD>

<TD>PE can support an I/O read operation </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>Instruction cache invalidate </TD>

<TD>PE can support an instruction cache invalidate operation </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>TLB invalidate-entry </TD>

<TD>PE can support a TLB invalidate-entry operation </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>TLB invalidate-entry sync </TD>

<TD>PE can support a TLB invalidate-entry sync operation </TD>
</TR>

<TR>
<TD>10–13 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14–15 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>

<TR>
<TD>16–29 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>30–31 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30654">5.4.2 	Destination Operations CAR (Configuration Space Offset 0x1C) </P>

<P>This register defines the set of RapidIO GSM operations that can be supported by 
<Link>this processing element; see Table 5-4. It is required that all processing elements can </Link>
respond to I/O logical maintenance read and write requests in order to access these registers. The Destination Operations CAR is applicable for end point devices only. RapidIO switches shall be able to route any packet. </P>

<Table>
<Caption>
<P>Table 5-4. Bit Settings for Destination Operations CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Read </TD>

<TD>PE can support a read operation </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Instruction read </TD>

<TD>PE can support an instruction read operation </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>Read-for-ownership </TD>

<TD>PE can support a read-for-ownership operation </TD>
</TR>

<TR>
<TD>3 </TD>

<TD>Data cache invalidate </TD>

<TD>PE can support a data cache invalidate operation </TD>
</TR>

<TR>
<TD>4 </TD>

<TD>Castout </TD>

<TD>PE can support a castout operation </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>Data cache flush </TD>

<TD>PE can support a flush operation </TD>
</TR>

<TR>
<TD>6 </TD>

<TD>I/O read </TD>

<TD>PE can support an I/O read operation </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>Instruction cache invalidate </TD>

<TD>PE can support an instruction cache invalidate operation </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>TLB invalidate-entry </TD>

<TD>PE can support a TLB invalidate-entry operation </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>TLB invalidate-entry sync </TD>

<TD>PE can support a TLB invalidate-entry sync operation </TD>
</TR>

<TR>
<TD>10–13 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14-15 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>

<TR>
<TD>16-29 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>30-31 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30655">5.5 Command and Status Registers (CSRs) </P>

<P>The RapidIO Globally Shared Memory Logical Specification does not define any command and status registers (CSRs). </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30656">Chapter 6  Communication Protocols </P>

<P id="LinkTarget_30657">6.1 Introduction </P>

<P>This chapter contains the RapidIO globally shared memory (GSM) communications protocol definitions. Three state machines are required for a processing element on the RapidIO interface: one for local system accesses to local and remote space, one for remote accesses to local space, and one for handling responses made by the remote system to requests from the local system. The protocols are documented as pseudo-code partitioned by operation type. The RapidIO protocols as defined here assume a directory state definition that uses a modified bit with the local processor always sharing as described in 
<Link>Chapter 2, “System Models.” The protocols can be </Link>
easily modified to use an alternate directory scheme that allows breaking the SHARED state into a REMOTE_SHARED and a REMOTE_AND_LOCAL_SHARED state pair. </P>

<P>Similarly, it may be desirable for an implementation to have an UNOWNED state instead of defaulting to LOCAL_SHARED or LOCAL_MODIFIED. These optimizations only affect the RapidIO transaction issuing behavior within a processing element, not the globally shared memory protocol itself. This flexibility allows a variety of local processor cache state coherence definitions such as MSI or MESI. </P>

<P>Some designs may not have a source of local system requests, for example, the 
<Link>memory only processing element described in Section 2.2.3, “Memory-Only </Link>

<Link>Processing Element Model”. The protocols for </Link>
these devices are much less complicated, only requiring the external request state machine and a portion of the response state machine. Similarly, a design may not have a local memory controller, which is also a much less complicated device, requiring only a portion of the internal request and response state machines. The protocols assume a processor element and 
<Link>memory processing element as described in Figure 2-2. </Link>
</P>

<P id="LinkTarget_30658">6.2 Definitions </P>

<P>
<Link>The general definitions of Section 6.2.1 apply throughout the protocol, and the </Link>
requests and responses of state machines are defined in 
<Link>Section 6.2.2, “Request and </Link>

<Link>Response Definitions</Link>
.” </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30659">6.2.1 General Definitions </P>

<P>address_collisionAn address match between the new request and an address currently being serviced by the state machines or some other address-based internal hazard. This frequently causes a retry of the new request. </P>

<P>assign_entry() Assign resources (such as a queue entry) to service a request, mark the address as able to participate in address collision detection (if appropriate), and assign a transaction ID </P>

<P>data Any data associated with the transaction; this field is frequently null </P>

<P>directory_state The memory directory state for the address being serviced </P>

<P>error() Signal an error (usually through an interrupt structure) to software, usually to indicate a coherence violation problem </P>

<P>free_entry() Release all resources assigned to this transaction, remove it from address collision detection, and deallocate the transaction ID </P>

<P>local Memory local to the processing element </P>

<P>local_request(m,n,...)A local request to a local processor caused by an incoming external request that requires a snoop of the processor’s caches </P>

<P>local_response(m,n,.)A local response to a local request; usually indicates the cache state for the requesting processor to mark the requested data </P>

<P>LOCAL_RTYPEThis is the response from the local agent to the local processor in response to a local request. </P>

<P>LOCAL_TTYPEThis is the transaction type for a request passed from the RapidIO interconnect to a local device. </P>

<P>(mask &lt;= (mask ~= received_srcid)) “Assign the mask field to the old mask field with the received ID bit cleared.” This result is generated when a response to a multicast is received and it is not the last one expected. </P>

<P>((mask ~= (my_id OR received_id)) == 0) “The mask field not including my ID or the received ID equals 0.” This result indicates that we have received all of the expected responses to a multicast request. </P>

<P>(mask ~= my_id)“The sharing mask not including my ID.” This result is used for multicast operations where the requestor is in the sharing list but does not need to be included in the multicast transaction because it is the source of the transaction. </P>

<P>(mask &lt;= (participant_list ~= my_id)) “The sharing mask includes all participants except my ID.” This result is used for the IKILL operation, which does not </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>use the memory directory information. </P>

<P>(mask &lt;= (participant_list ~= (received_srcid AND my_id))) “The sharing mask includes all participants except the requestor’s and my IDs.” This result is used for the IKILL operation, which does not use the memory directory information. </P>

<P>(mask == received_srcid) “The sharing mask only includes the requestor’s ID.” This result is used for the DKILL operation to detect a write-hit-on-shared case where the requestor has the only remote copy of the coherence granule. </P>

<P>original_srcid The ID of the initial requestor for a transaction, saved in the state associated with the transaction ID </P>

<P>received_data The response contained data </P>

<P>received_data_only_message Flag set by set_received_data_only_message() </P>

<P>received_done_message Flag set by set_received_done_message() </P>

<P>remote_request(m,n,...) Make a request to the interconnect fabric </P>

<P>remote_response(m,n,...) Send a response to the interconnect fabric </P>

<P>RESPONSE_TTYPE This is the RapidIO transaction type for a response to a request </P>

<P>return_data() Return data to the local requesting processor, either from memory or from a interconnect fabric buffer; the source can be determined from the context </P>

<P>secondary_id The third party identifier for intervention responses; the processing element ID concatenated with the processing element domain. </P>

<P>set_received_data_only_message() Remember that a DATA_ONLY response was received for this transaction ID </P>

<P>set_received_done_message() Remember that a DONE response was received for this transaction ID </P>

<P>source_id The source device identifier; the processing element ID concatenated with the processing element domain </P>

<P>target_id The destination device identifier; the processing element ID </P>

<P>RapidIO Trade Association </P>

<P>concatenated with the processing element domain </P>

<P>TRANSACTIONThe RapidIO transaction type code for the request </P>

<P>update_memory()Write memory with data received from a response </P>

<P>update_state(m,n,...)Modify the memory directory state to reflect the new system status </P>

<P id="LinkTarget_30660">6.2.2 Request and Response Definitions </P>

<P>Following are the formats used in the pseudocode to describe request and response transactions sent between processing elements and the formats of local requests and responses between the cache coherence controller and the local cache hierarchy and memory controllers. </P>

<P id="LinkTarget_30661">6.2.2.1 System Request </P>

<P>The system request format is: </P>

<P>remote_request(TRANSACTION, target_id, source_id, secondary_id, data) </P>

<P>which describes the necessary RapidIO request to implement the protocol. </P>

<P id="LinkTarget_30662">6.2.2.2 Local Request </P>

<P>The local request format is: </P>

<P>local_request(LOCAL_TTYPE) </P>

<P>that is the necessary local processor request to implement the protocol; the pseudocode assumes a generic local bus. A local request also examines the remote cache as part of the processing element’s caching hierarchy. The local transactions are defined as: </P>

<P>DKILL Causes the processor to transition the coherence granule to invalid regardless of the current state; data is not pushed if current state is modified </P>

<P>IKILL Causes the processor to invalidate the coherence granule in the instruction cache </P>

<P>READ Causes the processor to transition the coherence granule to shared and push data if necessary </P>

<P>READ_LATESTCauses the processor to push data if modified but not transition the cache state </P>

<P>READ_TO_OWNCauses the processor to transition the coherence granule to invalid and push data </P>

<P>TLBIE Causes the processor to invalidate the specified translation look-aside buffer entry </P>

<P>TLBSYNC Causes the processor to indicate when all outstanding TLBIEs have completed </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30663">6.2.2.3 System Response </P>

<P>The system response format is: </P>

<P>remote_response(RESPONSE_TTYPE, target_id, source_id, data (opt.)) </P>

<P>which is the proper response to implement the protocol. </P>

<P id="LinkTarget_30664">6.2.2.4 Local Response </P>

<P>The local response format is: </P>

<P>local_response(LOCAL_RTYPE) </P>

<P>In general, a transaction ID (TID) is associated with each device ID in order to uniquely identify a request. This TID is frequently a queue index in the source processing element. These TIDs are not explicitly called out in the pseudocode below. The local responses are defined as: </P>

<P>EXCLUSIVE The processor has exclusive access to the coherence granule </P>

<P>OK The transaction requested by the processor has or will complete properly </P>

<P>RETRY Causes the processor to re-issue the transaction; this response may cause a local bus spin loop until the protocol allows a different response </P>

<P>SHARED The processor has a shared copy of the coherence granule </P>

<P id="LinkTarget_30665">6.3 Operation to Protocol Cross Reference </P>

<P>
<Link>Table 6-1 contains a cross reference of the operations defined in the </Link>
RapidIO Interconnect Globally Shared Memory Logical Specification and their system usage. </P>

<Table>
<Caption>
<P>Table 6-1. Operation to Protocol Cross Reference </P>
</Caption>

<TR>
<TD>Operations </TD>

<TD>Protocol </TD>
</TR>

<TR>
<TD>Read </TD>

<TD>
<Link>Section 6.4 </Link>
</TD>
</TR>

<TR>
<TD>Instruction read </TD>

<TD>
<Link>Section 6.4 </Link>
</TD>
</TR>

<TR>
<TD>Read for ownership </TD>

<TD>
<Link>Section 6.6 </Link>
</TD>
</TR>

<TR>
<TD>Data cache invalidate </TD>

<TD>
<Link>Section 6.7 </Link>
</TD>
</TR>

<TR>
<TD>Instruction cache invalidate </TD>

<TD>
<Link>Section 6.7 </Link>
</TD>
</TR>

<TR>
<TD>Castout </TD>

<TD>
<Link>Section 6.8 </Link>
</TD>
</TR>

<TR>
<TD>TLB invalidate entry </TD>

<TD>
<Link>Section 6.9 </Link>
</TD>
</TR>

<TR>
<TD>TLB invalidate entry synchronize </TD>

<TD>
<Link>Section 6.9 </Link>
</TD>
</TR>

<TR>
<TD>Data cache flush </TD>

<TD>
<Link>Section 6.10 </Link>
</TD>
</TR>

<TR>
<TD>I/O read </TD>

<TD>
<Link>Section 6.11 </Link>
</TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30666">6.4 Read Operations </P>

<P>
<Link>This operation is a coherent data cache read; refer to the description in Section 3.3.1. </Link>
</P>

<P id="LinkTarget_30667">6.4.1 Internal Request State Machine </P>

<P>This state machine handles requests to both local and remote memory from the local </P>

<P>processor. </P>

<P>if (address_collision) // this is due to an external request// in progress or a cache local_response(RETRY); // index hazard from a previous request </P>

<P>elseif (local) // our local memory switch (directory_state)case LOCAL_MODIFIED: // local modified is OK if we default </P>

<P>// local memory to owned local_response(EXCLUSIVE);return_data();</P>

<P>case LOCAL_SHARED, // local, owned by memory </P>

<P>case SHARED: // shared local and remote local_response(SHARED);return_data(); // keep directory state </P>

<P>// the way it was </P>

<P>case REMOTE_MODIFIED: local_response(SHARED);assign_entry(); // this means to assign </P>

<P>// a transaction ID,
// usually a queue entry
remote_request(READ_OWNER, mask_id, my_id, my_id); 
default: 
error();
else // remote - we’ve got to go 
</P>

<P>// to another processing element assign_entry();local_response(RETRY); // can’t guarantee data before a</P>

<P>// snoop yet
remote_request(READ_HOME, mem_id, my_id); 
endif; 
</P>

<P id="LinkTarget_30668">6.4.2 Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local system or a third party. </P>

<P>if (my_id == mem_id == original_srcid) // original requestor is home memory switch(remote_response) // matches my_id only for // REMOTE_MODIFIED case </P>

<P>case INTERVENTION: 
update_memory();
update_state(SHARED, original_srcid);
return_data();
free_entry();
</P>

<P>case NOT_OWNER, // due to address collision or </P>

<P>case RETRY: // passing requests switch (directory_state)case LOCAL_MODIFIED: </P>

<P>local_response(EXCLUSIVE);</P>

<P>// when processor re-requests return_data();free_entry();</P>

<P>case LOCAL_SHARED: </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>local_response(SHARED);</P>

<P>// when processor re-requests return_data();free_entry();</P>

<P>case REMOTE_MODIFIED: // mask_id must match received_srcid </P>

<P>//or error; spin or wait for castoutremote_request(READ_OWNER, received_srcid,my_id, my_id);</P>

<Table>
<TR>
<TH>default: </TH>
</TR>

<TR>
<TH>default </TH>

<TD>error(); </TD>
</TR>

<TR>
<TH>error();elseif(my_id == mem_id ~== original_id switch(remote_response)case INTERVENTION: </TH>

<TD>// i’m home memory working for// a third party </TD>
</TR>

<TR>
<TH>update_memory();</TH>

<TD/>
</TR>
</Table>

<P>update_state(SHARED, original_srcid);</P>

<P>remote_response(DONE_INTERVENTION, original_srcid, my_id);free_entry();case NOT_OWNER, // data comes from memory,// mimic intervention </P>

<P>case RETRY: switch(directory_state)case LOCAL_SHARED: </P>

<P>update_state(SHARED, original_srcid);remote_response(DATA_ONLY, original_srcid,my_id, data);remote_response(DONE_INTERVENTION, original_srcid,my_id);free_entry();</P>

<P>case LOCAL_MODIFIED: update_state(SHARED, original_srcid);remote_response(DATA_ONLY, original_srcid,</P>

<P>my_id, data);remote_response(DONE_INTERVENTION, original_srcid,my_id);free_entry();case REMOTE_MODIFIED: // spin or wait for castoutremote_request(READ_OWNER, received_srcid,my_id, my_id);default: error();default: error();</P>

<P>else 	// my_id ~= mem_id - I’m // requesting a remote // memory location </P>

<P>switch(remote_response)</P>

<P>case DONE: local_response(SHARED); // when processor re-requests return_data();free_entry();</P>

<P>case DONE_INTERVENTION: // must be from third party set_received_done_message();if (received_data_only_message)</P>

<P>free_entry();else // wait for a DATA_ONLY endif; </P>

<P>case DATA_ONLY: 	// this is due to an intervention, a// DONE_INTERVENTION should come// separately </P>

<P>local_response(SHARED);set_received_data_only_message();if (received_done_message) </P>

<P>RapidIO Trade Association </P>

<P>return_data();</P>

<Table>
<TR>
<TH>else </TH>

<TH>free_entry(); </TH>
</TR>

<TR>
<TD>endif; case RETRY: </TD>

<TD>return_data(); </TD>

<TD>// OK for weak ordering </TD>
</TR>
</Table>

<P>remote_request(READ_HOME, received_srcid, my_id); default error();endif; </P>

<P id="LinkTarget_30669">6.4.3 External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory or the local system. This may require making further external requests. </P>

<P>if (address_collision) 	// use collision tables in</P>

<P>
<Link>// Chapter 7, “Address Collision Resolution </Link>

<Link>Tables” </Link>
elseif (READ_HOME) // remote request to our local memory </P>

<P>assign_entry();switch (directory_state)case LOCAL_MODIFIED: </P>

<P>local_request(READ);update_state(SHARED, received_srcid);</P>

<P>// after possible push completesremote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case LOCAL_SHARED, </P>

<P>case SHARED: update_state(SHARED, received_srcid);remote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case REMOTE_MODIFIED: if (mask_id ~= received_srcid) // intervention caseremote_request(READ_OWNER, mask_id,my_id, received_srcid); else </P>

<P>error(); 	// he already owned it; // cache paradox (or I-fetch after d// store if not fixed elsewhere) </P>

<P>endif; default: error();</P>

<P>else // READ_OWNER request to our caches assign_entry();local_request(READ); // spin until a valid response</P>

<P>// from cachesswitch (local_response)case MODIFIED: // processor indicated a push;</P>

<P>// wait for itcache_state(SHARED or INVALID);// surrender ownershipif (received_srcid == received_secid)// original requestor is also homeremote_response(INTERVENTION, received_srcid,my_id, data);else remote_response(DATA_ONLY, received_secid,my_id, data);remote_response(INTERVENTION, received_srcid,my_id, data);endif; case INVALID: // must have cast it out </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>remote_response(NOT_OWNER, received_srcid, my_id); default; error();free_entry(); endif; </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30670">6.5 Instruction Read Operations </P>

<P>This operation is a partially coherent instruction cache read; refer to the description 
<Link>in Section 3.3.2. </Link>
</P>

<P id="LinkTarget_30671">6.5.1 Internal Request State Machine </P>

<P>This state machine handles requests to both local and remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external// request in progress or a cache local_response(RETRY); // index hazard from a previous request</P>

<P>elseif (local) // our local memory switch (directory_state)case LOCAL_MODIFIED: // local modified is OK if we default</P>

<P>// local memory to owned local_response(EXCLUSIVE);return_data();</P>

<P>case LOCAL_SHARED, 	// local, owned by memory </P>

<P>case SHARED: // shared local and remote local_response(SHARED);return_data(); // keep directory state the way it was </P>

<P>case REMOTE_MODIFIED: local_response(SHARED);assign_entry(); // this means to assign a transaction</P>

<P>// ID, usually a queue entry
remote_request(READ_OWNER, mask_id, my_id, my_id); 
default: 
error();
else // remote - we’ve got to go
</P>

<P>// to another processing element assign_entry();local_response(RETRY); </P>

<P>// can’t guarantee data before a// snoop yetremote_request(IREAD_HOME, mem_id, my_id); endif; </P>

<P id="LinkTarget_30672">6.5.2 Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local system or a third party. </P>

<P>if (my_id == mem_id == original_srcid) // original requestor is home memory error();elseif(my_id == mem_id ~== original_id) // i’m home memory working for a</P>

<P>// third partyswitch(remote_response)case INTERVENTION: </P>

<P>update_memory();
update_state(SHARED, original_srcid);
remote_response(DONE, original_srcid, my_id);
free_entry();
</P>

<P>case NOT_OWNER, 	// data comes from memory,// mimic intervention </P>

<P>case RETRY: 
switch(directory_state)
case LOCAL_SHARED: 
</P>

<P>update_state(SHARED, original_srcid);remote_response(DONE, original_srcid, my_id); </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>free_entry();</P>

<P>case LOCAL_MODIFIED: update_state(SHARED, original_srcid);remote_response(DONE, original_srcid, my_id);free_entry();</P>

<P>case REMOTE_MODIFIED: // spin or wait for castoutremote_request(READ_OWNER, received_srcid,my_id, my_id);</P>

<Table>
<TR>
<TH>default: </TH>
</TR>

<TR>
<TH>default: </TH>

<TD>error(); </TD>
</TR>

<TR>
<TH>else </TH>

<TD>error(); switch(remote_response)case DONE: </TD>

<TD>// my_id ~= mem_id - I’m requesting// a remote memory location </TD>
</TR>

<TR>
<TH/>

<TD>local_response(SHARED);return_data();free_entry();case DONE_INTERVENTION: set_received_done_message();if (received_data_only_message)free_entry();else </TD>

<TD>// when processor re-requests // must be from third party </TD>
</TR>

<TR>
<TH/>

<TD>endif; case DATA_ONLY: local_response(SHARED);</TD>

<TD>// wait for a DATA_ONLY // this is due to an intervention; a// DONE_INTERVENTION should come// separately </TD>
</TR>
</Table>

<P>set_received_data_only_message();</P>

<P>if (received_done_message)return_data();free_entry();</P>

<P>else return_data(); // OK for weak ordering endif; case RETRY: remote_request(IREAD_HOME, received_srcid, my_id); default error();endif; </P>

<P id="LinkTarget_30673">6.5.3 External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory or the local system. This may require making further external requests. </P>

<P>if (address_collision) // use collision tables in</P>

<P>
<Link>// Chapter 7, “Address Collision Resolution </Link>

<Link>Tables” </Link>
elseif(IREAD_HOME) // remote request to our local memory </P>

<P>assign_entry();switch (directory_state)case LOCAL_MODIFIED: </P>

<P>local_request(READ);update_state(SHARED, received_srcid);</P>

<P>// after possible push completesremote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case LOCAL_SHARED, </P>

<P>case SHARED: update_state(SHARED, received_srcid);remote_response(DONE, received_srcid, my_id, data);free_entry(); </P>

<P>RapidIO Trade Association </P>

<P>case REMOTE_MODIFIED: if (mask_id ~= received_srcid) // intervention caseremote_request(READ_OWNER, mask_id,my_id, received_srcid); else // he already owned it in his //data cache; cache paradox caseremote_request(READ_OWNER, mask_id, my_id, my_id); endif; default: error();endif; </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30674">6.6 Read for Ownership Operations </P>

<P>This is the coherent cache store miss operation. </P>

<P id="LinkTarget_30675">6.6.1 Internal Request State Machine </P>

<P>This state machine handles requests to both local and remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external request// in progress or a cache index local_response(RETRY); // hazard from a previous request </P>

<P>elseif (local) // our local memory 
switch (directory_state
case LOCAL_MODIFIED, // local modified is OK if we
</P>

<P>// default memory to owned locally </P>

<P>case LOCAL_SHARED: local_response(EXCLUSIVE); // give ownership to processor return_data();if (directory_state == LOCAL_SHARED)</P>

<P>update_state(LOCAL_MODIFIED)endif; case REMOTE_MODIFIED: // owned by another, get a copy</P>

<P>// and ownershipassign_entry();local_response(RETRY); // retryremote_request(READ_TO_OWN_OWNER, mask_id, my_id, my_id);</P>

<P>case SHARED: // invalidate the sharing list assign_entry();local_response(RETRY); // retryremote_request(DKILL_SHARER, (mask ~= my_id), my_id, my_id); </P>

<P>default: error();else // remote - we’ve got to go to another</P>

<P>// processing elementassign_entry();local_response(RETRY);remote_request(READ_TO_OWN_HOME, mem_id, my_id); endif; </P>

<P id="LinkTarget_30676">6.6.2 Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local system or a third party. </P>

<P>if (my_id == mem_id == original_srcid) // original requestor is home memory switch (received_response)case DONE: // SHARED, so invalidate case</P>

<P>if ((mask ~= (my_id OR received_id)) == 0)</P>

<P>// this is the last DONElocal_response(EXCLUSIVE);return_data();update_state(LOCAL_MODIFIED);free_entry();else </P>

<P>mask &lt;= (mask ~= received_srcid);// flip the responder’s shared// bit and wait for next DONE </P>

<P>endif; case NOT_OWNER: // due to address collision with// CASTOUT or FLUSH </P>

<P>RapidIO Trade Association </P>

<P>switch(directory_state)</P>

<P>case LOCAL_MODIFIED,: local_response(EXCLUSIVE);return_data();free_entry();</P>

<P>case LOCAL_SHARED: local_response(EXCLUSIVE);return_data();update_state(LOCAL_MODIFIED);free_entry();</P>

<P>case REMOTE_MODIFIED: // spin or wait for castoutremote_request(READ_TO_OWN_OWNER, mask_id,my_id, my_id);default: error();</P>

<P>case INTERVENTION: // remotely owned local_response(EXCLUSIVE);return_data();update_state(LOCAL_MODIFIED);free_entry();</P>

<P>case RETRY: 
switch (directory_state)
case LOCAL_MODIFIED: 
</P>

<P>local_response(EXCLUSIVE);
return_data();
free_entry();
</P>

<P>case LOCAL_SHARED: local_response(EXCLUSIVE);return_data();update_state(LOCAL_MODIFIED);free_entry();</P>

<P>case REMOTE_MODIFIED: //mask_id must match received_srcid// or error conditionremote_request(READ_TO_OWN_OWNER, received_srcid,my_id, my_id);case SHARED: remote_request(DKILL_SHARER, received_srcid, my_id,my_id);default: error();default: error();</P>

<P>elseif (my_id == mem_id ~= original_srcid) // i’m home memory working// for a third party </P>

<P>switch(received_response)case DONE: // invalidates for shared // directory statesif ((mask ~= (my_id OR received_id)) == 0)</P>

<P>// this is the last DONEupdate_state(REMOTE_MODIFIED, original_srcid);remote_response(DONE, original_srcid, my_id, data);free_entry();</P>

<P>else mask &lt;= (mask ~= received_srcid);// flip the responder’s shared bit endif; // and wait for next DONEcase INTERVENTION: // remote_modified case update_memory(); // for possible coherence error</P>

<P>// recoveryupdate_state(REMOTE_MODIFIED, original_id);remote_response(DONE_INTERVENTION, original_id, my_id);free_entry();</P>

<P>case NOT_OWNER: 	// data comes from memory, mimic// intervention </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>switch(directory_state)case LOCAL_SHARED: case LOCAL_MODIFIED: </P>

<P>update_state(REMOTE_MODIFIED, original_srcid);remote_response(DATA_ONLY, original_srcid, my_id,</P>

<P>data);remote_response(DONE, original_srcid, my_id);free_entry();</P>

<P>case REMOTE_MODIFIED: remote_request(READ_TO_OWN_OWNER, received_srcid,my_id, original_srcid);default: error();</P>

<P>case RETRY: 
switch (directory_state)
case LOCAL_MODIFIED, 
case LOCAL_SHARED: 
</P>

<P>update_state(REMOTE_MODIFIED, original_srcid);remote_response(DATA_ONLY, original_srcid, my_id,</P>

<P>data);remote_response(DONE, original_srcid, my_id);free_entry();</P>

<P>case REMOTE_MODIFIED: // mask_id must match received_srcid// or error conditionremote_request(READ_TO_OWN_OWNER, received_srcid,my_id, my_id);case SHARED: remote_request(DKILL_SHARER, received_srcid, my_id,my_id);default: error();default: error();else // my_id ~= mem_id - I’m requesting</P>

<P>// a remote memory location switch (received_response)case DONE: </P>

<P>local_response(EXCLUSIVE);
return_data();
free_entry();
</P>

<P>case DONE_INTERVENTION: 
set_received_done_message();
if (received_data_message)
</P>

<P>free_entry();else // wait for DATA_ONLY endif; </P>

<P>case DATA_ONLY: 
set_received_data_message();
local_response(EXCLUSIVE);
if (received_done_message)
</P>

<P>return_data();free_entry();else return_data(); // OK for weak ordering endif; // and wait for a DONE case RETRY: // lost at remote memory so retryremote_request(READ_TO_OWN_HOME, mem_id, my_id); default: error();endif; </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30677">6.6.3 External Request State Machine </P>

<P>This state machine handles requests from the interconnect to the local memory or the local system. This may require making further external requests. </P>

<P>if (address_collision) // use collision tables</P>

<P>
<Link>// in Chapter 7, “Address Collision Resolution </Link>

<Link>Tables” </Link>
elseif (READ_TO_OWN_HOME) // remote request to our local memory </P>

<P>assign_entry();
switch (directory_state)
case LOCAL_MODIFIED, 
case LOCAL_SHARED: 
</P>

<P>local_request(READ_TO_OWN);remote_response(DONE, received_srcid, my_id, data);</P>

<P>// after possible pushupdate_state(REMOTE_MODIFIED, received_srcid);free_entry();</P>

<P>case REMOTE_MODIFIED: if (mask_id ~= received_srcid) //intervention caseremote_request(READ_TO_OWN_OWNER, mask_id, my_id,received_srcid);else error(); // he already owned it! endif; </P>

<P>case SHARED: 
local_request(READ_TO_OWN);
if (mask == received_srcid) 
</P>

<P>//requestor is only remote sharerupdate_state(REMOTE_MODIFIED, received_srcid);remote_response(DONE, received_srcid, my_id, data);</P>

<P>// from memory free_entry();else //there are other remote sharersremote_request(DKILL_SHARER, (mask ~= received_srcid),my_id, my_id);endif; default: error();</P>

<P>elseif(READ_TO_OWN_OWNER) // request to our caches assign_entry();local_request(READ_TO_OWN); // spin until a valid response from</P>

<P>// the caches switch (local_response)case MODIFIED: // processor indicated a push </P>

<P>cache_state(INVALID); // surrender ownershipif (received_srcid == received_secid)//the original request is from the homeremote_response(INTERVENTION, received_srcid, my_id,data);else // the original request is from a// third partyremote_response(DATA_ONLY, received_secid, my_id,data);remote_response(INTERVENTION, received_srcid, my_id,</P>

<P>data);endif; free_entry();</P>

<P>case INVALID: // castout address collision
remote_response(NOT_OWNER, received_srcid, my_id); 
default: 
error();
endif; 
</P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30678">6.7 	Data Cache and Instruction Cache Invalidate Operations </P>

<P>This operation is used with coherent cache store-hit-on-shared, cache operations; 
<Link>refer to the description in Section 3.3.4. </Link>
</P>

<P id="LinkTarget_30679">6.7.1 Internal Request State Machine </P>

<P>This state machine handles requests to both local and remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external request in // progress or a cache index local_response(RETRY); // hazard from a previous request elseif (local) // our local memory and we won </P>

<P>if (DKILL) // DKILL checks the directory switch (directory_state)case LOCAL_MODIFIED, // local modified is OK if we default</P>

<P>// memory to owned locally </P>

<P>case LOCAL_SHARED: local_response(EXCLUSIVE);if (LOCAL_SHARED)</P>

<P>update_state(LOCAL_MODIFIED, my_id); endif; case REMOTE_MODIFIED: // cache paradox; DKILL is// write-hit-on-shared error();</P>

<P>case SHARED: local_response(RETRY);assign_entry(); // Multicast if possible otherwise </P>

<P>// issue direct to each sharerremote_request(DKILL_SHARER, (mask ~= my_id), my_id); default: error();else // IKILL always goes to everyone remote_request(IKILL_SHARER,(mask &lt;= (participant_list ~= my_id)), my_id); endif; else // remote - we’ve got to go to another</P>

<P>// processing elementassign_entry();local_response(RETRY);remote_request({DKILL_HOME, IKILL_HOME}, mem_id, my_id); endif; </P>

<P id="LinkTarget_30680">6.7.2 Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local system or a third party. </P>

<P>if (my_id == mem_id == original_srcid) // original requestor is home memory switch (received_response)case DONE: // shared cases</P>

<P>if ((mask ~= (my_id OR received_id)) == 0)// this is the last DONE if (DKILL) // don’t update state for IKILLs</P>

<P>update_state(LOCAL_MODIFIED); endif; free_entry();else </P>

<P>RapidIO Trade Association </P>

<P>mask &lt;= (mask ~= received_srcid);// flip the responder’s shared bit and endif; // wait for next DONEcase RETRY: remote_request({DKILL_SHARER, IKILL_SHARER}, received_srcid,my_id); // retry the transaction default: error();</P>

<P>elseif (my_id == mem_id ~= original_srcid) // i’m home memory working// for a third party </P>

<P>switch(received_response)case DONE: // invalidates for shared // directory statesif ((mask ~= (my_id OR received_id)) == 0)// this is the last DONE if (DKILL) // don’t update state for IKILLs</P>

<P>update_state(REMOTE_MODIFIED, original_srcid); endif; remote_response(DONE, original_srcid, my_id);free_entry();</P>

<P>else mask &lt;= (mask ~= received_srcid);// flip the responder’s shared bit endif; // and wait for next DONEcase RETRY: remote_request({DKILL_SHARER, IKILL_SHARER}, received_srcid,my_id); // retry default: error();else // my_id ~= mem_id - I’m requesting</P>

<P>// a remote memory location switch (received_response)case DONE: </P>

<P>local_response(EXCLUSIVE);free_entry();case RETRY: remote_request({DKILL_HOME, IKILL_HOME}, received_srcid,my_id); // retry the transaction default: error();endif; </P>

<P id="LinkTarget_30681">6.7.3 External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory or the local system. This may require making further external requests. </P>

<P>if (address_collision) // use collision tables in</P>

<P>
<Link>// Chapter 7, “Address Collision Resolution </Link>

<Link>Tables” </Link>
elseif (DKILL_HOME || IKILL_HOME) // remote request to our local memory </P>

<P>assign_entry();</P>

<P>if (DKILL_HOME)switch (directory_state)case LOCAL_MODIFIED, // cache paradoxes; DKILL is</P>

<P>// write-hit-on-shared case LOCAL_SHARED, case REMOTE_MODIFIED: </P>

<P>error();case SHARED: // this is the right case, send</P>

<P>// invalidates to the sharing list local_request(DKILL);if (mask == received_srcid</P>

<P>// requestor is only remote sharer </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>if (DKILL) // don’t update state for (IKILLs)update_state(REMOTE_MODIFIED,</P>

<P>received_srcid); endif; remote_response(DONE, received_srcid, my_id);free_entry();</P>

<P>else // there are other remote sharersremote_request(DKILL_SHARER,(mask ~= received_srcid), my_id, NULL); endif; default: error();else // IKILL goes to everyone except the// requestor</P>

<P>remote_request(IKILL_SHARER,(mask &lt;= (participant_list ~=(received_srcid AND my_id), my_id); </P>

<P>else // DKILL_SHARER or IKILL_SHARER to </P>

<P>our caches assign_entry();local_request({READ_TO_OWN, IKILL}); // spin until a valid response from the</P>

<P>// caches switch (local_response)case SHARED, case INVALID: // invalidating for shared cases </P>

<P>cache_state(INVALID); // surrender copyremote_response(DONE, received_srcid, my_id);free_entry(); </P>

<P>default: error();endif; </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30682">6.8 Castout Operations </P>

<P>This operation is used to return ownership of a coherence granule to home memory, 
<Link>leaving it invalid in the cache; refer to the description in Section 3.3.5. </Link>
</P>

<P id="LinkTarget_30683">6.8.1 Internal Request State Machine </P>

<P>A castout is always done to remote memory space. A castout may require local activity to flush all caches in the hierarchy. </P>

<P>if (local) // our local memory switch (directory_state)case LOCAL_MODIFIED: // if the processor is doing a castout</P>

<P>// this is the only legal state local_response(OK);update_memory();update_state(LOCAL_SHARED); </P>

<P>default: error();else // remote - we’ve got to go to another</P>

<P>// processing elementassign_entry();local_response(OK);remote_request(CASTOUT, mem_id, my_id, data); endif; </P>

<P id="LinkTarget_30684">6.8.2 Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local system or a third party. </P>

<P>switch (received_response)
case DONE: 
free_entry(); 
default: 
error(); 
</P>

<P id="LinkTarget_30685">6.8.3 External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory or the local system. This may require making further external requests. </P>

<P>assign_entry();
update_memory();
state_update(LOCAL_SHARED, my_id); // may be LOCAL_MODIFIED if the
</P>

<P>// default is owned locally 
remote_response(DONE, received_srcid, my_id);
free_entry(); 
</P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30686">6.9 	TLB Invalidate Entry, TLB Invalidate Entry Synchronize Operations </P>

<P>These operations are used for software coherence management of the TLBs; refer to 
<Link>the descriptions in Section 3.3.6 and Section 3.3.7. </Link>
</P>

<P id="LinkTarget_30687">6.9.1 Internal Request State Machine </P>

<P>The TLBIE and TLBSYNC transactions are always sent to all domain participants except the sender and are always to the processor not home memory. </P>

<P>assign_entry();
remote_request({TLBIE, TLBSYNC}, participant_id, my_id);
endif; 
</P>

<P id="LinkTarget_30688">6.9.2 Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local system. The responses are always from a coherence participant, not a home memory. </P>

<P>switch (received_response)
case DONE: 
if ((mask ~= (my_id OR received_id)) == 0) 
// this is the last DONE 
free_entry(); 
else 
</P>

<P>mask &lt;= (mask ~= received_srcid); // flip the responder’s participant// bit and wait for next DONE </P>

<P>endif; 
case RETRY: 
remote_request({TLBIE, TLBSYNC}, received_srcid, my_id, my_id); 
default 
error(); 
</P>

<P id="LinkTarget_30689">6.9.3 External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory or the local system. The requests are always to the local caching hierarchy. </P>

<P>assign_entry();
local_request({TLBIE, TLBSYNC}); // spin until a valid response
</P>

<P>// from the caches 
remote_response(DONE, received_srcid, my_id);
free_entry(); 
</P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30690">6.10 Data Cache Flush Operations </P>

<P>This operation returns ownership of a coherence granule to home memory and 
<Link>performs a coherent write; refer to the description in Section 3.3.9. </Link>
</P>

<P id="LinkTarget_30691">6.10.1 Internal Request State Machine </P>

<P>This state machine handles requests to both local and remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external// request in progress or a cache index local_response(RETRY); // hazard from a previous request </P>

<P>elseif (local) // our local memory
switch (directory_state)
case LOCAL_MODIFIED, 
case LOCAL_SHARED: 
</P>

<P>local_response(OK);update_memory();</P>

<P>case REMOTE_MODIFIED: assign_entry();remote_request(READ_TO_OWN_OWNER, mask_id, my_id, my_id);</P>

<P>case SHARED: assign_entry();remote_request(DKILL_SHARER, (mask ~= my_id), my_id); </P>

<P>default: error();else // remote - we’ve got to go to</P>

<P>// another processing element assign_entry();remote_request(FLUSH, mem_id, my_id, data);</P>

<P>// data is optional 
endif; 
</P>

<P id="LinkTarget_30692">6.10.2 Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local system or a third party. </P>

<P>if (my_id == mem_id == original_srcid) // original requestor is home memory switch (received_response)case DONE: </P>

<P>if ((mask ~= (my_id OR received_id)) == 0)// this is the last DONE if (received_data) // with local request or response</P>

<P>update_memory(); endif; update_state(LOCAL_SHARED); // or LOCAL_MODIFIEDlocal_response(OK);free_entry();</P>

<P>else mask &lt;= (mask ~= received_srcid);// flip responder’s shared bit endif; // and wait for next DONE</P>

<P>case NOT_OWNER: 
switch(directory_state)
case LOCAL_SHARED, 
case LOCAL_MODIFIED: 
</P>

<P>if (received_data) // with local request from memory </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>update_memory(); endif; update_state(LOCAL_SHARED); // or LOCAL_MODIFIEDlocal_response(OK);free_entry();</P>

<P>case REMOTE_MODIFIED: remote_request(READ_TO_OWN_OWNER, mask_id, my_id,my_id); default: error();</P>

<P>case RETRY: 
switch (directory_state)
case LOCAL_MODIFIED, 
case LOCAL_SHARED: 
</P>

<P>if (received_data) // with local requestupdate_memory();</P>

<P>// if there was some write data endif; update_state(LOCAL_SHARED); // or LOCAL_MODIFIEDlocal_response(OK);free_entry();</P>

<P>case REMOTE_MODIFIED: // mask_id must match // received_srcid or errorremote_request(READ_TO_OWN_OWNER, received_srcid,my_id, my_id);case SHARED: remote_request(DKILL_SHARER, received_srcid, my_id,my_id);default: error();default: error();</P>

<P>elseif (my_id == mem_id ~= original_srcid) // i’m home memory working for a third// party</P>

<P>switch(received_response)case DONE: // invalidates for shared directory// statesif ((mask ~= (my_id OR received_id)) == 0)</P>

<P>// this is the last DONEremote_response(DONE, original_srcid, my_id, my_id);if (received_data) </P>

<P>// with original request or response</P>

<P>update_memory(); endif; update_state(LOCAL_SHARED);// or LOCAL_MODIFIEDfree_entry();</P>

<P>else mask &lt;= (mask ~= received_srcid);// flip responder’s shared bit endif; // and wait for next DONE</P>

<P>case NOT_OWNER: 
switch(directory_state)
case LOCAL_SHARED, 
case LOCAL_MODIFIED: 
</P>

<P>remote_response(DONE, original_srcid, my_id);if (received_data) // with original request</P>

<P>update_memory(); endif; free_entry();</P>

<P>case REMOTE_MODIFIED: remote_request(READ_TO_OWN_OWNER, received_srcid,my_id, my_id);default: error(); </P>

<P>RapidIO Trade Association </P>

<P>case RETRY: switch(directory_state)case LOCAL_SHARED, case LOCAL_MODIFIED: </P>

<P>remote_response(DONE, original_srcid, my_id);if (received_data) // with original request</P>

<P>update_memory(); endif; free_entry();</P>

<P>case REMOTE_MODIFIED: remote_request(READ_TO_OWN_OWNER, received_srcid,my_id, my_id);case SHARED: remote_request(DKILL_SHARER, received_srcid, my_id); </P>

<Table>
<TR>
<TH>default: </TH>
</TR>

<TR>
<TH>default: </TH>

<TD>error(); </TD>
</TR>

<TR>
<TH>else </TH>

<TD>error(); switch (received_response)case DONE: </TD>

<TD>// my_id ~= mem_id - I’m requesting// a remote memory location </TD>
</TR>

<TR>
<TH/>

<TD>local_response(OK);free_entry();case RETRY: </TD>

<TD/>
</TR>
</Table>

<P>remote_request(FLUSH, received_srcid, my_id, data);// data is optional default: error();endif; </P>

<P id="LinkTarget_30693">6.10.3 External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory or the local system. This may require making further external requests. </P>

<P>if (address_collision) // use collision table in</P>

<P>
<Link>// Chapter 7, “Address Collision Resolution </Link>

<Link>Tables” </Link>
elseif (FLUSH) // remote request to our local memory </P>

<P>assign_entry();switch (directory_state)case LOCAL_MODIFIED, case LOCAL_SHARED: </P>

<P>local_request(READ_TO_OWN);remote_response(DONE, received_srcid, my_id);// after snoop completes if (received_data) // from request or local response </P>

<P>update_memory();endif; update_state(LOCAL_SHARED, my_id);</P>

<P>// or LOCAL_MODIFIED free_entry();case REMOTE_MODIFIED: if (mask_id ~= received_srcid) // owned elsewhereremote_request(READ_TO_OWN_OWNER, mask_id, my_id,my_id); // secondary TID is a don’t care since data is// not forwarded to original requestor else // requestor owned it; shouldn’t// generate a flush error();endif; case SHARED: local_request(READ_TO_OWN); </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>if (mask == received_srcid) // requestor is only remote sharerremote_response(DONE, received_srcid, my_id);// after snoop completes if (received_data) // from request or response</P>

<P>update_memory(); endif; update_state(LOCAL_SHARED, my_id); // or LOCAL_MODIFIEDfree_entry();</P>

<P>else //there are other remote sharersremote_request(DKILL_SHARER, (mask ~= received_srcid), my_id,my_id);endif; default: error();endif; </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30694">6.11 I/O Read Operations </P>

<P>This operation is used for I/O reads of globally shared memory space; refer to the 
<Link>description in Section 3.3.10. </Link>
</P>

<P id="LinkTarget_30695">6.11.1  Internal Request State Machine </P>

<P>This state machine handles requests to both local and remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external request// in progress or a cache index hazard local_response(RETRY); // from a previous request </P>

<P>elseif (local) // our local memory local_response(OK);switch (directory_state)case LOCAL_MODIFIED: // local modified is OK if we default</P>

<P>// local memory to owned local_request(READ_LATEST);return_data()) // after possible push </P>

<P>case LOCAL_SHARED, case SHARED: return_data(); // keep directory state the way it was </P>

<P>case REMOTE_MODIFIED: assign_entry();remote_request(IO_READ_OWNER, mask_id, my_id, my_id); </P>

<P>default: error();else // remote - we’ve got to go to</P>

<P>// another processing element assign_entry();local_response(OK);remote_request(IO_READ_HOME, mem_id, my_id); endif; </P>

<P id="LinkTarget_30696">6.11.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local system or a third party. </P>

<P>if (my_id == mem_id == original_srcid) // original requestor is home memory switch(remote_response) // matches my_id only for // REMOTE_MODIFIED case </P>

<P>case INTERVENTION: 
return_data();
free_entry();
</P>

<P>case NOT_OWNER, 	// due to address collision or // passing requests </P>

<P>case RETRY: 
switch (directory_state)
case LOCAL_MODIFIED: 
case LOCAL_SHARED 
</P>

<P>return_data();free_entry();case REMOTE_MODIFIED: // mask_id must match received_srcid or// error; spin or wait for castoutremote_request(IO_READ_OWNER, received_srcid, my_id,my_id);default: </P>

<P>error(); </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>default error();elseif(my_id == mem_id ~== original_id) // i’m home memory working for a third</P>

<P>// party
switch(remote_response)
case INTERVENTION: 
</P>

<P>update_memory();
remote_response(DONE_INTERVENTION, original_srcid, my_id);
free_entry();
</P>

<P>case NOT_OWNER, 	// data comes from memory, mimic// intervention </P>

<P>case RETRY: switch(directory_state)case LOCAL_MODIFIED, case LOCAL_SHARED: </P>

<P>remote_response(DATA_ONLY, original_srcid, my_id,data);remote_response(DONE_INTERVENTION, original_srcid,my_id);free_entry();case REMOTE_MODIFIED: // spin or wait for castoutremote_request(IO_READ_OWNER, received_srcid, my_id,my_id);</P>

<Table>
<TR>
<TH>default: </TH>
</TR>

<TR>
<TH>default: </TH>

<TD>error(); </TD>
</TR>

<TR>
<TH>else </TH>

<TD>error(); switch(remote_response)case DONE: </TD>

<TD>// my_id ~= mem_id - I’m requesting a// remote memory location </TD>
</TR>

<TR>
<TH/>

<TD>return_data();free_entry();case DONE_INTERVENTION: set_received_done_message();if (received_data_only_message)free_entry();else </TD>

<TD>// must be from third party </TD>
</TR>
</Table>

<P>// wait for a DATA_ONLY endif; </P>

<P>case DATA_ONLY: 	// this is due to an intervention, a// DONE_INTERVENTION should come// separately </P>

<P>set_received_data_only_message();</P>

<P>if (received_done_message)return_data();free_entry();</P>

<P>else return_data(); // OK for weak ordering endif; case RETRY: remote_request(IO_READ_HOME, received_srcid, my_id); default error();endif; </P>

<P id="LinkTarget_30697">6.11.3  External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory or the local system. This may require making further external requests. </P>

<P>if (address_collision) 	// use collision tables in</P>

<P>
<Link>// Chapter 7, “Address Collision Resolution </Link>

<Link>Tables” </Link>
elseif (IO_READ_HOME) // remote request to our local memory </P>

<P>RapidIO Trade Association </P>

<P>assign_entry();
switch (directory_state)
case LOCAL_MODIFIED: 
</P>

<P>local_request(READ_LATEST);remote_response(DONE, received_srcid, my_id, data);// after push completes free_entry();</P>

<P>case LOCAL_SHARED: remote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case REMOTE_MODIFIED: remote_request(IO_READ_OWNER, mask_id, my_id, received_srcid);</P>

<P>case SHARED: remote_response(DONE, received_srcid, my_id, data);free_entry(); </P>

<P>default: 
error();
</P>

<P>else // IO_READ_OWNER request to our caches assign_entry();local_request(READ_LATEST); // spin until a valid response from</P>

<P>// the caches switch (local_response)case MODIFIED: // processor indicated a push;</P>

<P>// wait for it</P>

<P>if (received_srcid == received_secid)// original requestor is also home// memory</P>

<P>remote_response(INTERVENTION, received_srcid, my_id,data);else remote_response(DATA_ONLY, received_secid, my_id,data);remote_response(INTERVENTION, received_srcid, my_id); endif; case INVALID:  // must have cast it out during// an address collisionremote_response(NOT_OWNER, received_srcid, my_id); default: error();free_entry(); endif; </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30698">Chapter 7  Address Collision Resolution Tables </P>

<P id="LinkTarget_30699">7.1 Introduction </P>

<P>Address collisions are conflicts between incoming cache coherence requests to a processing element and outstanding cache coherence requests within it. A collision is usually due to a match between the associated addresses, but also may be because of a conflict for some internal resource such as a cache index. Within a processing element, actions taken in response to an address collision vary depending upon the outstanding request and the incoming request. These actions are described in 
<Link>Table 7-1</Link>

<Link> through Table 7-17. Non-cache coherent</Link>
 transactions (transactions specified in other RapidIO logical specifications) do not cause address collisions. </P>

<P>Some of the table entries specify that an outstanding request should be canceled at the local processor and that the incoming transaction then be issued immediately to the processor. This choosing between transactions is necessary to prevent deadlock conditions between multiple processing elements vying for ownership of a coherence granule. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30700">7.2 Resolving an Outstanding READ_HOME Transaction </P>

<P>
<Link>Table 7-1 describes the address collision resolution for an incoming transaction that </Link>
collides with an outstanding READ_HOME transaction. </P>

<Table>
<Caption>
<P>Table 7-1. Address Collision Resolution for READ_HOME </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>READ_OWNER </TD>

<TD>Generate “NOT_OWNER” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “NOT_OWNER” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>DKILL_SHARER </TD>

<TD>If outstanding request, wait for all expected responses. If final response is “DONE”, return data if necessary and forward DKILL_SHARER to processor then generate a “DONE” response. If final response is “RETRY”, cancel the read at the processor and forward DKILL_SHARED to processor then generate a “DONE” response If no outstanding request, cancel the read at the processor and forward DKILL_SHARER to processor then generate a “DONE” response (this case should be very rare). </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “NOT_OWNER” response </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30701">7.3 	Resolving an Outstanding IREAD_HOME Transaction </P>

<P>
<Link>Table 7-2 describes the address collision resolution for an incoming transaction that </Link>
collides with an outstanding IREAD_HOME transaction. </P>

<Table>
<Caption>
<P>Table 7-2. Address Collision Resolution for IREAD_HOME </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>READ_OWNER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>DKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>IO_READ_OWNER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30702">7.4 	Resolving an Outstanding READ_OWNER 
Transaction 
</P>

<P>
<Link>Table 7-3 describes the address collision resolution for an incoming transaction that </Link>
collides with an outstanding READ_OWNER transaction. </P>

<Table>
<Caption>
<P>Table 7-3. Address Collision Resolution for READ_OWNER </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>READ_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>READ_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>DKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>CASTOUT </TD>

<TD>No collision, update directory state, generate “DONE” response (CASTOUT bypasses address collision detection) </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>IKILL_HOME </TD>

<TD>No collision, forward to processor, send IKILL_SHARER to all participants except requestor (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>IKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>FLUSH </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30703">7.5 	Resolving an Outstanding READ_TO_OWN_HOME Transaction </P>

<P>
<Link>Table 7-4 describes the address collision resolution for an incoming transaction that </Link>
collides with an outstanding READ_TO_OWN_HOME transaction. </P>

<Table>
<Caption>
<P>Table 7-4. Address Collision Resolution for READ_TO_OWN_HOME </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>READ_OWNER </TD>

<TD>
<Link>If outstanding request, wait for all expected responses. If final response is “DONE”, return data if necessary and forward READ_OWNER to processor and generate an “DONE_INTERVENTION” with data response and a “DATA_ONLY” to originator as in Section 3.3.1. If final response is “RETRY” generate an “ERROR” response If no outstanding request generate an “NOT_OWNER” response. </Link>
</TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>
<Link>If outstanding request, wait for all expected responses. If final response is “DONE”, return data if necessary and forward READ_TO_OWN_OWNER to processor and generate an “DONE_INTERVENTION” with data response and a “DATA_ONLY” to originator as in Section 3.3.3. If final response is “RETRY” generate an “ERROR” response </Link>
</TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>DKILL_SHARER </TD>

<TD>If outstanding request, wait for all expected responses. If final response is “DONE” generate an “ERROR” response (we own the coherence granule and should never see a DKILL). If final response is “RETRY” generate a “DONE” response and continue the READ_TO_OWN_HOME. If no outstanding request generate a “DONE” response. </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>FLUSH </TD>

<TD>
<Link>If outstanding request, wait for all expected responses. If final response is “DONE”, return data if necessary and forward FLUSH to processor and generate a “DONE” with data response as in Section 3.3.9. If final response is “RETRY” generate an “ERROR” response (we didn’t own the data and we lost at home memory) If no outstanding request generate an “ERROR” response (we didn’t own the data). </Link>
</TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>IO_READ_OWNER </TD>

<TD>
<Link>If outstanding request, wait for all expected responses. If final response is “DONE”, return data if necessary and forward IO_READ_OWNER to processor then generate a “DONE” with data response, etc. as in Section 3.3.10. If final response is “RETRY” generate an “ERROR” response (we didn’t own the data and we lost at home memory) If no outstanding request generate an “NOT_OWNER” response. </Link>
</TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30704">7.6 	Resolving an Outstanding READ_TO_OWN_OWNER Transaction </P>

<P>
<Link>Table 7-5 describes the address collision resolution for an incoming transaction that </Link>
collides with an outstanding READ_TO_OWN_OWNER transaction. </P>

<Table>
<Caption>
<P>Table 7-5. Address Collision Resolution for READ_TO_OWN_OWNER </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>READ_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>READ_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>DKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>CASTOUT </TD>

<TD>No collision, update directory state, generate “DONE” response (CASTOUT bypasses address collision detection) </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>IKILL_HOME </TD>

<TD>No collision, forward to processor, send IKILL_SHARER to all participants except requestor (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>IKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>FLUSH </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30705">7.7 	Resolving an Outstanding DKILL_HOME 
Transaction 
</P>

<P>
<Link>Table 7-6 describes the address collision resolution for an incoming transaction that </Link>
collides with an outstanding DKILL_HOME transaction. </P>

<Table>
<Caption>
<P>Table 7-6. Address Collision Resolution for DKILL_HOME </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>READ_OWNER </TD>

<TD>
<Link>If outstanding request, wait for all expected responses. If final response is “DONE”, return data if necessary and forward READ_OWNER to processor and generate a “DONE_INTERVENTION” with data response and a “DATA_ONLY” to originator as in Section 3.3.1. If final response is “RETRY” generate an “ERROR” response (we didn’t own the data and we lost at home memory) If no outstanding request generate an “ERROR” response (we didn’t own the data). </Link>
</TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>
<Link>If outstanding request, wait for all expected responses. If final response is “DONE” forward READ_TO_OWN_OWNER to processor and generate a “DONE_INTERVENTION” with data response and a “DATA_ONLY” to originator as in Section 3.3.3. If final response is “RETRY” generate an “ERROR” response (we didn’t own the data and we lost at home memory) If no outstanding request generate an “ERROR” response (we didn’t own the data). </Link>
</TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>DKILL_SHARER </TD>

<TD>If outstanding request, wait for all expected responses. If final response is “DONE” generate an “ERROR” response (we should never see a DKILL_SHARER if we own the coherence granule). If final response is “RETRY” cancel the data cache invalidate at the processor and forward DKILL_SHARER to processor then generate a “DONE” response If no outstanding request, cancel the data cache invalidate at the processor and forward DKILL_SHARER to processor then generate a “DONE” response. </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response (cache paradox, can’t have a SHARED granule also MODIFIED in another processing element) </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>
</Table>

<Table>
<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>IO_READ_OWNER </TD>

<TD>
<Link>If outstanding request, wait for all expected responses. If final response is “DONE” forward IO_READ_OWNER to processor then generate a “DONE” with data response, etc. as in Section 3.3.10. If final response is “RETRY” generate an “ERROR” response (we didn’t own the data and we lost at home memory) If no outstanding request generate an “ERROR” response (we didn’t own the data). </Link>
</TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30706">7.8 	Resolving an Outstanding DKILL_SHARER 
Transaction 
</P>

<P>
<Link>Table 7-7 describes the address collision resolution for an incoming transaction that </Link>
collides with an outstanding DKILL_SHARER transaction. </P>

<Table>
<Caption>
<P>Table 7-7. Address Collision Resolution for DKILL_SHARER </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>READ_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>READ_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>DKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response (cache paradox, can’t have a SHARED granule also MODIFIED in another processing element) </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>IKILL_HOME </TD>

<TD>No collision, forward to processor, send IKILL_SHARER to all participants except requestor (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>IKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>FLUSH </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>IO_READ_HOME </TD>

<TD>
<Link>If processing element is HOME: generate a “RETRY” response If processing element is not HOME: If outstanding request, wait for all expected responses. If final response is “DONE” forward IO_READ to processor then generate a “DONE” with data response, etc. as in Section 3.3.10. If final response is “RETRY” generate an “ERROR” response (we didn’t own the data and we lost at home memory) If no outstanding request generate an “ERROR” response (we didn’t own the data). </Link>
</TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30707">7.9 Resolving an Outstanding IKILL_HOME Transaction </P>

<P>
<Link>Table 7-8 describes the address collision resolution for an incoming transaction that </Link>
collides with an outstanding IKILL_HOME transaction. </P>

<Table>
<Caption>
<P>Table 7-8. Address Collision Resolution for IKILL_HOME </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>READ_OWNER </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>DKILL_SHARER </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>CASTOUT </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>IO_READ_OWNER </TD>

<TD>No collision, process normally </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30708">7.10 	Resolving an Outstanding IKILL_SHARER 
Transaction 
</P>

<P>
<Link>Table 7-9 describes the address collision resolution for an incoming transaction that </Link>
collides with an outstanding IKILL_SHARER transaction. </P>

<Table>
<Caption>
<P>Table 7-9. Address Collision Resolution for IKILL_SHARER </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>READ_HOME </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>IREAD_HOME </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>READ_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>DKILL_HOME </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>DKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>CASTOUT </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>IKILL_HOME </TD>

<TD>No collision, forward to processor, send IKILL_SHARER to all participants except requestor (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>IKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>FLUSH </TD>

<TD>No collision, process normally </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>IO_READ_HOME </TD>

<TD>
<Link>If processing element is HOME: generate a “RETRY” response If processing element is not HOME: If outstanding request, wait for all expected responses. If final response is “DONE” forward IO_READ to processor then generate a “DONE” with data response, etc. as in Section 3.3.10. If final response is “RETRY” generate an “ERROR” response (we didn’t own the data and we lost at home memory) If no outstanding request generate an “ERROR” response (we didn’t own the data). </Link>
</TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30709">7.11  Resolving an Outstanding CASTOUT Transaction </P>

<P>
<Link>Table 7-10 describes the address collision resolution for an incoming transaction </Link>
that collides with an outstanding CASTOUT transaction. </P>

<Table>
<Caption>
<P>Table 7-10. Address Collision Resolution for CASTOUT </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>READ_OWNER </TD>

<TD>Generate “RETRY” response; the CASTOUT will bypass address collision at home memory and modify the directory state </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “RETRY” response; the CASTOUT will bypass address collision at home memory and modify the directory state </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>DKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “RETRY” response; the CASTOUT will bypass address collision at home memory and modify the directory state </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30710">7.12 	Resolving an Outstanding TLBIE or TLBSYNC 
Transaction 
</P>

<P>
<Link>Table 7-11 describes the address collision resolution for an incoming transaction </Link>
that collides with an outstanding TLBIE or TLBSYNC transaction. </P>

<Table>
<Caption>
<P>Table 7-11. Address Collision Resolution for Software Coherence Operations </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>TLBIE, TLBSYNC </TD>

<TD>ANY </TD>

<TD>
<Link>No collision, process request as described in Chapter 6, “Communication Protocols” </Link>
</TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30711">7.13 Resolving an Outstanding FLUSH Transaction </P>

<P>The flush operation has two distinct versions. The first is for processing elements that participate in the coherence protocol such as a processor and it’s associated agent, which may also have a local I/O device. The second is for processing elements that do not participate in the coherence protocols such as a pure I/O device 
<Link>that does not have a corresponding bit in the directory sharing mask. Table 7-12 </Link>
describes the address collision resolution for an incoming transaction that collides with an outstanding participant FLUSH transaction. </P>

<Table>
<Caption>
<P>Table 7-12. Address Collision Resolution for Participant FLUSH </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>READ_OWNER </TD>

<TD>Generate “NOT_OWNER” response (we are not allowed to issue FLUSH to an owned coherence granule - should be a CASTOUT) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “NOT_OWNER” response (we are not allowed to issue FLUSH to an owned coherence granule - should be a CASTOUT) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>DKILL_SHARER </TD>

<TD>If outstanding request, wait for all expected responses. If final response is “DONE” generate an “ERROR” response (we should never see a DKILL_SHARER if we own the coherence granule). If final response is “RETRY” cancel the flush at the processor and forward DKILL_SHARER to processor then generate a “DONE” response If no outstanding request, cancel the data cache invalidate at the processor and forward DKILL_SHARER to processor then generate a “DONE” response. </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “NOT_OWNER” response (we are not allowed to issue FLUSH to an owned coherence granule - should be a CASTOUT) </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>
<Link>Table 7-13 describes the address collision resolution for an incoming transaction </Link>
that collides with an outstanding non-participant FLUSH transaction. </P>

<Table>
<Caption>
<P>Table 7-13. Address Collision Resolution for Non-participant FLUSH </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>READ_OWNER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>DKILL_SHARER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) - non-participant may have page table hardware. </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) - non-participant may have page table hardware. </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) - non-participant may have software coherence. </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>FLUSH </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30712">7.14 	Resolving an Outstanding IO_READ_HOME Transaction </P>

<P>The I/O read operation is used by processing elements that do not want to participate in the coherence protocol but do want to get current copies of cached data. There are two versions of this operation, one for processing elements that have both processors and I/O devices, the second for pure I/O devices that do not have a corresponding 
<Link>bit in the directory sharing mask. Table 7-14 describes the address collision </Link>
resolution for an incoming transaction that collides with an outstanding participant IO_READ_HOME transaction. </P>

<Table>
<Caption>
<P>Table 7-14. Address Collision Resolution for Participant IO_READ_HOME </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>READ_OWNER </TD>

<TD>Generate “NOT_OWNER” response (we don’t own the data otherwise we could have obtained a copy locally) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “NOT_OWNER” response (we don’t own the data otherwise we could have obtained a copy locally) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>DKILL_SHARER </TD>

<TD>If outstanding request, wait for all expected responses. If final response is “DONE”, return data if necessary and forward DKILL_SHARER to processor then generate a “DONE” response. If final response is “RETRY” forward DKILL_SHARED to processor then generate a “DONE” response If no outstanding request forward DKILL_SHARER to processor then generate a “DONE” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “NOT_OWNER” response (we don’t own the data otherwise we could have obtained a copy locally) </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>
<Link>Table 7-15 describes the address collision resolution for an incoming transaction </Link>
that collides with an outstanding non-participant IO_READ_HOME transaction. </P>

<Table>
<Caption>
<P>Table 7-15. Address Collision Resolution for Non-participant IO_READ_HOME </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>READ_OWNER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>DKILL_SHARER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) - broadcast operation and non-participant may have page table hardware. </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) - broadcast operation and non-participant may have page table hardware. </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IKILL_HOME </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IKILL_SHARER </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain instruction cache coherence) - broadcast operation and non-participant may have software coherence. </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30713">7.15 	Resolving an Outstanding IO_READ_OWNER Transaction </P>

<P>The I/O read operation is used by processing elements that do not want to participate in the coherence protocol but do want to get current copies of cached data. There are two versions of this operation, one for processing elements that have both processors and I/O devices, the second for pure I/O devices that do not have a corresponding bit in
<Link> the directory sharing mask. Table 7-16 describes the </Link>
address collision resolution for an incoming transaction that collides with an outstanding IO_READ_OWNER transaction. </P>

<Table>
<Caption>
<P>Table 7-16. Address Collision Resolution for Participant IO_READ_OWNER </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>READ_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>READ_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>DKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>CASTOUT </TD>

<TD>No collision, update directory state and memory, generate DONE response (CASTOUT bypasses address collision detection) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IKILL_HOME </TD>

<TD>No collision, forward to processor, send IKILL_SHARER to all participants except requestor (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>FLUSH </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “RETRY” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “ERROR” response (we don’t own the data otherwise we could have obtained a copy locally) </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>
<Link>Table 7-17 describes the address collision resolution for an incoming transaction </Link>
that collides with an outstanding non-participant IO_READ_OWNER transaction. </P>

<Table>
<Caption>
<P>Table 7-17. Address Collision Resolution for Non-participant IO_READ_OWNER </P>
</Caption>

<TR>
<TH>Outstanding Request </TH>

<TH>Incoming Request </TH>

<TH>Resolution </TH>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>READ_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IREAD_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>READ_OWNER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>READ_TO_OWN_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>READ_TO_OWN_OWNER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>DKILL_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>DKILL_SHARER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>CASTOUT </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>TLBIE </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) - non-participant may have page table hardware. </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>TLBSYNC </TD>

<TD>No collision, forward to processor then generate “DONE” response (software must maintain TLB entry coherence) - non-participant may have page table hardware. </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IKILL_HOME </TD>

<TD>No collision, forward to processor, send IKILL_SHARER to all participants except requestor (software must maintain instruction cache coherence) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IKILL_SHARER </TD>

<TD>Generate “ERROR” response </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>FLUSH </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IO_READ_HOME </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>IO_READ_OWNER </TD>

<TD>Generate “ERROR” response (should never receive coherent operation) </TD>
</TR>
</Table>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P id="LinkTarget_30714">Glossary of Terms and Abbreviations 
</P>

<P>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </P>

<P>Address collision. An address based conflict between two or more cache </P>

<P>A </P>

<P>coherence operations when referencing the same coherence granule. </P>

<P>Agent. A processing element that provides services to a processor. </P>

<P>Asychronous transfer mode (ATM). A standard networking protocol which dynamically allocates bandwidth using a fixed-size packet. </P>

<P>B Big-endian. A byte-ordering method in memory where the address n of a word corresponds to the most significant byte. In an addressed memory word, the bytes are ordered (left to right) 0, 1, 2, 3, with 0 being the most significant byte. </P>

<P>Block flush. An operation that returns the latest copy of a block of data from caches within the system to memory. </P>

<P>Bridge. A processing element that connects one computer bus to another, allowing a processing element on one bus to access an processing element on the other. </P>

<P>Broadcast. The concept of sending a packet to all processing elements in a system. </P>

<P>Bus-based snoopy protocol. A broadcast cache coherence protocol that assumes that all caches in the system are on a common bus. </P>

<P>Cache. High-speed memory containing recently accessed data and/or instructions (subset of main memory) associated with a processor. </P>

<P>Cache coherence. Caches are coherent if a processor performing a read from its cache is supplied with data corresponding to the most recent value written to memory or to another processor’s cache. In other words, a write operation to an address in the system is visible to all other caches in the system. Also referred to as memory coherence. </P>

<P>RapidIO Trade Association </P>

<P>Cache coherent-non uniform memory access (CC-NUMA). A cache coherent system in which memory accesses have different latencies depending upon the physical location of the accessed address. </P>

<P>Cache paradox. A circumstance in which the caches in a system have an undefined or disallowed state for a coherence granule, for example, two caches have the same coherence granule marked “modified”. </P>

<P>Capability registers (CARs). A set of read-only registers that allows a processing element to determine another processing element’s capabilities. </P>

<P>Castout operation. An operation used by a processing element to relinquish its ownership of a coherence granule and return it to home memory. </P>

<P>Coherence domain. A logically associated group of processing elements that participate in the globally shared memory protocol and are able to maintain cache coherence among themselves. </P>

<P>Coherence granule. A contiguous block of data associated with an address for the purpose of guaranteeing cache coherence. </P>

<P>Command and status registers (CSRs). A set of registers that allows a processing element to control and determine the status of another processing element’s internal hardware. </P>

<P>D 
</P>

<P>Deadlock. A situation in which two processing elements that are sharing resources prevent each other from accessing the resources, resulting in a halt of system operation. </P>

<P>Destination. The termination point of a packet on the RapidIO interconnect, also referred to as a target. </P>

<P>Device. 	A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a processing element. </P>

<P>Device ID. The identifier of an end point processing element connected to the RapidIO interconnect. </P>

<P>Direct Memory Access (DMA). The process of accessing memory in a device by specifying the memory address directly. </P>

<P>Distributed memory. System memory that is distributed throughout the system, as opposed to being centrally located. </P>

<P>Domain. A logically associated group of processing elements. </P>

<P>Double-word. An eight byte quantity, aligned on eight byte boundaries. </P>

<P>E 
</P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>End point. A processing element which is the source or destination of transactions through a RapidIO fabric. </P>

<P>Ethernet. A common local area network (LAN) technology. </P>

<P>Exclusive. A processing element has the only cached copy of a sharable coherence granule. The exclusive state allows the processing element to modify the coherence granule without notifying the rest of the system. </P>

<Table>
<TR>
<TH>F </TH>

<TD>Field or Field name. A sub-unit of a register, where bits in the register are named and defined. Flush operation. An operation used by a processing element to return the ownership and current data of a coherence granule to home memory. </TD>
</TR>

<TR>
<TH>G </TH>

<TD>Globally shared memory (GSM). Cache coherent system memory that can be shared between multiple processors in a system. </TD>
</TR>

<TR>
<TH>H </TH>

<TD>Half-word. A two byte or 16 bit quantity, aligned on two byte boundaries. Home memory. The physical memory corresponding to the physical address of a coherence granule. </TD>
</TR>
</Table>

<P>Initiator. The origin of a packet on the RapidIO interconnect, also referred to as a source. </P>

<P>Instruction cache. High-speed memory containing recently accessed instructions (subset of main memory) associated with a processor. </P>

<P>Instruction cache invalidate operation. An operation that is used if the instruction cache coherence must be maintained by software. </P>

<P>Instruction read operation. An operation used to obtain a globally shared copy of a coherence granule specifically for an instruction cache. </P>

<P>Instruction set architecture (ISA). The instruction set for a certain processor or family of processors. </P>

<P>Intervention. A data transfer between two processing elements that does not go through the coherence granule’s home memory, but directly between the requestor of the coherence granule and the current owner. </P>

<P>Invalidate operation. An operation used to remove a coherence granule from caches within the coherence domain. </P>

<P>RapidIO Trade Association </P>

<P>I/O. Input-output. </P>

<P>I/O read operation. An operation used by an I/O processing element to obtain a globally shared copy of a coherence granule without disturbing the coherence state of the granule. </P>

<P>Little-endian. A byte-ordering method in memory where the address n of a word corresponds to the least significant byte. In an addressed memory word, the bytes are ordered (left to right) 3, 2, 1, 0, with 3 being the most significant byte. </P>

<P>Local memory. Memory associated with the processing element in question. </P>

<P>LSB. Least significant byte. </P>

<P>M 
</P>

<P>Memory coherence. Memory is coherent if a processor performing a read from its cache is supplied with data corresponding to the most recent value written to memory or to another processor’s cache. In other words, a write operation to an address in the system is visible to all other caches in the system. Also referred to as cache coherence. </P>

<P>Memory controller. The point through which home memory is accessed. </P>

<P>Memory directory. A table of information associated with home memory that is used to track the location and state of coherence granules cached by coherence domain participants. </P>

<P>Message passing. An application programming model that allows processing elements to communicate via messages to mailboxes instead of via DMA or GSM. Message senders do not write to a memory address in the receiver. </P>

<P>Modified. A processing element has written to a locally cached coherence granule and so has the only valid copy of the coherence granule in the system. </P>

<P>Modified exclusive shared invalid (MESI). A standard 4 state cache coherence definition. </P>

<P>Modified shared invalid (MSI). A standard 3 state cache coherence definition. </P>

<P>Modified shared local (MSL). A standard 3 state cache coherence definition. </P>

<P>MSB. Most significant byte. </P>

<P>Multicast. The concept of sending a packet to more than one processing elements in a system. </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>N Non-coherent. A transaction that does not participate in any system globally shared memory cache coherence mechanism. </P>

<P>O 
</P>

<P>Operation. A set of transactions between end point devices in a RapidIO system (requests and associated responses) such as a read or a write. </P>

<P>Ownership. A processing element has the only valid copy of a coherence granule and is responsible for returning it to home memory. </P>

<P>P 
</P>

<P>Packet. 	A set of information transmitted between devices in a RapidIO system. </P>

<P>Peripheral component interface (PCI). A bus commonly used for connecting I/O devices in a system. </P>

<P>Priority. The relative importance of a packet; in most systems a higher priority packet will be serviced or transmitted before one of lower priority. </P>

<P>Processing Element (PE). A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a device. </P>

<P>Processor. The logic circuitry that responds to and processes the basic instructions that drive a computer. </P>

<P>R 
</P>

<P>Read operation. An operation used to obtain a globally shared copy of a coherence granule. </P>

<P>Read-for-ownership operation. An operation used to obtain ownership of a coherence granule for the purposes of performing a write operation. </P>

<P>Remote access. An access by a processing element to memory located in another processing element. </P>

<P>Remote memory. Memory associated with a processing element other than the processing element in question. </P>

<P>S 
</P>

<P>Shared. A processing element has a cached copy of a coherence granule that may be cached by other processing elements and is consistent with the copy in home memory. </P>

<P>Sharing mask. The state associated with a coherence granule in the memory directory that tracks the processing elements that are sharing the coherence granule. </P>

<P>Source. The origin of a packet on the RapidIO interconnect, also referred to as an initiator. </P>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 Sub-double-word. Aligned on eight byte boundaries. Switch. A multiple port processing element that directs a packet received on one of its input ports to one of its output ports. </P>

<P>T 
</P>

<P>Target. The termination point of a packet on the RapidIO interconnect, also referred to as a destination. </P>

<P>Transaction. A specific request or response packet transmitted between end point devices in a RapidIO system. </P>

<P>Translation look-aside buffer (TLB). Part of a processor’s memory management unit; a TLB contains a set of virtual to physical page address translations, along with a set of attributes that describe access behavior for that portion of physical memory. </P>

<P>Write-through. A cache policy that passes all write operations through the </P>

<P>W </P>

<P>caching hierarchy directly to home memory. Word. A four byte or 32 bit quantity, aligned on four byte boundaries. </P>

<P>RapidIO Part 5: Globally Shared Memory Logical Specification Rev. 1.3 </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P id="LinkTarget_30715">RapidIOTM Interconnect SpecificationPart 6: 1x/4x LP-Serial PhysicalLayer Specification </P>

<P>Rev. 1.3, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_97.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>
</TR>

<TR>
<TH>1.1 </TH>

<TH>First release </TH>

<TD>12/17/2001 </TD>
</TR>

<TR>
<TH>1.2 </TH>

<TH>Technical changes: incorporate Rev. 1.1 errata rev. 1.1.1, errata 3 </TH>

<TD>06/26/2002 </TD>
</TR>

<TR>
<TH>1.3 </TH>

<TH>Technical changes: incorporate Rev 1.2 errata 1 as applicable, the following errata showings: 03-03-00004.002, 03-07-00002.001, 03-12-00000.002, 03-12-00002.004, 04-02-00000.001, 04-05-00000.003, 04-05-00006.002 (partial), 04-05-00007.001 and the following new features showings: 02-03-0003.004, 02-06-00001.004, 04-08-00013.002, 04-09-00022.002 Converted to ISO-friendly templates </TH>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TH>1.3 </TH>

<TH>Removed confidentiality markings for public release </TH>

<TD>06/07/2005 </TD>
</TR>
</Table>

<P>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE 
ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND 
CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO 
WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE. USER AGREES TO 
ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE 
GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR 
RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER 
SUCH USE OF THE SPECIFICATION. 
</P>

<P>DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, 
INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST 
PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION 
WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE 
RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. 
</P>

<P>Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: 
RapidIO Trade Association 
Suite 325, 3925 W. Braker Lane 
Austin, TX 78759 
512-305-0070 Tel. 
512-305-0009 FAX. 
</P>

<P>RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their 
respective owners. 
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents 
</P>

<P>
<Link>Chapter 1 Overview </Link>
</P>

<P>
<Link>1.1 Introduction........................................................................................................... 13 
</Link>
</P>

<P>
<Link>1.2 Packets .................................................................................................................. 14 
</Link>
</P>

<P>
<Link>1.3 Control Symbols ................................................................................................... 14 
</Link>
</P>

<P>
<Link>1.4 PCS and PMA Layers ........................................................................................... 14 
</Link>
</P>

<P>
<Link>1.5 LP-Serial Protocol................................................................................................. 15 
</Link>
</P>

<P>
<Link>1.6 LP-Serial Registers ............................................................................................... 15 
</Link>
</P>

<P>
<Link>1.7 Signal Descriptions ............................................................................................... 15 
</Link>
</P>

<P>
<Link>1.8 AC Electrical Specifications ................................................................................. 15 
</Link>
</P>

<P>
<Link>1.9 Interface Management .......................................................................................... 15 
</Link>
</P>

<P>
<Link>1.10 System Resources ................................................................................................. 16 
</Link>
</P>

<P>
<Link>1.11 Manufacturability and Testability......................................................................... 16 
</Link>
</P>

<P>
<Link>Chapter 2  Packets </Link>
</P>

<P>
<Link>2.1 Introduction........................................................................................................... 17 
</Link>
</P>

<P>
<Link>2.2 Packet Field Definitions........................................................................................ 17 
</Link>
</P>

<P>
<Link>2.3 Packet Format ....................................................................................................... 18 
</Link>
</P>

<P>
<Link>2.4 Packet Protection .................................................................................................. 18 
</Link>
</P>

<P>
<Link>2.4.1 Packet CRC Operation...................................................................................... 19 
</Link>
</P>

<P>
<Link>2.4.2 16-Bit Packet CRC Code .................................................................................. 21 
</Link>
</P>

<P>
<Link>2.5 Maximum Packet Size .......................................................................................... 23 
</Link>
</P>

<P>
<Link>Chapter 3  Control Symbols </Link>
</P>

<P>
<Link>3.1 Introduction........................................................................................................... 25 
</Link>
</P>

<P>
<Link>3.2 Control Symbol Field Definitions......................................................................... 25 
</Link>
</P>

<P>
<Link>3.3 Control Symbol Format ........................................................................................ 25 
</Link>
</P>

<P>
<Link>3.4 Stype0 Control Symbols ....................................................................................... 26 
</Link>
</P>

<P>
<Link>3.4.1 Packet-Accepted Control Symbol..................................................................... 27 
</Link>
</P>

<P>
<Link>3.4.2 Packet-Retry Control Symbol ........................................................................... 28 
</Link>
</P>

<P>
<Link>3.4.3 Packet-Not-Accepted Control Symbol ............................................................. 28 
</Link>
</P>

<P>
<Link>3.4.4 Status Control Symbol ...................................................................................... 29 
</Link>
</P>

<P>
<Link>3.4.5 Link-Response Control Symbol ....................................................................... 29 
</Link>
</P>

<P>
<Link>3.5 Stype1 Control Symbols ....................................................................................... 30 
</Link>
</P>

<P>
<Link>3.5.1 Start-of-Packet Control Symbol........................................................................ 30 
</Link>
</P>

<P>
<Link>3.5.2 Stomp Control Symbol ..................................................................................... 31 
</Link>
</P>

<P>
<Link>3.5.3 End-of-Packet Control Symbol......................................................................... 31 
</Link>
</P>

<P>
<Link>3.5.4 Restart-From-Retry Control Symbol ................................................................ 31 
</Link>
</P>

<P>
<Link>3.5.5 Link-Request Control Symbol .......................................................................... 32 
</Link>
</P>

<P>
<Link>3.5.5.1 Reset-Device Command ............................................................................... 32 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>3.5.5.2 Input-Status Command ................................................................................. 33 
</Link>
</P>

<P>
<Link>3.5.6 Multicast-Event Control Symbol ...................................................................... 33 
</Link>
</P>

<P>
<Link>3.6 Control Symbol Protection ................................................................................... 33 
</Link>
</P>

<P>
<Link>3.6.1 CRC-5 Code...................................................................................................... 33 
</Link>
</P>

<P>
<Link>3.6.2 CRC-5 Parallel Code Generation...................................................................... 34 
</Link>
</P>

<P>
<Link>Chapter 4 PCS and PMA Layers </Link>
</P>

<P>
<Link>4.1 Introduction........................................................................................................... 35 
</Link>
</P>

<P>
<Link>4.2 PCS Layer Functions ............................................................................................ 35 
</Link>
</P>

<P>
<Link>4.3 PMA Layer Functions........................................................................................... 36 
</Link>
</P>

<P>
<Link>4.4 Definitions ............................................................................................................ 36 
</Link>
</P>

<P>
<Link>4.5 8B/10B Transmission Code .................................................................................. 37 
</Link>
</P>

<P>
<Link>4.5.1 Character and Code-Group Notation ................................................................ 37 
</Link>
</P>

<P>
<Link>4.5.2 Running Disparity............................................................................................. 38 
</Link>
</P>

<P>
<Link>4.5.3 Running Disparity Rules................................................................................... 39 
</Link>
</P>

<P>
<Link>4.5.4 8B/10B Encoding.............................................................................................. 39 
</Link>
</P>

<P>
<Link>4.5.5 Transmission Order........................................................................................... 40 
</Link>
</P>

<P>
<Link>4.5.6 8B/10B Decoding ............................................................................................. 41 
</Link>
</P>

<P>
<Link>4.5.7 Special Characters and Columns ...................................................................... 49 
</Link>
</P>

<P>
<Link>4.5.7.1 Packet Delimiter Control Symbol (/PD/)...................................................... 49 
</Link>
</P>

<P>
<Link>4.5.7.2 Start of Control Symbol (/SC/) ..................................................................... 50 
</Link>
</P>

<P>
<Link>4.5.7.3 Idle (/I/) ......................................................................................................... 50 
</Link>
</P>

<P>
<Link>4.5.7.4 Sync (/K/)...................................................................................................... 50 
</Link>
</P>

<P>
<Link>4.5.7.5 Skip (/R/) ...................................................................................................... 50 
</Link>
</P>

<P>
<Link>4.5.7.6 Align (/A/) .................................................................................................... 50 
</Link>
</P>

<P>
<Link>4.5.8 Effect of Single Bit Code-Group Errors ........................................................... 51 
</Link>
</P>

<P>
<Link>4.5.9 Idle Sequence .................................................................................................... 51 
</Link>
</P>

<P>
<Link>4.5.9.1 Idle Sequence Generation ............................................................................. 53 
</Link>
</P>

<P>
<Link>4.5.10 1x Link Transmission Rules ............................................................................. 54 
</Link>
</P>

<P>
<Link>4.5.11 4x Link Striping and Transmission Rules ........................................................ 56 
</Link>
</P>

<P>
<Link>4.6 Retimers and Repeaters ........................................................................................ 58 
</Link>
</P>

<P>
<Link>4.6.1 Retimers ............................................................................................................ 59 
</Link>
</P>

<P>
<Link>4.6.2 Repeaters........................................................................................................... 59 
</Link>
</P>

<P>
<Link>4.7 Port Initialization .................................................................................................. 60 
</Link>
</P>

<P>
<Link>4.7.1 1x Mode Initialization....................................................................................... 60 
</Link>
</P>

<P>
<Link>4.7.2 1x/4x Mode Initialization.................................................................................. 60 
</Link>
</P>

<P>
<Link>4.7.3 State Machines .................................................................................................. 61 
</Link>
</P>

<P>
<Link>4.7.3.1 State Machine Conventions .......................................................................... 61 
</Link>
</P>

<P>
<Link>4.7.3.2 State Machine Variables and Functions ....................................................... 61 
</Link>
</P>

<P>
<Link>4.7.3.3 Lane Synchronization State Machine ........................................................... 64 
</Link>
</P>

<P>
<Link>4.7.3.4 Lane Alignment State Machine .................................................................... 67 
</Link>
</P>

<P>
<Link>4.7.3.5 1x Mode Initialization State Machine........................................................... 69 
</Link>
</P>

<P>
<Link>4.7.3.6 1x/4x Mode Initialization State Machine ..................................................... 70 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 5 LP-Serial Protocol </Link>
</P>

<P>
<Link>5.1 Introduction........................................................................................................... 73 
</Link>
</P>

<P>
<Link>5.2 Packet Exchange Protocol .................................................................................... 73 
</Link>
</P>

<P>
<Link>5.3 Control Symbols ................................................................................................... 74 
</Link>
</P>

<P>
<Link>5.3.1 Control Symbol Delimiting .............................................................................. 74 
</Link>
</P>

<P>
<Link>5.3.2 Control Symbol Transmission .......................................................................... 75 
</Link>
</P>

<P>
<Link>5.3.3 Embedded Control Symbols ............................................................................. 75 
</Link>
</P>

<P>
<Link>5.3.4 Multicast-Event Control Symbols .................................................................... 76 
</Link>
</P>

<P>
<Link>5.4 Packets .................................................................................................................. 77 
</Link>
</P>

<P>
<Link>5.4.1 Packet Delimiting ............................................................................................. 77 
</Link>
</P>

<P>
<Link>5.4.1.1 Packet Start ................................................................................................... 77 
</Link>
</P>

<P>
<Link>5.4.1.2 Packet Termination ....................................................................................... 77 
</Link>
</P>

<P>
<Link>5.4.2 Acknowledgment Identifier .............................................................................. 77 
</Link>
</P>

<P>
<Link>5.4.3 Packet Priority and Transaction Request Flows ............................................... 78 
</Link>
</P>

<P>
<Link>5.5 Link Maintenance Protocol................................................................................... 79 
</Link>
</P>

<P>
<Link>5.6 Packet Transmission Protocol............................................................................... 80 
</Link>
</P>

<P>
<Link>5.7 Flow Control ......................................................................................................... 82 
</Link>
</P>

<P>
<Link>5.7.1 Receiver-Controlled Flow Control ................................................................... 82 
</Link>
</P>

<P>
<Link>5.7.2 Transmitter-Controlled Flow Control ............................................................... 84 
</Link>
</P>

<P>
<Link>5.7.2.1 Input Retry-Stopped Recovery Process ........................................................ 85 
</Link>
</P>

<P>
<Link>5.7.2.2 Output Retry-Stopped Recovery Process ..................................................... 86 
</Link>
</P>

<P>
<Link>5.7.2.3 Receive Buffer Management ........................................................................ 86 
</Link>
</P>

<P>
<Link>5.7.2.4 Effective Number of Free Receive Buffers .................................................. 87 
</Link>
</P>

<P>
<Link>5.7.2.5 Speculative Packet Transmission ................................................................. 88 
</Link>
</P>

<P>
<Link>5.7.3 Flow Control Mode Negotiation....................................................................... 88 
</Link>
</P>

<P>
<Link>5.8 Canceling Packets ................................................................................................. 89 
</Link>
</P>

<P>
<Link>5.9 Transaction and Packet Delivery Ordering Rules................................................. 90 
</Link>
</P>

<P>
<Link>5.10 Deadlock Avoidance ............................................................................................. 91 
</Link>
</P>

<P>
<Link>5.11 Error Detection and Recovery .............................................................................. 93 
</Link>
</P>

<P>
<Link>5.11.1 Lost Packet Detection ....................................................................................... 94 
</Link>
</P>

<P>
<Link>5.11.2 Link Behavior Under Error............................................................................... 94 
</Link>
</P>

<P>
<Link>5.11.2.1 Recoverable Errors ....................................................................................... 95 
</Link>
</P>

<P>
<Link>5.11.2.2 Idle Sequence Errors ..................................................................................... 95 
</Link>
</P>

<P>
<Link>5.11.2.3 Control Symbol Errors.................................................................................. 95 
</Link>
</P>

<P>
<Link>5.11.2.3.1 Link Protocol Violations .......................................................................... 96 
</Link>
</P>

<P>
<Link>5.11.2.3.2 Corrupted Control symbols ...................................................................... 96 
</Link>
</P>

<P>
<Link>5.11.2.4 Packet Errors................................................................................................. 97 
</Link>
</P>

<P>
<Link>5.11.2.5 Link Time-Out .............................................................................................. 97 
</Link>
</P>

<P>
<Link>5.11.2.6 Input Error-Stopped Recovery Process ........................................................ 97 
</Link>
</P>

<P>
<Link>5.11.2.7 Output Error-Stopped Recovery Process ...................................................... 98 
</Link>
</P>

<P>
<Link>5.12 Power Management .............................................................................................. 98 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 6 LP-Serial Registers </Link>
</P>

<P>
<Link>6.1 Introduction........................................................................................................... 99 
</Link>
</P>

<P>
<Link>6.2 Register Map ......................................................................................................... 99 
</Link>
</P>

<P>
<Link>6.3 Reserved Register and Bit Behavior ................................................................... 100 
</Link>
</P>

<P>
<Link>6.4 Capability Registers (CARs) .............................................................................. 102 
</Link>
</P>

<P>
<Link>6.4.1 Processing Element Features CAR (Configuration Space Offset 0x10) ........ 102 
</Link>
</P>

<P>
<Link>6.5 Generic End Point Devices ................................................................................. 103 
</Link>
</P>

<P>
<Link>6.5.1 Register Map................................................................................................... 103 
</Link>
</P>

<P>
<Link>6.5.2 Command and Status Registers (CSRs) ......................................................... 105 
</Link>
</P>

<P>
<Link>6.5.2.1 1x/4x LP-Serial Register Block Header (Block Offset 0x0) ...................... 105 
</Link>
</P>

<P>
<Link>6.5.2.2 Port Link Time-out Control CSR (Block Offset 0x20) .............................. 105 
</Link>
</P>

<P>
<Link>6.5.2.3 Port Response Time-out Control CSR (Block Offset 0x24) ...................... 106 
</Link>
</P>

<P>
<Link>6.5.2.4 Port General Control CSR (Block Offset 0x3C) ........................................ 106 
</Link>
</P>

<P>
<Link>6.5.2.5 Port n Error and Status CSRs (Block Offsets 0x58, 78, ..., 238)................ 107 
</Link>
</P>

<P>
<Link>6.5.2.6 Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C) ............................. 108 
</Link>
</P>

<P>
<Link>6.6 Generic End Point Devices, software assisted error recovery option ................. 110 
</Link>
</P>

<P>
<Link>6.6.1 Register Map................................................................................................... 110 
</Link>
</P>

<P>
<Link>6.6.2 Command and Status Registers (CSRs) ......................................................... 112 
</Link>
</P>

<P>
<Link>6.6.2.1 1x/4x LP-Serial Register Block Header (Block Offset 0x0) ...................... 112 
</Link>
</P>

<P>
<Link>6.6.2.2 Port Link Time-out Control CSR (Block Offset 0x20) .............................. 112 
</Link>
</P>

<P>
<Link>6.6.2.3 Port Response Time-out Control CSR (Block Offset 0x24) ...................... 113 
</Link>
</P>

<P>
<Link>6.6.2.4 Port General Control CSR (Block Offset 0x3C) ........................................ 113 
</Link>
</P>

<P>
<Link>6.6.2.5 	Port n Link Maintenance Request CSRs (Block Offsets 0x40, 60, ..., 220) ........................................................... 114 </Link>
</P>

<P>
<Link>6.6.2.6 	Port n Link Maintenance Response CSRs (Block Offsets 0x44, 64, ..., 224) ........................................................... 114 </Link>
</P>

<P>
<Link>6.6.2.7 Port n Local ackID CSRs (Block Offsets 0x48, 68, ..., 228) ...................... 114 
</Link>
</P>

<P>
<Link>6.6.2.8 Port n Error and Status CSRs (Block Offset 0x58, 78, ..., 238) ................. 115 
</Link>
</P>

<P>
<Link>6.6.2.9 Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C) ............................. 116 
</Link>
</P>

<P>
<Link>6.7 Generic End Point Free Devices ......................................................................... 119 
</Link>
</P>

<P>
<Link>6.7.1 Register Map ................................................................................................... 119 
</Link>
</P>

<P>
<Link>6.7.2 Command and Status Registers (CSRs) ......................................................... 120 
</Link>
</P>

<P>
<Link>6.7.2.1 1x/4x LP-Serial Register Block Header (Block Offset 0x0) ...................... 120 
</Link>
</P>

<P>
<Link>6.7.2.2 Port Link Time-out Control CSR (Block Offset 0x20) .............................. 120 
</Link>
</P>

<P>
<Link>6.7.2.3 Port General Control CSR (Block Offset 0x3C) ........................................ 121 
</Link>
</P>

<P>
<Link>6.7.2.4 Port n Error and Status CSRs (Block Offsets 0x58, 78, .., 238)................. 121 
</Link>
</P>

<P>
<Link>6.7.2.5 Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C) ............................. 122 
</Link>
</P>

<P>
<Link>6.8 Generic End Point Free Devices, software assisted error recovery option......... 125 
</Link>
</P>

<P>
<Link>6.8.1 Register Map ................................................................................................... 125 
</Link>
</P>

<P>
<Link>6.8.2 Command and Status Registers (CSRs) ......................................................... 127 
</Link>
</P>

<P>
<Link>6.8.2.1 1x/4x LP-Serial Register Block Header (Block Offset 0x0) ...................... 127 
</Link>
</P>

<P>
<Link>6.8.2.2 Port Link Time-out Control CSR (Block Offset 0x20) .............................. 127 
</Link>
</P>

<P>
<Link>6.8.2.3 Port General Control CSR (Block Offset 0x3C) ........................................ 128 
</Link>
</P>

<P>
<Link>6.8.2.4 	Port n Link Maintenance Request CSRs (Block Offsets 0x40, 60, ..., 220) ........................................................... 128 </Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>6.8.2.5 	Port n Link Maintenance Response CSRs (Block Offsets 0x44, 64, ..., 224) ........................................................... 128 </Link>
</P>

<P>
<Link>6.8.2.6 Port n Local ackID CSRs (Block Offsets 0x48, 68, ..., 228) ...................... 129 
</Link>
</P>

<P>
<Link>6.8.2.7 Port n Error and Status CSRs (Block Offset 0x58, 78, ..., 238) ................. 129 
</Link>
</P>

<P>
<Link>6.8.2.8 Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C) ............................. 130 
</Link>
</P>

<P>
<Link>Chapter 7 Signal Descriptions </Link>
</P>

<P>
<Link>7.1 Introduction......................................................................................................... 133 
</Link>
</P>

<P>
<Link>7.2 Signal Definitions ............................................................................................... 133 
</Link>
</P>

<P>
<Link>7.3 Serial RapidIO Interface Diagrams..................................................................... 134 
</Link>
</P>

<P>
<Link>Chapter 8 Electrical Specifications </Link>
</P>

<P>
<Link>8.1 Introduction......................................................................................................... 135 
</Link>
</P>

<P>
<Link>8.2 Signal Definitions ............................................................................................... 136 
</Link>
</P>

<P>
<Link>8.3 Equalization ........................................................................................................ 137 
</Link>
</P>

<P>
<Link>8.4 Explanatory Note on Transmitter and Receiver Specifications .......................... 137 
</Link>
</P>

<P>
<Link>8.5 Transmitter Specifications .................................................................................. 138 
</Link>
</P>

<P>
<Link>8.6 Receiver Specifications....................................................................................... 142 
</Link>
</P>

<P>
<Link>8.7 Receiver Eye Diagrams ...................................................................................... 145 
</Link>
</P>

<P>
<Link>8.8 Measurement and Test Requirements ................................................................. 146 
</Link>
</P>

<P>
<Link>8.8.1 Eye template measurements............................................................................ 146 
</Link>
</P>

<P>
<Link>8.8.2 Jitter test measurements .................................................................................. 146 
</Link>
</P>

<P>
<Link>8.8.3 Transmit jitter ................................................................................................. 146 
</Link>
</P>

<P>
<Link>8.8.4 Jitter tolerance ................................................................................................. 147 
</Link>
</P>

<P>
<Link>Annex A   Interface Management (Informative) </Link>
</P>

<P>
<Link>A.1 Introduction......................................................................................................... 149 
</Link>
</P>

<P>
<Link>A.2 Packet Retry Mechanism .................................................................................... 149 
</Link>
</P>

<P>
<Link>A.2.1 Input port retry recovery state machine .......................................................... 149 
</Link>
</P>

<P>
<Link>A.2.2 Output port retry recovery state machine ....................................................... 151 
</Link>
</P>

<P>
<Link>A.3 Error Recovery.................................................................................................... 153 
</Link>
</P>

<P>
<Link>A.3.1 Input port error recovery state machine .......................................................... 153 
</Link>
</P>

<P>
<Link>A.3.2 Output port error recovery state machine ....................................................... 154 
</Link>
</P>

<P>
<Link>Annex B   Critical Resource Performance Limits (Informative) </Link>
</P>

<P>
<Link>Annex C   Manufacturability and Testability (Informative) </Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>List of Figures 
</P>

<P>
<Link>2-2 Packet Alignment............................................................................................................18 
</Link>

<Link>2-1 Packet Format .................................................................................................................18 
</Link>

<Link>2-3 Error Coverage of First 16 Bits of Packet Header ..........................................................19 
</Link>

<Link>2-4 Unpadded Packet of Length 80 Bytes or Less ................................................................20 
</Link>

<Link>2-5 Padded Packet of Length 80 Bytes or Less.....................................................................20 
</Link>

<Link>2-6 Unpadded Packet of Length Greater than 80 Bytes........................................................20 
</Link>

<Link>2-7 Padded Packet of Length Greater than 80 Bytes ............................................................21 
</Link>

<Link>2-8 CRC Generation Pipeline................................................................................................22 
</Link>

<Link>3-1 Packet-Retry Control Symbol Format ............................................................................25 
</Link>

<Link>3-2 Packet-Accepted Control Symbol Format ......................................................................27 
</Link>

<Link>3-3 Packet-Retry Control Symbol Format ............................................................................28 
</Link>

<Link>3-4 Packet-Not-Accepted Control Symbol Format ...............................................................28 
</Link>

<Link>3-5 Status Control Symbol Format .......................................................................................29 
</Link>

<Link>3-6 Link-Response Control Symbol Format .........................................................................29 
</Link>

<Link>3-7 Start-of-Packet Control Symbol Format .........................................................................30 
</Link>

<Link>3-8 Stomp Control Symbol Format .......................................................................................31 
</Link>

<Link>3-9 End-of-Packet Control Symbol Format ..........................................................................31 
</Link>

<Link>3-10 Restart-From-Retry Control Symbol Format..................................................................31 
</Link>

<Link>3-11 Link-Request Control Symbol Format ...........................................................................32 
</Link>

<Link>3-12 Multicast-Event Control Symbol Format .......................................................................33 
</Link>

<Link>3-13 5-bit CRC Implementation..............................................................................................34 
</Link>

<Link>4-1 Character Notation Example (D25.3) .............................................................................38 
</Link>

<Link>4-2 Code-Group Notation Example (/D25.3/) ......................................................................38 
</Link>

<Link>4-3 Lane Encoding, Serialization, Deserialization, and Decoding Process ..........................40 
</Link>

<Link>4-4 Example of a Pseudo-Random Idle Code-Group Generator ..........................................53 
</Link>

<Link>4-5 1x Mode Control Symbol Encoding and Transmission Order .......................................54 
</Link>

<Link>4-6 1x Mode Packet Encoding and Transmission Order ......................................................55 
</Link>

<Link>4-7 1x Typical Data Flow .....................................................................................................56 
</Link>

<Link>4-8 Typical 4x Data Flow .....................................................................................................58 
</Link>

<Link>4-9 Lane_Synchronization State ...........................................................................................66 
</Link>

<Link>4-10 Lane_Alignment State Machine .....................................................................................68 
</Link>

<Link>4-11 1x_Initialization State Machine ......................................................................................70 
</Link>

<Link>4-12 1x/4x_Initialization State Machine .................................................................................72 
</Link>

<Link>5-1 Example Transaction with Acknowledgment .................................................................74 
</Link>

<Link>5-2 Receiver-Controlled Flow Control .................................................................................83 
</Link>

<Link>5-3 Transmitter-Controlled Flow Control .............................................................................85 
</Link>

<Link>7-1 RapidIO 1x Device to 1x Device Interface Diagram ....................................................134 
</Link>

<Link>7-2 RapidIO 4x Device to 4x Device Interface Diagram ....................................................134 
</Link>

<Link>7-3 RapidIO 4x Device to 1x Device Interface Diagram ....................................................134 
</Link>

<Link>8-1 Differential Peak-Peak Voltage of Transmitter or Receiver .........................................136 
</Link>

<Link>8-2 Transmitter Output Compliance Mask .........................................................................141 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>
<Link>8-3 Single Frequency Sinusoidal Jitter Limits ....................................................................144 
</Link>

<Link>8-4 Receiver Input Compliance Mask.................................................................................145 
</Link>

<Link>A-1 Input Port Retry Recovery State Machine ....................................................................150 
</Link>

<Link>A-2 Output Port Retry Recovery State Machine .................................................................151 
</Link>

<Link>A-3 Input Port Error Recovery State Machine.....................................................................153 
</Link>

<Link>A-4 Output Port Error Recovery State Machine ..................................................................155 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables 
</P>

<P>
<Link>2-1 Packet Field Definitions..................................................................................................17 
</Link>

<Link>2-2 Parallel CRC Intermediate Value Equations ..................................................................21 
</Link>

<Link>2-3 Maximum Packet Size ....................................................................................................23 
</Link>

<Link>3-1 Control Symbol Field Definitions...................................................................................25 
</Link>

<Link>3-2 Stype0 Control Symbol Encoding ..................................................................................26 
</Link>

<Link>3-3 Stype0 Parameter Definitions .........................................................................................27 
</Link>

<Link>3-4 Cause Field Definition ....................................................................................................28 
</Link>

<Link>3-5 Port_status Field Definitions ..........................................................................................29 
</Link>

<Link>3-6 Stype1 Control Symbol Encoding ..................................................................................30 
</Link>

<Link>3-7 Cmd Field Definitions ....................................................................................................32 
</Link>

<Link>3-8 Parallel CRC Equations ..................................................................................................34 
</Link>

<Link>4-1 Data Character Encodings ..............................................................................................41 
</Link>

<Link>4-2 Special Character Encodings ..........................................................................................48 
</Link>

<Link>4-3 Special Characters and Columns ....................................................................................49 
</Link>

<Link>4-4 Code-Group Corruption Caused by Single Bit Errors ....................................................51 
</Link>

<Link>5-1 Transaction Request Flow to Priority Mapping..............................................................78 
</Link>

<Link>5-2 Transaction Request Flow to Priority and Critical Request Flow Mapping ...................78 
</Link>

<Link>6-1 1x/4x LP-Serial Register Map ......................................................................................100 
</Link>

<Link>6-2 Configuration Space Reserved Access Behavior..........................................................100 
</Link>

<Link>6-3 Bit Settings for Processing Element Features CAR......................................................102 
</Link>

<Link>6-4 LP-Serial Register Map - Generic End Point Devices.................................................103 
</Link>

<Link>6-5 Bit Settings for 1x/4x LP-Serial Register Block Header ..............................................105 
</Link>

<Link>6-6 Bit Settings for Port Link Time-out Control CSR ........................................................105 
</Link>

<Link>6-7 Bit Settings for Port Response Time-out Control CSR ................................................106 
</Link>

<Link>6-8 Bit Settings for Port General Control CSRs .................................................................106 
</Link>

<Link>6-9 Bit Settings for Port n Error and Status CSRs ..............................................................107 
</Link>

<Link>6-10 Bit Settings for Port n Control CSRs ............................................................................108 
</Link>

<Link>6-11 LP-Serial Register Map - Generic End Point Devices (SW assisted)...........................110 
</Link>

<Link>6-12 Bit Settings for 1x/4x LP-Serial Register Block Header ..............................................112 
</Link>

<Link>6-13 Bit Settings for Port Link Time-out Control CSR ........................................................112 
</Link>

<Link>6-14 Bit Settings for Port Response Time-out Control CSR ................................................113 
</Link>

<Link>6-15 Bit Settings for Port General Control CSRs .................................................................113 
</Link>

<Link>6-16 Bit Settings for Port n Link Maintenance Request CSRs .............................................114 
</Link>

<Link>6-17 Bit Settings for Port n Link Maintenance Response CSRs...........................................114 
</Link>

<Link>6-18 Bit Settings for Port n Local ackID Status CSRs..........................................................114 
</Link>

<Link>6-19 Bit Settings for Port n Error and Status CSRs ..............................................................115 
</Link>

<Link>6-20 Bit Settings for Port n Control CSRs ............................................................................116 
</Link>

<Link>6-21 LP-Serial Register Map - Generic End Point Free Devices.........................................119 
</Link>

<Link>6-22 Bit Settings for 1x/4x LP-Serial Register Block Header ..............................................120 
</Link>

<Link>6-23 Bit Settings for Port Link Time-out Control CSR ........................................................120 
</Link>

<Link>6-24 Bit Settings for Port General Control CSRs .................................................................121 
</Link>

<Link>6-25 Bit Settings for Port n Error and Status CSRs ..............................................................121 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>
<Link>6-26 Bit Settings for Port n Control CSRs ............................................................................122 
</Link>

<Link>6-27 LP-Serial Register Map - Generic End Point-free Devices (SW assisted) ...................125 
</Link>

<Link>6-28 Bit Settings for 1x/4x LP-Serial Register Block Header ..............................................127 
</Link>

<Link>6-29 Bit Settings for Port Link Time-out Control CSR ........................................................127 
</Link>

<Link>6-30 Bit Settings for Port General Control CSRs .................................................................128 
</Link>

<Link>6-31 Bit Settings for Port n Link Maintenance Request CSRs .............................................128 
</Link>

<Link>6-32 Bit Settings for Port n Link Maintenance Response CSRs...........................................128 
</Link>

<Link>6-33 Bit Settings for Port n Local ackID Status CSRs..........................................................129 
</Link>

<Link>6-34 Bit Settings for Port n Error and Status CSRs ..............................................................129 
</Link>

<Link>6-35 Bit Settings for Port n Control CSRs ............................................................................130 
</Link>

<Link>7-1 1x/4x LP-Serial Signal Description ..............................................................................133 
</Link>

<Link>8-1 Short Run Transmitter AC Timing Specifications - 1.25 GBaud .................................138 
</Link>

<Link>8-2 Short Run Transmitter AC Timing Specifications - 2.5 GBaud ...................................138 
</Link>

<Link>8-3 Short Run Transmitter AC Timing Specifications - 3.125 GBaud ...............................139 
</Link>

<Link>8-4 Long Run Transmitter AC Timing Specifications - 1.25 GBaud .................................139 
</Link>

<Link>8-5 Long Run Transmitter AC Timing Specifications - 2.5 GBaud ...................................140 
</Link>

<Link>8-6 Long Run Transmitter AC Timing Specifications - 3.125 GBaud ...............................140 
</Link>

<Link>8-7 Transmitter Differential Output Eye Diagram Parameters ...........................................141 
</Link>

<Link>8-8 Receiver AC Timing Specifications - 1.25 GBaud.......................................................142 
</Link>

<Link>8-9 Receiver AC Timing Specifications - 2.5 GBaud.........................................................142 
</Link>

<Link>8-10 Receiver AC Timing Specifications - 3.125 GBaud.....................................................143 
</Link>

<Link>8-11 Receiver Input Compliance Mask Parameters exclusive of Sinusoidal Jitter ..............145 
</Link>

<Link>A-1 Input Port Retry Recovery State Machine Transition Table.........................................150 
</Link>

<Link>A-2 Output Port Retry Recovery State Machine Transition Table ......................................152 
</Link>

<Link>A-3 Input Port Error Recovery State Machine Transition Table .........................................154 
</Link>

<Link>A-4 Output Port Error Recovery State Machine Transition Table ......................................155 
</Link>

<Link>B-12 Packet Transmission Delay Components .....................................................................160 
</Link>

<Link>B-13 Packet Acknowledgment Delay Components...............................................................161 
</Link>

<Link>B-14 Packet Delays................................................................................................................161 
</Link>

<Link>B-15 Maximum Transmission Distances...............................................................................162 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30716">Chapter 1 Overview </P>

<P id="LinkTarget_30717">1.1 Introduction </P>

<P>The RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification addresses the physical layer requirements for devices utilizing an electrical serial connection medium. This specification defines a full duplex serial physical layer interface (link) between devices using unidirectional differential signals in each direction. Further, it allows ganging of four serial links for applications requiring higher link performance. It also defines a protocol for link management and packet transport over a link. </P>

<P>RapidIO systems are comprised of end point processing elements and switch processing elements. The RapidIO interconnect architecture is partitioned into a layered hierarchy of specifications which includes the Logical, Common Transport, and Physical layers. The Logical layer specifications define the operations and associated transactions by which end point processing elements communicate with each other. The Common Transport layer defines how transactions are routed from one end point processing element to another through switch processing elements. The Physical Layer defines how adjacent processing elements electrically connect to each other. RapidIO packets are formed through the combination of bit fields defined in the Logical, Common Transport, and Physical Layer specifications. </P>

<P>The RapidIO 1x/4x LP-Serial specification defines a protocol for packet delivery between serial RapidIO devices including packet and control symbol transmission, flow control, error management, and other device to device functions. A particular device may not implement all of the mode selectable features found in this document. See the appropriate user’s manual or implementation specification for specific implementation details of a device. </P>

<P>The 1x/4x LP-Serial physical layer specification has the following properties: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Embeds the transmission clock with data using an 8B/10B encoding scheme. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Supports one serial differential pair, referred to as one lane, or four ganged serial differential pairs, referred to as four lanes, in each direction. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Allows switching packets between RapidIO 1x/4x LP-Serial ports and RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification ports without requiring packet manipulation. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Employs similar retry and error recovery protocols as the RapidIO 8/16 LP-LVDS physical layer specification. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P>• Supports transmission rates of 1.25, 2.5, and 3.125 Gbaud (data rates of 1.0, 2.0, and 2.5 Gbps) per lane. </P>

<P>This specification first defines the individual elements that make up the link protocol such as packets, control symbols, and the serial bit encoding scheme. This is followed by a description of the link protocol. Finally, the control and status registers, signal descriptions, and electrical specifications are specified. </P>

<P id="LinkTarget_30718">1.2 Packets </P>

<P>
<Link>Chapter 2, “Packets” defines how a RapidIO 1x/4x LP-Serial packet is formed by </Link>
prefixing a 10-bit physical layer header to the combined RapidIO transport and logical layer bit fields followed by an appended 16-bit CRC field. </P>

<P>This chapter shows the packet header format, the packet field definitions, the CRC error detection mechanism, and the packet alignment rules necessary to form LP-Serial packets. </P>

<P id="LinkTarget_30719">1.3 Control Symbols </P>

<P>
<Link>Chapter 3, “Control Symbols” defines the format of the two classes of control </Link>
symbols (stype0 and stype1) used for packet acknowledgment, link utility functions, link maintenance, and packet delineation. A control symbol is a 24-bit entity (including a 5-bit CRC code). The control symbol is used for packet delineation and may also be embedded within a packet as well as sent when the link is idle. </P>

<P>Acknowledgment control symbols are used by processing elements to indicate packet transmission status. Utility control symbols are used to communicate buffer status and link recovery synchronization. Link maintenance control symbols are used by adjacent devices to communicate physical layer status, synchronization requests, and device reset. </P>

<P id="LinkTarget_30720">1.4 PCS and PMA Layers </P>

<P>
<Link>Chapter 4, “PCS and PMA Layers” describes the Physical Coding Sublayer (PCS) </Link>
functionality as well as the Physical Media Attachment (PMA) functionality. The PCS layer functionality includes 8B/10B encoding scheme for embedding clock with data. It also gives transmission rules for the 1x and 4x interfaces and defines the link initialization sequence for clock synchronization. </P>

<P>The PMA (Physical Medium Attachment) function is responsible for serializing the 10-bit code-groups to and from the serial bitstream(s). </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30721">1.5 LP-Serial Protocol </P>

<P>
<Link>Chapter 5, “LP-Serial Protocol” describes in detail how packets, control symbols, </Link>
and the PCS/PMA layers are used to implement the physical layer protocol. This includes topics such as link initialization, link maintenance, error detection and recovery, flow control, and transaction delivery ordering. </P>

<P id="LinkTarget_30722">1.6 LP-Serial Registers </P>

<P>
<Link>Chapter 6, “LP-Serial Registers” describes the physical layer control and status </Link>
register set. By accessing these registers a processing element may query the capabilities and status and configure another 1x/4x LP-Serial RapidIO processing element. </P>

<P>These registers utilize the Extended Features blocks and are accessed using RapidIO Part 1: Input/Output Logical Specification maintenance operations. Four types of RapidIO devices are defined in this section as follows: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Generic End Point Processing Elements </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Generic End Point Processing Elements with software assisted error recovery </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Generic End Point Free Processing Elements (typically switch processing elements) </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Generic End Point Free Processing Elements with software assisted error recovery </LI_Title>
</LI>
</L>

<P id="LinkTarget_30723">1.7 Signal Descriptions </P>

<P>
<Link>Chapter 7, “Signal Descriptions” contains the signal pin descriptions for a RapidIO </Link>
LP-Serial end point device and shows connectivity between processing elements with 1x ports and processing elements with 4x ports. </P>

<P id="LinkTarget_30724">1.8 AC Electrical Specifications </P>
</Div>

<Div>
<P>
<Link>Chapter 8, “Electrical Specifications” describes the electrical specifications for the </Link>
RapidIO 1x/4x LP-Serial device. This section defines two transmission types; short run and long run, as well as three speed grades (1.25 GHz, 2.5 GHz, and 3.125 GHz). This section also shows the required receiver eye diagrams for each link speed. </P>

<P id="LinkTarget_30725">1.9 Interface Management </P>

<P>
<Link>Annex A, “Interface Management (Informative)” contains information pertinent to </Link>
interface management in a RapidIO system, including error recovery, link initialization, and packet retry state machines. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30726">1.10 System Resources </P>

<P>
<Link>Annex B, “Critical Resource Performance Limits (Informative)” contains a </Link>
discussion on outstanding transactions and their relationship to transmission distance capability. </P>

<P id="LinkTarget_30727">1.11  Manufacturability and Testability </P>

<P>
<Link>Section Annex C, “Manufacturability and Testability (Informative)” recommends </Link>
implementing to IEEE standard 1149.6 for improved manufacturing and manufacturing test. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30728">Chapter 2 Packets </P>

<P id="LinkTarget_30729">2.1 Introduction </P>

<P>This chapter specifies the LP-Serial packet format and the fields that are added by LP-Serial physical layer. These packets are fed into the PCS function explained in 
<Link>Chapter 4, “PCS and PMA Layers”. </Link>
</P>

<P id="LinkTarget_30730">2.2 Packet Field Definitions </P>

<P>This section specifies the bit fields added to a packet by the LP-Serial physical layer. These fields are required to implement the flow control, error management, and other specified system functions of the LP-Serial specification. The fields are specified in 
<Link>Table 2-1. </Link>
</P>

<Table>
<Caption>
<P>Table 2-1. Packet Field Definitions </P>
</Caption>

<TR>
<TD>Field </TD>

<TD>Description </TD>
</TR>

<TR>
<TD>ackID </TD>

<TD>
<Link>Acknowledge ID is the packet identifier for acknowledgments back to the packet sender—see Section 5.4.2 for details concerning ackID functionality. </Link>
</TD>
</TR>

<TR>
<TD>rsvd </TD>

<TD>The reserved bits are set to logic 0 when the packet is generated and ignored when a packet is received. </TD>
</TR>

<TR>
<TD>prio </TD>

<TD>
<Link>Sets packet priority: 0b00 - lowest priority 0b01 - medium priority 0b10 - high priority 0b11 - highest priority See Section 5.4.3 for an explanation of prioritizing packets </Link>
</TD>
</TR>

<TR>
<TD>CRF </TD>

<TD>
<Link>Critical Request Flow is an optional bit that differentiates between flows of equal priority If Critical Request Flow is not supported, this bit is reserved See Section 5.4.3 for an explanation of prioritizing packets </Link>
</TD>
</TR>

<TR>
<TD>CRC </TD>

<TD>
<Link>Cyclic Redundancy Code used to detect transmission errors in the packet. See Section 2.4.1 for details on the CRC error detection scheme. </Link>
</TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30731">2.3 Packet Format </P>

<P>
<Link>This section specifies the format of a LP-Serial packets. Figure 2-1 shows the format </Link>
of the LP-Serial packet and how the physical layer ackID, rsvd, CRF, and prio fields are prefixed at the beginning of the packet and the 16-bit CRC field is appended to the end of the packet. </P>

<Table>
<TR>
<TH>ackID </TH>

<TH>rsvd </TH>

<TH>CRF </TH>

<TH>prio </TH>

<TH>transport &amp; logical fields </TH>

<TH>CRC </TH>
</TR>
</Table>

<P>5 2 1 2 n 16 </P>

<P>Figure 2-1. Packet Format </P>

<P>The unshaded fields are the fields added by the physical layer. The shaded field is the combined logical and transport layer bits and fields that are passed to the physical layer. The 2-bit rsvd field is required to make the packet length an integer multiple of 16 bits. </P>

<P>LP-Serial packets shall have a length that is an integer multiple of 32 bits. This sizing simplifies the design of port logic whose internal data paths are an integer multiple of 32 bits in width. Packets, as defined in this specification and the appropriate logical and transport layer specifications, have a length that is an integer 
<Link>multiple of 16 bits. This is illustrated in Figure 2-2. If the length of a packet defined </Link>
by the above combination of specifications is an odd multiple of 16 bits, a 16-bit pad whose value is 0 (0x0000) shall be appended at the end of the packet such that the resulting padded packet is an integer multiple of 32 bits in length. </P>

<Table>
<TR>
<TH>ackID</TH>

<TH>00 </TH>

<TH>CRF </TH>

<TH>prio </TH>

<TH>tt </TH>

<TH>ftype </TH>

<TH>Remainder of transport &amp; logical fields </TH>

<TH>CRC </TH>
</TR>
</Table>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_98.jpg"/>
16 bits </Figure>
5 2 1 2 2 4 n*16 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_99.jpg"/>
</Figure>

<P>start of packet 16-bit boundary </P>

<P>Figure 2-2. Packet Alignment </P>

<P id="LinkTarget_30732">2.4 Packet Protection </P>

<P>A 16-bit CRC code is added to each packet by the LP-Serial physical layer to provide error detection. The code covers the entire packet except for the ackID field and one bit of the rsvd field, which are considered to be zero for the CRC calculations. 
<Link>Figure 2-3 shows the CRC coverage for the first 16 bits of the packet </Link>
which contain the bits not covered by the code. </P>

<P>RapidIO Trade Association </P>

<P>This structure allows the ackID to be changed on a link-by-link basis as the packet is transported across the fabric without requiring that the CRC be recomputed for each link. Since ackIDs on each link are assigned sequentially for each subsequent transmitted packet, an error in the ackID field is easily detected. </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_100.jpg"/>
ackID ftype0 0 prio ttCRF </Figure>
Protected by protocol </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_101.jpg"/>
</Figure>
Protected by CRC 51112 2 4 </P>

<P>Figure 2-3. Error Coverage of First 16 Bits of Packet Header </P>

<P id="LinkTarget_30733">2.4.1 Packet CRC Operation </P>

<P>The CRC is appended to a packet in one of two ways. For a packet whose length, exclusive of CRC, is 80 bytes or less, a single CRC is appended at the end of the logical fields. For packets whose length, exclusive of CRC, is greater than 80 bytes, a CRC is added after the first 80 bytes and a second CRC is appended at the end of the logical layer fields. </P>

<P>The second CRC value is a continuation of the first. The first CRC is included in the running calculation, meaning that the running CRC value is not reinitialized after it is inserted after the first 80 bytes of the packet. This allows intervening devices to regard the embedded CRC value as two bytes of packet payload for CRC checking purposes. If the CRC appended to the end of the logical layer fields does not cause the end of the resulting packet to align to a 32-bit boundary, a two byte pad of all logic 0s is postpended to the packet. The pad of logic 0s allows the CRC check to always be done at the 32-bit boundary. A corrupt pad may or may not cause a CRC error to be detected, depending upon the implementation. </P>

<P>The early CRC value can be used by the receiving processing element to validate the header of a large packet and start processing the data before the entire packet has been received, freeing up resources earlier and reducing transaction completion latency. </P>

<P>NOTE: </P>

<P>While the embedded CRC value can be used by a processing element to start processing the data within a packet before receiving the entire packet, it is possible that upon reception of the end of the packet the final CRC value for the packet is incorrect. This would result in a processing element that has processed data that may have been corrupted. Outside of the error recovery mechanism described in 
<Link>Section 5.11.2</Link>
, the RapidIO Interconnect Specification does not address the occurrence of such situations nor does it suggest a means by which a processing element would handle such situations. Instead, the mechanism for handling this situation is left to be addressed by the device manufacturers for devices that implement the functionality of </P>

<P>RapidIO Trade Association </P>

<P>early processing of packet data. </P>

<P>
<Link>Figure 2-4</Link>
 is an example of an unpadded packet of length less than or equal to 80 bytes. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_102.jpg"/>
Even multiple of 16-bits 16 start of packet CRCFirst half-word Remainder of packet 32-bit boundary 16 </Figure>

<P>Figure 2-4. Unpadded Packet of Length 80 Bytes or Less </P>

<P>
<Link>Figure 2-5</Link>
 is an example of a padded packet of length less than or equal to 80 bytes. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_103.jpg"/>
16 CRC Logic 0 pad 16 Odd multiple of 16-bits start of packet First half-word Remainder of packet 32-bit boundary 16 </Figure>

<P>Figure 2-5. Padded Packet of Length 80 Bytes or Less </P>

<P>
<Link>Figure 2-6</Link>
 is an example of an unpadded packet of length greater than 80 bytes. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_104.jpg"/>
Odd multiple of 16-bits start of packet First half-word Remainder of packet header Logical data CRC 32-bit boundary 16 (bytes 1 and 2) </Figure>

<P>Even multiple of 16-bits 16 (bytes 81 and 82) </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_105.jpg"/>
Remainder of logical data CRC </Figure>

<P>Even multiple of 16-bits 16 32-bit boundary </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_106.jpg"/>
</Figure>

<P>Figure 2-6. Unpadded Packet of Length Greater than 80 Bytes </P>

<P>
<Link>Figure 2-7</Link>
 is an example of a padded packet of length greater than 80 bytes. </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_107.jpg"/>
Even multiple of 16-bits start of packet First half-word Remainder of packet header 16 (bytes 81 and 82) Logical data CRC 16 Remainder of logical data CRC Odd multiple of 16-bits Odd multiple of 16-bits Logic 0 pad 16 32-bit boundary 16 (bytes 1 and 2) </Figure>

<P>32-bit boundary </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_108.jpg"/>
</Figure>

<P>Figure 2-7. Padded Packet of Length Greater than 80 Bytes </P>

<P id="LinkTarget_30734">2.4.2 16-Bit Packet CRC Code </P>

<P>The ITU polynomial X16+X12+X5+1 shall be used to generate the 16-bit CRC for packets. The value of the CRC shall be initialized to 0xFFFF (all logic 1s) at the beginning of each packet. For the CRC calculation, the uncovered six bits are treated as logic 0s. As an example, a 16-bit wide parallel calculation is described in the equations in 
<Link>Table 2-2. Equivalent implementations of other widths can be </Link>
employed. </P>

<Table>
<Caption>
<P>Table 2-2. Parallel CRC Intermediate Value Equations </P>
</Caption>

<TR>
<TH>Check Bit </TH>

<TH>e 0 0 </TH>

<TH>e 0 1 </TH>

<TH>e 0 2 </TH>

<TH>e 0 3 </TH>

<TH>e 0 4 </TH>

<TH>e 0 5 </TH>

<TH>e 0 6 </TH>

<TH>e 0 7 </TH>

<TH>e 0 8 </TH>

<TH>e 0 9 </TH>

<TH>e 1 0 </TH>

<TH>e 1 1 </TH>

<TH>e 1 2 </TH>

<TH>e 1 3 </TH>

<TH>e 1 4 </TH>

<TH>e 1 5 </TH>
</TR>

<TR>
<TD>C00 </TD>

<TD/>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>C01 </TD>

<TD/>

<TD/>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>
</TR>

<TR>
<TD>C02 </TD>

<TD/>

<TD/>

<TD/>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>
</TR>

<TR>
<TD>C03 </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>
</TR>

<TR>
<TD>C04 </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>C05 </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>C06 </TD>

<TD>x </TD>

<TD/>

<TD>x</TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x</TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>C07 </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>C08 </TD>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x</TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x</TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>
</TR>

<TR>
<TD>C09 </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x</TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x</TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>
</TR>

<TR>
<TD>C10 </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x</TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x</TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>
</TR>

<TR>
<TD>C11 </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>C12 </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Check Bit </TH>

<TH>e 0 0 </TH>

<TH>e 0 1 </TH>

<TH>e 0 2 </TH>

<TH>e 0 3 </TH>

<TH>e 0 4 </TH>

<TH>e 0 5 </TH>

<TH>e 0 6 </TH>

<TH>e 0 7 </TH>

<TH>e 0 8 </TH>

<TH>e 0 9 </TH>

<TH>e 1 0 </TH>

<TH>e 1 1 </TH>

<TH>e 1 2 </TH>

<TH>e 1 3 </TH>

<TH>e 1 4 </TH>

<TH>e 1 5 </TH>
</TR>

<TR>
<TD>C13 </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>
</TR>

<TR>
<TD>C14 </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>
</TR>

<TR>
<TD>C15 </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>
</TR>
</Table>

<P>where: C00–C15 contents of the new check symbol e00–e15 contents of the intermediate value symbol </P>

<P>e00 = d00 XOR c00 e01 = d01 XOR c01 through e15 = d15 XOR c15 </P>

<P>d00–d15 contents of the next 16 bits of the packet c00–c15 contents of the previous check symbol assuming the pipeline described in 
<Link>Figure 2-8 </Link>
</P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_109.jpg"/>
</Figure>
d00–d15 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_110.jpg"/>
c XOR d XOR e00–e15 C00–C15 c00–c15 equations network </Figure>

<P>Figure 2-8. CRC Generation Pipeline </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30735">2.5 Maximum Packet Size </P>

<P>The maximum packet size permitted by the LP-Serial specification is 276 bytes. This includes all packet logical, transport, and physical layer header information, data payload, and required CRC bytes. </P>

<P>The maximum packet size of 276 bytes is achieved as shown below: </P>

<Table>
<Caption>
<P>Table 2-3. Maximum Packet Size </P>
</Caption>

<TR>
<TH>Field </TH>

<TH>Size (bytes) </TH>

<TH>Layer </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Header </TD>

<TD>2 </TD>

<TD>Physical, Transport, Logical </TD>

<TD/>
</TR>

<TR>
<TD>Source ID </TD>

<TD>2 </TD>

<TD>Transport </TD>

<TD/>
</TR>

<TR>
<TD>Destination ID </TD>

<TD>2 </TD>

<TD>Transport </TD>

<TD/>
</TR>

<TR>
<TD>Trans/wrsize </TD>

<TD>1 </TD>

<TD>Logical </TD>

<TD/>
</TR>

<TR>
<TD>srcTID </TD>

<TD>1 </TD>

<TD>Logical </TD>

<TD/>
</TR>

<TR>
<TD>Address </TD>

<TD>8 </TD>

<TD>Logical </TD>

<TD>Includes Extended_address, Address, Wdptr, and Xambs </TD>
</TR>

<TR>
<TD>Payload </TD>

<TD>256 </TD>

<TD>Logical </TD>

<TD/>
</TR>

<TR>
<TD>CRC </TD>

<TD>4 </TD>

<TD>Physical </TD>

<TD>Extra two CRC bytes for packets greater than 80 bytes </TD>
</TR>

<TR>
<TD>Total </TD>

<TD>276 </TD>

<TD/>

<TD/>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30736">Chapter 3  Control Symbols </P>

<P id="LinkTarget_30737">3.1 Introduction </P>

<P>This chapter specifies RapidIO physical layer control symbols. Control symbols are the message elements used by ports connected by an LP-Serial link to manage all aspects of LP-Serial link operation. They are used for link maintenance, packet delimiting, packet acknowledgment, error reporting, and error recovery. For forward compatibility, control symbols received by a port with a reserved field encoding shall be ignored and not cause an error to be reported. </P>

<P id="LinkTarget_30738">3.2 Control Symbol Field Definitions </P>

<P>This section describes the fields that make up the control symbols. </P>

<Table>
<Caption>
<P>Table 3-1. Control Symbol Field Definitions </P>
</Caption>

<TR>
<TD>Field </TD>

<TD>Definition </TD>
</TR>

<TR>
<TD>stype0 </TD>

<TD>
<Link>Encoding for control symbols that make use of parameter0 and parameter1. Eight encodings are defined in Table 3-2. </Link>
</TD>
</TR>

<TR>
<TD>parameter0 </TD>

<TD>
<Link>Used in conjunction with stype0 encodings. Reference Table 3-2 for the description of parameter0 encodings. </Link>
</TD>
</TR>

<TR>
<TD>parameter1 </TD>

<TD>
<Link>Used in conjunction with stype0 encodings. Reference Table 3-2 for the description of parameter1 encodings. </Link>
</TD>
</TR>

<TR>
<TD>stype1 </TD>

<TD>
<Link>Encoding for control symbols which make use of the cmd field. The eight encodings are defined in Table 3-6. </Link>
</TD>
</TR>

<TR>
<TD>cmd </TD>

<TD>
<Link>Used in conjunction with the stype1 field to define the link maintenance commands. Refer to Table 3-7 for the cmd field descriptions. </Link>
</TD>
</TR>

<TR>
<TD>CRC </TD>

<TD>
<Link>5-bit code used to detect transmission errors in control symbols. See Section 3.6 for details on the CRC error detection scheme. </Link>
</TD>
</TR>
</Table>

<P id="LinkTarget_30739">3.3 Control Symbol Format </P>

<P>This section describes the general format of the LP-Serial control symbols. 
<Link>Figure 3-1 shows the control symbol format. </Link>
</P>

<P>bits 0 2 3 7 8 12 13 1516 1819 23 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_111.jpg"/>
stype0 3 5 stype1 3 parameter1 5 cmd 3 CRC 5 parameter0 </Figure>

<P>Figure 3-1. Packet-Retry Control Symbol Format </P>

<P>All control symbols follow the 24-bit control symbol format as detailed above. The </P>

<P>RapidIO Trade Association </P>

<P>fields parameter0 and parameter1 are used by the functions encoded in the stype0 field. The cmd field is a modifier for the functions encoded in the stype1 field. </P>

<P>Control symbols can carry two functions, one encoded in the stype0 field and one encoded in the stype1 field. The functions encoded in stype0 are “status” functions that convey some type of status about the port transmitting the control symbol. The functions encoded in stype1 are requests to the receiving port or transmission delimiters. </P>

<P>A control symbol carrying one function is referred to using the name of the function it carries. A control symbol carrying two functions may be referred to using the name of either function that it carries. For example, a control symbol with stype0 set to packet-accepted and stype1 set to NOP is referred to a packet-accepted control symbol. A control symbol with stype0 set to packet-accepted and stype1 set to restart-from-retry is referred to as either a packet-accepted control symbol or a restart-from-retry control symbol depending on which name is appropriate for the context. </P>

<P>Control symbols are specified with the ability to carry two functions so that a packet acknowledgment and a packet delimiter can be carried in the same control symbol. Packet acknowledgment and packet delimiter control symbols constitute the vast majority of control symbol traffic on a busy link. Carrying an acknowledgment (or status) and a packet delimiter whenever possible in a single control symbol allows a significant reduction in link overhead traffic and an increase in the link bandwidth available for packet transmission. </P>

<P id="LinkTarget_30740">3.4 Stype0 Control Symbols </P>

<P>The encoding and function of stype0 and the information carried in parameter0 and 
<Link>parameter1 for each stype0 encoding shall be as specified in Table 3-2. </Link>
</P>

<Table>
<Caption>
<P>Table 3-2. Stype0 Control Symbol Encoding </P>
</Caption>

<TR>
<TH>stype0 </TH>

<TH>Function </TH>

<TH>Contents of </TH>

<TH>Reference </TH>
</TR>

<TR>
<TD>Parameter0 </TD>

<TD>Parameter1 </TD>
</TR>

<TR>
<TH>0b000 </TH>

<TD>Packet-accepted </TD>

<TD>packet_ackID </TD>

<TD>buf_status </TD>

<TD>
<Link>Section 3.4.1 </Link>
</TD>
</TR>

<TR>
<TH>0b001 </TH>

<TD>Packet-retry </TD>

<TD>packet_ackID </TD>

<TD>buf_status </TD>

<TD>
<Link>Section 3.4.2 </Link>
</TD>
</TR>

<TR>
<TH>0b010 </TH>

<TD>Packet-not-accepted </TD>

<TD>packet_ackID </TD>

<TD>cause </TD>

<TD>
<Link>Section 3.4.3 </Link>
</TD>
</TR>

<TR>
<TH>0b011 </TH>

<TD>Reserved </TD>

<TD>-</TD>

<TD>-</TD>

<TD>-</TD>
</TR>

<TR>
<TH>0b100 </TH>

<TD>Status </TD>

<TD>ackID_status </TD>

<TD>buf_status </TD>

<TD>
<Link>Section 3.4.4 </Link>
</TD>
</TR>

<TR>
<TH>0b101 </TH>

<TD>Reserved </TD>

<TD>-</TD>

<TD>-</TD>

<TD>-</TD>
</TR>

<TR>
<TH>0b110 </TH>

<TD>Link-response </TD>

<TD>ackID_status </TD>

<TD>port_status </TD>

<TD>
<Link>Section 3.4.5 </Link>
</TD>
</TR>

<TR>
<TH>0b111 </TH>

<TD>Reserved </TD>

<TD>-</TD>

<TD>-</TD>

<TD>-</TD>
</TR>
</Table>

<P>The status control symbol is the default stype0 encoding and is used when the control symbol does not convey another stype0 function. The following table </P>

<P>RapidIO Trade Association </P>

<P>defines the parameters valid for stype0 control symbols. </P>

<Table>
<Caption>
<P>Table 3-3. Stype0 Parameter Definitions </P>
</Caption>

<TR>
<TD>Parameter </TD>

<TD>Definition </TD>
</TR>

<TR>
<TD>packet_ackID </TD>

<TD>The ackID of the packet being acknowledged by an acknowledgment control symbol. </TD>
</TR>

<TR>
<TD>ackID_status </TD>

<TD>The value of ackID expected in the next packet the port receives. For example, a value of 0b00001 indicates the device is expecting to receive ackID 1. </TD>
</TR>

<TR>
<TD>buf_status </TD>

<TD>Specifies the number of maximum length packets that the port can accept without issuing a retry due to a lack of resources. The value of buf_status in a packet-accepted, packet-retry, or status control symbol is the number of maximum packets that can be accepted, inclusive of the effect of the packet being accepted or retried. Value 0-29: The encoding value specifies the number of new maximum sized packets the receiving device can receive. The value 0, for example, signifies that the downstream device has no available packet buffers (thus is not able to hold any new packets). Value 30: The value 30 signifies that the downstream device can receive 30 or more new maximum sized packets. Value 31: The downstream device can receive an undefined number of maximum sized packets, and relies on the retry protocol for flow control. </TD>
</TR>
</Table>

<P>NOTE: </P>

<P>The following sections depict various control symbols. Since control symbols can contain one or two functions, shading in the figures is used to indicate which fields are applicable to that specific control symbol function. </P>

<P id="LinkTarget_30741">3.4.1 Packet-Accepted Control Symbol </P>

<P>The packet-accepted control symbol indicates that the receiving device has taken responsibility for sending the packet to its final destination and that resources allocated by the sending device can be released. This control symbol shall be generated only after the entire packet has been received and found to be free of detectable errors. The packet-accepted control symbol format is displayed in 
<Link>Figure 3-2. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_112.jpg"/>
0b000 3 packet_ackID 5 stype1 3 buf_status 5 cmd 3 CRC 5 </Figure>

<P>Figure 3-2. Packet-Accepted Control Symbol Format </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30742">3.4.2 Packet-Retry Control Symbol </P>

<P>A packet-retry control symbol indicates that the receiving device was not able to accept the packet due to some temporary resource conflict such as insufficient buffering and the sender should retransmit the packet. This control symbol format is displayed in 
<Link>Figure 3-3. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_113.jpg"/>
0b001 packet_ackID stype1buf_status cmd CRC </Figure>

<P>35 5 335 </P>

<P>Figure 3-3. Packet-Retry Control Symbol Format </P>

<P id="LinkTarget_30743">3.4.3 Packet-Not-Accepted Control Symbol </P>

<P>The packet-not-accepted control symbol is used to indicate to the sender of a packet why the packet was not accepted by the receiving port. As shown in 
<Link>Figure 3-4, the </Link>
control symbol contains a cause field that indicates the reason for not accepting the packet and a packet_ackID field. If the receiving device is not able to specify the cause, or the cause is not one of defined options, the general error encoding shall be used. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_114.jpg"/>
0b010 packet_ackID stype1cause cmd CRC </Figure>

<P>35 5 335 </P>

<P>Figure 3-4. Packet-Not-Accepted Control Symbol Format </P>

<P>The cause field shall be used to display informational fields useful for debug. 
<Link>Table 3-4 displays the reasons a packet may not be accepted, indicated by the cause </Link>
field. </P>

<Table>
<Caption>
<P>Table 3-4. Cause Field Definition </P>
</Caption>

<TR>
<TD>Cause </TD>

<TD>Definition </TD>
</TR>

<TR>
<TD>0b00000 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b00001 </TD>

<TD>Received unexpected ackID on packet </TD>
</TR>

<TR>
<TD>0b00010 </TD>

<TD>Received a control symbol with bad CRC </TD>
</TR>

<TR>
<TD>0b00011 </TD>

<TD>Non-maintenance packet reception is stopped </TD>
</TR>

<TR>
<TD>0b00100 </TD>

<TD>Received packet with bad CRC </TD>
</TR>

<TR>
<TD>0b00101 </TD>

<TD>Received invalid character, or valid but illegal character </TD>
</TR>

<TR>
<TD>0b00110 - 0b11110 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b11111 </TD>

<TD>General error </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30744">3.4.4 Status Control Symbol </P>

<P>The status control symbol is the default stype0 encoding and is used when the control symbol does not convey another stype0 function. The status control symbol contains the ackID_status and the buf_status fields. The buf_status field indicates to the receiving port the number of maximum length packet buffers the sending port had available for packet reception at the time the control symbol was generated. The ackID_status field allows the receiving port to determine if it and the sending port are in sync with respect to the next ackID value the sending port expects to receive. 
<Link>The status control symbol format is shown in Figure 3-5 below. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_115.jpg"/>
0b100 ackID_status stype1buf_status cmd CRC </Figure>

<P>35 5 335 </P>

<P>Figure 3-5. Status Control Symbol Format </P>

<P id="LinkTarget_30745">3.4.5 Link-Response Control Symbol </P>

<P>The link-response control symbol is used by a device to respond to a link-request 
<Link>control symbol as described in the link maintenance protocol described in Section </Link>
</P>

<P>
<Link>5.5</Link>
. The status reported in the status field is the status of the port at the time the associated input-status link-request control symbol was received. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_116.jpg"/>
0b110 ackID_status stype1port_status cmd CRC </Figure>

<P>35 5 335 </P>

<P>Figure 3-6. Link-Response Control Symbol Format </P>

<P>
<Link>The port_status field of the link-response control symbol is defined in Table 3-5. </Link>
</P>

<Table>
<Caption>
<P>Table 3-5. Port_status Field Definitions </P>
</Caption>

<TR>
<TH>Port_status </TH>

<TH>Status </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0b00000 </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b00001 </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b00010 </TD>

<TD>Error </TD>

<TD>The port has encountered an unrecoverable error and is unable to accept packets. </TD>
</TR>

<TR>
<TD>0b00011 </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b00100 </TD>

<TD>Retry-stopped </TD>

<TD>The port has retried a packet and is waiting in the input retry-stopped state to be restarted. </TD>
</TR>

<TR>
<TD>0b00101 </TD>

<TD>Error-stopped </TD>

<TD>The port has encountered a transmission error and is waiting in the input error-stopped state to be restarted. </TD>
</TR>

<TR>
<TD>0b00110 - 0b01111 </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0b10000 </TD>

<TD>OK </TD>

<TD>The port is accepting packets </TD>
</TR>

<TR>
<TD>0b10001 - 0b11111 </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30746">3.5 Stype1 Control Symbols </P>

<P>The encoding of stype1 and the function of the cmd field are defined in 
<Link>Table 3-6. </Link>
</P>

<Table>
<Caption>
<P>Table 3-6. Stype1 Control Symbol Encoding </P>
</Caption>

<TR>
<TH>stype1 </TH>

<TH>stype1 Function </TH>

<TH>cmd </TH>

<TH>cmd Function </TH>

<TH>Packet Delimiter </TH>

<TH>Reference </TH>
</TR>

<TR>
<TH>0b000 </TH>

<TD>Start-of-packet </TD>

<TD>0b000 </TD>

<TD>-</TD>

<TD>yes </TD>

<TD>
<Link>Section 3.5.1 </Link>
</TD>
</TR>

<TR>
<TH>0b001 </TH>

<TD>Stomp </TD>

<TD>0b000 </TD>

<TD>-</TD>

<TD>yes </TD>

<TD>
<Link>Section 3.5.2 </Link>
</TD>
</TR>

<TR>
<TH>0b010 </TH>

<TD>End-of-packet </TD>

<TD>0b000 </TD>

<TD>-</TD>

<TD>yes </TD>

<TD>
<Link>Section 3.5.3 </Link>
</TD>
</TR>

<TR>
<TH>0b011 </TH>

<TD>Restart-from-retry </TD>

<TD>0b000 </TD>

<TD>-</TD>

<TD>* </TD>

<TD>
<Link>Section 3.5.4 </Link>
</TD>
</TR>

<TR>
<TH>0b100 </TH>

<TD>Link-request </TD>

<TD>0b000 - 0b010 </TD>

<TD>Reserved </TD>

<TD>* </TD>

<TD>-</TD>
</TR>

<TR>
<TD>0b011 </TD>

<TD>Reset-device </TD>

<TD>
<Link>Section 3.5.5.1 </Link>
</TD>
</TR>

<TR>
<TD>0b100 </TD>

<TD>Input-status </TD>

<TD>
<Link>Section 3.5.5.2 </Link>
</TD>
</TR>

<TR>
<TD>0b101- 0b111 </TD>

<TD>Reserved </TD>

<TD>-</TD>
</TR>

<TR>
<TH>0b101 </TH>

<TD>Multicast-event </TD>

<TD>0b000 </TD>

<TD>-</TD>

<TD>No </TD>

<TD>
<Link>Section 3.5.6 </Link>
</TD>
</TR>

<TR>
<TH>0b110 </TH>

<TD>Reserved </TD>

<TD>0b000 </TD>

<TD>-</TD>

<TD>No </TD>

<TD>-</TD>
</TR>

<TR>
<TH>0b111 </TH>

<TD>NOP (Ignore) ** </TD>

<TD>0b000 </TD>

<TD>-</TD>

<TD>No </TD>

<TD>-</TD>
</TR>
</Table>

<P>Note: * denotes that restart-from-retry and link-request control symbols may only be packet delimiters if a packet is in progress. </P>

<P>Note: ** NOP (Ignore) is not defined as a control symbol, but is the default value when the control symbol does not convey another stype1 function. </P>

<P>NOTE: </P>

<P>The following sections depict various control symbols. Since control symbols can contain one or two functions, shading in the figures is used to indicate which fields are applicable to that specific control symbol function. </P>

<P id="LinkTarget_30747">3.5.1 Start-of-Packet Control Symbol </P>

<P>The start-of-packet control symbol format is shown in 
<Link>Figure 3-7 below. </Link>
</P>

<Table>
<TR>
<TH>stype0 </TH>

<TH>parameter0 </TH>

<TH>parameter1 </TH>

<TH>0b000 </TH>

<TH>0b000 </TH>

<TH>CRC </TH>
</TR>
</Table>

<P>35 5 335 </P>

<P>Figure 3-7. Start-of-Packet Control Symbol Format </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30748">3.5.2 Stomp Control Symbol </P>

<P>The stomp control symbol is used to cancel a partially transmitted packet. The 
<Link>protocol for packet cancelation is specified in Section 5.8. The stomp control symbol </Link>
format is shown in 
<Link>Figure 3-8 below. </Link>
</P>

<Table>
<TR>
<TH>stype0 </TH>

<TH>parameter0 </TH>

<TH>parameter1 </TH>

<TH>0b001 </TH>

<TH>0b000 </TH>

<TH>CRC </TH>
</TR>
</Table>

<P>35 5 335 </P>

<P>Figure 3-8. Stomp Control Symbol Format </P>

<P id="LinkTarget_30749">3.5.3 End-of-Packet Control Symbol </P>

<P>The end-of-packet control symbol format is shown in 
<Link>Figure 3-9 below. </Link>
</P>

<Table>
<TR>
<TH>stype0 </TH>

<TH>parameter0 </TH>

<TH>parameter1 </TH>

<TH>0b010 </TH>

<TH>0b000 </TH>

<TH>CRC </TH>
</TR>
</Table>

<P>35 5 335 </P>

<P>Figure 3-9. End-of-Packet Control Symbol Format </P>

<P id="LinkTarget_30750">3.5.4 Restart-From-Retry Control Symbol </P>

<P>The restart-from-retry control symbol cancels a current packet and may also be transmitted on an idle link. This control symbol is used to mark the beginning of packet retransmission, so that the receiver knows when to start accepting packets after the receiver has requested a packet to be retried. The control symbol format is shown in 
<Link>Figure 3-10 below. </Link>
</P>

<Table>
<TR>
<TH>stype0 </TH>

<TH>parameter0 </TH>

<TH>parameter1 </TH>

<TH>0b011 </TH>

<TH>0b000 </TH>

<TH>CRC </TH>
</TR>
</Table>

<P>35 5 335 </P>

<P>Figure 3-10. Restart-From-Retry Control Symbol Format </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30751">3.5.5 Link-Request Control Symbol </P>

<P>A link-request control symbol is used by a device to either issue a command to the connected device or request its input port status. A link-request control symbol always cancels a packet whose transmission is in progress and can also be sent between packets. Under error conditions, a link-request/input-status control symbol acts as a link-request/restart-from-error control symbol as described in 
<Link>Section 5.11.2.1, “Recoverable Errors.” This control symbol format is displayed in </Link>

<Link>Figure 3-11. </Link>
</P>

<Table>
<TR>
<TH>stype0 </TH>

<TH>parameter0 </TH>

<TH>parameter1 </TH>

<TH>0b100 </TH>

<TH>cmd </TH>

<TH>CRC </TH>
</TR>
</Table>

<P>35 5 335 </P>

<P>Figure 3-11. Link-Request Control Symbol Format </P>

<P>The cmd, or command, field of the link-request control symbol format is defined in 
<Link>Table 3-7 below. </Link>
</P>

<Table>
<Caption>
<P>Table 3-7. Cmd Field Definitions </P>
</Caption>

<TR>
<TH>cmd Encoding </TH>

<TH>Command Name </TH>

<TH>Description </TH>

<TH>Reference </TH>
</TR>

<TR>
<TD>0b000-0b010 </TD>

<TD>-</TD>

<TD>Reserved </TD>

<TD/>
</TR>

<TR>
<TD>0b011 </TD>

<TD>Reset-device </TD>

<TD>Reset the receiving device </TD>

<TD>
<Link>Section 3.5.5.1 </Link>
</TD>
</TR>

<TR>
<TD>0b100 </TD>

<TD>Input-status </TD>

<TD>Return input port status; functions as a link request (restart-from-error) control symbol under error conditions </TD>

<TD>
<Link>Section 3.5.5.2 </Link>
</TD>
</TR>

<TR>
<TD>0b101-0b111 </TD>

<TD>-</TD>

<TD>Reserved </TD>

<TD/>
</TR>
</Table>

<P id="LinkTarget_30752">3.5.5.1  Reset-Device Command </P>

<P>The reset-device command causes the receiving device to go through its reset or power-up sequence. All state machines and the configuration registers reset to the original power on states. The reset-device command does not generate a link-response control symbol. </P>

<P>Due to the undefined reliability of system designs it is necessary to put a safety lockout on the reset function of the link-request control symbol. A device receiving a reset-device command in a link-request control symbol shall not perform the reset function unless it has received four reset-device commands in a row without any other intervening packets or control symbols, except status control symbols. This will prevent spurious reset commands from inadvertently resetting a device. </P>

<P>When issuing a reset with four consecutive reset commands, care must be taken to account for all effects associated with the reset event. Consult RapidIO Part 8: Error Management Extensions Specification for more information. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30753">3.5.5.2 Input-Status Command </P>

<P>The input-status command requests the receiving device to return the ackID value it expects to next receive from the sender on its input port and the current input port operational status for informational purposes. This command causes the receiver to flush its output port of all control symbols generated by packets received before the input-status command. Flushing the output port is implementation dependent and may result in either discarding the contents of the receive buffers or sending the control symbols on the link. The receiver then responds with a link-response control symbol. </P>

<P id="LinkTarget_30754">3.5.6 Multicast-Event Control Symbol </P>

<P>The multicast-event control symbol differs from other control symbols in that it carries information not related to the link carrying the control symbol. The multicast-event control symbol allows the occurrence of a user-defined system event to be multicast throughout a system. Refer to 
<Link>Section 5.3.4</Link>
 for more details on Multicast-Events. </P>

<P>The multicast-event control symbol format is shown in 
<Link>Figure 3-12 below. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_117.jpg"/>
stype0 parameter0 0b101parameter1 0b000 CRC </Figure>

<P>35 5 335 </P>

<P>Figure 3-12. Multicast-Event Control Symbol Format </P>

<P id="LinkTarget_30755">3.6 Control Symbol Protection </P>

<P>The 5-bit CRC shall be computed over control symbol bits 0 through 18 and provides 5-bit burst error detection for the entire 24-bit control symbol. </P>

<P id="LinkTarget_30756">3.6.1 CRC-5 Code </P>

<P>The ITU polynomial X5+X4+X2+1 shall be used to generate the 5-bit CRC for control symbols. The CRC check bits c0, c1, c2, c3, and c4 occupy the last 5 bits of a control symbol. It should be noted that the 5-bit CRC must be generated by each transmitter and verified by each receiver. Before the 5-bit CRC is computed, the CRC should be set to all 1’s or 0b11111. In order to provide maximum implementation flexibility for all types of designs, a 20th bit has been added. For all computations, the 20th bit shall be the last bit applied and shall be set to a logic 0 (0b0). </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30757">3.6.2 CRC-5 Parallel Code Generation </P>

<P>Since it is often more efficient to implement a parallel CRC algorithm rather than a serial, examples of the equations for a complete, 19-bit single-stage parallel implementation is shown in shown in 
<Link>Table 3-8. Since only a single stage is used, </Link>
the effect of both setting the initial CRC to all 1’s (0b11111) and a 20th bit set to logic 0 (0b0) have been included in the equations. </P>

<P>In 
<Link>Table 3-8, an “x” means that the data input should be an input to the </Link>
Exclusive-OR necessary to compute that particular bit of the CRC. A “!x”, means 
<Link>that bit 18 being applied to the CRC circuit must be inverted. Figure 3-13 shows the </Link>
19-bits that the CRC covers and how they should be applied to the circuit. As seen in 
<Link>Figure 3-13, bits are labeled with 0 on the left and 18 on the right. Bit 0, from the </Link>
stype0 field, would apply to D0 in 
<Link>Table 3-8 and bit 18, from the cmd field, would </Link>
apply to D18 in 
<Link>Table 3-8. Once completed, the 5-bit CRC is appended to the control </Link>
symbol. </P>

<Table>
<TR>
<TH>CRC Checksum </TH>

<TH/>

<TH/>

<TH/>

<TH/>

<TH/>

<TH/>

<TH>Control Symbol Data For CRC </TH>

<TH/>

<TH/>

<TH/>

<TH/>

<TH/>
</TR>

<TR>
<TD>Bits </TD>

<TD>D 0 </TD>

<TD>D 1 </TD>

<TD>D 2 </TD>

<TD>D 3 </TD>

<TD>D 4 </TD>

<TD>D 5 </TD>

<TD>D 6 </TD>

<TD>D 7 </TD>

<TD>D 8 </TD>

<TD>D 9 </TD>

<TD>D 10 </TD>

<TD>D 11 </TD>

<TD>D 12 </TD>

<TD>D 13 </TD>

<TD>D 14 </TD>

<TD>D 15 </TD>

<TD>D 16 </TD>

<TD>D 17 </TD>

<TD>D 18 </TD>
</TR>

<TR>
<TD>4 </TD>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>
</TR>

<TR>
<TD>3 </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD>!x </TD>
</TR>

<TR>
<TD>2 </TD>

<TD/>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD/>

<TD>!x </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD>!x </TD>
</TR>

<TR>
<TD>0 </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD/>

<TD/>

<TD/>

<TD>x </TD>

<TD/>

<TD>x </TD>

<TD/>

<TD/>

<TD>x </TD>

<TD>x </TD>

<TD/>

<TD>x </TD>
</TR>

<Caption>
<P>Table 3-8. Parallel CRC Equations </P>
</Caption>
</Table>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_118.jpg"/>
stype0 parameter0 stype1 parameter1 cmd CRC </Figure>

<P>0 18 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_119.jpg"/>
</Figure>

<P>Function From Equations 
In Table 3-8 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_120.jpg"/>
</Figure>

<P>5-bit CRC (C0:C4) Figure 3-13. 5-bit CRC Implementation </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30758">Chapter 4 PCS and PMA Layers </P>

<P id="LinkTarget_30759">4.1 Introduction </P>

<P>This chapter specifies the functions provided by the Physical Coding Sublayer (PCS) and Physical Media Attachment (PMA) sublayer. (The PCS and PMA terminology is adopted from IEEE 802.3). The topics include 8B/10B encoding, character representation, serialization of the data stream, code-groups, columns, link transmission rules, idle sequences, and link initialization. </P>

<P>The concept of lanes is used to describe the width of a LP-Serial link. A lane is defined as one unidirectional differential pair in each direction. RapidIO LP-Serial defines two link widths. The 1x LP-Serial link is a one-lane link and the 4x LP-Serial link is a 4-lane link. Wider links are possible, but are left for future work. </P>

<P id="LinkTarget_30760">4.2 PCS Layer Functions </P>

<P>The Physical Coding Sublayer (PCS) function is responsible for idle sequence generation, lane striping, and encoding for transmission and decoding, lane alignment, and destriping on reception. The PCS uses an 8B/10B encoding for transmission over the link. </P>

<P>The PCS layer also provides mechanisms for determining the operational mode of the port as 4-lane or 1-lane operation, and means to detect link states. It provides for clock difference tolerance between the sender and receiver without requiring flow control. </P>

<P>The PCS layer performs the following transmit functions: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Dequeues packets and delimited control symbols awaiting transmission as a character stream. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Stripes the transmit character stream across the available lanes. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Generates the idle sequence and inserts it into the transmit character stream for each lane when no packets or delimited control symbols are available for transmission. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Encodes the character stream of each lane independently into 10-bit parallel code-groups. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Passes the resulting 10-bit parallel code-groups to the PMA. </LI_Title>
</LI>
</L>

<P>The PCS layer performs the following receive functions: </P>

<P>RapidIO Trade Association </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Decodes the received stream of 10-bit parallel code-groups for each lane independently into characters. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Marks characters decoded from invalid code-groups as invalid. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>If the link is using more than one lane, aligns the character streams to eliminate the skew between the lanes and reassembles (destripes) the character stream from each lane into a single character stream. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Delivers the decoded character stream of packets and delimited control symbols to the higher layers. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30761">4.3 PMA Layer Functions </P>

<P>The PMA (Physical Medium Attachment) function is responsible for serializing 10-bit parallel code-groups to/from a serial bitstream on a lane-by-lane basis. Upon receiving data, the PMA function provides alignment of the received bitstream to 10-bit code-group boundaries, independently on a lane-by-lane basis. It then provides a continuous stream of 10-bit code-groups to the PCS, one stream for each lane. The 10-bit code-groups are not observable by layers higher than the PCS. </P>

<P id="LinkTarget_30762">4.4 Definitions </P>

<P>Definitions of terms used in this specification are provided below. 
</P>

<P>Byte: An 8-bit unit of information. Each bit of a byte has the value 0 or 1. 
Character: A 9-bit entity comprised of an information byte and a control bit that indicates 
whether the information byte contains data or control information. The control bit has the 
</P>

<P>value D or K indicating that the information byte contains respectively data or control 
information. 
D-character: A character whose control bit has the value “D”. 
K-character: A character whose control bit has the value “K”. Also referred to as a special 
</P>

<P>character. 
Code-group: A 10-bit entity that is the result of 8B/10B encoding a character. 
Column: A group of four characters that are transmitted simultaneously on a 4x (4 lane) 
</P>

<P>link. 
Comma: A 7-bit pattern, unique to certain 8B/10B special code-groups, that is used by a 
</P>

<P>receiver to determine code-group boundaries. See more in 
<Link>“Section 4.5.7.4, Sync (/K/)” on 
</Link>

<Link>page 50 and Table 4-2, on page 48. 
</Link>
Idle sequence: The sequence of characters (code-groups after encoding) that is transmitted 
</P>

<P>when a packet or control symbol is not being transmitted. The idle sequence allows the 
receiver to maintain bit synchronization and code-group alignment in between packets and 
control symbols. 
</P>

<P>Lane Alignment: The process of eliminating the skew between the lanes of a 4-lane 
LP-Serial link such that the characters transmitted as a column by the sender are output by 
</P>

<P>RapidIO Trade Association </P>

<P>the alignment process of receiver as a column. Without lane alignment, the characters transmitted as a column might be scattered across several columns output by the receiver. The alignment process uses the columns of “A” special characters transmitted as part of the idle sequence. </P>

<P>Striping: The method used on a 4x link to send data across four lanes simultaneously. The character stream is striped across the lanes, on a character-by-character basis, starting with lane 0, to lane 1, to lane 2, to lane3, and wrapping back with the 5th character to lane 0. </P>

<P id="LinkTarget_30763">4.5 8B/10B Transmission Code </P>

<P>The 8B/10B transmission code used by the PCS encodes 9-bit characters (8 bits of information and a control bit) into 10-bit code-groups for transmission and reverses the process on reception. Encodings are defined for 256 data characters and 12 special (control) characters. </P>

<P>The code-groups used by the code have either an equal number of ones and zeros (balanced) or the number of ones differs from the number of zeros by two (unbalanced). This selection of code-groups guarantees a minimum of two transitions, 0 to 1 or 1 to 0, within each code-group and it also eases the task of maintaining balance. Characters are encoded into either a single balanced code-group or a pair of unbalanced code-groups. The members of each code-group pair are the logical complement of each other. This allows the encoder, when selecting an unbalanced code-group, to select a code-group unbalanced toward ones or unbalanced toward zeros, depending on which is required to maintain the 0/1 balance of the encoder output code-group stream. </P>

<P>The 8B/10B code has the following properties. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Sufficient bit transition density (3 to 8 transitions per code-group) to allow clock recovery by the receiver. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Special code-groups that are used for establishing the receiver synchronization to the 10-bit code-group boundaries, delimiting control symbols and maintaining receiver bit and code-group boundary synchronization. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Balanced. (can be AC coupled) </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Detection of single and some multiple-bit errors. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30764">4.5.1 Character and Code-Group Notation </P>

<P>The description of 8B/10B encoding and decoding uses the following notation for characters, code-group and their bits. </P>

<P>The information bits ([0-7]) of an unencoded character are denoted with the letters “A” through “H” where the letter “H” denotes the most significant information bit (RapidIO bit 0) and the letter “A” denotes the least significant information bit (RapidIO bit 7). This is shown in 
<Link>Figure 4-1. </Link>
</P>

<P>RapidIO Trade Association </P>

<P>37 </P>

<P>Each data character has a representation of the form Dx.y where x is the decimal value of the least significant 5 information bits EDCBA, and y is the decimal value of the most significant 3 information bits HGF as shown in 
<Link>Figure 4-1. Each special </Link>
character has a similar representation of the form Kx.y. </P>

<P>D25.3 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_121.jpg"/>
HGF EDCBA 011 11001 </Figure>

<P>Y=3 X=25 </P>

<P>Figure 4-1. Character Notation Example (D25.3) </P>

<P>The output of the 8B/10B encoding process is a 10-bit code-group. The bits of a code-group are denoted with the letters “a” through “j”. The bits of a code-group are all of equal significance, there is no most significant or least significant bit. The ordering of the code-group bits is shown in 
<Link>Figure 4-2. </Link>
</P>

<P>The code-groups corresponding to the data character Dx.y is denoted by /Dx.y/. The code-groups corresponding to the special character Kx.y is denoted by /Kx.y/. </P>

<P>/D25.3/ 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_122.jpg"/>
abcdei fghj 100110 1100 </Figure>

<P>Figure 4-2. Code-Group Notation Example (/D25.3/) </P>

<P id="LinkTarget_30765">4.5.2 Running Disparity </P>

<P>The 8B/10B encoding and decoding functions use a binary variable called running disparity. The variable can have a value of either positive (RD+) or negative (RD-). The encoder and decoder each have a running disparity variable for each lane which are all independent of each other. </P>

<P>The primary use of running disparity in the encoding process is to keep track of whether the decoder has output more ones or more zeros. The current value of encoder running disparity is used to select the which unbalanced code-group will be used when the encoding for a character requires a choice between two unbalanced code-groups. </P>

<P>The primary use of running disparity in the decoding process is to detect errors. Given a value of decoder running disparity, only (256 + 12) = 268 of the 1024 possible code-group values have defined decodings. The remaining 756 possible code-group values have no defined decoding and represent errors, either in that code-group or in an earlier code-group. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30766">4.5.3 Running Disparity Rules </P>

<P>After power-up and before the port is operational, both the transmitter (encoder) and receiver (decoder) must establish current values of running disparity. </P>

<P>The transmitter shall use a negative value as the initial value for the running disparity for each lane. </P>

<P>The receiver may use either a negative or positive initial value of running disparity for each lane. </P>

<P>The following algorithm shall be used for calculating the running disparity for each lane. In the encoder, the algorithm operates on the code-group that has just been generated by the encoder. In the receiver, the algorithm operates on the received code-group that has just been decoded by the decoder. </P>

<P>
<Link>Each code-group is divided to two sub-blocks as shown in Figure 4-2</Link>
, where the first six bits (abcdei) form one sub-block (6-bit sub-block) and the second four bits (fghj) form a second sub-block (4-bit sub-block). Running disparity at the beginning of the 6-bit sub-block is the running disparity at the end of the previous code-group. Running disparity at the beginning of the 4-bit sub-block is the running disparity at the end of the 6-bit sub-block. Running disparity at the end of the code-group is the running disparity at the end of the 4-bit sub-block. </P>

<P>The sub-block running disparity shall be calculated as follows: </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> The running disparity is positive at the end of any sub-block if the sub-block contains more 1s than 0s. It is also positive at the end of a 4-bit sub-block if the sub-block has the value 0b0011 and at the end of a 6-bit sub-block if the sub-block has the value 0b000111. </LI_Title>
</LI>

<LI>
<LI_Label>2. </LI_Label>

<LI_Title>The running disparity is negative at the end of any sub-block if the sub-block contains more 0s than 1s. It is also negative at the end of a 4-bit sub-block if the sub-block has the value 0b1100 and at the end of a 6-bit sub-block if the sub-block has the value 0b111000. </LI_Title>
</LI>

<LI>
<LI_Label>3. </LI_Label>

<LI_Title>In all other cases, the value of the running disparity at the end of the sub-block is running disparity at the beginning of the sub-block (the running disparity is unchanged). </LI_Title>
</LI>
</L>

<P id="LinkTarget_30767">4.5.4 8B/10B Encoding </P>

<P>The 8B/10B encoding function encodes 9-bit characters into 10-bit code-groups. </P>

<P>
<Link>The encodings for the 256 data characters (Dx.y) are specified in Table 4-1. The </Link>

<Link>encodings for the 12 special characters (Kx.y) are specified in Table 4-2. Both tables </Link>
have two columns of encodings, one marked RD- and one marked RD+. When encoding a character, the code-group in the RD- column is selected if the current value of encoder running disparity is negative and the code-group in the RD+ column is selected if the current value of encoder running disparity is positive. </P>

<P>RapidIO Trade Association </P>

<P>
<Link>Data characters (Dx.y) shall be encoded according to Table 4-1 and the current value </Link>
of encoder running disparity. Special characters (Kx.y) shall be encoded according to 
<Link>Table 4-2 and the current value of encoder running disparity. After each character </Link>
is encoded, the resulting code-group shall be used by the encoder to update the 
<Link>running disparity according to the rules in Section 4.5.3, “Running Disparity Rules. </Link>
</P>

<P id="LinkTarget_30768">4.5.5 Transmission Order </P>

<P>The parallel 10-bit code-group output of the encoder shall be serialized and transmitted with bit “a” transmitted first and a bit ordering of “abcdeifghj”. This is shown in 
<Link>Figure 4-3. </Link>
</P>

<P>
<Link>Figure 4-3 gives an overview of a character passing through the encoding, </Link>
serializing, transmission, deserializing, and decoding processes. The left side of the figure shows the transmit process of encoding a character stream using 8B/10B encoding and the 10-bit serialization. The right side shows the reverse process of the receiver deserializing and using 8B/10B decoding on the received code-groups. </P>

<P>The dotted line shows the functional separation between the PCS layer, that provides 10-bit code-groups, and the PMA layer that serializes the code-groups. </P>

<P>The drawing also shows on the receive side the bits of a special character containing the comma pattern that is used by the receiver to establish 10-bit code-boundary synchronization. </P>

<P>MSB LSB MSB LSB 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_123.jpg"/>
Input to the H G F E D C B A 8B/10B Encoder a b c d e i f g h j 8 + control 10 0 1 2 3 4 5 6 7 8 9 Bit 0 transmitted first Output of the Lane bitstream H G F E D C B A 8B/10B Decoder a b c d e i f g h j 8 + control 10 0 1 2 3 4 5 6 7 8 9 Bit 0 received first Lane bitstream 0 0 1 1 1 1 1 x x x Aligned comma code-group PMA Layer PCS Layer ENCODE function ENCODE function Output of the DECODE function Input to the DECODE function </Figure>

<P>Figure 4-3. Lane Encoding, Serialization, Deserialization, and Decoding Process </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30769">4.5.6 8B/10B Decoding </P>

<P>The 8B/10B decoding function decodes received 10-bit code-groups into 9-bit characters, detects received code-groups that have no defined decoding and marks the resulting characters in the output stream of the decode as invalid character (INVALID). </P>

<P>
<Link>The decoding function uses Table 4-1, Table 4-2 and the current value of the decoder </Link>
running disparity. To decode a received code-group, the decoder shall select the RD-column of 
<Link>Table 4-1 and Table 4-2 if the current value of the decoder running </Link>
disparity is negative or shall select the RD+ column if the value is positive. The decoder shall then compare the received code-group with the code-groups in the selected column of both tables. If a match is found, the code-group is decoded to the associated character. If no match is found, the code-group is decoded to a character that is flagged in some manner as invalid. After each code-group is decoded, the decoded code-group shall be used by the decoder to update the decoder running disparity according to the rules in 
<Link>Section 4.5.3, “Running Disparity Rules. </Link>
</P>

<Table>
<Caption>
<P>Table 4-1. Data Character Encodings </P>
</Caption>

<TR>
<TH>Character Name </TH>

<TH>Character Value (hex)</TH>

<TH> Character Bits HGF EDCBA</TH>

<TH> Current RD – </TH>

<TH>Current RD + </TH>
</TR>

<TR>
<TH>abcdei fghj </TH>

<TH>abcdei fghj </TH>
</TR>

<TR>
<TH>D0.0 </TH>

<TD>00 </TD>

<TD>000 00000 </TD>

<TD>100111 0100 </TD>

<TD>011000 1011 </TD>
</TR>

<TR>
<TH>D1.0 </TH>

<TD>01 </TD>

<TD>000 00001 </TD>

<TD>011101 0100 </TD>

<TD>100010 1011 </TD>
</TR>

<TR>
<TH>D2.0 </TH>

<TD>02 </TD>

<TD>000 00010 </TD>

<TD>101101 0100 </TD>

<TD>010010 1011 </TD>
</TR>

<TR>
<TH>D3.0 </TH>

<TD>03 </TD>

<TD>000 00011 </TD>

<TD>110001 1011 </TD>

<TD>110001 0100 </TD>
</TR>

<TR>
<TH>D4.0 </TH>

<TD>04 </TD>

<TD>000 00100 </TD>

<TD>110101 0100 </TD>

<TD>001010 1011 </TD>
</TR>

<TR>
<TH>D5.0 </TH>

<TD>05 </TD>

<TD>000 00101 </TD>

<TD>101001 1011 </TD>

<TD>101001 0100 </TD>
</TR>

<TR>
<TH>D6.0 </TH>

<TD>06 </TD>

<TD>000 00110 </TD>

<TD>011001 1011 </TD>

<TD>011001 0100 </TD>
</TR>

<TR>
<TH>D7.0 </TH>

<TD>07 </TD>

<TD>000 00111 </TD>

<TD>111000 1011 </TD>

<TD>000111 0100 </TD>
</TR>

<TR>
<TH>D8.0 </TH>

<TD>08 </TD>

<TD>000 01000 </TD>

<TD>111001 0100 </TD>

<TD>000110 1011 </TD>
</TR>

<TR>
<TH>D9.0 </TH>

<TD>09 </TD>

<TD>000 01001 </TD>

<TD>100101 1011 </TD>

<TD>100101 0100 </TD>
</TR>

<TR>
<TH>D10.0 </TH>

<TD>0A </TD>

<TD>000 01010 </TD>

<TD>010101 1011 </TD>

<TD>010101 0100 </TD>
</TR>

<TR>
<TH>D11.0 </TH>

<TD>0B </TD>

<TD>000 01011 </TD>

<TD>110100 1011 </TD>

<TD>110100 0100 </TD>
</TR>

<TR>
<TH>D12.0 </TH>

<TD>0C </TD>

<TD>000 01100 </TD>

<TD>001101 1011 </TD>

<TD>001101 0100 </TD>
</TR>

<TR>
<TH>D13.0 </TH>

<TD>0D </TD>

<TD>000 01101 </TD>

<TD>101100 1011 </TD>

<TD>101100 0100 </TD>
</TR>

<TR>
<TH>D14.0 </TH>

<TD>0E </TD>

<TD>000 01110 </TD>

<TD>011100 1011 </TD>

<TD>011100 0100 </TD>
</TR>

<TR>
<TH>D15.0 </TH>

<TD>0F </TD>

<TD>000 01111 </TD>

<TD>010111 0100 </TD>

<TD>101000 1011 </TD>
</TR>

<TR>
<TH>D16.0 </TH>

<TD>10 </TD>

<TD>000 10000 </TD>

<TD>011011 0100 </TD>

<TD>100100 1011 </TD>
</TR>

<TR>
<TH>D17.0 </TH>

<TD>11 </TD>

<TD>000 10001 </TD>

<TD>100011 1011 </TD>

<TD>100011 0100 </TD>
</TR>

<TR>
<TH>D18.0 </TH>

<TD>12 </TD>

<TD>000 10010 </TD>

<TD>010011 1011 </TD>

<TD>010011 0100 </TD>
</TR>

<TR>
<TH>D19.0 </TH>

<TD>13 </TD>

<TD>000 10011 </TD>

<TD>110010 1011 </TD>

<TD>110010 0100 </TD>
</TR>

<TR>
<TH>D20.0 </TH>

<TD>14 </TD>

<TD>000 10100 </TD>

<TD>001011 1011 </TD>

<TD>001011 0100 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Character Name </TH>

<TH>Character Value (hex)</TH>

<TH> Character Bits HGF EDCBA</TH>

<TH> Current RD – </TH>

<TH>Current RD + </TH>
</TR>

<TR>
<TH>abcdei fghj </TH>

<TH>abcdei fghj </TH>
</TR>

<TR>
<TH>D21.0 </TH>

<TD>15 </TD>

<TD>000 10101 </TD>

<TD>101010 1011 </TD>

<TD>101010 0100 </TD>
</TR>

<TR>
<TH>D22.0 </TH>

<TD>16 </TD>

<TD>000 10110 </TD>

<TD>011010 1011 </TD>

<TD>011010 0100 </TD>
</TR>

<TR>
<TH>D23.0 </TH>

<TD>17 </TD>

<TD>000 10111 </TD>

<TD>111010 0100 </TD>

<TD>000101 1011 </TD>
</TR>

<TR>
<TH>D24.0 </TH>

<TD>18 </TD>

<TD>000 11000 </TD>

<TD>110011 0100 </TD>

<TD>001100 1011 </TD>
</TR>

<TR>
<TH>D25.0 </TH>

<TD>19 </TD>

<TD>000 11001 </TD>

<TD>100110 1011 </TD>

<TD>100110 0100 </TD>
</TR>

<TR>
<TH>D26.0 </TH>

<TD>1A </TD>

<TD>000 11010 </TD>

<TD>010110 1011 </TD>

<TD>010110 0100 </TD>
</TR>

<TR>
<TH>D27.0 </TH>

<TD>1B </TD>

<TD>000 11011 </TD>

<TD>110110 0100 </TD>

<TD>001001 1011 </TD>
</TR>

<TR>
<TH>D28.0 </TH>

<TD>1C </TD>

<TD>000 11100 </TD>

<TD>001110 1011 </TD>

<TD>001110 0100 </TD>
</TR>

<TR>
<TH>D29.0 </TH>

<TD>1D </TD>

<TD>000 11101 </TD>

<TD>101110 0100 </TD>

<TD>010001 1011 </TD>
</TR>

<TR>
<TH>D30.0 </TH>

<TD>1E </TD>

<TD>000 11110 </TD>

<TD>011110 0100 </TD>

<TD>100001 1011 </TD>
</TR>

<TR>
<TH>D31.0 </TH>

<TD>1F </TD>

<TD>000 11111 </TD>

<TD>101011 0100 </TD>

<TD>010100 1011 </TD>
</TR>

<TR>
<TH>D0.1 </TH>

<TD>20 </TD>

<TD>001 00000 </TD>

<TD>100111 1001 </TD>

<TD>011000 1001 </TD>
</TR>

<TR>
<TH>D1.1 </TH>

<TD>21 </TD>

<TD>001 00001 </TD>

<TD>011101 1001 </TD>

<TD>100010 1001 </TD>
</TR>

<TR>
<TH>D2.1 </TH>

<TD>22 </TD>

<TD>001 00010 </TD>

<TD>101101 1001 </TD>

<TD>010010 1001 </TD>
</TR>

<TR>
<TH>D3.1 </TH>

<TD>23 </TD>

<TD>001 00011 </TD>

<TD>110001 1001 </TD>

<TD>110001 1001 </TD>
</TR>

<TR>
<TH>D4.1 </TH>

<TD>24 </TD>

<TD>001 00100 </TD>

<TD>110101 1001 </TD>

<TD>001010 1001 </TD>
</TR>

<TR>
<TH>D5.1 </TH>

<TD>25 </TD>

<TD>001 00101 </TD>

<TD>101001 1001 </TD>

<TD>101001 1001 </TD>
</TR>

<TR>
<TH>D6.1 </TH>

<TD>26 </TD>

<TD>001 00110 </TD>

<TD>011001 1001 </TD>

<TD>011001 1001 </TD>
</TR>

<TR>
<TH>D7.1 </TH>

<TD>27 </TD>

<TD>001 00111 </TD>

<TD>111000 1001 </TD>

<TD>000111 1001 </TD>
</TR>

<TR>
<TH>D8.1 </TH>

<TD>28 </TD>

<TD>001 01000 </TD>

<TD>111001 1001 </TD>

<TD>000110 1001 </TD>
</TR>

<TR>
<TH>D9.1 </TH>

<TD>29 </TD>

<TD>001 01001 </TD>

<TD>100101 1001 </TD>

<TD>100101 1001 </TD>
</TR>

<TR>
<TH>D10.1 </TH>

<TD>2A </TD>

<TD>001 01010 </TD>

<TD>010101 1001 </TD>

<TD>010101 1001 </TD>
</TR>

<TR>
<TH>D11.1 </TH>

<TD>2B </TD>

<TD>001 01011 </TD>

<TD>110100 1001 </TD>

<TD>110100 1001 </TD>
</TR>

<TR>
<TH>D12.1 </TH>

<TD>2C </TD>

<TD>001 01100 </TD>

<TD>001101 1001 </TD>

<TD>001101 1001 </TD>
</TR>

<TR>
<TH>D13.1 </TH>

<TD>2D </TD>

<TD>001 01101 </TD>

<TD>101100 1001 </TD>

<TD>101100 1001 </TD>
</TR>

<TR>
<TH>D14.1 </TH>

<TD>2E </TD>

<TD>001 01110 </TD>

<TD>011100 1001 </TD>

<TD>011100 1001 </TD>
</TR>

<TR>
<TH>D15.1 </TH>

<TD>2F </TD>

<TD>001 01111 </TD>

<TD>010111 1001 </TD>

<TD>101000 1001 </TD>
</TR>

<TR>
<TH>D16.1 </TH>

<TD>30 </TD>

<TD>001 10000 </TD>

<TD>011011 1001 </TD>

<TD>100100 1001 </TD>
</TR>

<TR>
<TH>D17.1 </TH>

<TD>31 </TD>

<TD>001 10001 </TD>

<TD>100011 1001 </TD>

<TD>100011 1001 </TD>
</TR>

<TR>
<TH>D18.1 </TH>

<TD>32 </TD>

<TD>001 10010 </TD>

<TD>010011 1001 </TD>

<TD>010011 1001 </TD>
</TR>

<TR>
<TH>D19.1 </TH>

<TD>33 </TD>

<TD>001 10011 </TD>

<TD>110010 1001 </TD>

<TD>110010 1001 </TD>
</TR>

<TR>
<TH>D20.1 </TH>

<TD>34 </TD>

<TD>001 10100 </TD>

<TD>001011 1001 </TD>

<TD>001011 1001 </TD>
</TR>

<TR>
<TH>D21.1 </TH>

<TD>35 </TD>

<TD>001 10101 </TD>

<TD>101010 1001 </TD>

<TD>101010 1001 </TD>
</TR>

<TR>
<TH>D22.1 </TH>

<TD>36 </TD>

<TD>001 10110 </TD>

<TD>011010 1001 </TD>

<TD>011010 1001 </TD>
</TR>

<TR>
<TH>D23.1 </TH>

<TD>37 </TD>

<TD>001 10111 </TD>

<TD>111010 1001 </TD>

<TD>000101 1001 </TD>
</TR>

<TR>
<TH>D24.1 </TH>

<TD>38 </TD>

<TD>001 11000 </TD>

<TD>110011 1001 </TD>

<TD>001100 1001 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Character Name </TH>

<TH>Character Value (hex)</TH>

<TH> Character Bits HGF EDCBA</TH>

<TH> Current RD – </TH>

<TH>Current RD + </TH>
</TR>

<TR>
<TH>abcdei fghj </TH>

<TH>abcdei fghj </TH>
</TR>

<TR>
<TH>D25.1 </TH>

<TD>39 </TD>

<TD>001 11001 </TD>

<TD>100110 1001 </TD>

<TD>100110 1001 </TD>
</TR>

<TR>
<TH>D26.1 </TH>

<TD>3A </TD>

<TD>001 11010 </TD>

<TD>010110 1001 </TD>

<TD>010110 1001 </TD>
</TR>

<TR>
<TH>D27.1 </TH>

<TD>3B </TD>

<TD>001 11011 </TD>

<TD>110110 1001 </TD>

<TD>001001 1001 </TD>
</TR>

<TR>
<TH>D28.1 </TH>

<TD>3C </TD>

<TD>001 11100 </TD>

<TD>001110 1001 </TD>

<TD>001110 1001 </TD>
</TR>

<TR>
<TH>D29.1 </TH>

<TD>3D </TD>

<TD>001 11101 </TD>

<TD>101110 1001 </TD>

<TD>010001 1001 </TD>
</TR>

<TR>
<TH>D30.1 </TH>

<TD>3E </TD>

<TD>001 11110 </TD>

<TD>011110 1001 </TD>

<TD>100001 1001 </TD>
</TR>

<TR>
<TH>D31.1 </TH>

<TD>3F </TD>

<TD>001 11111 </TD>

<TD>101011 1001 </TD>

<TD>010100 1001 </TD>
</TR>

<TR>
<TH>D0.2 </TH>

<TD>40 </TD>

<TD>010 00000 </TD>

<TD>100111 0101 </TD>

<TD>011000 0101 </TD>
</TR>

<TR>
<TH>D1.2 </TH>

<TD>41 </TD>

<TD>010 00001 </TD>

<TD>011101 0101 </TD>

<TD>100010 0101 </TD>
</TR>

<TR>
<TH>D2.2 </TH>

<TD>42 </TD>

<TD>010 00010 </TD>

<TD>101101 0101 </TD>

<TD>010010 0101 </TD>
</TR>

<TR>
<TH>D3.2 </TH>

<TD>43 </TD>

<TD>010 00011 </TD>

<TD>110001 0101 </TD>

<TD>110001 0101 </TD>
</TR>

<TR>
<TH>D4.2 </TH>

<TD>44 </TD>

<TD>010 00100 </TD>

<TD>110101 0101 </TD>

<TD>001010 0101 </TD>
</TR>

<TR>
<TH>D5.2 </TH>

<TD>45 </TD>

<TD>010 00101 </TD>

<TD>101001 0101 </TD>

<TD>101001 0101 </TD>
</TR>

<TR>
<TH>D6.2 </TH>

<TD>46 </TD>

<TD>010 00110 </TD>

<TD>011001 0101 </TD>

<TD>011001 0101 </TD>
</TR>

<TR>
<TH>D7.2 </TH>

<TD>47 </TD>

<TD>010 00111 </TD>

<TD>111000 0101 </TD>

<TD>000111 0101 </TD>
</TR>

<TR>
<TH>D8.2 </TH>

<TD>48 </TD>

<TD>010 01000 </TD>

<TD>111001 0101 </TD>

<TD>000110 0101 </TD>
</TR>

<TR>
<TH>D9.2 </TH>

<TD>49 </TD>

<TD>010 01001 </TD>

<TD>100101 0101 </TD>

<TD>100101 0101 </TD>
</TR>

<TR>
<TH>D10.2 </TH>

<TD>4A </TD>

<TD>010 01010 </TD>

<TD>010101 0101 </TD>

<TD>010101 0101 </TD>
</TR>

<TR>
<TH>D11.2 </TH>

<TD>4B </TD>

<TD>010 01011 </TD>

<TD>110100 0101 </TD>

<TD>110100 0101 </TD>
</TR>

<TR>
<TH>D12.2 </TH>

<TD>4C </TD>

<TD>010 01100 </TD>

<TD>001101 0101 </TD>

<TD>001101 0101 </TD>
</TR>

<TR>
<TH>D13.2 </TH>

<TD>4D </TD>

<TD>010 01101 </TD>

<TD>101100 0101 </TD>

<TD>101100 0101 </TD>
</TR>

<TR>
<TH>D14.2 </TH>

<TD>4E </TD>

<TD>010 01110 </TD>

<TD>011100 0101 </TD>

<TD>011100 0101 </TD>
</TR>

<TR>
<TH>D15.2 </TH>

<TD>4F </TD>

<TD>010 01111 </TD>

<TD>010111 0101 </TD>

<TD>101000 0101 </TD>
</TR>

<TR>
<TH>D16.2 </TH>

<TD>50 </TD>

<TD>010 10000 </TD>

<TD>011011 0101 </TD>

<TD>100100 0101 </TD>
</TR>

<TR>
<TH>D17.2 </TH>

<TD>51 </TD>

<TD>010 10001 </TD>

<TD>100011 0101 </TD>

<TD>100011 0101 </TD>
</TR>

<TR>
<TH>D18.2 </TH>

<TD>52 </TD>

<TD>010 10010 </TD>

<TD>010011 0101 </TD>

<TD>010011 0101 </TD>
</TR>

<TR>
<TH>D19.2 </TH>

<TD>53 </TD>

<TD>010 10011 </TD>

<TD>110010 0101 </TD>

<TD>110010 0101 </TD>
</TR>

<TR>
<TH>D20.2 </TH>

<TD>54 </TD>

<TD>010 10100 </TD>

<TD>001011 0101 </TD>

<TD>001011 0101 </TD>
</TR>

<TR>
<TH>D21.2 </TH>

<TD>55 </TD>

<TD>010 10101 </TD>

<TD>101010 0101 </TD>

<TD>101010 0101 </TD>
</TR>

<TR>
<TH>D22.2 </TH>

<TD>56 </TD>

<TD>010 10110 </TD>

<TD>011010 0101 </TD>

<TD>011010 0101 </TD>
</TR>

<TR>
<TH>D23.2 </TH>

<TD>57 </TD>

<TD>010 10111 </TD>

<TD>111010 0101 </TD>

<TD>000101 0101 </TD>
</TR>

<TR>
<TH>D24.2 </TH>

<TD>58 </TD>

<TD>010 11000 </TD>

<TD>110011 0101 </TD>

<TD>001100 0101 </TD>
</TR>

<TR>
<TH>D25.2 </TH>

<TD>59 </TD>

<TD>010 11001 </TD>

<TD>100110 0101 </TD>

<TD>100110 0101 </TD>
</TR>

<TR>
<TH>D26.2 </TH>

<TD>5A </TD>

<TD>010 11010 </TD>

<TD>010110 0101 </TD>

<TD>010110 0101 </TD>
</TR>

<TR>
<TH>D27.2 </TH>

<TD>5B </TD>

<TD>010 11011 </TD>

<TD>110110 0101 </TD>

<TD>001001 0101 </TD>
</TR>

<TR>
<TH>D28.2 </TH>

<TD>5C </TD>

<TD>010 11100 </TD>

<TD>001110 0101 </TD>

<TD>001110 0101 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Character Name </TH>

<TH>Character Value (hex)</TH>

<TH> Character Bits HGF EDCBA</TH>

<TH> Current RD – </TH>

<TH>Current RD + </TH>
</TR>

<TR>
<TH>abcdei fghj </TH>

<TH>abcdei fghj </TH>
</TR>

<TR>
<TH>D29.2 </TH>

<TH>5D </TH>

<TD>010 11101 </TD>

<TD>101110 0101 </TD>

<TD>010001 0101 </TD>
</TR>

<TR>
<TH>D30.2 </TH>

<TH>5E </TH>

<TD>010 11110 </TD>

<TD>011110 0101 </TD>

<TD>100001 0101 </TD>
</TR>

<TR>
<TH>D31.2 </TH>

<TH>5F </TH>

<TD>010 11111 </TD>

<TD>101011 0101 </TD>

<TD>010100 0101 </TD>
</TR>

<TR>
<TH>D0.3 </TH>

<TD>60 </TD>

<TD>011 00000 </TD>

<TD>100111 0011 </TD>

<TD>011000 1100 </TD>
</TR>

<TR>
<TH>D1.3 </TH>

<TD>61 </TD>

<TD>011 00001 </TD>

<TD>011101 0011 </TD>

<TD>100010 1100 </TD>
</TR>

<TR>
<TH>D2.3 </TH>

<TD>62 </TD>

<TD>011 00010 </TD>

<TD>101101 0011 </TD>

<TD>010010 1100 </TD>
</TR>

<TR>
<TH>D3.3 </TH>

<TD>63 </TD>

<TD>011 00011 </TD>

<TD>110001 1100 </TD>

<TD>110001 0011 </TD>
</TR>

<TR>
<TH>D4.3 </TH>

<TD>64 </TD>

<TD>011 00100 </TD>

<TD>110101 0011 </TD>

<TD>001010 1100 </TD>
</TR>

<TR>
<TH>D5.3 </TH>

<TD>65 </TD>

<TD>011 00101 </TD>

<TD>101001 1100 </TD>

<TD>101001 0011 </TD>
</TR>

<TR>
<TH>D6.3 </TH>

<TD>66 </TD>

<TD>011 00110 </TD>

<TD>011001 1100 </TD>

<TD>011001 0011 </TD>
</TR>

<TR>
<TH>D7.3 </TH>

<TD>67 </TD>

<TD>011 00111 </TD>

<TD>111000 1100 </TD>

<TD>000111 0011 </TD>
</TR>

<TR>
<TH>D8.3 </TH>

<TD>68 </TD>

<TD>011 01000 </TD>

<TD>111001 0011 </TD>

<TD>000110 1100 </TD>
</TR>

<TR>
<TH>D9.3 </TH>

<TD>69 </TD>

<TD>011 01001 </TD>

<TD>100101 1100 </TD>

<TD>100101 0011 </TD>
</TR>

<TR>
<TH>D10.3 </TH>

<TD>6A </TD>

<TD>011 01010 </TD>

<TD>010101 1100 </TD>

<TD>010101 0011 </TD>
</TR>

<TR>
<TH>D11.3 </TH>

<TD>6B </TD>

<TD>011 01011 </TD>

<TD>110100 1100 </TD>

<TD>110100 0011 </TD>
</TR>

<TR>
<TH>D12.3 </TH>

<TD>6C </TD>

<TD>011 01100 </TD>

<TD>001101 1100 </TD>

<TD>001101 0011 </TD>
</TR>

<TR>
<TH>D13.3 </TH>

<TD>6D </TD>

<TD>011 01101 </TD>

<TD>101100 1100 </TD>

<TD>101100 0011 </TD>
</TR>

<TR>
<TH>D14.3 </TH>

<TD>6E </TD>

<TD>011 01110 </TD>

<TD>011100 1100 </TD>

<TD>011100 0011 </TD>
</TR>

<TR>
<TH>D15.3 </TH>

<TD>6F </TD>

<TD>011 01111 </TD>

<TD>010111 0011 </TD>

<TD>101000 1100 </TD>
</TR>

<TR>
<TH>D16.3 </TH>

<TD>70 </TD>

<TD>011 10000 </TD>

<TD>011011 0011 </TD>

<TD>100100 1100 </TD>
</TR>

<TR>
<TH>D17.3 </TH>

<TD>71 </TD>

<TD>011 10001 </TD>

<TD>100011 1100 </TD>

<TD>100011 0011 </TD>
</TR>

<TR>
<TH>D18.3 </TH>

<TD>72 </TD>

<TD>011 10010 </TD>

<TD>010011 1100 </TD>

<TD>010011 0011 </TD>
</TR>

<TR>
<TH>D19.3 </TH>

<TD>73 </TD>

<TD>011 10011 </TD>

<TD>110010 1100 </TD>

<TD>110010 0011 </TD>
</TR>

<TR>
<TH>D20.3 </TH>

<TD>74 </TD>

<TD>011 10100 </TD>

<TD>001011 1100 </TD>

<TD>001011 0011 </TD>
</TR>

<TR>
<TH>D21.3 </TH>

<TD>75 </TD>

<TD>011 10101 </TD>

<TD>101010 1100 </TD>

<TD>101010 0011 </TD>
</TR>

<TR>
<TH>D22.3 </TH>

<TD>76 </TD>

<TD>011 10110 </TD>

<TD>011010 1100 </TD>

<TD>011010 0011 </TD>
</TR>

<TR>
<TH>D23.3 </TH>

<TD>77 </TD>

<TD>011 10111 </TD>

<TD>111010 0011 </TD>

<TD>000101 1100 </TD>
</TR>

<TR>
<TH>D24.3 </TH>

<TD>78 </TD>

<TD>011 11000 </TD>

<TD>110011 0011 </TD>

<TD>001100 1100 </TD>
</TR>

<TR>
<TH>D25.3 </TH>

<TD>79 </TD>

<TD>011 11001 </TD>

<TD>100110 1100 </TD>

<TD>100110 0011 </TD>
</TR>

<TR>
<TH>D26.3 </TH>

<TD>7A </TD>

<TD>011 11010 </TD>

<TD>010110 1100 </TD>

<TD>010110 0011 </TD>
</TR>

<TR>
<TH>D27.3 </TH>

<TD>7B </TD>

<TD>011 11011 </TD>

<TD>110110 0011 </TD>

<TD>001001 1100 </TD>
</TR>

<TR>
<TH>D28.3 </TH>

<TD>7C </TD>

<TD>011 11100 </TD>

<TD>001110 1100 </TD>

<TD>001110 0011 </TD>
</TR>

<TR>
<TH>D29.3 </TH>

<TD>7D </TD>

<TD>011 11101 </TD>

<TD>101110 0011 </TD>

<TD>010001 1100 </TD>
</TR>

<TR>
<TH>D30.3 </TH>

<TD>7E </TD>

<TD>011 11110 </TD>

<TD>011110 0011 </TD>

<TD>100001 1100 </TD>
</TR>

<TR>
<TH>D31.3 </TH>

<TD>7F </TD>

<TD>011 11111 </TD>

<TD>101011 0011 </TD>

<TD>010100 1100 </TD>
</TR>

<TR>
<TH>D0.4 </TH>

<TD>80 </TD>

<TD>100 00000 </TD>

<TD>100111 0010 </TD>

<TD>011000 1101 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>D1.4 Character Name </TH>

<TH>81 Character Value (hex)</TH>

<TH>100 00001  Character Bits HGF EDCBA</TH>

<TH> Current RD – </TH>

<TH>Current RD + </TH>
</TR>

<TR>
<TH>011101 0010 abcdei fghj </TH>

<TH>100010 1101 abcdei fghj </TH>
</TR>

<TR>
<TH>D2.4 </TH>

<TD>82 </TD>

<TD>100 00010 </TD>

<TD>101101 0010 </TD>

<TD>010010 1101 </TD>
</TR>

<TR>
<TH>D3.4 </TH>

<TD>83 </TD>

<TD>100 00011 </TD>

<TD>110001 1101 </TD>

<TD>110001 0010 </TD>
</TR>

<TR>
<TH>D4.4 </TH>

<TD>84 </TD>

<TD>100 00100 </TD>

<TD>110101 0010 </TD>

<TD>001010 1101 </TD>
</TR>

<TR>
<TH>D5.4 </TH>

<TD>85 </TD>

<TD>100 00101 </TD>

<TD>101001 1101 </TD>

<TD>101001 0010 </TD>
</TR>

<TR>
<TH>D6.4 </TH>

<TD>86 </TD>

<TD>100 00110 </TD>

<TD>011001 1101 </TD>

<TD>011001 0010 </TD>
</TR>

<TR>
<TH>D7.4 </TH>

<TD>87 </TD>

<TD>100 00111 </TD>

<TD>111000 1101 </TD>

<TD>000111 0010 </TD>
</TR>

<TR>
<TH>D8.4 </TH>

<TD>88 </TD>

<TD>100 01000 </TD>

<TD>111001 0010 </TD>

<TD>000110 1101 </TD>
</TR>

<TR>
<TH>D9.4 </TH>

<TD>89 </TD>

<TD>100 01001 </TD>

<TD>100101 1101 </TD>

<TD>100101 0010 </TD>
</TR>

<TR>
<TH>D10.4 </TH>

<TD>8A </TD>

<TD>100 01010 </TD>

<TD>010101 1101 </TD>

<TD>010101 0010 </TD>
</TR>

<TR>
<TH>D11.4 </TH>

<TD>8B </TD>

<TD>100 01011 </TD>

<TD>110100 1101 </TD>

<TD>110100 0010 </TD>
</TR>

<TR>
<TH>D12.4 </TH>

<TD>8C </TD>

<TD>100 01100 </TD>

<TD>001101 1101 </TD>

<TD>001101 0010 </TD>
</TR>

<TR>
<TH>D13.4 </TH>

<TD>8D </TD>

<TD>100 01101 </TD>

<TD>101100 1101 </TD>

<TD>101100 0010 </TD>
</TR>

<TR>
<TH>D14.4 </TH>

<TD>8E </TD>

<TD>100 01110 </TD>

<TD>011100 1101 </TD>

<TD>011100 0010 </TD>
</TR>

<TR>
<TH>D15.4 </TH>

<TD>8F </TD>

<TD>100 01111 </TD>

<TD>010111 0010 </TD>

<TD>101000 1101 </TD>
</TR>

<TR>
<TH>D16.4 </TH>

<TD>90 </TD>

<TD>100 10000 </TD>

<TD>011011 0010 </TD>

<TD>100100 1101 </TD>
</TR>

<TR>
<TH>D17.4 </TH>

<TD>91 </TD>

<TD>100 10001 </TD>

<TD>100011 1101 </TD>

<TD>100011 0010 </TD>
</TR>

<TR>
<TH>D18.4 </TH>

<TD>92 </TD>

<TD>100 10010 </TD>

<TD>010011 1101 </TD>

<TD>010011 0010 </TD>
</TR>

<TR>
<TH>D19.4 </TH>

<TD>93 </TD>

<TD>100 10011 </TD>

<TD>110010 1101 </TD>

<TD>110010 0010 </TD>
</TR>

<TR>
<TH>D20.4 </TH>

<TD>94 </TD>

<TD>100 10100 </TD>

<TD>001011 1101 </TD>

<TD>001011 0010 </TD>
</TR>

<TR>
<TH>D21.4 </TH>

<TD>95 </TD>

<TD>100 10101 </TD>

<TD>101010 1101 </TD>

<TD>101010 0010 </TD>
</TR>

<TR>
<TH>D22.4 </TH>

<TD>96 </TD>

<TD>100 10110 </TD>

<TD>011010 1101 </TD>

<TD>011010 0010 </TD>
</TR>

<TR>
<TH>D23.4 </TH>

<TD>97 </TD>

<TD>100 10111 </TD>

<TD>111010 0010 </TD>

<TD>000101 1101 </TD>
</TR>

<TR>
<TH>D24.4 </TH>

<TD>98 </TD>

<TD>100 11000 </TD>

<TD>110011 0010 </TD>

<TD>001100 1101 </TD>
</TR>

<TR>
<TH>D25.4 </TH>

<TD>99 </TD>

<TD>100 11001 </TD>

<TD>100110 1101 </TD>

<TD>100110 0010 </TD>
</TR>

<TR>
<TH>D26.4 </TH>

<TD>9A </TD>

<TD>100 11010 </TD>

<TD>010110 1101 </TD>

<TD>010110 0010 </TD>
</TR>

<TR>
<TH>D27.4 </TH>

<TD>9B </TD>

<TD>100 11011 </TD>

<TD>110110 0010 </TD>

<TD>001001 1101 </TD>
</TR>

<TR>
<TH>D28.4 </TH>

<TD>9C </TD>

<TD>100 11100 </TD>

<TD>001110 1101 </TD>

<TD>001110 0010 </TD>
</TR>

<TR>
<TH>D29.4 </TH>

<TD>9D </TD>

<TD>100 11101 </TD>

<TD>101110 0010 </TD>

<TD>010001 1101 </TD>
</TR>

<TR>
<TH>D30.4 </TH>

<TD>9E </TD>

<TD>100 11110 </TD>

<TD>011110 0010 </TD>

<TD>100001 1101 </TD>
</TR>

<TR>
<TH>D31.4 </TH>

<TD>9F </TD>

<TD>100 11111 </TD>

<TD>101011 0010 </TD>

<TD>010100 1101 </TD>
</TR>

<TR>
<TH>D0.5 </TH>

<TD>A0 </TD>

<TD>101 00000 </TD>

<TD>100111 1010 </TD>

<TD>011000 1010 </TD>
</TR>

<TR>
<TH>D1.5 </TH>

<TD>A1 </TD>

<TD>101 00001 </TD>

<TD>011101 1010 </TD>

<TD>100010 1010 </TD>
</TR>

<TR>
<TH>D2.5 </TH>

<TD>A2 </TD>

<TD>101 00010 </TD>

<TD>101101 1010 </TD>

<TD>010010 1010 </TD>
</TR>

<TR>
<TH>D3.5 </TH>

<TD>A3 </TD>

<TD>101 00011 </TD>

<TD>110001 1010 </TD>

<TD>110001 1010 </TD>
</TR>

<TR>
<TH>D4.5 </TH>

<TD>A4 </TD>

<TD>101 00100 </TD>

<TD>110101 1010 </TD>

<TD>001010 1010 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Character Name </TH>

<TH>Character Value (hex)</TH>

<TH> Character Bits HGF EDCBA</TH>

<TH> Current RD – </TH>

<TH>Current RD + </TH>
</TR>

<TR>
<TH>abcdei fghj </TH>

<TH>abcdei fghj </TH>
</TR>

<TR>
<TH>D5.5 </TH>

<TH>A5 </TH>

<TD>101 00101 </TD>

<TD>101001 1010 </TD>

<TD>101001 1010 </TD>
</TR>

<TR>
<TH>D6.5 </TH>

<TH>A6 </TH>

<TD>101 00110 </TD>

<TD>011001 1010 </TD>

<TD>011001 1010 </TD>
</TR>

<TR>
<TH>D7.5 </TH>

<TH>A7 </TH>

<TD>101 00111 </TD>

<TD>111000 1010 </TD>

<TD>000111 1010 </TD>
</TR>

<TR>
<TH>D8.5 </TH>

<TH>A8 </TH>

<TD>101 01000 </TD>

<TD>111001 1010 </TD>

<TD>000110 1010 </TD>
</TR>

<TR>
<TH>D9.5 </TH>

<TH>A9 </TH>

<TD>101 01001 </TD>

<TD>100101 1010 </TD>

<TD>100101 1010 </TD>
</TR>

<TR>
<TH>D10.5 </TH>

<TH>AA </TH>

<TD>101 01010 </TD>

<TD>010101 1010 </TD>

<TD>010101 1010 </TD>
</TR>

<TR>
<TH>D11.5 </TH>

<TH>AB </TH>

<TD>101 01011 </TD>

<TD>110100 1010 </TD>

<TD>110100 1010 </TD>
</TR>

<TR>
<TH>D12.5 </TH>

<TH>AC </TH>

<TD>101 01100 </TD>

<TD>001101 1010 </TD>

<TD>001101 1010 </TD>
</TR>

<TR>
<TH>D13.5 </TH>

<TH>AD </TH>

<TD>101 01101 </TD>

<TD>101100 1010 </TD>

<TD>101100 1010 </TD>
</TR>

<TR>
<TH>D14.5 </TH>

<TH>AE </TH>

<TD>101 01110 </TD>

<TD>011100 1010 </TD>

<TD>011100 1010 </TD>
</TR>

<TR>
<TH>D15.5 </TH>

<TH>AF </TH>

<TD>101 01111 </TD>

<TD>010111 1010 </TD>

<TD>101000 1010 </TD>
</TR>

<TR>
<TH>D16.5 </TH>

<TH>B0 </TH>

<TD>101 10000 </TD>

<TD>011011 1010 </TD>

<TD>100100 1010 </TD>
</TR>

<TR>
<TH>D17.5 </TH>

<TH>B1 </TH>

<TD>101 10001 </TD>

<TD>100011 1010 </TD>

<TD>100011 1010 </TD>
</TR>

<TR>
<TH>D18.5 </TH>

<TH>B2 </TH>

<TD>101 10010 </TD>

<TD>010011 1010 </TD>

<TD>010011 1010 </TD>
</TR>

<TR>
<TH>D19.5 </TH>

<TH>B3 </TH>

<TD>101 10011 </TD>

<TD>110010 1010 </TD>

<TD>110010 1010 </TD>
</TR>

<TR>
<TH>D20.5 </TH>

<TH>B4 </TH>

<TD>101 10100 </TD>

<TD>001011 1010 </TD>

<TD>001011 1010 </TD>
</TR>

<TR>
<TH>D21.5 </TH>

<TH>B5 </TH>

<TD>101 10101 </TD>

<TD>101010 1010 </TD>

<TD>101010 1010 </TD>
</TR>

<TR>
<TH>D22.5 </TH>

<TH>B6 </TH>

<TD>101 10110 </TD>

<TD>011010 1010 </TD>

<TD>011010 1010 </TD>
</TR>

<TR>
<TH>D23.5 </TH>

<TH>B7 </TH>

<TD>101 10111 </TD>

<TD>111010 1010 </TD>

<TD>000101 1010 </TD>
</TR>

<TR>
<TH>D24.5 </TH>

<TH>B8 </TH>

<TD>101 11000 </TD>

<TD>110011 1010 </TD>

<TD>001100 1010 </TD>
</TR>

<TR>
<TH>D25.5 </TH>

<TH>B9 </TH>

<TD>101 11001 </TD>

<TD>100110 1010 </TD>

<TD>100110 1010 </TD>
</TR>

<TR>
<TH>D26.5 </TH>

<TH>BA </TH>

<TD>101 11010 </TD>

<TD>010110 1010 </TD>

<TD>010110 1010 </TD>
</TR>

<TR>
<TH>D27.5 </TH>

<TH>BB </TH>

<TD>101 11011 </TD>

<TD>110110 1010 </TD>

<TD>001001 1010 </TD>
</TR>

<TR>
<TH>D28.5 </TH>

<TH>BC </TH>

<TD>101 11100 </TD>

<TD>001110 1010 </TD>

<TD>001110 1010 </TD>
</TR>

<TR>
<TH>D29.5 </TH>

<TH>BD </TH>

<TD>101 11101 </TD>

<TD>101110 1010 </TD>

<TD>010001 1010 </TD>
</TR>

<TR>
<TH>D30.5 </TH>

<TH>BE </TH>

<TD>101 11110 </TD>

<TD>011110 1010 </TD>

<TD>100001 1010 </TD>
</TR>

<TR>
<TH>D31.5 </TH>

<TH>BF </TH>

<TD>101 11111 </TD>

<TD>101011 1010 </TD>

<TD>010100 1010 </TD>
</TR>

<TR>
<TH>D0.6 </TH>

<TH>C0 </TH>

<TD>110 00000 </TD>

<TD>100111 0110 </TD>

<TD>011000 0110 </TD>
</TR>

<TR>
<TH>D1.6 </TH>

<TH>C1 </TH>

<TD>110 00001 </TD>

<TD>011101 0110 </TD>

<TD>100010 0110 </TD>
</TR>

<TR>
<TH>D2.6 </TH>

<TH>C2 </TH>

<TD>110 00010 </TD>

<TD>101101 0110 </TD>

<TD>010010 0110 </TD>
</TR>

<TR>
<TH>D3.6 </TH>

<TH>C3 </TH>

<TD>110 00011 </TD>

<TD>110001 0110 </TD>

<TD>110001 0110 </TD>
</TR>

<TR>
<TH>D4.6 </TH>

<TH>C4 </TH>

<TD>110 00100 </TD>

<TD>110101 0110 </TD>

<TD>001010 0110 </TD>
</TR>

<TR>
<TH>D5.6 </TH>

<TH>C5 </TH>

<TD>110 00101 </TD>

<TD>101001 0110 </TD>

<TD>101001 0110 </TD>
</TR>

<TR>
<TH>D6.6 </TH>

<TH>C6 </TH>

<TD>110 00110 </TD>

<TD>011001 0110 </TD>

<TD>011001 0110 </TD>
</TR>

<TR>
<TH>D7.6 </TH>

<TH>C7 </TH>

<TD>110 00111 </TD>

<TD>111000 0110 </TD>

<TD>000111 0110 </TD>
</TR>

<TR>
<TH>D8.6 </TH>

<TH>C8 </TH>

<TD>110 01000 </TD>

<TD>111001 0110 </TD>

<TD>000110 0110 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Character Name </TH>

<TH>Character Value (hex)</TH>

<TH> Character Bits HGF EDCBA</TH>

<TH> Current RD – </TH>

<TH>Current RD + </TH>
</TR>

<TR>
<TH>abcdei fghj </TH>

<TH>abcdei fghj </TH>
</TR>

<TR>
<TH>D9.6 </TH>

<TH>C9 </TH>

<TD>110 01001 </TD>

<TD>100101 0110 </TD>

<TD>100101 0110 </TD>
</TR>

<TR>
<TH>D10.6 </TH>

<TH>CA </TH>

<TD>110 01010 </TD>

<TD>010101 0110 </TD>

<TD>010101 0110 </TD>
</TR>

<TR>
<TH>D11.6 </TH>

<TH>CB </TH>

<TD>110 01011 </TD>

<TD>110100 0110 </TD>

<TD>110100 0110 </TD>
</TR>

<TR>
<TH>D12.6 </TH>

<TH>CC </TH>

<TD>110 01100 </TD>

<TD>001101 0110 </TD>

<TD>001101 0110 </TD>
</TR>

<TR>
<TH>D13.6 </TH>

<TH>CD </TH>

<TD>110 01101 </TD>

<TD>101100 0110 </TD>

<TD>101100 0110 </TD>
</TR>

<TR>
<TH>D14.6 </TH>

<TH>CE </TH>

<TD>110 01110 </TD>

<TD>011100 0110 </TD>

<TD>011100 0110 </TD>
</TR>

<TR>
<TH>D15.6 </TH>

<TH>CF </TH>

<TD>110 01111 </TD>

<TD>010111 0110 </TD>

<TD>101000 0110 </TD>
</TR>

<TR>
<TH>D16.6 </TH>

<TH>D0 </TH>

<TD>110 10000 </TD>

<TD>011011 0110 </TD>

<TD>100100 0110 </TD>
</TR>

<TR>
<TH>D17.6 D18.6 D19.6 </TH>

<TH>D1 D2 D3 </TH>

<TD>110 10001 110 10010 110 10011 </TD>

<TD>100011 0110 010011 0110 110010 0110 </TD>

<TD>100011 0110 010011 0110 110010 0110 </TD>
</TR>

<TR>
<TH>D20.6 </TH>

<TH>D4 </TH>

<TD>110 10100 </TD>

<TD>001011 0110 </TD>

<TD>001011 0110 </TD>
</TR>

<TR>
<TH>D21.6 </TH>

<TH>D5 </TH>

<TD>110 10101 </TD>

<TD>101010 0110 </TD>

<TD>101010 0110 </TD>
</TR>

<TR>
<TH>D22.6 </TH>

<TH>D6 </TH>

<TD>110 10110 </TD>

<TD>011010 0110 </TD>

<TD>011010 0110 </TD>
</TR>

<TR>
<TH>D23.6 </TH>

<TH>D7 </TH>

<TD>110 10111 </TD>

<TD>111010 0110 </TD>

<TD>000101 0110 </TD>
</TR>

<TR>
<TH>D24.6 </TH>

<TH>D8 </TH>

<TD>110 11000 </TD>

<TD>110011 0110 </TD>

<TD>001100 0110 </TD>
</TR>

<TR>
<TH>D25.6 </TH>

<TH>D9 </TH>

<TD>110 11001 </TD>

<TD>100110 0110 </TD>

<TD>100110 0110 </TD>
</TR>

<TR>
<TH>D26.6 </TH>

<TH>DA </TH>

<TD>110 11010 </TD>

<TD>010110 0110 </TD>

<TD>010110 0110 </TD>
</TR>

<TR>
<TH>D27.6 </TH>

<TH>DB </TH>

<TD>110 11011 </TD>

<TD>110110 0110 </TD>

<TD>001001 0110 </TD>
</TR>

<TR>
<TH>D28.6 </TH>

<TH>DC </TH>

<TD>110 11100 </TD>

<TD>001110 0110 </TD>

<TD>001110 0110 </TD>
</TR>

<TR>
<TH>D29.6 </TH>

<TH>DD </TH>

<TD>110 11101 </TD>

<TD>101110 0110 </TD>

<TD>010001 0110 </TD>
</TR>

<TR>
<TH>D30.6 </TH>

<TH>DE </TH>

<TD>110 11110 </TD>

<TD>011110 0110 </TD>

<TD>100001 0110 </TD>
</TR>

<TR>
<TH>D31.6 </TH>

<TH>DF </TH>

<TD>110 11111 </TD>

<TD>101011 0110 </TD>

<TD>010100 0110 </TD>
</TR>

<TR>
<TH>D0.7 </TH>

<TH>E0 </TH>

<TD>111 00000 </TD>

<TD>100111 0001 </TD>

<TD>011000 1110 </TD>
</TR>

<TR>
<TH>D1.7 </TH>

<TH>E1 </TH>

<TD>111 00001 </TD>

<TD>011101 0001 </TD>

<TD>100010 1110 </TD>
</TR>

<TR>
<TH>D2.7 </TH>

<TH>E2 </TH>

<TD>111 00010 </TD>

<TD>101101 0001 </TD>

<TD>010010 1110 </TD>
</TR>

<TR>
<TH>D3.7 </TH>

<TH>E3 </TH>

<TD>111 00011 </TD>

<TD>110001 1110 </TD>

<TD>110001 0001 </TD>
</TR>

<TR>
<TH>D4.7 </TH>

<TH>E4 </TH>

<TD>111 00100 </TD>

<TD>110101 0001 </TD>

<TD>001010 1110 </TD>
</TR>

<TR>
<TH>D5.7 </TH>

<TH>E5 </TH>

<TD>111 00101 </TD>

<TD>101001 1110 </TD>

<TD>101001 0001 </TD>
</TR>

<TR>
<TH>D6.7 </TH>

<TH>E6 </TH>

<TD>111 00110 </TD>

<TD>011001 1110 </TD>

<TD>011001 0001 </TD>
</TR>

<TR>
<TH>D7.7 </TH>

<TH>E7 </TH>

<TD>111 00111 </TD>

<TD>111000 1110 </TD>

<TD>000111 0001 </TD>
</TR>

<TR>
<TH>D8.7 </TH>

<TH>E8 </TH>

<TD>111 01000 </TD>

<TD>111001 0001 </TD>

<TD>000110 1110 </TD>
</TR>

<TR>
<TH>D9.7 </TH>

<TH>E9 </TH>

<TD>111 01001 </TD>

<TD>100101 1110 </TD>

<TD>100101 0001 </TD>
</TR>

<TR>
<TH>D10.7 </TH>

<TH>EA </TH>

<TD>111 01010 </TD>

<TD>010101 1110 </TD>

<TD>010101 0001 </TD>
</TR>

<TR>
<TH>D11.7 </TH>

<TH>EB </TH>

<TD>111 01011 </TD>

<TD>110100 1110 </TD>

<TD>110100 1000 </TD>
</TR>

<TR>
<TH>D12.7 </TH>

<TH>EC </TH>

<TD>111 01100 </TD>

<TD>001101 1110 </TD>

<TD>001101 0001 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Character Name </TH>

<TH>Character Value (hex)</TH>

<TH> Character Bits HGF EDCBA</TH>

<TH> Current RD – </TH>

<TH>Current RD + </TH>
</TR>

<TR>
<TH>abcdei fghj </TH>

<TH>abcdei fghj </TH>
</TR>

<TR>
<TH>D13.7 </TH>

<TH>ED </TH>

<TD>111 01101 </TD>

<TD>101100 1110 </TD>

<TD>101100 1000 </TD>
</TR>

<TR>
<TH>D14.7 </TH>

<TH>EE </TH>

<TD>111 01110 </TD>

<TD>011100 1110 </TD>

<TD>011100 1000 </TD>
</TR>

<TR>
<TH>D15.7 </TH>

<TH>EF </TH>

<TD>111 01111 </TD>

<TD>010111 0001 </TD>

<TD>101000 1110 </TD>
</TR>

<TR>
<TH>D16.7 </TH>

<TH>F0 </TH>

<TD>111 10000 </TD>

<TD>011011 0001 </TD>

<TD>100100 1110 </TD>
</TR>

<TR>
<TH>D17.7 </TH>

<TH>F1 </TH>

<TD>111 10001 </TD>

<TD>100011 0111 </TD>

<TD>100011 0001 </TD>
</TR>

<TR>
<TH>D18.7 </TH>

<TH>F2 </TH>

<TD>111 10010 </TD>

<TD>010011 0111 </TD>

<TD>010011 0001 </TD>
</TR>

<TR>
<TH>D19.7 </TH>

<TH>F3 </TH>

<TD>111 10011 </TD>

<TD>110010 1110 </TD>

<TD>110010 0001 </TD>
</TR>

<TR>
<TH>D20.7 </TH>

<TH>F4 </TH>

<TD>111 10100 </TD>

<TD>001011 0111 </TD>

<TD>001011 0001 </TD>
</TR>

<TR>
<TH>D21.7 </TH>

<TH>F5 </TH>

<TD>111 10101 </TD>

<TD>101010 1110 </TD>

<TD>101010 0001 </TD>
</TR>

<TR>
<TH>D22.7 </TH>

<TH>F6 </TH>

<TD>111 10110 </TD>

<TD>011010 1110 </TD>

<TD>011010 0001 </TD>
</TR>

<TR>
<TH>D23.7 </TH>

<TH>F7 </TH>

<TD>111 10111 </TD>

<TD>111010 0001 </TD>

<TD>000101 1110 </TD>
</TR>

<TR>
<TH>D24.7 </TH>

<TH>F8 </TH>

<TD>111 11000 </TD>

<TD>110011 0001 </TD>

<TD>001100 1110 </TD>
</TR>

<TR>
<TH>D25.7 </TH>

<TH>F9 </TH>

<TD>111 11001 </TD>

<TD>100110 1110 </TD>

<TD>100110 0001 </TD>
</TR>

<TR>
<TH>D26.7 </TH>

<TH>FA </TH>

<TD>111 11010 </TD>

<TD>010110 1110 </TD>

<TD>010110 0001 </TD>
</TR>

<TR>
<TH>D27.7 </TH>

<TH>FB </TH>

<TD>111 11011 </TD>

<TD>110110 0001 </TD>

<TD>001001 1110 </TD>
</TR>

<TR>
<TH>D28.7 </TH>

<TH>FC </TH>

<TD>111 11100 </TD>

<TD>001110 1110 </TD>

<TD>001110 0001 </TD>
</TR>

<TR>
<TH>D29.7 </TH>

<TH>FD </TH>

<TD>111 11101 </TD>

<TD>101110 0001 </TD>

<TD>010001 1110 </TD>
</TR>

<TR>
<TH>D30.7 </TH>

<TH>FE </TH>

<TD>111 11110 </TD>

<TD>011110 0001 </TD>

<TD>100001 1110 </TD>
</TR>

<TR>
<TH>D31.7 </TH>

<TH>FF </TH>

<TD>111 11111 </TD>

<TD>101011 0001 </TD>

<TD>010100 1110 </TD>
</TR>

<Caption>
<P>Table 4-2. Special Character Encodings </P>
</Caption>
</Table>

<Table>
<TR>
<TH>Character Name </TH>

<TH>Character Value (hex)</TH>

<TH> Character Bits HGF EDCBA </TH>

<TH>Current RD – </TH>

<TH>Current RD + </TH>

<TH>Notes </TH>
</TR>

<TR>
<TH>abcdei fghj </TH>

<TH>abcdei fghj </TH>
</TR>

<TR>
<TH>K28.0 </TH>

<TH>1C </TH>

<TD>000 11100 </TD>

<TD>001111 0100 </TD>

<TD>110000 1011 </TD>

<TD/>
</TR>

<TR>
<TH>K28.1 </TH>

<TH>3C </TH>

<TD>001 11100 </TD>

<TD>001111 1001 </TD>

<TD>110000 0110 </TD>

<TD>1,2 </TD>
</TR>

<TR>
<TH>K28.2 </TH>

<TH>5C </TH>

<TD>010 11100 </TD>

<TD>001111 0101 </TD>

<TD>110000 1010 </TD>

<TD>1 </TD>
</TR>

<TR>
<TH>K28.3 </TH>

<TH>7C </TH>

<TD>011 11100 </TD>

<TD>001111 0011 </TD>

<TD>110000 1100 </TD>

<TD/>
</TR>

<TR>
<TH>K28.4 </TH>

<TH>9C </TH>

<TD>100 11100 </TD>

<TD>001111 0010 </TD>

<TD>110000 1101 </TD>

<TD>1 </TD>
</TR>

<TR>
<TH>K28.5 </TH>

<TH>BC </TH>

<TD>101 11100 </TD>

<TD>001111 1010 </TD>

<TD>110000 0101 </TD>

<TD>2 </TD>
</TR>

<TR>
<TH>K28.6 </TH>

<TH>DC </TH>

<TD>110 11100 </TD>

<TD>001111 0110 </TD>

<TD>110000 1001 </TD>

<TD>1 </TD>
</TR>

<TR>
<TH>K28.7 </TH>

<TH>FC </TH>

<TD>111 11100 </TD>

<TD>001111 1000 </TD>

<TD>110000 0111 </TD>

<TD>1,2 </TD>
</TR>

<TR>
<TH>K23.7 </TH>

<TH>F7 </TH>

<TD>111 10111 </TD>

<TD>111010 1000 </TD>

<TD>000101 0111 </TD>

<TD>1 </TD>
</TR>

<TR>
<TH>K27.7 </TH>

<TH>FB </TH>

<TD>111 11011 </TD>

<TD>110110 1000 </TD>

<TD>001001 0111 </TD>

<TD/>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Character </TD>

<TD>Character Value </TD>

<TD> Character Bits </TD>

<TD>Current RD – </TD>

<TD>Current RD + </TD>

<TD>Notes </TD>
</TR>

<TR>
<TD>Name </TD>

<TD>(hex)</TD>

<TD>HGF EDCBA </TD>

<TD>abcdei fghj </TD>

<TD>abcdei fghj </TD>
</TR>

<TR>
<TD>K29.7 </TD>

<TD>FD </TD>

<TD>111 11101 </TD>

<TD>101110 1000 </TD>

<TD>010001 0111 </TD>

<TD/>
</TR>

<TR>
<TD>K30.7 </TD>

<TD>FE </TD>

<TD>111 11110 </TD>

<TD>011110 1000 </TD>

<TD>100001 0111 </TD>

<TD>1 </TD>
</TR>
</Table>

<P>1 - Reserved code-groups. 
2 - The code-groups /K28.5/, /K28.7/, and /K28.1/ contain a comma. 
</P>

<P id="LinkTarget_30770">4.5.7 Special Characters and Columns </P>

<P>
<Link>Table 4-3</Link>
 defines the special characters and columns of special characters used by 1x and 4x LP-Serial links. Special characters are used for the following functions: </P>

<L>
<LI>
<LI_Label>1. </LI_Label>

<LI_Title>Alignment to code-group (10-bit) boundaries on lane-by-lane basis. </LI_Title>
</LI>

<LI>
<LI_Label>2. </LI_Label>

<LI_Title>Alignment of the receive data stream across four lanes. </LI_Title>
</LI>

<LI>
<LI_Label>3.</LI_Label>

<LI_Title> Clock rate compensation between receiver and transmitter. </LI_Title>
</LI>

<LI>
<LI_Label>4. </LI_Label>

<LI_Title>Control symbol delimiting. </LI_Title>
</LI>
</L>

<Table>
<Caption>
<P>Table 4-3. Special Characters and Columns </P>
</Caption>

<TR>
<TH>Code-Group/Column Designation </TH>

<TH>Code-Group/Column Use </TH>

<TH>Number of Code-groups </TH>

<TH>Encoding </TH>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>Packet_Delimiter Control Symbol </TD>

<TD>1 </TD>

<TD>/K28.3/ </TD>
</TR>

<TR>
<TD>/SC/ </TD>

<TD>Start_of_Control_Symbol </TD>

<TD>1 </TD>

<TD>/K28.0/ </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>Idle </TD>

<TD/>

<TD/>
</TR>

<TR>
<TD>/K/ </TD>

<TD>1x Sync </TD>

<TD>1 </TD>

<TD>/K28.5/ </TD>
</TR>

<TR>
<TD>/R/ </TD>

<TD>1x Skip </TD>

<TD>1 </TD>

<TD>/K29.7/ </TD>
</TR>

<TR>
<TD>/A/ </TD>

<TD>1x Align </TD>

<TD>1 </TD>

<TD>/K27.7/ </TD>
</TR>

<TR>
<TD>||I|| </TD>

<TD>Idle column </TD>

<TD/>

<TD/>
</TR>

<TR>
<TD>||K|| </TD>

<TD>4x Sync column </TD>

<TD>4 </TD>

<TD>/K28.5/K28.5/K28.5/K28.5/ </TD>
</TR>

<TR>
<TD>||R|| </TD>

<TD>4x Skip column </TD>

<TD>4 </TD>

<TD>/K29.7/K29.7/K29.7/K29.7/ </TD>
</TR>

<TR>
<TD>||A|| </TD>

<TD>4x Align column </TD>

<TD>4 </TD>

<TD>/K27.7/K27.7/K27.7/K27.7/ </TD>
</TR>
</Table>

<P id="LinkTarget_30771">4.5.7.1  Packet Delimiter Control Symbol (/PD/) </P>

<P>PD and /PD/ are aliases for respectively the K28.3 character and the /K28.3/ code-group which are used to delimit the beginning of a control symbol that contains a packet delimiter. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30772">4.5.7.2 Start of Control Symbol (/SC/) </P>

<P>SC and /SC/ are aliases for respectively the K28.0 character and the /K28.0/ code-group which are used to delimit the beginning of a control symbol that does not contain a packet delimiter. </P>

<P id="LinkTarget_30773">4.5.7.3 Idle (/I/) </P>

<P>I and /I/ are aliases for respectively any of the idle sequence characters (A, K, or R) and idle sequence code-groups (/A/, /K/, or /R/). </P>

<P id="LinkTarget_30774">4.5.7.4 Sync (/K/) </P>

<P>K and /K/ are aliases for respectively the K28.5 character and the /K28.5/ code-group which is used in the idle sequence to provide the receiver with the information it requires to achieve and maintain bit and 10-bit code-group boundary synchronization. The /K28.5/ code-group was selected as the Sync character for the following reasons: </P>

<L>
<LI>
<LI_Label>1. </LI_Label>

<LI_Title>It contains the comma pattern in bits abcdeif which can be easily found in the code-group bit stream and marks the code-group boundary. </LI_Title>
</LI>

<LI>
<LI_Label>2.</LI_Label>

<LI_Title> The bits ghj provide the maximum number of transitions (i.e. 101 or 010). </LI_Title>
</LI>
</L>

<P>A comma is a 7-bit string defined as either b’0011111’ (comma+) or b’1100000’ (comma-). Within the code-group set it is a singular bit pattern, which, in the absence of transmission errors, cannot appear in any other location of a code-group and cannot be generated across the boundaries of any two adjacent code-groups with the following exception: </P>

<P>The /K28.7/ special code-group when followed by any of the data code-groups /D3.y/, /D11.y/, /D12.y/, /D19.y/, /D20.y/, /D28.y/, or /K28.y/, where y is an integer in the range 0 through 7, may (depending on the value of running disparity) cause a comma to be generated across the boundary of the two code-groups. A comma that is generated across the boundary between two adjacent code-groups may cause the receiver to change the 10-bit code-group alignment. As a result, the /K28.7/ special code-group may be used for test and diagnostic purposes only. </P>

<P id="LinkTarget_30775">4.5.7.5 Skip (/R/) </P>

<P>R and /R/ are aliases for respectively the K29.7 character and the /29.7/ code-group which are used in the idle sequence and are also used in the clock compensation sequence. </P>

<P id="LinkTarget_30776">4.5.7.6 Align (/A/) </P>

<P>A and /A/ are aliases for respectively the K27.7 character and the /27.7/ code-group which are used in the idle sequence and are used for lane alignment on 4x links. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30777">4.5.8 Effect of Single Bit Code-Group Errors </P>

<P>Single bit code-group errors will be the dominant code-group error by many orders of magnitude. It is therefore useful to know the variety of code-group corruptions that can be caused by a single bit error. </P>

<P>
<Link>Table 4-4</Link>
 lists all possible code-group corruptions that can be caused by a single-bit error. The notation /X/ =&gt; /Y/ means that the code-group for the character X has been corrupted by a single-bit error into the code-group for the character Y. If the corruption results in a code-group that is invalid for the current receiver running disparity, the notation /X/ =&gt; /INVALID/ is used. The table provides the information required to deterministically detect all isolated single bit transmission errors. </P>

<Table>
<Caption>
<P>Table 4-4. Code-Group Corruption Caused by Single Bit Errors </P>
</Caption>

<TR>
<TD>Corruption </TD>

<TD>Detection </TD>
</TR>

<TR>
<TD>/SC/ =&gt; /INVALID/ </TD>

<TD>Detectable as an error when decoding the code-group. When this error occurs within a packet, it is indistinguishable from a /Dx.y/ =&gt; /INVALID/. When this error occurs outside of a packet, the type of error can be inferred from whether the /INVALID/ is followed by the three /Dx.y/ that comprise the control symbol data. </TD>
</TR>

<TR>
<TD>/PD/ =&gt; /INVALID/ </TD>

<TD>Detectable as an error when decoding the code-group. When this error occurs within a packet, it is indistinguishable from a /Dx.y/ =&gt; /INVALID/. When this error occurs outside of a packet, the type of error can be inferred from whether the /INVALID/ is followed by the three /Dx.y/ that comprise the control symbol data. </TD>
</TR>

<TR>
<TD>/A/, /K/ or /R/ =&gt; /Dx.y/ </TD>

<TD>Detectable as an error as /Dx.y/ is illegal outside of a packet or control symbol and /A/, /K/ and /R/ are illegal within a packet or control symbol. </TD>
</TR>

<TR>
<TD>/A/, /K/ or /R/ =&gt; /INVALID/ </TD>

<TD>Detectable as an error when decoding the code-group. </TD>
</TR>

<TR>
<TD>/Dx.y/ =&gt; /A/, /K/ or /R/ </TD>

<TD>Detectable as an error as /A/, /K/ and /R/ are illegal within a packet or control symbol and /Dx.y/ is illegal outside of a packet or control symbol. </TD>
</TR>

<TR>
<TD>/Dx.y/ =&gt; /INVALID/ </TD>

<TD>Detectable as an error when decoding the code-group. </TD>
</TR>

<TR>
<TD>/Dx.y/ =&gt; /Du.v/ </TD>

<TD>Detectable as an error by the packet or control symbol CRC. The error will also result in a subsequent unerrored code-group being decoded as INVALID, but that resulting INVALID code-group may occur an arbitrary number of code-groups after the errored code-group. </TD>
</TR>
</Table>

<P id="LinkTarget_30778">4.5.9 Idle Sequence </P>

<P>The idle sequence is a sequence of code-groups that shall be transmitted continuously over each lane of an LP-Serial link whenever packets or control symbols are not being transmitted. An idle sequence may not be inserted in a packet or delimited control symbol. The idle sequence is transmitted over each lane as part of the port initialization process as required in 
<Link>Section 4.7.3.5 and Section 4.7.3.6. </Link>
An idle sequence containing a special clock compensation sequence shall be transmitted at least once every 5000 code-groups even when there are packets or </P>

<P>RapidIO Trade Association </P>

<P>control symbols available to transmit to allow clock rate compensation. </P>

<P>The 1x idle sequence consists of a sequence of the code-groups /K/, /A/, and /R/ (the idle code-groups) and shall be used by ports in operating is 1x mode. The 4x idle sequence consists of a sequence of the columns ||K||, ||A||, ||R|| (the idle columns) and shall be used by ports operating in 4x mode. Both sequences shall comply with the following requirements: </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> The first code-group (column) of an idle sequence generated by a port operating in 1x mode (4x mode) shall be a /K/ (||K||). The first code-group (column) shall be transmitted immediately following the last code-group (column) of a packet or delimited control symbol. </LI_Title>
</LI>

<LI>
<LI_Label>2.</LI_Label>

<LI_Title> At least once every 5000 code-groups (columns) transmitted by a port operating in 1x mode (4x mode), an idle sequence containing the /K/R/R/R/ code-group sequence (||K||R||R||R|| column sequence) shall be transmitted by the port. This sequence is referred to as the “compensation sequence”. </LI_Title>
</LI>

<LI>
<LI_Label>3. </LI_Label>

<LI_Title>When not transmitting the compensation sequence, all code-groups (columns) following the first code-group (column) of an idle sequence generated by a port operating in 1x mode (4x mode) shall be a pseudo-randomly selected sequence of /A/, /K/, and /R/ (||A||, ||K||, and ||R||) based on a pseudo-random sequence generator of 7th order or greater and subject to the minimum and maximum /A/ (||A||) spacing requirements. </LI_Title>
</LI>

<LI>
<LI_Label>4. </LI_Label>

<LI_Title>The number of non /A/ code-groups (non ||A|| columns) between /A/ code-groups (||A|| columns) in the idle sequence of a port operating in 1x mode (4x mode) shall be no less than 16 and no more than 32. The number shall be pseudo-randomly selected, uniformly distributed across the range and based on a pseudo-random sequence generator of 7th order or greater. </LI_Title>
</LI>
</L>

<P>There are no requirements on the length of an idle sequence. An idle sequence may be of any length. </P>

<P>The idle sequence is transmitted on each lane of a link when neither packets nor delimited control symbols are being transmitted to allow each lane receiver to maintain bit and 10-bit code-group boundary synchronization. </P>

<P>The pseudo-random selection of code-groups in the idle sequence results in an idle sequence whose spectrum has no discrete lines which minimizes the EMI of long idle sequences. </P>

<P>The compensation sequence allows retiming repeaters (discussed in 
<Link>Section 4.6</Link>
) to compensate for up to a +/- 200 ppm difference between input bit rate and output bit rate, each of which have a +/-100 ppm tolerance. It may also be used to allow the input side of a port to compensate for up to a +/-200 ppm difference between the input bit rate and the bit rate of the device core which may be running off a different clock. This is done by dropping or adding an /R/ or ||R|| as needed to avoid overrun/underrun. Since a packet or delimited control symbol may not be interrupted by an idle sequence, designers must be careful to guarantee that no more </P>

<P>RapidIO Trade Association </P>

<P>than 5000 code-groups are transmitted between compensation sequences. </P>

<P id="LinkTarget_30779">4.5.9.1  Idle Sequence Generation </P>

<P>A primitive 7th order polynomial is recommended as the generating polynomial for the pseudo-random sequence that is used in the generation of the idle sequence. The polynomials x7 + x6 + 1 and x7 + x3 + 1 are examples of primitive 7th order polynomials which could be used as generator polynomials. The pseudo-random sequence generator is clocked (generates a new pseudo-random sequence value) once per idle sequence code-group (column). Four of the pseudo-random sequence generator state bits may be selected as the pseudo-random value for /A/ (||A||) spacing and any other state bit or logical function of state bits may be selected as the /K/ vs. /R/ selector. </P>

<P>
<Link>Figure 4-4 shows an example circuit illustrating how this may be done. The clock </Link>
ticks whenever a code-group or column is transmitted. Send_idle is asserted whenever an idle sequence begins. The equations indicate the states in which to transmit the indicated idle code-group, except when the compensation sequence is being transmitted. Any equivalent method is acceptable. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_124.jpg"/>
1 DDD D D QQQQQLOAD pseudo_random_integer_generator down_counter lsbmsb Acntr_eq_zero QQQQQQQ clock pseudo_random_bit DQ send_idle send_idle_dlyd send_idle </Figure>

<P>send_K = send_idle &amp; (!send_idle_dlyd | send_idle_dlyd &amp; !Acntr_eq_zero &amp; pseudo_random_bit) send_A = send_idle &amp; send_idle_dlyd &amp; Acntr_eq_zero send_R = send_idle &amp; send_idle_dlyd &amp; !Acntr_eq_zero &amp; !pseudo_random_bit </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30780">4.5.10 1x Link Transmission Rules </P>

<P>A 1x LP-Serial link has a single lane (differential pair) in each direction. A 1x LP-Serial port shall be encoded and transmit the character stream of delimited control symbols and packets received from the upper layers over the differential pair in the order the characters were received from the upper layers. When neither control symbols nor packets are available from the upper layers for transmission, the 1x idle sequence shall be fed to the input of the encoder for encoding and transmission. On reception, the code-group stream is decoded and passed to the upper layers. </P>

<P>When a 4x port is operating in 1x mode, the character stream from the upper layers is not striped across the lanes before encoding as is done when operating in 4x mode. The entire character stream from the upper layers is fed in parallel to both lanes 0 and 2. A 4x LP-Serial port operating in 1x mode shall encoded and transmit the character stream of delimited control symbols and packets received from the upper layers over both lane 0 and lane 2, with the following exception. A 4x port operating in 1x mode may elect to disable the output driver of the lane which was not selected by the initialization state machine. It is recommended that the mechanism for disabling the output driver be under software control. </P>

<P>When neither delimited control symbols nor packets are available from the upper layers for transmission, the 1x idle sequence shall be fed in parallel to the input of the lane 0 and lane 2 encoders for encoding and transmission on lanes 0 and 2. On reception, the code-group stream from either lane 0 or 2 is selected according to the 
<Link>state of the 1x/4x_Initialization state machine (Section 4.7.3.6, “1x/4x Mode </Link>

<Link>Initialization State Machine), decoded and passed to the upper layers. </Link>
</P>

<P>
<Link>Figure 4-5 shows the encoding and transmission order for a control symbol </Link>
transmitted over a 1x LP-Serial link. </P>

<P>1st byte[0-7] 2nd byte[0-7] 3rd byte[0-7] </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_125.jpg"/>
1st byte 2nd byte 3rd byte 1st /Dx.y/ 2nd /Dx.y/ 3rd /Dx.y//SC/ or /PD/ bit and code-group transmission order 8b/10b CRC cmd param 1 Unencoded Encoded 8b/10b 8b/10b param 0 stype0 stype1 Delimiter 8b/10b </Figure>

<P>RapidIO Trade Association </P>

<P>
<Link>Figure 4-6 shows the encoding and transmission order for a packet transmitted over </Link>
a 1x LP-Serial link. </P>

<P>1st byte[0-7] 2nd byte[0-7] 3rd byte[0-7] </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_126.jpg"/>
ackID 0 0 0 prio ttUnencoded </Figure>

<P>1st byte </P>

<P>2nd byte </P>

<P>3rd byte </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_127.jpg"/>
</Figure>

<P>8b/10b </P>

<P>8b/10b </P>

<P>8b/10b </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_128.jpg"/>
</Figure>

<P>1st /Dx.y/ </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_129.jpg"/>
</Figure>
2nd /Dx.y/ </P>

<P>3rd /Dx.y/ </P>

<P>Encoded </P>

<P>bit and code-group transmission order </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_130.jpg"/>
</Figure>

<P>Figure 4-6. 1x Mode Packet Encoding and Transmission Order </P>

<P>RapidIO Trade Association </P>

<P>
<Link>Figure 4-7 shows an example of control symbol, packet, and idle sequence </Link>
transmission on a 1x LP-Serial link. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_131.jpg"/>
</Figure>

<Table>
<TR>
<TD>/SC/ </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Cdata-0 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Cdata-1 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Cdata-2 </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Control </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Symbol </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>(start-pkt) </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>Data-0 </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Data-1 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Data-2 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Data-3 </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>Data-4 </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Data-5 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Data-6 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Data-7 </TD>

<TD>char-3 </TD>
</TR>
</Table>

<Table>
<TR>
<TD>/PD/ </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Control </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Symbol </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>(start pkt) </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>Data-0 </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Data-1 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Data-2 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Data-3 </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>Data-4 </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Data-5 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Data-6 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Data-7 </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>Data-8 </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Data-9 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Data-10 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Data-11 </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>/SC/ </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Cdata-0 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Cdata-1 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Cdata-2 </TD>

<TD>char-3 </TD>
</TR>
</Table>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_132.jpg"/>
/PD/ char-0 Data-8 char-0 Control char-1 Data-9 char-1 Symbol char-2 Data-10 char-2 (end pkt) char-3 Data-11 char-3 /PD/ char-0 /SC/ char-0 Control char-1 Cdata-0 char-1 Symbol char-2 Cdata-1 char-2 (start pkt) char-3 Cdata-2 char-3 Data-0 char-0 Data-12 char-0 Data-1 char-1 Data-13 char-1 Data-2 char-2 Data-14 char-2 Data-3 char-3 Data-15 char-3 Data-4 char-0 /PD/ char-0 Data-5 char-1 Restart char-1 Data-6 char-2 from char-2 Data-7 char-3 Retry char-3 /SC/ char-0 /PD/ char-0 Cdata-0 char-1 Control char-1 Cdata-1 char-2 Symbol char-2 Cdata-2 char-3 (start pkt) char-3 </Figure>

<Table>
<TR>
<TD>/SC/ </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Cdata-0 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Cdata-1 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Cdata-2 </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>Data-0 </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Data-1 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Data-2 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Data-3 </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>Data-4 </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Data-5 </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Data-6 </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>Data-7 </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>Control </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>Symbol </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>(end pkt) </TD>

<TD>char-3 </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>char-0 </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>char-1 </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>char-2 </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>char-3 </TD>
</TR>
</Table>

<P>Time </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_133.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_134.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_135.jpg"/>
</Figure>

<P>Figure 4-7. 1x Typical Data Flow </P>

<P id="LinkTarget_30781">4.5.11  4x Link Striping and Transmission Rules </P>

<P>A LP-Serial port operating in 4x mode shall stripe the character stream of delimited control symbols and packets that it receives from the upper layers across the four lanes before 8B/10B encoding as follows: </P>

<P>Packets and delimited control symbols shall be striped across the four lanes beginning with lane 0. The first character of each packet, or delimited control symbol, is placed in lane 0, the second character is placed in lane1, the third character is placed in lane 2, and the fourth character is placed in lane 3. The fifth character and subsequent characters wrap around and continue beginning in lane </P>

<P>0. </P>

<P>As a result of their defined lengths, delimited control symbols will form a column after striping and a packet will form an integer number of contiguous columns. </P>

<P>RapidIO Trade Association </P>

<P>After striping, each of the 4 streams of characters shall be independently 8B/10B encoded and transmitted. </P>

<P>When neither delimited control symbols nor packets are available from the upper layers for transmission, the 4x idle sequence shall be transmitted. This can be achieved by feeding the 1x idle sequence in parallel to the inputs of the encoders for all four lanes for encoding and transmission on the four lanes. Feeding the 1x idle sequence in parallel to the input of all four lane encoders converts each 1x idle sequence character in to a 4x idle sequence column. The 1x sequence is not striped across the four lanes. </P>

<P>On reception, each lane shall be 8B/10B decoded. After decoding, the four lanes shall be aligned. The ||A|| columns transmitted as part of the 4x idle sequence provide the information needed to perform alignment. After alignment, the columns are destriped into a single character stream and passed to the upper layers. </P>

<P>The lane alignment process eliminates the skew between lanes so that after destriping, the ordering of characters in the received character stream is the same as the ordering of characters before striping and transmission. Since the minimum number of non ||A|| columns between ||A|| columns is 16, the maximum lane skew that can be unambiguously corrected is the time it takes for to transmit 7 code-groups on a lane. </P>

<P>RapidIO Trade Association </P>

<P>
<Link>Figure 4-8 shows an example of idle sequence, packet, and delimited control symbol </Link>
transmission on a 4x link. </P>

<P>Time </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_136.jpg"/>
</Figure>

<Table>
<TR>
<TD>Lane-0 </TD>

<TD>Lane-1 </TD>

<TD>Lane-2 </TD>

<TD>Lane-3 </TD>
</TR>

<TR>
<TD>/SC/ </TD>

<TD>Cdata-0 </TD>

<TD>Cdata-1 </TD>

<TD>Cdata-2 </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>/I/ </TD>

<TD>/I/ </TD>

<TD>/I/ </TD>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>Control Symbol (Start-of-packet) </TD>
</TR>

<TR>
<TD>Data-0 </TD>

<TD>Data-1 </TD>

<TD>Data-2 </TD>

<TD>Data-3 </TD>
</TR>

<TR>
<TD>Data-4 </TD>

<TD>Data-5 </TD>

<TD>Data-6 </TD>

<TD>Data-7 </TD>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>Control Symbol (Start-of-packet) </TD>
</TR>

<TR>
<TD>Data-0 </TD>

<TD>Data-1 </TD>

<TD>Data-2 </TD>

<TD>Data-3 </TD>
</TR>

<TR>
<TD>Data-4 </TD>

<TD>Data-5 </TD>

<TD>Data-6 </TD>

<TD>Data-7 </TD>
</TR>

<TR>
<TD>Data-8 </TD>

<TD>Data-9 </TD>

<TD>Data-10 </TD>

<TD>Data-11 </TD>
</TR>

<TR>
<TD>/SC/ </TD>

<TD>Cdata-0 </TD>

<TD>Cdata-1 </TD>

<TD>Cdata-2 </TD>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>Control Symbol (End-of-packet) </TD>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>Control Symbol (Start-of-packet) </TD>
</TR>

<TR>
<TD>Data-0 </TD>

<TD>Data-1 </TD>

<TD>Data-2 </TD>

<TD>Data-3 </TD>
</TR>

<TR>
<TD>Data-4 </TD>

<TD>Data-5 </TD>

<TD>Data-6 </TD>

<TD>Data-7 </TD>
</TR>

<TR>
<TD>/SC/ </TD>

<TD>Cdata-0 </TD>

<TD>Cdata-1 </TD>

<TD>Cdata-2 </TD>
</TR>

<TR>
<TD>Data-8 </TD>

<TD>Data-9 </TD>

<TD>Data-10 </TD>

<TD>Data-11 </TD>
</TR>

<TR>
<TD>/SC/ </TD>

<TD>Cdata-0 </TD>

<TD>Cdata-1 </TD>

<TD>Cdata-2 </TD>
</TR>

<TR>
<TD>Data-12 </TD>

<TD>Data-13 </TD>

<TD>Data-14 </TD>

<TD>Data-15 </TD>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>Control Symbol (Restart-from-retry) </TD>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>Control Symbol (Start-of-packet) </TD>
</TR>

<TR>
<TD>/SC/ </TD>

<TD>Cdata-0 </TD>

<TD>Cdata-1 </TD>

<TD>Cdata-2 </TD>
</TR>

<TR>
<TD>Data-0 </TD>

<TD>Data-1 </TD>

<TD>Data-2 </TD>

<TD>Data-3 </TD>
</TR>

<TR>
<TD>Data-4 </TD>

<TD>Data-5 </TD>

<TD>Data-6 </TD>

<TD>Data-7 </TD>
</TR>

<TR>
<TD>/PD/ </TD>

<TD>Control Symbol (End-of-packet) </TD>
</TR>

<TR>
<TD>/I/ </TD>

<TD>/I/ </TD>

<TD>/I/ </TD>

<TD>/I/ </TD>
</TR>
</Table>

<P>Figure 4-8. Typical 4x Data Flow </P>

<P id="LinkTarget_30782">4.6 Retimers and Repeaters </P>

<P>The LP-Serial Specification allows “retimers” and “repeaters”. Retimers amplify a weakened signal, but do not transfer jitter to the next segment. Repeaters also amplify a weakened signal, but transfer jitter to the next segment. Retimers allow greater distances between end points at the cost of additional latency. Repeaters support less distance between end points than retimers and only add a small amount of latency. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30783">4.6.1 Retimers </P>

<P>A retimer shall comply with all AC specifications found in 
<Link>Chapter 8, “Electrical </Link>

<Link>Specifications”. This includes resetting the jitter budget thus extending the </Link>
transmission distance for the link. The retimer repeats the received code-groups after performing code-group synchronization and serializes the bitstream again on transmission, based on a local clock reference. Up to two retimers are allowed between two end nodes. </P>

<P>A retimer is not RapidIO protocol-aware or addressable in any way. The only awareness a retimer has is to the synchronization on the /K/ code-group and the function of /R/ insertion and removal. A retimer may insert up to one /R/ code-group immediately following a /K/ code-group sequence, or remove one /R/ code-group that immediately follows a /K/ code-group sequence. Note that the /R/ code-group is disparity neutral and therefore its insertion or deletion does not affect the running disparity. </P>

<P>A 4-lane retimer must perform lane synchronization and deskew, in exactly the same way a RapidIO device implementing this physical layer does when synchronizing inputs during initialization and startup. A 4-lane retimer will synchronize and align all lanes that are driven to it. Therefore, such a retimer allows for the degradation of an input 4x link to a 1x link on either lane 0 or 2. If any link drops out, the retimer must merely continue to pass the active links, monitoring for the compensation sequence and otherwise passing through whatever code-groups appear on its inputs. A retimer may optionally not drive any outputs whose corresponding inputs are not active. </P>

<P>Any insertion or removal of a /R/ code-groups in a 4-lane retimer must be done on a full column. A retimer may retime links operating at the same width only (i.e. cannot connect a link operating at 1x to a link operating at 4x). A retimer may connect a 1x link to a 4x link that is operating at 1x. Retimers perform clock tolerance compensation between the receive and transmit clock. The transmit clock is usually derived from a local reference. </P>

<P>Retimers do not check for code violations. Code-groups received on one port are transmitted on the other regardless of code violations or running disparity errors. </P>

<P id="LinkTarget_30784">4.6.2 Repeaters </P>

<P>A repeater is used to amplify the signal, but does not retime the signal, and therefore can add additional jitter to the signal. It does not compensate for clock rate variation. The repeater repeats the received code-groups as the bits are received by sampling the incoming bits with a clock derived from the bit stream, and then retransmitting them based on that clock. Repeaters may be used with 4x links but lane-to-lane skew may be amplified. Repeaters do not interpret or alter the bit stream in any way. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30785">4.7 Port Initialization </P>

<P>This section specifies the port initialization process. The process includes detecting the presence of a partner at the other end of the link (a link partner), establishing bit synchronization and code-group boundary alignment and if the port is capable of supporting both 1x and 4x modes (a 1x/4x port), discovering whether the link partner is capable of 4x mode (4-lane) operation, selecting 1x or 4x mode operation and if 1x mode is selected, selecting lane 0 or lane 2 for link reception. </P>

<P>The initialization process is controlled by several state machines. The number and type of state machines depends on whether the port supports only 1x mode (a 1x port) or supports both 1x and 4x modes (a 1x/4x port). In either case, there is a primary state machine and one or more secondary state machines. The use of multiple state machines results in a simpler overall design. As might be expected, the initialization process for a 1x port is simpler than and a subset of the initialization process for a 1x/4x port. </P>

<P>The initialization process for 1x and 1x/4x ports is both described in text and specified with state machine diagrams. In the case of conflict between the text and a state machine diagram, the state machine diagram takes precedence. </P>

<P id="LinkTarget_30786">4.7.1 1x Mode Initialization </P>

<P>The initialization process for ports that support only 1x mode shall be controlled by two state machines, 1x_Initialization and Lane_Synchronization. 1x_Initialization is the primary state machine and Lane_Synchronization is the secondary state machine. The operation of these state machines is described and specified in 
<Link>Section </Link>
</P>

<P>
<Link>4.7.3.5</Link>

<Link> and Section 4.7.3.3 respectively. </Link>
</P>

<P>After a 1x port has been initialized, the port is required to receive seven error-free status control symbols without intervening detected errors to verify link operation before transmitting any packets. </P>

<P id="LinkTarget_30787">4.7.2 1x/4x Mode Initialization </P>

<P>The initialization process for ports that support both 1x and 4x modes shall be controlled by six state machines, 1x/4x_Initialization, Lane_Synchronization[0-3] (one for each of the four lanes) and Lane_Alignment. 1x/4x_Initialization is the primary state machine. Lane_Synchronization[0-3] and Lane_Alignment are the secondary state machines. The operation of these state machines is described and specified in 
<Link>Section 4.7.3.6</Link>
, 
<Link>Section 4.7.3.3</Link>

<Link> and Section 4.7.3.4 respectively. </Link>
</P>

<P>After a 4x port has been initialized, the port is required to receive seven error-free status control symbols without intervening detected errors to verify link operation before transmitting any packets. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30788">4.7.3 State Machines </P>

<P id="LinkTarget_30789">4.7.3.1  State Machine Conventions </P>

<P>A state machine state is persistent until an exit condition occurs. </P>

<P>A state machine variable that is listed in the body of a state but is not part of an assignment statement is asserted for the duration of that state only. </P>

<P>A state machine variable that is assigned a value in the body of a state retains that value until assigned a new value in another state. </P>

<P>A state machine function that is listed in the body of a state is executed once during the state. </P>

<P id="LinkTarget_30790">4.7.3.2  State Machine Variables and Functions </P>

<P>A state machine variable is asserted when its value is 1 and deasserted when it value is 0. The functions used in the state machines are defined as follows. change( ) Asserted when the variable on which it operates changes state. next_code_group( ) Gets the next 10 bit code-group for the lane when it becomes available. next_column( ) Gets the next column of 4 code-groups when it becomes available. The variables used in the state machines are defined as follows. 4x-mode Asserted when the port is operating in 4x mode ||A|| Asserted when the current column contains all /A/s. </P>

<P>Acounter A counter used in the Lane Alignment state machine to count received alignment columns (||A||s). </P>

<P>align_error Asserted when the current column contains at least one /A/, but not all /A/s. all_lane_sync Asserted when all four lanes of a 4x mode receiver are in bit synchronization and </P>

<P>RapidIO Trade Association </P>

<P>61 </P>

<P>code-group boundary alignment. (all_lane_sync = lane_sync[0] &amp; lane_sync[1] &amp; lane_sync[2] &amp; lane_sync[3]) </P>

<P>discovery_timer_done Asserted when discovery_timer_en has been continuously asserted for 12 +/- 4 msec and the state machine is in the DISCOVERY state. The assertion of discovery_timer_done causes discovery_timer_en to be deasserted. When the state machine is not in the DISCOVERY state, discovery_timer_done is deasserted. </P>

<P>discovery_timer_en When asserted, the discovery_timer runs. When deasserted, the discovery_timer is reset to and maintains its initial value. force_1x_mode When asserted, forces the 1x/4x Initialization state machine to use 1x mode. force_lane2 When asserted in 1x mode, forces the 1x/4x Initialization state machine to use lane 2 for reception. force_reinit When asserted, forces a 1x or 1x/4x Initialization state machine to reinitialize. The signal is set under software control and is cleared by the Initialization state machine. Icounter Counter used in the Lane_Synchronization state machine to count INVALID received code-groups. There is one Icounter for each lane in a 4x mode receiver. /K28.5/ Asserted when the current code-group is /K28.5/ Kcounter Counter used in the Lane_Synchronization state machine to count received /K.28.5/ code-groups. There is one Kcounter for each lane in a 4x mode receiver. lane02_drvr_oe The output enable for the lane 0 and the lane 2 output drivers of a 1x/4x mode port. lane13_drvr_oe The output enable for the lane 1 and the lane 3output drivers of a 1x/4x mode port. lanes_aligned Asserted by the Lane_Alignment state machine when it determines that all four </P>

<P>RapidIO Trade Association </P>

<P>lanes are in sync and aligned. </P>

<P>lane_sync </P>

<P>Asserted by the Lane_Synchronization state machine when it determines that the lane it is monitoring is in bit synchronization and code-group boundary alignment. The is a lane_sync signal for each lane in a 4x mode receiver. </P>

<P>link_drvr_oe </P>

<P>When asserted, the output link driver of a 1x port is enabled. </P>

<P>Mcounter </P>

<P>Mcounter is used in the Lane_Alignment state machine to count columns received that contain at least one /A/, but not all /A/s. </P>

<P>Vcounter </P>

<P>Vcounter is used in the Lane_Synchronization state machine to count VALID received code-groups. There is one Vcounter for each lane in a 4x mode receiver. </P>

<P>port_initialized </P>

<P>When asserted, port_initialized indicates that the link is initialized and is available for transmitting control symbols and packets. When deasserted, the link is not initialized and is not available for transmitting control symbols and packets. </P>

<P>receive_lane2 </P>

<P>In a 1x/4x capable port that is initialized and is operating in 1x mode (4x_mode deasserted), receive_lane2 indicates which lane the port has selected for input. When asserted, the port input is from lane 2. When deasserted the port input is from lane 0. When the port is operating in 4x mode (4x_mode asserted), receive_lane2 is undefined and shall be ignored. </P>

<P>signal_detect </P>

<P>Asserted when a lane receiver is enabled and a signal meeting an implementation defined criteria is present at the input of the receiver. The use of signal_detect is implementation dependent. It may be continuously asserted or it may be used to require that some implementation defined additional condition be met before the Lane_Synchronization state machine is allowed to exit the NO_SYNC state. Signal_detect might for example be used to ensure that the input signal to a lane receiver meet some minimum AC input power requirement so that the receiver can not lock up on crosstalk from an output of the same port. </P>

<P>silence_timer_done </P>

<P>Asserted when silence_timer_en has been continuously asserted for 120 +/- 40 µs and the state machine is in the SILENT state. The assertion of silence_timer_done causes silence_timer_en to be deasserted. When the state machine is not in the SILENT state, silence_timer_done is deasserted. </P>

<P>RapidIO Trade Association </P>

<P>63 </P>

<P>silence_timer_en </P>

<P>When asserted, the silence_timer runs. When deasserted, the silence_timer is reset to and maintains its initial value. </P>

<P>/VALID/ </P>

<P>When asserted, /VALID/ indicates that the current code-group is a valid code-group given the current running disparity. </P>

<P>/INVALID/ </P>

<P>When asserted, /INVALID/ indicates that the current code-group is an invalid code-group given the current running disparity. </P>

<P id="LinkTarget_30791">4.7.3.3  Lane Synchronization State Machine </P>

<P>The Lane_Synchronization state machine monitors the bit synchronization and code-group boundary alignment for a lane receiver. A port that supports only 1x mode has one Lane_Synchronization state machine. A port that supports both 1x and 4x modes has four Lane_Synchronization state machines, one for each lane (Lane_Synchronization[0] through Lane_Synchronization[3]). </P>

<P>The state machine determines the bit synchronization and code-group boundary alignment state of a lane receiver by monitoring the received code-groups and looking for /K28.5/s, other valid code-groups and invalid code-groups. The code-group /K28.5/ contains the “comma” bit sequence that is used to establish code-group boundary alignment. When a lane is error free, the “comma” pattern occurs only in the /K28.5/ code-group. Several counters are used to provide hysteresis so that occasional bit errors do not cause spurious lane_sync state changes. </P>

<P>The state machine does not specify how bit synchronization and code-group boundary alignment is to be achieved. The methods used by a lane receiver to achieve bit synchronization and code-group boundary alignment are implementation dependent. However, isolated single bit errors shall not cause the code-group boundary alignment mechanism to change alignment. For example, a isolated single bit error that results in a “comma” pattern across a code-group boundary may not cause the code-group boundary alignment mechanism to change alignment. </P>

<P>The state machine starts in the NO_SYNC state and sets the variables Kcounter[0] and lane_sync[n] to 0 (lane n is out of code-group boundary sync). It then looks for a /K28.5/ code-group. When it finds one and the signal signal_detect[n] is asserted, the machine moves to the NO_SYNC_1 state. </P>

<P>The NO_SYNC_1 state in combination with the NO_SYNC_2 state looks for 127 /K28.5/ code-groups without any intervening /INVALID/ code-groups. When this condition is achieved, machine goes to state SYNC. If an intervening /INVALID/ code-group is detected, the machine goes back to the NO_SYNC state. The number </P>

<P>RapidIO Trade Association </P>

<P>127 was selected because it is large enough that it would be highly unlikely that SYNC would be falsely achieved and also because it fits in a 7-bit counter. Since the /K28.5/ code-group comprises slightly less than half of the code-groups in the idle sequence, something more than 256 code-groups must be received after the first /K28.5/ to achieve the 128 /K28.5/ code-group criteria to transition to the SYNC state. </P>

<P>In the SYNC state, the machine sets the variable lane_sync[n] to 1 (lane n is in code-group boundary sync), set the variable Icounter[n] to 0 and begins looking for /INVALID/ code-groups. If an /INVALID/ code-group is detected, the machine goes to state SYNC_1. </P>

<P>The SYNC_1 state in combination with the SYNC_2, SYNC_3, and SYNC_4 states looks for 255 consecutive /VALID/ code-groups without any /INVALID/ code-groups. When 255 /VALID/ symbols are received, the Icounter[n] value is decremented in the transition through the SYNC_4 state. If it does not, it increments Icounter[n]. If Icounter[n] is decremented back to 0, the machine returns to the SYNC state. If Icounter[n] is incremented to 3, the machine goes to the NO_SYNC state and starts over. This algorithm tolerates isolated single bit errors in that an isolated single bit error will not cause the machine to change the variable lane_sync[n] from 1 to 0 (in sync to out of sync). Three errors (sometimes two errors when one of them causes a disparity error on the following code group) within 256 code-groups will result in an out-of-sync indication. </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_137.jpg"/>
NO_SYNC lane_sync[n] = 0 Kcounter[n] = 0 next_code_group() NO_SYNC_1 Kcounter[n] = Kcounter[n] + 1 NO_SYNC_2 next_code_group( ) SYNC lane_sync[n] = 1 Icounter[n] = 0 next_code_group( ) Icounter[n] = Icounter[n] + 1 Vcounter[n] = 0 Vcounter[n] = Vcounter[n] + 1 Icounter[n] = Icounter[n] - 1 Vcounter[n] = 0 SYNC_2 next_code_group( ) SYNC_1 SYNC_3 SYNC_4 reset | change(signal_detect) signal_detect[n] &amp; /K28.5/ !signal_detect[n] | !/K28.5/ Kcounter[n] = 127 Kcounter[n] &lt; 127 !(/K28.5/ | /INVALID/) /K28.5/ /INVALID/ /INVALID/ /VALID/ Icounter[n] = 3 Vcounter[n] = 255 /INVALID/ /VALID/ Icounter[n] &gt; 0 Icounter[n] &lt; 3 Icounter[n] = 0 Vcounter[n] &lt; 255 </Figure>

<P>Figure 4-9. Lane_Synchronization State </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30792">4.7.3.4 Lane Alignment State Machine </P>

<P>The Lane_Alignment state machine monitors the alignment of the output of the four lane receivers in a port operating in 4x mode. A port supporting 4x mode has one Lane_alignment state machine, a port supporting only 1x mode does not have a Lane_Alignment state machine. (Lane alignment is required in a 4x port receiver to compensate for unequal propagation delays through the four lanes.) </P>

<P>The state machine determines the alignment state by monitoring the fours lanes for columns containing all /A/s (||A||), columns containing at least one but not all /A/s and columns containing no /A/s. Several counters are used to provide hysteresis so that occasional bit errors do not cause spurious lanes_aligned state changes. </P>

<P>The state machine does not specify how lane alignment is to be achieved. The methods used by a 4x port receiver to achieve lane alignment are implementation dependent. However, isolated single bit errors shall not cause the lane alignment mechanism to change lane alignment. For example, a isolated single bit error that results in a column that contains at least one /A/ but not all /A/s may not cause the lane alignment mechanism to change the lane alignment. </P>

<P>The state machine starts in the NOT_ALIGNED state where the variables Acounter and lanes_aligned are set to 0 (all lanes are not aligned). The machine then waits for all (four) lanes to achieve code-group boundary alignment (all_lanes_sync asserted) and the reception of an ||A|| (a column of all /A/s). When this obtains, the machine goes to NOT_ALIGNED_1 state. </P>

<P>The NOT_ALIGNED_1 state in combination with the NOT_ALIGNED_2 state looks for the reception of four ||A||s without the intervening reception of a misaligned column (a column with at least one /A/ but not all /A/s which causes the signal align_error to be asserted). When this obtains, the machine goes to the ALIGNED state. If an intervening misaligned column is received, the machine goes back to the NOT_ALIGNED state. </P>

<P>In the ALIGNED state, the machine sets the variable lanes_aligned to 1 (all lanes are aligned) and the variable Mcounter to 0 and looks for a misaligned column (align_error asserted). If a misaligned column is detected, the machine goes to the ALIGNED_1 state. </P>

<P>The ALIGNED_1 state in combination with the ALIGNED_2 and ALIGNED_3 states look for the reception of four ||A||s without the intervening reception of a misaligned column. If this condition obtains, the machine returns to the ALIGNED state. If an intervening misaligned column occurs, the machine goes to the NOT_ALIGNED state and starts over. This algorithm tolerates isolated single bit errors in that an isolated single bit error will not cause the machine to change the variable lanes_aligned from 1 to 0 (in lane alignment to out of lane alignment). The 
<Link>Lane_Alignment state machine is specified in Figure 4-10. </Link>
</P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_138.jpg"/>
lanes_aligned = 0 Acounter = 0 next_colunm( ) NOT_ALIGNED Acounter = Acounter + 1 NOT_ALIGNED_1 next_column( ) NOT_ALIGNED_2 lanes_aligned = 1 Mcounter = 0 ALIGNED Acounter = 0 Mcounter = Mcounter +1 ALIGNED_1 next_column( ) ALIGNED_2 Acounter = Acounter+1 ALIGNED_3 reset | change(all_lane_sync) !(all_lane_sync &amp; ||A||) !align_error &amp; !||A|| all_lane_sync &amp; ||A|| Acounter = 4 Acounter &lt; 4 ||A|| align_error !align_error &amp; !||A|| align_error align_error !align_error ||A|| Mcounter = 2 Mcounter &lt; 2 Acounter = 4 Acounter &lt; 4 </Figure>

<P>Figure 4-10. Lane_Alignment State Machine </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30793">4.7.3.5 1x Mode Initialization State Machine </P>

<P>The 1x_Initialization state machine shall be used by ports that support only 1x mode (1x ports). </P>

<P>The machine starts in the SILENT state. The link output driver is disabled to force the link partner to initialize regardless of its current state. The duration of the SILENT state is controlled by the silence_timer. The duration must be long enough to ensure that the link partner detects the silence (as a loss of lane_sync) and is forced to initialize but short enough that it is readily distinguished from a link break. When the silent interval is complete, the SEEK state is entered. </P>

<P>In the SEEK state, the link output driver is enabled, the idle sequence is transmitted, and the port waits for lane_sync to be asserted indicating the presence of a link partner. While lane_sync as defined indicates the bit and code-group boundary alignment synchronization state of the link receiver, it may also be thought of as indicating the presence of a link partner. When lane-sync is asserted, the 1X_MODE state is entered. </P>

<P>The input signal force_reinit allows the port to force link initialization at any time. </P>

<P>The variable port_initialized is asserted only in the 1X_MODE state. When port_initialized is deasserted, the port shall transmit a continuous idle sequence uninterrupted by control symbols or packets. To maintain receiver bit synchronization and code-group alignment, the port shall transmit the idle sequence when no control symbol or packet is being transmitted. </P>

<P>
<Link>The 1x_Initialization state machine is specified in Figure 4-11. </Link>
</P>

<P>RapidIO Trade Association </P>

<P>reset </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_139.jpg"/>
</Figure>

<P>SILENT </P>

<P>link_drvr_oe = 0 port_initialized = 0 force_reinit = 0 silence_timer_en = 1 </P>

<P>silence_timer_done </P>

<P>SEEK link_drvr_oe = 1 </P>

<P>lane_sync </P>

<P>1X_MODE port_initialized = 1 </P>

<P>!lane_sync | force_reinit </P>

<P>Figure 4-11. 1x_Initialization State Machine </P>

<P id="LinkTarget_30794">4.7.3.6 1x/4x Mode Initialization State Machine </P>

<P>The 1x/4x_Initialization state machine shall be used by ports that support both 1x and 4x mode (1x/4x ports). In addition to determining when the link is initialized, the state machine controls whether the port receiver operates in 1x or 4x mode and in 1x mode whether lane 0 or lane 2 is selected as the inbound lane. </P>

<P>The machine starts in SILENT state. All four lane output drivers are disabled to force the link partner to initialize regardless of its current state. The duration of the SILENT state is controlled by the silence_timer. The duration must be long enough to ensure that the link partner detects the silence (as a loss of lane_sync) and is forced to initialize but short enough that it is readily distinguished from a link break. When the silent interval is complete, the SEEK state is entered. </P>

<P>In the SEEK state, a 1x/4x port transmits the idle sequence on lanes 0 and 2 (the lane 1 and lane 3 output drivers remain disabled to save power) and waits for an indication that a link partner is present. While lane_sync as defined indicates the bit and code-group boundary alignment synchronization state of a lane receiver, it is also used to indicate the presence of a link partner. A link partner is declared to be present when either lane_sync[0] or lane_sync[2] is asserted. If force_1x_mode is not asserted, the assertion of either lane_sync[0] or lane_sync[2] causes the state machine to enter the DISCOVERY state. If force_1x_mode is asserted, the state machine enters either the 1X_MODE_LANE0 or 1X_MODE_LANE2 state depending on whether lane_sync[0] or lane_sync[2] is asserted first and whether </P>

<P>RapidIO Trade Association </P>

<P>force_lane2 is asserted. </P>

<P>In the DISCOVERY state, the port enables the output drivers for lanes 1 and 3 and transmits the idle sequence on all four lanes. The discovery_timer is also started. The discovery_timer allows time for the link partner to enter its DISCOVERY state and if the link partner is supporting 4x mode, for all four local lane receivers to acquire bit synchronization and code-group boundary alignment and for all four lanes to be aligned. </P>

<P>If lane alignment is achieved (lanes_aligned asserted) while in the DISCOVERY state, the machine enters the 4X_MODE state. It remains in this state until lane alignment or at least one lane_sync is lost (lanes_aligned deasserted) or reinitialization is forced (force_reinit is asserted). </P>

<P>At the end of the discovery period (discovery_timer_done is asserted), if lane alignment has not been achieved (lanes_aligned not asserted), the machine enters one of the 1x mode states. If code-group alignment has been achieved on lane 0 (lane_sync[0] asserted), the machine enters 1X_MODE_LANE0 and remains in that state until code-group boundary alignment is lost (lane0_sync deasserted) or reinitialization is forced (force_reinit is asserted). If code-group alignment has been achieved on lane 2 (lane_sync[2] asserted) but not on lane 0 (lane_sync[0] not asserted), the machine enters 1X_MODE_LANE2 and remains in that state until code-group boundary alignment is lost (lane_sync[2] deasserted) or reinitialization is forced (force_reinit is asserted). </P>

<P>If lane synchronization for both lane 0 and lane 2 is lost during the DISCOVERY state, it is not possible to successfully complete initialization and it is necessary to re-start the initialization process. Re-starting the initialization process is done by transitioning to the SILENT state. This results in the link partner also losing lane syncronization on both lanes 0 and 2, resulting in both ends of the link re-entering the SEEK state after the end of the respective silent periods (silence_timer_done asserted). </P>

<P>When in the 4X_MODE state, if lane alignment or at least one lane_sync is lost (lanes_aligned deasserted), the state machine transitions to either the SILENT state if both lane_sync[0] and land_sync[2] are deasserted or the DISCOVERY state if either lane_sync[0] or lane_sync[2] is asserted. This allows a 1x/4x port in the 4X_MODE state to return to 4X_MODE if lanes_aligned is deasserted due to multi-bit reception error, but also allows the port to switch to 1x mode if the connected 1x/4x port is not able to receive in 4x mode and has switched to 1x mode. </P>

<P>The input signals force_1x_mode and force_lane2 allow the state of the machine to be forced during initialization into 1x mode, and in 1x mode to be forced to receive on lane 2. The input signal force_reinit allows the port to force link initialization at any time. </P>

<P>The variable port_initialized is asserted only in the 1X_MODE_LANE0, 1X_MODE_LANE2 and 4X_MODE states. When port_initialized is deasserted, the </P>

<P>RapidIO Trade Association </P>

<P>port shall transmit a continuous idle sequence uninterrupted by control symbols or packets. To maintain receiver bit synchronization and code-group alignment, the port shall transmit the idle sequence when no control symbol or packet is being transmitted. </P>

<P>The 1x/4x_Initialization state machine is specified in 
<Link>Figure 4-12. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_140.jpg"/>
lane02_drvr_oe = 1 SEEK port_initialized = 0 4x_mode = 0 lane13_drvr_oe = 1 discovery_timer_en = 1 DISCOVERY 4X_MODE 1X_MODE_LANE0 discovery_timer_en = 0 4x_mode = 1 port_initialized = 1 lane13_drvr_oe = 0 port_initialized = 1 1X_MODE_LANE2 receive_lane2 = 1 lane13_drvr_oe = 0 port_initialized = 1 !lane0_sync &amp;!lane2_sync reset lanes_aligned discovery_timer_done &amp;!lanes_aligned &amp;!lane0_sync &amp; lane2_sync discovery_timer_done &amp;!lanes_aligned &amp; lane0_sync !lane2_sync| force_reinit !lane0_sync| force_reinit (!lanes_aligned &amp;!lane0_sync &amp;!lane2_sync) | force_reinit discovery_timer_en = 0 lane02_drvr_oe = 0 lane13_drvr_oe = 0 port_initialized = 0 4x_mode = 0 receive_lane2 = 0 force_reinit = 0 silence_timer_en = 1 SILENT silence_timer_done force_1x_mode &amp; (!lane0_sync | force_lane2) &amp; !force_1x_mode &amp; (lane0_sync | lane2_sync) force_1x_mode &amp; !force_lane2 &amp; lane0_sync lane2_sync) !lanes_aligned &amp;(lane0_sync| lane2_sync) </Figure>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30795">Chapter 5  LP-Serial Protocol </P>

<P id="LinkTarget_30796">5.1 Introduction </P>

<P>This chapter specifies the LP-serial protocol. The protocol provides the reliable delivery of packets between two RapidIO devices that are connected by an LP-Serial link. </P>

<P>Packet priority, the mapping of transaction request flows onto packet priority, buffer management, and the use of control symbols in managing the delivery of packets between two devices is explained in this chapter. </P>

<P id="LinkTarget_30797">5.2 Packet Exchange Protocol </P>

<P>This physical layer LP-Serial specification defines a protocol for devices connected by a LP-Serial link in which each packet transmitted by one device is acknowledged by control symbols transmitted by the other device. If a packet cannot be accepted for any reason, an acknowledgment control symbol indicates the reason and that the original packet and any transmitted subsequent packets must be resent. This behavior provides a flow control and error control mechanism between connected processing elements. </P>

<P>
<Link>Figure 5-1 shows an example of transporting a request and response packet pair </Link>
across an interconnect fabric with acknowledgments between the link transmitter/receiver pairs along the way. This allows flow control and error handling to be managed between each electrically connected device pair rather than between the original source and final target of the packet. An end point device shall transmit an acknowledgment control symbol for a request packet before transmitting the response packet corresponding to that request. </P>

<P>RapidIO Trade Association </P>

<P>Data </P>

<P>Initiator (Source) </P>

<P>Returned </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_141.jpg"/>
OperationIssued ByMaster RequestPacket Issued Fabric OperationCompleted forMaster AcknowledgmentControl Symbol </Figure>

<P>Response</P>

<P>Acknowledgment</P>

<P>Packet Forwarded </P>

<P>Control Symbol </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_142.jpg"/>
</Figure>

<P>Request</P>

<P>Acknowledgment</P>

<P>Packet Forwarded </P>

<P>Control Symbol </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_143.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_144.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_145.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_146.jpg"/>
</Figure>

<P>Target (Destination) </P>

<P>Acknowledgment
Control Symbol 
</P>

<P>Response
Packet Issued 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_147.jpg"/>
TargetCompletesOperation </Figure>

<P>Figure 5-1. Example Transaction with Acknowledgment </P>

<P id="LinkTarget_30798">5.3 Control Symbols </P>

<P>Control Symbols are the message elements used by ports connected by an LP-Serial link to manage all aspects of LP-Serial link operation. They are used for link maintenance, packet delimiting, packet acknowledgment, error reporting, and error recovery. </P>

<P id="LinkTarget_30799">5.3.1 Control Symbol Delimiting </P>

<P>LP-Serial control symbols are delimited for transmission by a single 8B/10B special (control) character. The control character marks the beginning of the control symbol and immediately precedes the first bit of the control symbol. The control symbol delimiting special character is added to the control symbol before the control symbol is passed to the PCS sublayer for lane striping (if applicable) and 8B/10B encoding. Since control symbol length is constant and known, control symbols do not need end delimiters. The combined delimiter and control symbol is referred to as a delimited control symbol. </P>

<P>One of two special characters is used to delimit a control symbol. If the control </P>

<P>RapidIO Trade Association </P>

<P>symbol contains a packet delimiter, the special character PD (K28.3) is used. If the control symbol does not contain a packet delimiter, the special character SC (K28.0) is used. This use of special characters provides the receiver with an “early warning” of the content of the control symbol. </P>

<P id="LinkTarget_30800">5.3.2 Control Symbol Transmission </P>

<P>After an LP-Serial port is initialized, it shall transmit the idle sequence interrupted by one status control symbol every 1024 transmitted code-groups until the port has received an error free status control symbol from the connected port. The transmission of status control symbols indicates to the connected port that the port has completed initialization. The transmission of the idle sequence is required for the connected port to complete initialization. </P>

<P>After an initialized LP-Serial port has received an error free status control symbol from the connected port, the port shall transmit the idle sequence and a minimum of 15 status control symbols and shall receive an additional 6 error free status control symbols with no intervening detected errors before entering the normal operational state. Once in the normal operational state, the port may begin the transmission of packets and other (non-status) control symbols. This group of 15 status control symbols may be sent more rapidly than the minimum rate of one every 1024 code-groups. The requirement that a total of seven status control symbols be received provides a degree of link verification before packets and other control symbols are transmitted. The requirement that at least 15 status control symbols be transmitted is to minimize the probability that the connected port will not receive 7 control symbols even if a single bit error occurs. </P>

<P>When an LP-Serial port is in the normal operational state, it shall transmit a control symbol containing the buf_status field at least once every 1024 transmitted code-groups. To comply with this requirement, the port shall transmit a status control symbol if no other control symbol containing the buf_status field is available for transmission. </P>

<P>In each of the above cases, the time required to transmit 1024 code-groups shall be computed based on the aggregate unidirectional baud rate of the link. For example, a 4x link with each lane operating at 3.125 GBaud has an aggregate unidirectional baud rate of (4*3.125 =) 12.5 GBaud. In this example, the time required to transmit 1024 code-groups is (1024*10/12.5*10^9 =) 819.2 ns. </P>

<P id="LinkTarget_30801">5.3.3 Embedded Control Symbols </P>

<P>Any control symbol that does not contain a packet delimiter may be embedded in a packet. An embedded control symbol may contain any defined encoding of stype0 and an stype1 encoding of “multicast-event” or “NOP”. Control symbols with stype1 encodings of start-of-packet, end-of-packet, stomp, restart-from-retry, or link-request cannot be embedded as they would terminate the packet. </P>

<P>RapidIO Trade Association </P>

<P>When a control symbol is embedded in a packet, the control symbol delimiting special character shall begin on a 4-character boundary of the packet. That is, the number of packet characters between the start of the first packet character and the start of the delimited control symbol shall be a non-negative integer multiple of 4. </P>

<P>The manner and degree to which control symbol embedding is used on a link impacts both link and system performance. For example, embedding multicast-event control symbols allows their propagation delay and delay variation through switch processing elements to be minimized and is highly desirable for some multicast-event applications. On the other hand, embedding all packet acknowledgment control symbols rather than combining as many of them as possible with packet delimiter control symbols reduces the link bandwidth available for packet transmission and may be undesirable. </P>

<P id="LinkTarget_30802">5.3.4 Multicast-Event Control Symbols </P>

<P>The Multicast-Event control symbol provides a mechanism through which end points are notified that some system defined event has occurred. This event can be selectively multicast through the system. Refer to 
<Link>Section 3.5.6</Link>
 for the format of the multicast-event control symbol. </P>

<P>When a switch processing element receives a Multicast-Event control symbol, the switch shall forward the Multicast-Event by issuing a Multicast-Event control symbol from each port that is designated in the port's CSR as a Multicast-Event output port. A switch port shall never forward a Multicast-Event control symbol back to the device from which it received a Multicast-Event control symbol regardless of whether the port is designated a Multicast-Event output or not. </P>

<P>It is intended that at any given time, Multicast-Event control symbols will be sourced by a single device. However, the source device can change (in case of failover, for example). In the event that two or more Multicast-Event control symbols are received by a switch processing element close enough in time that more than one is present in the switch at the same time, at least one of the Multicast-Event control symbols shall be forwarded. The others may be forwarded or discarded (device dependent). </P>

<P>The system defined event whose occurrence Multicast-Event gives notice of has no required temporal characteristics. It may occur randomly, periodically, or anything in between. For instance, Multicast-Event may be used for a heartbeat function or for a clock synchronization function in a multiprocessor system. </P>

<P>In an application such as clock synchronization in a multiprocessor system, both the propagation time of the notification through the system and the variation in propagation time from Multicast-Event to Multicast-Event are of concern. For these reasons and the need to multicast, control symbols are used to convey Multicast-Events as control symbols have the highest priority for transmission on a link and can be embedded in packets. </P>

<P>RapidIO Trade Association </P>

<P>While this specification places no limits on Multicast-Event forwarding delay or forwarding delay variation, switch functions should be designed to minimize these characteristics. In addition, switch functions shall include in their specifications the maximum value of Multicast-Event forwarding delay (the maximum value of Multicast-Event forwarding delay through the switch) and the maximum value of Multicast-Event forwarding delay variation (the maximum value of Multicast-Event forwarding delay through the switch minus the minimum value of Multicast-Event forwarding delay through the switch). </P>

<P id="LinkTarget_30803">5.4 Packets </P>

<P id="LinkTarget_30804">5.4.1 Packet Delimiting </P>

<P>LP-Serial packets are delimited for transmission by control symbols. Since packet length is variable, both start-of-packet and end-of-packet delimiters are required. The control symbol marking the end of a packet (packet termination) follows the end of the packet or the end of an embedded control symbol. </P>

<P>The following control symbols are used to delimit packets. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Start-of-packet </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> End-of-packet </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Stomp </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Restart-from-retry </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Any link-request </LI_Title>
</LI>
</L>

<P id="LinkTarget_30805">5.4.1.1 Packet Start </P>

<P>The beginning of a packet (packet start) shall be marked by a start-of-packet control symbol. </P>

<P id="LinkTarget_30806">5.4.1.2  Packet Termination </P>

<P>A packet shall be terminated in one of the following three ways: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> The end of a packet is marked with an end-of-packet control symbol. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The end of a packet is marked with a start-of-packet control symbol that also marks the beginning of a new packet. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The packet is canceled by a restart-from-retry, stomp, or any link-request control symbol </LI_Title>
</LI>
</L>

<P id="LinkTarget_30807">5.4.2 Acknowledgment Identifier </P>

<P>Each packet requires an identifier to uniquely identify its acknowledgment control symbol. This identifier, the acknowledge ID (ackID), is five bits long, allowing for a range of one to thirty two outstanding unacknowledged request or </P>

<P>RapidIO Trade Association </P>

<P>response packets between adjacent processing elements, however only up to thirty one outstanding unacknowledged packets are allowed at any one time. The first value of ackID assigned after a reset shall be 0b00000. Subsequent values of ackID shall be assigned sequentially (in increasing numerical order, wrapping back to 0 on overflow) to indicate the order of the packet transmission. The acknowledgments themselves are a number of control symbols defined in 
<Link>Chapter 3, “Control </Link>

<Link>Symbols</Link>
. </P>

<P id="LinkTarget_30808">5.4.3 Packet Priority and Transaction Request Flows </P>

<P>Each packet has a priority, and optionally a critical request flow, that is assigned by the end point processing element that is the source of (initiates) the packet. The priority is carried in the prio field of the packet and has four possible values: 0, 1, 2, or 3. Packet priority increases with the priority value with 0 being the lowest priority and 3 being the highest. Packet priority is used in RapidIO for several purposes which include transaction ordering and deadlock prevention. The critical request flow is carried in the CRF bit. It allows a flow to be designated as a critical or preferred flow with respect to other flows of the same priority. Support for critical request flows is strongly encouraged. </P>

<P>When a transaction is encapsulated in a packet for transmission, the transaction request flow indicator (flowID) of the transaction is mapped into the prio field (and optionally the CRF bit) of the packet. If the CRF bit is not supported, transaction request flows A and B are mapped to priorities 0 and 1 respectively and transaction request flows C and above are mapped to priority 2 as specified in 
<Link>Table 5-1. </Link>
</P>

<Table>
<Caption>
<P>Table 5-1. Transaction Request Flow to Priority Mapping </P>
</Caption>

<TR>
<TH>Flow </TH>

<TH>System Priority </TH>

<TH>Request Packet Priority </TH>

<TH>Response Packet Priority </TH>
</TR>

<TR>
<TD>C or higher </TD>

<TD>Highest </TD>

<TD>2 </TD>

<TD>3 </TD>
</TR>

<TR>
<TD>B </TD>

<TD>Next </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>A </TD>

<TD>Lowest </TD>

<TD>0 </TD>

<TD>1, 2, or 3 </TD>
</TR>
</Table>

<P>If the CRF bit is supported, the transaction request flows are mapped similarly as specified in 
<Link>Table 5-2. Devices that do not support the CRF bit treat it as reserved, </Link>
setting it to logic 0 on transmit and ignoring it on receive. </P>

<P>Table 5-2. Transaction Request Flow to Priority and Critical Request Flow Mapping </P>

<Table>
<TR>
<TH>Flow </TH>

<TH>System Priority </TH>

<TH>CRF Bit Setting </TH>

<TH>Request Packet Priority </TH>

<TH>Response Packet Priority </TH>
</TR>

<TR>
<TD>F or higher </TD>

<TD>Highest </TD>

<TD>1 </TD>

<TD>2 </TD>

<TD>3 </TD>
</TR>

<TR>
<TD>E </TD>

<TD>Higher than A, B, C, D </TD>

<TD>0 </TD>

<TD>2 </TD>

<TD>3 </TD>
</TR>

<TR>
<TD>D </TD>

<TD>Higher than A, B, C </TD>

<TD>1 </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>C </TD>

<TD>Higher than A, B </TD>

<TD>0 </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Flow </TH>

<TH>System Priority </TH>

<TH>CRF Bit Setting </TH>

<TH>Request Packet Priority </TH>

<TH>Response Packet Priority </TH>
</TR>

<TR>
<TD>B </TD>

<TD>Higher than A </TD>

<TD>1 </TD>

<TD>0 </TD>

<TD>1, 2, or 3 </TD>
</TR>

<TR>
<TD>A </TD>

<TD>Lowest </TD>

<TD>0 </TD>

<TD>0 </TD>

<TD>1, 2, or 3 </TD>
</TR>
</Table>

<P>The mapping of transaction request flows allows a RapidIO transport fabric to maintain transaction request flow ordering without the fabric having any knowledge of transaction types or their interdependencies. This allows a RapidIO fabric to be forward compatible as the types and functions of transactions evolve. A fabric can maintain transaction request flow ordering by simply maintaining the order of packets with the same priority and critical request flow for each path through the fabric and can maintain transaction request flow priority by never allowing a lower priority packet to pass a higher priority packet taking the same path through the fabric. In the case of congestion or some other restriction, a set CRF bit indicates that a flow of a priority can pass a flow of the same priority without the CRF bit set. </P>

<P id="LinkTarget_30809">5.5 Link Maintenance Protocol </P>

<P>The link maintenance protocol involves a request and response pair between ports connected by an LP-Serial link. For software management, the request is generated through ports in the configuration space of the sending device. An external host write of a command to the link-request register with an I/O logical specification maintenance write transaction causes a link-request control symbol to be issued onto the output port of the device, but only one link-request can be outstanding on a link at a time. </P>

<P>The device that is linked to the sending device shall respond with an link-response control symbol if the link-request command required it to do so. The external host retrieves the link-response by polling the link-response register with I/O logical maintenance read transactions. A device with multiple RapidIO interfaces has a link-request and a link-response register pair for each corresponding RapidIO interface. </P>

<P>The automatic error recovery mechanism relies on the hardware generating link-request/input-status control symbols under the transmission error conditions described in 
<Link>Section 5.11.2.1, “Recoverable Errors and using the corresponding </Link>
link-response information to attempt recovery. </P>

<P>Due to the undefined reliability of system designs, it is necessary to put a safety lockout on the reset function of the link-request/reset-device control symbol. A device receiving a link-request/reset-device control symbol shall not perform the reset function unless it has received four link-request/reset-device control symbols in a row without any intervening packets or other control symbols, except status control symbols. This will prevent spurious reset-device commands inadvertently resetting a device. The link-request/reset-device control symbol does not require a response. </P>

<P>RapidIO Trade Association </P>

<P>The input-status command of the link-request/input-status control symbol is used by the hardware to recover from transmission errors. If the input port had stopped due to a transmission error that generated a packet-not-accepted control symbol back to the sender, the link-request/input-status control symbol acts as a link-request/restart-from-error control symbol, and the receiver is re-enabled to receive new packets after generating the link-response control symbol. The link-request/input-status control symbol may also be used to restart the receiving device if it is waiting for a restart-from-retry control symbol after retrying a packet. This situation can occur if transmission errors are encountered while trying to resynchronize the sending and receiving devices after the retry. </P>

<P>The link-request/input-status control symbol requires a response. A port receiving a link-request/input-status control symbol returns a link-response control symbol containing two pieces of information: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> port_status </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> ackID_status </LI_Title>
</LI>
</L>

<P>These status indicators are described in 
<Link>Table 3-5. </Link>
</P>

<P>The retry-stopped state indicates that the port has retried a packet and is waiting to be restarted. This state is cleared when a restart-from-retry (or a link-request/input-status) control symbol is received. The error-stopped state indicates that the port has encountered a transmission error and is waiting to be restarted. This state is cleared when a link-request/input-status control symbol is received. </P>

<P id="LinkTarget_30810">5.6 Packet Transmission Protocol </P>

<P>The LP-Serial protocol for packet transmission provides link level flow and error detection and recovery. </P>

<P>The LP-Serial link protocol uses control symbols to delimit packets when they are transmitted across an LP-Serial link as specified in
<Link> Section 5.4.1, “Packet </Link>

<Link>Delimiting</Link>
. </P>

<P>The LP-Serial link protocol uses acknowledgment to monitor packet transmission. Each packet transmitted across an LP-Serial link shall be acknowledged by the receiving port with a packet acknowledgment control symbol. To associate packet acknowledgment control symbols with transmitted packets, each packet shall be assigned an ackID value that is carried in the ackID field of the packet and the packet_ackID field of the associated acknowledgment control symbol. AckID values are assigned to packets sequentially in increasing numerical order wrapping to 0 on overflow. The ackID value carried by packets indicates their order of transmission. </P>

<P>The LP-Serial link protocol uses retransmission to recover from packet transmission errors. To enable packet retransmission, a copy of each packet transmitted across an </P>

<P>RapidIO Trade Association </P>

<P>LP-Serial link shall kept by the sending port until either a packet-accepted packet acknowledgment control symbol is received for the packet from the receiving port indicating that the port has received the packet without detected error and has accepted responsibility for the packet or the port determines that the packet has an encountered an unrecoverable error condition. </P>

<P>The LP-Serial link protocol uses the ackID value carried in each packet to ensure that no packets are lost due to transmission errors. A port shall accept packets from an LP-Serial link only in sequential ackID order, i.e. if the ackID value of the last packet accepted was N, the ackID value of the next packet that is accepted must be (N+1) modulo32. </P>

<P>An LP-Serial port accepts or rejects each error-free packet it receives depending on whether the port has input buffer space available at the priority level of the packet. The use of the packet-accepted, packet-retry, and restart-from-retry control symbols and the buf_status field in packet acknowledgment control symbols to control the 
<Link>flow of packets across an LP-Serial link is cover in Section 5.7, “Flow Control. </Link>
</P>

<P>The LP-Serial link protocol allows a packet that is being transmitted to be canceled 
<Link>at any point during its transmission. Packet cancelation is covered in Section 5.8, </Link>

<Link>“Canceling Packets</Link>
. </P>

<P>The LP-Serial link protocol provides detection and recovery processes for both transmission errors and protocol violations. The enumeration of detectable errors, the detection of errors and the associated error recovery processes are covered in 
<Link>Section 5.11, “Error Detection and Recovery. </Link>
</P>

<P>In order to prevent internal switch processing element internal errors, such as SRAM soft bit errors, from silently corrupting a packet and the system, switch processing elements shall maintain packet error detection coverage while a packet is passing through the switch. The simplest method for maintain packet error detection coverage is pass the packet CRC through the switch as part of the packet. This works well for all non-maintenance packets whose CRC does not change as the packets are transported from source to destination through the fabric. Maintaining error detection coverage is more complicated for maintenance packets as their hop_count and CRC change every time they pass through a switch. </P>

<P>In order to support transaction ordering requirements of the I/O Logical Layer specification, the LP-Serial protocol imposes packet delivery ordering requirements within the physical layer and transaction delivery ordering requirements between the physical layer and the transport layer in end point processing elements. These requirements are covered in 
<Link>Section 5.9, “Transaction and Packet Delivery Ordering </Link>

<Link>Rules</Link>
. </P>

<P>In order to prevent deadlock, the LP-Serial protocol imposes a set of deadlock prevention rules. These rules are covered in 
<Link>Section 5.10, “Deadlock Avoidance. </Link>
</P>

<P>The LP-Serial specification does not require the use of fair bandwidth allocation </P>

<P>RapidIO Trade Association </P>

<P>
<Link>mechanisms within the transport fabric</Link>
, therefore, it is possible that traffic associated with higher flow levels can starve traffic associated with lower flow levels. Any sort of starvation prevention, flow level bandwidth allocation, or fairness mechanisms are device and system dependent and are beyond the scope of this specification. </P>

<P id="LinkTarget_30811">5.7 Flow Control </P>

<P>This section defines RapidIO LP-Serial link level flow control. The flow control operates between each pair of ports connected by an LP-Serial link. The purpose of link level flow control is to prevent the loss of packets due to a lack of buffer space in a link receiver. </P>

<P>The LP-Serial protocol defines two methods or modes of flow control. These are named receiver-controlled flow control and transmitter-controlled flow control. Every RapidIO LP-Serial port shall support receiver-controlled flow control. LP-Serial ports may optionally support transmitter-controlled flow control. </P>

<P id="LinkTarget_30812">5.7.1 Receiver-Controlled Flow Control </P>

<P>Receiver-controlled flow control is the simplest and basic method of flow control. In this method, the input side of a port controls the flow of packets from its link partner by accepting or rejecting (retrying) packets on a packet by packet basis. The receiving port provides no information to its link partner about the amount of buffer space it has available for packet reception. </P>

<P>As a result, its link partner transmits packets with no a priori expectation as to whether a given packet will be accepted or rejected. A port signals its link partner that it is operating in receiver-controlled flow control mode by setting the buf_status field to all 1’s in every control symbol containing the field that the port transmits. This method is named receiver-controlled flow control because the receiver makes all of the decisions about how buffers in the receiver are allocated for packet reception. </P>

<P>A port operating in receiver-controlled flow control mode accepts or rejects each inbound error-free packet based on whether the receiving port has enough buffer space available at the priority level of the packet. If there is enough buffer space available, the port accepts the packet and transmits a packet-accepted control symbol to its link partner that contains the ackID of the accepted packet in its packet_ackID field. This informs the port’s link partner that the packet has been received without detected errors and that it has been accepted by the port. On receiving the packet-accepted control symbol, the link partner discards its copy of the accepted packet freeing buffer space in the partner. </P>

<P>If buffer space is not available, the port rejects the packet. When a port rejects (retries) an error-free packet, it immediately enters the Input Retry-stopped state and follows the Input Retry-stopped recovery process specified in 
<Link>Section 5.7.2.1, </Link>
</P>

<P>RapidIO Trade Association </P>

<P>
<Link>“Input Retry-Stopped Recovery Process. As part of the Input Retry-stopped </Link>
recovery process, the port sends a packet-retry control symbol to its link partner indicating that the packet whose ackID is in the packet_ackID field of the control symbol and all packets subsequently transmitted by the port have been discarded by the link partner and must all be retransmitted. The control symbol also indicates that the link partner is temporarily out of buffers for packets of priority less than or equal to the priority of the retried packet. </P>

<P>A port that receives a packet-retry control symbol immediately enters the Output Retry-stopped state and follows the Output Retry-stopped recovery process specified in 
<Link>Section 5.7.2.2, “Output Retry-Stopped Recovery Process. As part of </Link>
the Output Retry-stopped recovery process, the port receiving the packet-retry control symbol sends a restart-from-retry control symbol which causes its link partner to exit the Input Retry-stopped state and resume packet reception. The ackID assigned to that first packet transmitted after the restart-from-retry control symbol is the ackID of the packet that was retried. </P>

<P>
<Link>Figure 5-2 shows an example of receiver-controlled flow control operation. In this </Link>
example the transmitter is capable of sending packets faster than the receiver is able to absorb them. Once the transmitter has received a retry for a packet, the transmitter may elect to cancel any packet that is presently being transmitted since it will be discarded anyway. This makes bandwidth available for any higher priority packets that may be pending transmission. </P>

<P>Figure 5-2. Receiver-Controlled Flow Control </P>

<P>Transmitter Receiver 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_148.jpg"/>
Time Write 0 Write 1 Ack 0 Write 2 Ack 1 Rtry 2 Write 3 Write 4 Write 5 Write 2 Ack 2 Write 3 Write 4 Write 5 Ack 3 Ack 4 Ack 5 </Figure>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30813">5.7.2 Transmitter-Controlled Flow Control </P>

<P>In transmitter-controlled flow control, the receiving port provides information to its link partner about the amount of buffer space it has available for packet reception. With this information, the sending port can allocate the use of the receiving port’s receive buffers according to the number and priority of packets that the sending port has waiting for transmission without concern that one or more of the packets shall be forced to retry. </P>

<P>A port signals its link partner that it is operating in transmitter-controlled flow control mode by setting the buf_status field to a value different from all 1’s in every control symbol containing the field that the port transmits. This method is named transmitter-controlled flow control because the transmitter makes almost all of the decisions about how the buffers in the receiver are allocated for packet reception. </P>

<P>The number of free buffers that a port has available for packet reception is conveyed to its link partner by the value of the buf_status field in the control symbols that the port transmits. The value conveyed by the buf_status field is the number of maximum length packet buffers currently available for packet reception up to the limit that can be reported in the field. If a port has more buffers available than the maximum value that can be reported in the buf_status field, the port sets the field to that maximum value. A port may report a smaller number of buffers than it actually has available, but it shall not report a greater number. </P>

<P>A port informs its link partner when the number of free buffers available for packet reception changes. The new value of buf_status is conveyed in the buf_status field of a packet-accepted, packet-retry, or status control symbol. Each change in the number of free buffers a port has available for packet reception need not be conveyed to the link partner. However, a port shall send a control symbol containing the buf_status field to its link partner no less often than the minimum rate specified in 
<Link>Section 5.3.2, “Control Symbol Transmission. </Link>
</P>

<P>A port whose link partner is operating in transmitter-control flow control mode should never receive a packet-retry control symbol from its link partner unless the port has transmitted more packets than its link partner has receive buffers, violated the rules that all input buffer may not be filled with low priority packets or there is some fault condition. If a port whose link partner is operating in transmitter-control flow control mode receives a packet-retry control symbol, the output side of the port immediately enters the Output Retry-stopped state and follows the Output 
<Link>Retry-stopped recovery process specified in Section 5.7.2.2, “Output Retry-Stopped </Link>

<Link>Recovery Process</Link>
. </P>

<P>RapidIO Trade Association </P>

<P>A simple example of transmitter-controlled flow control is shown in 
<Link>Figure 5-3. </Link>
</P>

<P>Figure 5-3. Transmitter-Controlled Flow Control </P>

<P>Transmitter Receiver </P>

<P>Time 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_149.jpg"/>
Write 0 Write 1 Write 2 Write 3 Write 4 Write 5 </Figure>

<P>Ack 0, 2 buffers avail Ack 1, 1 buffer avail </P>

<P>Ack 2, 0 buffers avail Idle, 0 buffers avail Idle, 0 buffers avail Idle, 2 buffers avail </P>

<P>Ack 3, 3 buffers avail </P>

<P>Ack 4, 2 buffers avail </P>

<P>Ack 5, 1 buffers avail </P>

<P id="LinkTarget_30814">5.7.2.1 Input Retry-Stopped Recovery Process </P>

<P>When the input side of a port retries a packet, it immediately enters the Input Retry-stopped state. To recover from this state, the input side of the port takes the following actions. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Discards the rejected or canceled packet without reporting a packet error and ignores all subsequently received packets while the port is in the Input Retry-stopped state. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Causes the output side of the port to issue a packet-retry control symbol containing the ackID value of the retried packet in the packet_ackID field of the control symbol. (The packet-retry control symbol causes the output side of the link partner to enter the Output Retry-stopped state and send a restart-from-retry control symbol.) </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> When a restart-from-retry control symbol is received, exit the Input Retry-stopped state and resume packet reception. </LI_Title>
</LI>
</L>

<P>An example state machine with the behavior described in this section is included in 
<Link>Section A.2, “Packet Retry Mechanism.” </Link>
</P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30815">5.7.2.2  Output Retry-Stopped Recovery Process </P>

<P>To recover from the Output Retry-stopped state, the output side of a port takes the following actions. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Immediately stops transmitting new packets. Resets the link packet acknowledgment timers for all transmitted but unacknowledged packets. (This prevents the generation of spurious time-out errors.) </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Transmits a restart-from-retry control symbol. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Backs up to the first unaccepted packet (the retried packet) which is the packet whose ackID value is specified by the packet_ackID value contained in the packet-retry control symbol. (The packet_ackID value is also the value of ackID field the port retrying the packet expects in the first packet it receives after receiving the restart-from-retry control symbol.) </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Exits the Output Retry-stopped state and resumes transmission with either the retried packet or a higher priority packet which is assigned the ackID value contained in the packet_ackID field of the packet-retry control symbol. </LI_Title>
</LI>
</L>

<P>An example state machine with the behavior described in this section is included in 
<Link>Section A.2, “Packet Retry Mechanism.” </Link>
</P>

<P id="LinkTarget_30816">5.7.2.3  Receive Buffer Management </P>

<P>In transmitter-controlled flow control, the transmitter manages the packet receive buffers in the receiver. This may be done in a number of ways, but the selected method shall not violate the rules in 
<Link>Section 5.10, “Deadlock Avoidance concerning </Link>
the acceptance of packets by ports </P>

<P>One possible implementation to organize the buffers is establish watermarks and use them to progressively limit the packet priorities that can be transmitted as the effective number of free buffers in the receiver decreases. For example, RapidIO LP-Serial has four priority levels. Three non-zero watermarks are needed to progressively limit the packet priorities that may be transmitted as the effective number of free buffers decreases. Designate the three watermarks as WM0, WM1, and WM2 where WM0 &gt; WM1 &gt; WM2 &gt; 0 and employ the following rules. </P>

<P>If free_buffer_count &gt;= WM0, all priority packets may be transmitted. </P>

<P>If WM0 &gt; free_buffer_count &gt;= WM1, only priority 1, 2, and 3 </P>

<P>packets may be transmitted. </P>

<P>If WM1 &gt; free_buffer_count &gt;= WM2, only priority 2 and 3 packets </P>

<P>may be transmitted. </P>

<P>If WM2 &gt; free_buffer_count, only priority 3 packets may be </P>

<P>transmitted. </P>

<P>If this method is implemented, the initial values of the watermarks may be set by the hardware at reset as follows. </P>

<P>RapidIO Trade Association </P>

<P>WM0 = 4 </P>

<P>WM1 = 3 </P>

<P>WM2 = 2 </P>

<P>These initial values may be modified by hardware or software. The modified watermark values shall be based on the number of free buffers reported in the buf_status field of status control symbols received by the port following link initialization and before the start of packet transmission. </P>

<P>The three watermark values and the number of free buffers reported in the buf_status field of status control symbols received by the port following link initialization and before the start of packet transmission may be stored in a CSR. Since the maximum value of each of these four items is 30, each will fit in an 8-bit field and all four will fit in a single 32-bit CSR. If the watermarks are software setable, the three watermark fields in the CSR should be writable. For the greatest flexibility, a watermark register should be provided for each port on a device. </P>

<P id="LinkTarget_30817">5.7.2.4  Effective Number of Free Receive Buffers </P>

<P>The number of buffers available in a port’s link partner for packet reception is typically less than the value of the buf_status field most recently received from the link partner. The value in the buf_status field does not account for packets that have been transmitted by the port but not acknowledged by its link partner. The variable free_buffer_count is defined to be the effective number of free buffers available in the link partner for packet reception. The value of free_buffer_count shall be determined according to the following rules. </P>

<P>The port shall maintain a count of the packets that it has transmitted but that have not been acknowledged by its link partner. This count is named the outstanding_packet_count. </P>

<P>After link initialization and before the start of packet transmission, </P>

<P>If (received_buf_status &lt; 31) { flow_control_mode = transmitter; free_buffer_count = received_buf_status; outstanding_packet_count = 0; </P>

<P>} 
else 
flow_control_mode = receiver; 
</P>

<P>When a packet is transmitted by the port, </P>

<P>outstanding_packet_count = outstanding_packet_count + 1; </P>

<P>When a status control symbol is received by the port, </P>

<P>free_buffer_count = received_buf_status -</P>

<P>RapidIO Trade Association </P>

<P>outstanding_packet_count; </P>

<P>When a packet-accepted control symbol is received by the port </P>

<P>indicating that a packet has been accepted by the link partner, </P>

<P>Outstanding_packet_count = Outstanding_packet_count - 1; free_buffer_count = received_buf_status outstanding_packet_count; </P>

<P>When a packet-retry control symbol is received by the port indicating </P>

<P>that a packet has been forced by the link partner to retry, </P>

<P>Outstanding_packet_count = 0; </P>

<P>free_buffer_count = received_buf_status; </P>

<P>When a packet-not-accepted control symbol is received by the port indicating that a packet has been rejected by the link partner because of one or more detected errors, </P>

<P>Outstanding_packet_count = 0; </P>

<P>free_buffer_count = 0; </P>

<P>The port then transmits a link-request/input-status (for input-status) control symbol and waits for the link partner to respond with a link-response control symbol. When the link-response control symbol is received, </P>

<P>free_buffer_count = received_buf_status; </P>

<P id="LinkTarget_30818">5.7.2.5  Speculative Packet Transmission </P>

<P>A port whose link partner is operating in transmitter-controlled flow control mode may send more packets than the number of free buffers indicated by the link partner. Packets transmitted in excess of the free_buffer_count are transmitted on a speculative basis and are subject to retry by the link partner. The link partner accepts or rejects these packets on a packet by packet basis in exactly the same way it would if operating in receiver-controlled flow control mode. A port may use such speculative transmission in an attempt to maximize the utilization of the link. However, speculative transmission that results in a significant number of retries and discarded packets can reduce the effective bandwidth of the link. </P>

<P id="LinkTarget_30819">5.7.3 Flow Control Mode Negotiation </P>

<P>Immediately following the initialization of a link, each port begins sending status control symbols to its link partner. The value of the buf_status field in these control symbols indicates to the link partner the flow control mode supported by the sending port. </P>

<P>RapidIO Trade Association </P>

<P>The flow control mode negotiation rule is as follows: </P>

<P>If the port and its link partner both support transmitter-controlled flow control, then both ports shall use transmitter-controlled flow control. Otherwise, both ports shall use receiver-controlled flow control. </P>

<P id="LinkTarget_30820">5.8 Canceling Packets </P>

<P>When a port becomes aware of some condition that will require the packet it is currently transmitting to be retransmitted, the port may cancel the packet. This allows the port to avoid wasting bandwidth by not completing the transmission of a packet that the port knows must be retransmitted. Alternatively, the sending port may choose to complete transmission of the packet normally. </P>

<P>A port may cancel a packet if the port detects a problem with the packet as it is being transmitted or if the port receives a packet-retry or packet-not-accepted control symbol for a packet that is still being transmitted or that was previously transmitted. A packet-retry or packet-not-accepted control symbol can be transmitted by a port for a packet at any time after the port begins receiving the packet. </P>

<P>The sending device shall use the stomp control symbol, the restart-from-retry control symbol (in response to a packet-retry control symbol), or link-request/input-status control symbol (in response to a packet-not-accepted control symbol) or any link request control symbol to cancel a packet. </P>

<P>A port receiving a canceled packet shall drop the packet. The cancelation of a packet shall not result in the generation of any errors. If the packet was canceled because the sender received a packet-not-accepted control symbol, the error that caused the packet-not-accepted to be sent shall be reported in the normal manner. </P>

<P>The behavior of a port that receives a canceled packet depends on the control symbol that canceled the packet. A port that is not in an input stopped state (Retry-stopped or Error-stopped) while receiving the canceled packet and has not previously acknowledged the packet shall have the following behavior. If the packet is canceled by a link-request/input-status control symbol, the port shall drop the packet without reporting a packet error. If the packet is canceled by a restart-from-retry control symbol a protocol error has occurred and the port enters the Input Error-stopped state and follows the Input Error-stopped recovery process specified in 
<Link>Section 5.11.2.6, “Input Error-Stopped Recovery Process. If the packet was </Link>
canceled by other than a restart-from-retry or link-request/input-status control symbol, the port shall immediately enter the Input Retry-Stopped state and follow the Input Retry-Stopped recovery process specified in 
<Link>Section 5.7.2.1, “Input </Link>

<Link>Retry-Stopped Recovery Process. The Input Retry-Stopped recovery process </Link>
includes the dropping of the canceled packet without reporting a packet error and the transmission of a packet-retry control symbol. In either case, if the packet was canceled before the packet ackID field was received by the port, the packet_ackID field of the associated retry control symbol will be set to the ackID the port expected </P>

<P>RapidIO Trade Association </P>

<P>in the canceled packet. The packet sent following a canceled packet has the same ackID value as the canceled packet. </P>

<P id="LinkTarget_30821">5.9 Transaction and Packet Delivery Ordering Rules </P>

<P>The rules specified in this section are required for the physical layer to support the transaction ordering rules specified in the logical layer specifications. </P>

<P>Transaction Delivery Ordering Rules: </P>

<P>1. The physical layer of an end point processing element port shallencapsulate in packets and forwarded to the RapidIO fabrictransactions comprising a given transaction request flow in the same order that the transactions were received from the transport layer of the processing element. </P>

<P>2.The physical layer of an end point processing element port shall ensure that a higher priority request transaction that it receives from the transport layer of the processing elementbefore a lower priority request transaction with the samesourceID and the same destinationID is forwarded to the fabric before the lower priority transaction. </P>

<P>3. The physical layer of an end point processing element port shalldeliver transactions to the transport layer of the processingelement in the same order that the packetized transactionswere received by the port. </P>

<P>Packet Delivery Ordering Rules: </P>

<L>
<LI>
<LI_Label>1. </LI_Label>

<LI_Title>A packet initiated by a processing element shall not beconsidered committed to the RapidIO fabric and does notparticipate in the packet delivery ordering rules until thepacket has been accepted by the device at the other end of thelink. (RapidIO does not have the concept of delayed or deferredtransactions. Once a packet is accepted into the fabric, it iscommitted.) </LI_Title>
</LI>

<LI>
<LI_Label>2. </LI_Label>

<LI_Title>A switch shall not alter the priority or critical request flow of apacket. </LI_Title>
</LI>

<LI>
<LI_Label>3. </LI_Label>

<LI_Title>Packet forwarding decisions made by a switch processingelement shall provide a consistent output port selection whichis based solely on the value of the destinationID field carried inthe packet. </LI_Title>
</LI>

<LI>
<LI_Label>4. </LI_Label>

<LI_Title>A switch processing element shall not change the order ofpackets comprising a transaction request flow (packets withthe same sourceID, the same destinationID, the same priority,same critical request flow and ftype != 8) as the packets passthrough the switch. </LI_Title>
</LI>

<LI>
<LI_Label>5. </LI_Label>

<LI_Title>A switch processing element shall not allow lower prioritynon-maintenance packets (ftype != 8) to pass higher priority </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P>non-maintenance packets with the same sourceID and </P>

<P>destinationID as the packets pass through the switch. </P>

<P>6. A switch processing element shall not allow a priority Nmaintenance packet (ftype = 8) to pass another maintenancepacket of priority N or greater that takes the same paththrough the switch (same switch input port and same switchoutput port). </P>

<P id="LinkTarget_30822">5.10 Deadlock Avoidance </P>

<P>To allow a RapidIO protocol to evolve without changing the switching fabric, switch processing elements are not required, with the sole exception of ftype 8 maintenance transactions, to discern between packet types, their functions or their interdependencies. Switches, for instance, are not required to discern between packets carrying request transactions and packets carrying response transactions. As a result, it is possible for two end points, A and B to each fill all of their output buffers, the fabric connecting them and the other end point’s input buffers with read requests. This would result in an input to output dependency loop in each end point in which there would be no buffer space to hold the responses necessary to complete any of the outstanding read requests. </P>

<P>To break input to output dependencies, end point processing elements must have the ability to issue outbound response packets even if outbound request packets awaiting transmission are congestion blocked by the connected device. Two techniques are provided to break input to output dependencies. First, a response packet (a packet carrying a response transaction) is always assigned an initial priority one priority level greater than the priority of the associated request packet (the packet carrying the associated request transaction). </P>

<P>This requirement is specified in 
<Link>Table 5-1. It breaks the dependency cycle at the </Link>
request flow level. Second, the end point processing element that is the source of the response packet may additionally raise the priority of the response packet to a 
<Link>priority higher than the minimum required by Table 5-1 if necessary for the packet </Link>
to be accepted by the connected device. This additional increase in response packet priority above the minimum required by 
<Link>Table 5-1 is called promotion. An end point </Link>
processing element may promote a response packet only to the degree necessary for the packet to be accepted by the connected device. </P>

<P>The following rules define the deadlock prevention mechanism: </P>

<P>Deadlock Prevention Rules: </P>

<P>1. A RapidIO fabric shall be dependency cycle free for alloperations that do not require a response. (This rule isnecessary as there are no mechanisms provided in the fabric tobreak dependency cycles for operations not requiring responses.) </P>

<P>RapidIO Trade Association </P>

<L>
<LI>
<LI_Label>2. </LI_Label>

<LI_Title>A packet carrying a request transaction that requires a
response shall not be issued at the highest priority. (This rule
ensures that an end point processing element can issue a
response packet at a priority higher then the priority of the
associated request. This rule in combination with rule 3 are
basis for the priority assignments in 
<Link>Table 5-1.) 
</Link>
</LI_Title>
</LI>

<LI>
<LI_Label>3. </LI_Label>

<LI_Title>A packet carrying a response shall have a priority at least one
priority level higher than the priority of the associated request.
(This rule in combination with rule 2 are basis for the priority
assignments in 
<Link>Table 5-1.) 
</Link>
</LI_Title>
</LI>

<LI>
<LI_Label>4. </LI_Label>

<LI_Title>A switch processing element port shall accept an error-free
packet of priority N if there is no packet of priority greater
than or equal to N that was previously received by the port and
is still waiting in the switch to be forwarded. (This rule has
multiple implications which include but are not limited to the
following. First, a switch processing element port must have at
least as many maximum length packet input buffers as there
are priority levels. Second, a minimum of one maximum length
packet input buffer must be reserved for each priority level. A
input buffer reserved for priority N might be restricted to only
priority N packets or might be allowed to hold packets of
priority greater than or equal to N, either approach complies
with the rule.) 
</LI_Title>
</LI>

<LI>
<LI_Label>5. </LI_Label>

<LI_Title>A switch processing element port that transmits a priority N
packet that is forced to retry by the connected device shall
select a packet of priority greater than N, if one is available, for
transmission. (This guarantees that packets of a given priority
will not block higher priority packets.) 
</LI_Title>
</LI>

<LI>
<LI_Label>6. </LI_Label>

<LI_Title>An end point processing element port shall accept an error-free
packet of priority N if the port has enough space for the packet
in the input buffer space of the port allocated for packets of
priority N. (Lack of input buffer space is the only reason an end
point may retry a packet.) 
</LI_Title>
</LI>

<LI>
<LI_Label>7. </LI_Label>

<LI_Title>The decision of an end point processing element to accept or
retry an error-free packet of priority N shall not dependent on
the ability of the end point to issue request packets of priority
less than or equal to N from any of its ports. (This rule works
in conjunction with rule 6. It prohibits a device’s inability to
issue packets of priority less than or equal to N, due to
congestion in the connected device, from resulting in a lack of
buffers to receive inbound packets of priority greater than or
equal to N which in turn would result in packets of priority
greater than or equal to N being forced to retry. The 
implications and some ways of complying with this rule are
presented in the following paragraphs.) 
</LI_Title>
</LI>
</L>

<P>One implication of Rule 7 is that a port may not fill all of its buffers that can be used to hold packets awaiting transmission with packets carrying request transactions. If this situation was allowed to occur and the output was blocked due to congestion in </P>

<P>RapidIO Trade Association </P>

<P>the connected device, read transactions could not be processed (no place to put the response packet), input buffer space would become filled and all subsequent inbound request packets would be forced to retry violating Rule 7. </P>

<P>Another implication is that a port must have a way of preventing output blockage at priority less than or equal to N, due to congestion in the connected device, from resulting in a lack of input buffer space for inbound packets of priority greater than or equal to N. There are multiple ways of doing this. </P>

<P>One way is to provide a port with input buffer space for at least four maximum length packets and reserve input buffer space for higher priority packets in a manner similar to that required by Rule 4 for switches. In this case, output port blockage at priority less than or equal to N will not result is blocking inbound packets of priority greater than or equal to N as any responses packets they generate will be of priority greater than N which is not congestion blocked. The port must however have the ability to select packets of priority greater than N for transmission from the packets awaiting transmission. This approach does not require the use of response packet priority promotion. </P>

<P>Alternatively, a port that does not have enough input buffer space for at least four maximum length packets or that does not reserve space for higher priority packets can use the promotion mechanism to increase the priority of response packets until they are accepted by the connected device. This allows output buffer space containing response packets to be freed even though all request packets awaiting transmission are congestion blocked. </P>

<P>As an example, suppose an end point processing element has a blocked input port because all available resources are being used for a response packet that the processing element is trying to send. If the response packet is retried by the downstream processing element, raising the priority of the response packet until it is accepted allows the processing element’s input port to unblock so the system can make forward progress. </P>

<P id="LinkTarget_30823">5.11  Error Detection and Recovery </P>

<P>Error detection and recovery is becoming a more important issue for many systems. The LP-Serial specification provides extensive error detection and recovery by combining retry protocols with cyclic redundancy codes, the selection of delimiter control characters and response timers. </P>

<P>One feature of the error protection strategy is that with the sole exception of maintenance packets, the CRC value carried in a packet remains unchanged as the packet moves through the fabric. The CRC carried in a maintenance packet must be regenerated at each switch as the hop count changes. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30824">5.11.1  Lost Packet Detection </P>

<P>Some types of errors, such as a lost request or response packet or a lost acknowledgment, result in a system with hung resources. To detect this type of error there shall be time-out counters that expire when sufficient time has elapsed without receiving the expected response from the system. Because the expiration of one of these timers should indicate to the system that there is a problem, this time interval should be set long enough so that a false time-out is not signaled. The response to this error condition is implementation dependent. </P>

<P>The RapidIO specifications require time-out counters for the physical layer, the port link time-out counters, and counters for the logical layer, the port response time-out counters. The interpretation of the counter values is implementation dependent, based on a number of factors including link clock rate, the internal clock rate of the device, and the desired system behavior. </P>

<P>The physical layer time-out occurs between the transmission of a packet and the receipt of an acknowledgment control symbol. This time-out interval is likely to be comparatively short because the packet and acknowledgment pair must only traverse a single link. </P>

<P>The logical layer time-out occurs between the issuance of a request packet that requires a response packet and the receipt of that response packet. This time-out is counted from the time that the logical layer issues the packet to the physical layer to the time that the associated response packet is delivered from the physical layer to the logical layer. Should the physical layer fail to complete the delivery of the packet, the logical layer time-out will occur. This time-out interval is likely to be comparatively long because the packet and response pair have to traverse the fabric at least twice and be processed by the target. Error handling for a response time-out is implementation dependent. </P>

<P>Certain GSM operations may require two response transactions, and both must be received for the operation to be considered complete. In the case of a device implementation with multiple links, one response packet may be returned on the same link where the operation was initiated and the other response packet may be returned on a different link. If this behavior is supported by the issuing processing element, the port response time-out implementation must look for both responses, regardless on which links they are returned. </P>

<P id="LinkTarget_30825">5.11.2  Link Behavior Under Error </P>

<P>The LP-Serial link uses an error detection and retransmission protocol to protect against and recover from transmission errors. Transmission error detection is done at the input port, and all transmission error recovery is also initiated at the input port. </P>

<P>The protocol requires that each packet transmitted be acknowledged by the receiving port and that a copy of each transmitted packet be retained by the sender </P>

<P>RapidIO Trade Association </P>

<P>until the sender receives a packet-accepted control symbol acknowledgment for the packet or the sending port determines that the packet has encountered an unrecoverable error. If the receiving port detects a transmission error in a packet, the port sends a packet-not-accepted control symbol acknowledgment back to the sender indicating that the packet was corrupted as received. After a link-request/input-status and link-response control symbol exchange, the sender begins retransmission with either the packet that was corrupted during transmission or a higher priority packet if one is awaiting transmission. </P>

<P>All packets corrupted in transmission are retransmitted. The number of times a packet may be retransmitted before the sending port determines that the packet has encountered an unrecoverable condition is implementation dependent. </P>

<P id="LinkTarget_30826">5.11.2.1  Recoverable Errors </P>

<P>The following four basic types of errors are detected by an LP-Serial port: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> An idle sequence error </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A control symbol error </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A packet error </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A time-out waiting for an acknowledgment control symbol </LI_Title>
</LI>
</L>

<P id="LinkTarget_30827">5.11.2.2  Idle Sequence Errors </P>

<P>The idle sequence is comprised of A, K, and R (8B/10B special) characters. If an input port detects an invalid character or any valid character other then A, K, or R in an idle sequence, it shall enter the Input Error-stopped state and follow the Input 
<Link>Error-stopped recovery process specified in Section 5.11.2.6, “Input Error-Stopped </Link>

<Link>Recovery Process</Link>
. </P>

<P>To limit input port complexity, the port is no required to determine the specific error that resulted in an idle sequence error. Following are several examples of idle sequence errors. </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>A single bit transmission error can change an /A/, /K/, or /R/ code-group into a /Dx.y/ (data) code-group which is illegal in an idle sequence. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A single bit transmission error can change an /A/, /K/, or /R/ code-group into an invalid code-group. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A single bit transmission error can change an /SP/ or /PD/ (control symbol delimiters) into an invalid code-group. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30828">5.11.2.3  Control Symbol Errors </P>

<P>There are two types of detectable control symbol errors </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> An uncorrupted control symbol that violates the link protocol </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A corrupted control symbol </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30829">5.11.2.3.1  Link Protocol Violations </P>

<P>The reception of a control symbol with no detected corruption that violates the link protocol shall cause the receiving port to immediately enter the appropriate Error-stopped state. Stype1 control symbol protocol errors shall cause the receiving port to immediately enter the Input Error-stopped state if not already in the Input Error-stopped state and follow the Error-stopped recovery process specified in 
<Link>Section 5.11.2.6, “Input Error-Stopped Recovery Process”. Stype0 control symbol </Link>
protocol errors shall cause the receiving port to immediately enter the Output Error-stopped state if not already in the Output Error-stopped state and follow the Output Error-stopped recovery process 
<Link>specified in Section 5.11.2.7, “Output </Link>

<Link>Error-Stopped Recovery Process</Link>
”. If both stype0 and stype1 control symbols contain protocol errors, then the receiving port shall enter both Error-stopped states and follow both error recovery processes. </P>

<P>Link protocol violations include the following: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Unexpected packet-accepted, packet-retry, or packet-not-accepted control symbol </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Packet acknowledgment control symbol with an unexpected packet_ackID value </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Link time-out while waiting for an acknowledgment control symbol </LI_Title>
</LI>
</L>

<P>The following is an example of a link protocol violation and recovery. A sender transmits packets labeled ackID 2, 3, 4, and 5. It receives acknowledgments for packets 2, 4, and 5, indicating a probable error associated with ackID 3. The sender then stops transmitting new packets and sends a link-request/input-status (restart-from-error) control symbol to the receiver. The receiver then returns a link-response control symbol indicating which packets it has received properly. These are the possible responses and the sender’s resulting behavior: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> expecting ackID = 3 - sender must retransmit packets 3, 4, and 5 </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> expecting ackID = 4 - sender must retransmit packets 4 and 5 </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> expecting ackID = 5 - sender must retransmit packet 5 </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> expecting ackID = 6 - receiver got all packets, resume operation </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> expecting ackID = anything else - fatal (non-recoverable) error </LI_Title>
</LI>
</L>

<P id="LinkTarget_30830">5.11.2.3.2  Corrupted Control symbols </P>

<P>The reception of a control symbol with detected corruption shall cause the receiving port to immediately enter the Input Error-stopped state and follow the Input 
<Link>Error-stopped recovery process specified in Section 5.11.2.6, “Input Error-Stopped </Link>

<Link>Recovery Process</Link>
. For this type of error, the packet-not-accepted control symbol sent by the output side of the port as part of the recovery process shall have an undefined packet_ackID value. </P>

<P>Input ports detect the following types of control symbol corruption. </P>

<P>RapidIO Trade Association </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>A control symbol containing invalid characters or valid but non-data characters </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A control symbol with an incorrect CRC value </LI_Title>
</LI>
</L>

<P id="LinkTarget_30831">5.11.2.4  Packet Errors </P>

<P>The reception of a packet with detected corruption shall cause the receiving port to immediately enter the Input Error-stopped state and follow the Input Error-stopped 
<Link>recovery process specified in Section 5.11.2.6, “Input Error-Stopped Recovery </Link>

<Link>Process. </Link>
</P>

<P>Input ports detect the following types of packet corruption </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Packet with an unexpected ackID value </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Packet with an incorrect CRC value </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Packet containing invalid characters or valid non-data characters </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Packet that overruns some defined boundary such as the maximum data payload. </LI_Title>
</LI>
</L>

<P>An optional alternative behavior, error recovery suppression, can be enabled with the Re-transmit Suppression Mask field in the Port n Control CSR in systems that can withstand “lossy” transaction request flows (transaction request flows that are not required to have guaranteed data delivery). If this behavior is supported and enabled, when a processing element receives a corrupted packet as indicated by a bad CRC value, the processing element sends a packet-accepted control symbol, discards the corrupted packet, does not transition the “Input Error-stopped” state, and accepts new packets normally. The reporting mechanism for such an event is implementation dependent. Note that care must be taken when using this feature as it is possible that the CRF and/or the priority bits themselves could be corrupt. </P>

<P id="LinkTarget_30832">5.11.2.5  Link Time-Out </P>

<P>A link time-out while waiting for an acknowledgment control symbol is handled as 
<Link>a link protocol violation as described in Section 5.11.2.3.1, “Link Protocol </Link>

<Link>Violations </Link>
</P>

<P id="LinkTarget_30833">5.11.2.6  Input Error-Stopped Recovery Process </P>

<P>When the input side of a port detects a transmission error, it immediately enters the Input Error-stopped state. To recover from this state, the input side of the port takes the following actions. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Record the error(s) that caused the port to enter the Input Error-stopped state. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> If the detected error(s) occurred in a control symbol or packet, discard the control symbol or packet. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Ignore all subsequently received packets while the port is in the Input Error-stopped state. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Cause the output side of the port to issue a packet-not-accepted control symbol. The packet_ackID field of the control symbol contains an undefined value. (The packet-not-accepted control symbol causes the output side of the receiving port to enter the Output Error-stopped state and send a link-request/input-status control symbol.) </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>When an link-request/input-status control symbol is received, cause the output side of the port to issue a link-response control symbol, exit the Input Error-stopped state and resume packet reception. </LI_Title>
</LI>
</L>

<P>An example state machine with the behavior described in this section is included in 
<Link>Section A.3, “Error Recovery”. </Link>
</P>

<P id="LinkTarget_30834">5.11.2.7  Output Error-Stopped Recovery Process </P>

<P>To recover from the Output Error-stopped state, the output side of a port takes the following actions. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Immediately stops transmitting new packets. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Resets the link packet acknowledgment timers for all transmitted but unacknowledged packets. (This prevents the generation of spurious time-out errors.) </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Transmits an input-status link-request/input-status (restart-from-error) control symbol. (The input status link-request/input-status control symbol causes the receiving port to transmit a link-response control symbol that contains the input_status and ackID_status of the input side of the port. The ackID_status is the ackID value that is expected in the next packet that the port receives.) </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> When the link-response is received, the port backs up the first unaccepted packet, exits the Output Error-stopped state and resumes transmission with either the first unaccepted packet or a higher priority packet. </LI_Title>
</LI>
</L>

<P>An example state machine with the behavior described in this section is included in 
<Link>Section A.3, “Error Recovery”. </Link>
</P>

<P id="LinkTarget_30835">5.12 Power Management </P>

<P>Power management is currently beyond the scope of this specification and is implementation dependent. A device that supports power management features can make these features accessible to the rest of the system using the device’s local configuration registers. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30836">Chapter 6 LP-Serial Registers </P>

<P id="LinkTarget_30837">6.1 Introduction </P>

<P>This chapter describes the visible register set that allows an external processing element to determine the capabilities, configuration, and status of a processing element using this physical layer specification. This chapter only describes registers or register bits defined by this specification. Refer to the other RapidIO logical, transport, and physical specifications of interest to determine a complete list of registers and bit definitions. All registers are 32-bits and aligned to a 32-bit boundary. </P>

<P>There are four types of 1x/4x LP-Serial devices, an end point device, an end point device with additional software recovery registers, an end point free (or switch) device, and an end point free device with additional software recovery registers. 
<Link>Each has a different set of CSRs, specified in Section 6.5, Section 6.6, Section 6.7, </Link>
and 
<Link>Section 6.8, respectively. All four device types have the same CARs, specified </Link>
in 
<Link>Section 6.4</Link>
. </P>

<P id="LinkTarget_30838">6.2 Register Map </P>

<P>These registers utilize the Extended Features blocks and can be accessed using RapidIO Part 1: Input/Output Logical Specification maintenance operations. Any register offsets not defined are considered reserved for this specification unless otherwise stated. Other registers required for a processing element are defined in other applicable RapidIO specifications and by the requirements of the specific device and are beyond the scope of this specification. Read and write accesses to reserved register offsets shall terminate normally and not cause an error condition in the target device. </P>

<P>The Extended Features pointer (EF_PTR) defined in the RapidIO logical specifications contains the offset of the first Extended Features block in the Extended Features data structure for a device. The 1x/4x LP-Serial physical features block shall exist in any position in the Extended Features data structure and shall exist in any portion of the Extended Features Space in the register address map for the device. </P>

<P>Register bits defined as reserved are considered reserved for this specification only. Bits that are reserved in this specification may be defined in another RapidIO specification. </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x0-C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x10 </TD>

<TD>Processing Element Features CAR </TD>
</TR>

<TR>
<TD>0x14–FC </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x100– FFFC </TD>

<TD>Extended Features Space </TD>
</TR>

<TR>
<TD>0x10000– FFFFFC </TD>

<TD>Implementation-defined Space </TD>
</TR>
</Table>

<P id="LinkTarget_30839">6.3 Reserved Register and Bit Behavior </P>

<P>
<Link>Table 6-2 describes the required behavior for accesses to reserved register bits and </Link>
reserved registers for the RapidIO register space, </P>

<Table>
<Caption>
<P>Table 6-2. Configuration Space Reserved Access Behavior </P>
</Caption>

<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x0–3C </TH>

<TD>Capability Register Space (CAR Space - this space is read-only) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value1 </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - </TD>

<TD>write - ignored</TD>
</TR>

<TR>
<TD> Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write - </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x40–FC </TH>

<TD>Command and Status Register Space (CSR Space) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value2 </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write implementation-defined </TD>
</TR>

<TR>
<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write - </TD>

<TD>write - ignored </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification Rev. 1.3 Table 6-2. Configuration Space Reserved Access Behavior (Continued) </P>

<Table>
<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x100– FFFC </TH>

<TD>Extended Features Space </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD/>

<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write implementation-defined </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD/>

<TD>write - </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x10000– FFFFFC </TH>

<TD>Implementation-defined Space </TD>

<TD>Reserved bit and register </TD>

<TD>All behavior implementation-defined </TD>
</TR>
</Table>

<P>1Do not depend on reserved bits being a particular value; use appropriate masks to extract defined bits from the read value. </P>

<P>2All register writes shall be in the form: read the register to obtain the values of all reserved bits, merge in the desired values for defined bits to be modified, and write the register, thus preserving the value of all reserved bits. </P>

<P>RapidIO Trade Association </P>

<P>101 </P>

<P id="LinkTarget_30840">6.4 	Capability Registers (CARs) </P>

<P>Every processing element shall contain a set of registers that allows an external processing element to determine its capabilities using the I/O logical maintenance read operation. All registers are 32 bits wide and are organized and accessed in 32-bit (4 byte) quantities, although some processing elements may optionally allow 
<Link>larger accesses. CARs are read-only. Refer to Table 6-2 for the required behavior for </Link>
accesses to reserved registers and register bits. </P>

<P>CARs are big-endian with bit 0 the most significant bit. </P>

<P id="LinkTarget_30841">6.4.1 	Processing Element Features CAR 
(Configuration Space Offset 0x10) 
</P>

<P>The processing element features CAR identifies the major functionality provided by 
<Link>the processing element. The bit settings are shown in Table 6-3. </Link>
</P>

<Table>
<Caption>
<P>Table 6-3. Bit Settings for Processing Element Features CAR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–24 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>25 </TD>

<TD>Re-transmit Suppression Support </TD>

<TD>PE supports suppression of error recovery on packet CRC errors 0b0 - The error recovery suppression option is not supported by the PE 0b1 - The error recovery suppression option is supported by the PE </TD>
</TR>

<TR>
<TD>26 </TD>

<TD>CRF Support </TD>

<TD>PE supports the Critical Request Flow (CRF) indicator 0b0 - Critical Request Flow is not supported 0b1 - Critical Request Flow is supported </TD>
</TR>

<TR>
<TD>27–31 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30842">6.5 Generic End Point Devices </P>

<P>This section describes the 1x/4x LP-Serial registers for a general end point device. This Extended Features register block is assigned Extended Features block ID=0x0001. </P>

<P id="LinkTarget_30843">6.5.1 Register Map </P>

<P>
<Link>Table 6-4 shows the register map for generic RapidIO 1x/4x LP-Serial end point </Link>
devices. The Block Offset is the offset relative to the 16-bit Extended Features Pointer (EF_PTR) that points to the beginning of the block. </P>

<P>The address of a byte in the block is calculated by adding the block byte offset to EF_PTR that points to the beginning of the block. This is denoted as [EF_PTR+xx] where xx is the block byte offset in hexadecimal. </P>

<P>This register map is currently only defined for devices with up to 16 RapidIO ports, but can be extended or shortened if more or less port definitions are required for a device. For example, a device with four RapidIO ports is only required to use register map space corresponding to offsets [EF_PTR + 0x00] through [EF_PTR + 0xBC]. Register map offset [EF_PTR + 0xC0] can be used for another Extended Features block. </P>

<Table>
<Caption>
<P>Table 6-4. LP-Serial Register Map - Generic End Point Devices </P>
</Caption>

<TR>
<TH/>

<TH>Block Byte Offset </TH>

<TH>Register Name </TH>
</TR>

<TR>
<TH>General </TH>

<TD>0x0 </TD>

<TD>1x/4x LP-Serial Register Block Header </TD>
</TR>

<TR>
<TD>0x4–1C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x20 </TD>

<TD>Port Link Time-Out Control CSR </TD>
</TR>

<TR>
<TD>0x24 </TD>

<TD>Port Response Time-Out Control CSR </TD>
</TR>

<TR>
<TD>0x28-38 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x3C </TD>

<TD>Port General Control CSR </TD>
</TR>

<TR>
<TH>Port 0</TH>

<TD>0x40-54 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x58 </TD>

<TD>Port 0 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x5C </TD>

<TD>Port 0 Control CSR </TD>
</TR>

<TR>
<TH>Port 1</TH>

<TD>0x60-74 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x78 </TD>

<TD>Port 1 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x7C </TD>

<TD>Port 1 Control CSR </TD>
</TR>

<TR>
<TH>Ports 2-14</TH>

<TD>0x80–218 </TD>

<TD>Assigned to Port 2-14 CSRs </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH/>

<TH>Block Byte Offset </TH>

<TH>Register Name </TH>
</TR>

<TR>
<TH>Port 15</TH>

<TD>0x220-234 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x238 </TD>

<TD>Port 15 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x23C </TD>

<TD>Port 15 Control CSR </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30844">6.5.2 Command and Status Registers (CSRs) </P>

<P>Refer to 
<Link>Table 6-2 for the required behavior for accesses to reserved registers and </Link>
register bits. </P>

<P id="LinkTarget_30845">6.5.2.1 	1x/4x LP-Serial Register Block Header
(Block Offset 0x0) 
</P>

<P>The 1x/4x LP-Serial register block header register contains the EF_PTR to the next extended features block and the EF_ID that identifies this as the generic end point 1x/4x LP-Serial register block header. </P>

<Table>
<Caption>
<P>Table 6-5. Bit Settings for 1x/4x LP-Serial Register Block Header </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-15 </TD>

<TD>EF_PTR </TD>

<TD/>

<TD>Hard wired pointer to the next block in the data structure, if one exists </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>EF_ID </TD>

<TD>0x0001 </TD>

<TD>Hard wired Extended Features ID </TD>
</TR>
</Table>

<P id="LinkTarget_30846">6.5.2.2 	Port Link Time-out Control CSR (Block Offset 0x20) </P>

<P>The port link time-out control register contains the time-out timer value for all ports on a device. This time-out is for link events such as sending a packet to receiving the corresponding acknowledge, and sending a link-request to receiving the corresponding link-response. The reset value is the maximum time-out interval, and represents between 3 and 6 seconds. </P>

<Table>
<Caption>
<P>Table 6-6. Bit Settings for Port Link Time-out Control CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–23 </TD>

<TD>time-out value </TD>

<TD>All 1s </TD>

<TD>time-out interval value </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>105 </P>

<P id="LinkTarget_30847">6.5.2.3 	Port Response Time-out Control CSR
(Block Offset 0x24) 
</P>
</Div>

<Div>
<P>The port response time-out control register contains the time-out timer count for all ports on a device. This time-out is for sending a request packet to receiving the corresponding response packet.The reset value is the maximum time-out interval, and represents between 3 and 6 seconds. </P>

<Table>
<Caption>
<P>Table 6-7. Bit Settings for Port Response Time-out Control CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–23 </TD>

<TD>time-out value </TD>

<TD>All 1s </TD>

<TD>time-out interval value </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P id="LinkTarget_30848">6.5.2.4 	Port General Control CSR (Block Offset 0x3C) </P>

<P>The bits accessible through the Port General Control CSR are bits that apply to all ports on a device. There is a single copy of each such bit per device. These bits are also accessible through the Port General Control CSR of any other physical layers implemented on a device. </P>

<Table>
<Caption>
<P>Table 6-8. Bit Settings for Port General Control CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Host </TD>

<TD>see footnote1 </TD>

<TD>A Host device is a device that is responsible for system exploration, initialization, and maintenance. Agent or slave devices are typically initialized by Host devices. 0b0 - agent or slave device 0b1 - host device </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Master Enable </TD>

<TD>see footnote2 </TD>

<TD>The Master Enable bit controls whether or not a device is allowed to issue requests into the system. If the Master Enable is not set, the device may only respond to requests. 0b0 - processing element cannot issue requests 0b1 - processing element can issue requests </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>Discovered </TD>

<TD>see footnote3 </TD>

<TD>This device has been located by the processing element responsible for system configuration 0b0 - The device has not been previously discovered 0b1 - The device has been discovered by another processing element </TD>
</TR>

<TR>
<TD>3-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>1The Host reset value is implementation dependent 2The Master Enable reset value is implementation dependent 3The Discovered reset value is implementation dependent </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30849">6.5.2.5 	Port n Error and Status CSRs (Block Offsets 0x58, 78, ..., 238) </P>

<P>These registers are accessed when a local processor or an external device wishes to examine the port error and status information. </P>

<Table>
<Caption>
<P>Table 6-9. Bit Settings for Port n Error and Status CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-10 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Output Retry-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered a retry condition.This bit is set when bit 13 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Output Retried </TD>

<TD>0b0 </TD>

<TD>Output port has received a packet-retry control symbol and can not make forward progress. This bit is set when bit 13 is set and is cleared when a packet-accepted or a packet-not-accepted control symbol is received (read-only). </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Output Retry-stopped </TD>

<TD>0b0 </TD>

<TD>Output port has received a packet-retry control symbol and is in the “output retry-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Output Error-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered (and possibly recovered from) a transmission error. This bit is set when bit 15 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>15 </TD>

<TD>Output Error-stopped </TD>

<TD>0b0 </TD>

<TD>Output is in the “output error-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>16-20 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>21 </TD>

<TD>Input Retry-stopped </TD>

<TD>0b0 </TD>

<TD>Input port is in the “input retry-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>22 </TD>

<TD>Input Error-encountered </TD>

<TD>0b0 </TD>

<TD>Input port has encountered (and possibly recovered from) a transmission error. This bit is set when bit 23 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>23 </TD>

<TD>Input Error-stopped </TD>

<TD>0b0 </TD>

<TD>Input port is in the “input error-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>24-26 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>27 </TD>

<TD>Port-write Pending </TD>

<TD>0b0 </TD>

<TD>Port has encountered a condition which required it to initiate a Maintenance Port-write operation This bit is only valid if the device is capable of issuing a maintenance port-write transaction. Once set remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>28 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>29 </TD>

<TD>Port Error </TD>

<TD>0b0 </TD>

<TD>Input or output port has encountered an error from which hardware was unable to recover. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>30 </TD>

<TD>Port OK </TD>

<TD>0b0 </TD>

<TD>The input and output ports are initialized and the port is exchanging error-free control symbols with the attached device (read-only). </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Port Uninitialized </TD>

<TD>0b1 </TD>

<TD>Input and output ports are not initialized. This bit and bit 30 are mutually exclusive (read-only). </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>107 </P>

<P id="LinkTarget_30850">6.5.2.6 	Port n Control CSR 
(Block Offsets 0x5C, 7C, ..., 23C) 
</P>

<P>The port n control registers contain control register bits for individual ports on a processing element. </P>

<Table>
<Caption>
<P>Table 6-10. Bit Settings for Port n Control CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-1 </TD>

<TD>Port Width </TD>

<TD>see footnote1 </TD>

<TD>Hardware width of the port (read-only): 0b00 - Single-lane port 0b01 - Four-lane port 0b10 - 0b11 - Reserved </TD>
</TR>

<TR>
<TD>2-4 </TD>

<TD>Initialized Port Width </TD>

<TD>see footnote2 </TD>

<TD>Width of the ports after initialized (read only): 0b000 - Single-lane port, lane 0 0b001 - Single-lane port, lane 2 0b010 - Four-lane port 0b011 - 0b111 - Reserved </TD>
</TR>

<TR>
<TD>5-7 </TD>

<TD>Port Width Override </TD>

<TD>0b000 </TD>

<TD>Soft port configuration to override the hardware size: 0b000 - No override 0b001 - Reserved 0b010 - Force single lane, lane 0 0b011 - Force single lane, lane 2 0b100 - 0b111 - Reserved If the port size is overridden, the port will re-initialize to change to the requested size. </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>Port Disable </TD>

<TD>0b0 </TD>

<TD>Port disable: 0b0 - port receivers/drivers are enabled 0b1 - port receivers/drivers are disabled and are unable to receive/transmit any packets or control symbols </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>Output Port Enable </TD>

<TD>see footnote3 </TD>

<TD>Output port transmit enable: 0b0 - port is stopped and not enabled to issue any packets except to route or respond to I/O logical MAINTENANCE packets. Control symbols are not affected and are sent normally. This is the recommended state after device reset. 0b1 - port is enabled to issue any packets </TD>
</TR>

<TR>
<TD>10 </TD>

<TD>Input Port Enable </TD>

<TD>see footnote4 </TD>

<TD>Input port receive enable: 0b0 - port is stopped and only enabled to route or respond I/O logical MAINTENANCE packets. Other packets generate packet-not-accepted control symbols to force an error condition to be signaled by the sending device. Control symbols are not affected and are received and handled normally. This is the recommended state after device reset. 0b1 - port is enabled to respond to any packet </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Error Checking Disable </TD>

<TD>0b0 </TD>

<TD>This bit disables all RapidIO transmission error checking 0b0 - Error checking and recovery is enabled 0b1 - Error checking and recovery is disabled Device behavior when error checking and recovery is disabled and an error condition occurs is undefined </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Multicast-event Participant </TD>

<TD>see footnote5 </TD>

<TD>Send incoming Multicast-event control symbols to this port (multiple port devices only) </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>14 </TD>

<TD>Enumeration Boundary </TD>

<TD>see footnote6 </TD>

<TD>An enumeration boundary aware system enumeration algorithm shall honor this flag. The algorithm, on either the ingress or the egress port, shall not enumerate past a port with this bit set. This provides for software enforced enumeration domains within the RapidIO fabric. </TD>
</TR>

<TR>
<TD>15-19 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>20-27 </TD>

<TD>Re-transmit Suppression Mask </TD>

<TD>0x00 </TD>

<TD>Suppress packet re-transmission on CRC error. For devices that support CRF: 0b0000_0000 - Error recovery suppression disabled 0bxxxx_xxx1 - Suppress CRF=0, priority 0 re-transmission 0bxxxx_xx1x - Suppress CRF=0, priority 1 re-transmission 0bxxxx_x1xx - Suppress CRF=0, priority 2 re-transmission 0bxxxx_1xxx - Suppress CRF=0, priority 3 re-transmission 0bxxx1_xxxx - Suppress CRF=1, priority 0 re-transmission 0bxx1x_xxxx - Suppress CRF=1, priority 1 re-transmission 0bx1xx_xxxx - Suppress CRF=1, priority 2 re-transmission 0b1xxx_xxxx - Suppress CRF=1, priority 3 re-transmission For devices that do not support CRF: 0b0000_0000 - Error recovery suppression disabled 0b0000_xxx1 - Suppress priority 0 re-transmission 0b0000_xx1x - Suppress priority 1 re-transmission 0b0000_x1xx - Suppress priority 2 re-transmission 0b0000_1xxx - Suppress priority 3 re-transmission 0b0001_0000 - reserved ... 0b1111_1111 - reserved This field is only valid if bit 25 of the Processing Element Features CAR is set. </TD>
</TR>

<TR>
<TD>28-30 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Port Type </TD>

<TD/>

<TD>This indicates the port type (read only) 0b0 - Reserved 0b1 - Serial port </TD>
</TR>
</Table>

<P>1The Port Width reset value is implementation dependent </P>

<P>2The Initialized Port Width reset value is implementation dependent </P>

<P>3The Output Port Enable reset value is implementation dependent </P>

<P>4The Input Port Enable reset value is implementation dependent </P>

<P>5The Multicast-event Participant reset value is implementation dependent </P>

<P>6The Enumeration Boundary reset value is implementation dependent. Provision shall be made to allow the reset value of this bit to be configurable on a per system basis if this feature is supported. </P>

<P>RapidIO Trade Association </P>

<P>109 </P>

<P id="LinkTarget_30851">6.6 	Generic End Point Devices, software assisted error 
recovery option 
</P>

<P>This section describes the 1x/4x LP-Serial registers for a general end point device that supports software assisted error recovery. This is most useful for devices that for whatever reason do not want to implement error recovery in hardware and to allow software to generate link-request control symbols and see the results of the responses. This Extended Features register block is assigned Extended Features block ID=0x0002. </P>

<P id="LinkTarget_30852">6.6.1 Register Map </P>

<P>
<Link>Table 6-11 shows the register map for generic RapidIO 1x/4x LP-Serial end point </Link>
devices with software assisted error recovery. The Block Offset is the offset based on the Extended Features pointer (EF_PTR) to this block. This register map is currently only defined for devices with up to 16 RapidIO ports, but can be extended or shortened if more or less port definitions are required for a device. For example, a device with four RapidIO ports is only required to use register map space corresponding to offsets [EF_PTR + 0x00] through [EF_PTR + 0xBC]. Register map offset [EF_PTR + 0xC0] can be used for another Extended Features block. </P>

<Table>
<Caption>
<P>Table 6-11. LP-Serial Register Map - Generic End Point Devices (SW assisted) </P>
</Caption>

<TR>
<TH/>

<TH>Block Byte Offset </TH>

<TH>Register Name </TH>
</TR>

<TR>
<TH>General </TH>

<TD>0x0 </TD>

<TD>1x/4x LP-Serial Register Block Header </TD>
</TR>

<TR>
<TD>0x4–1C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x20 </TD>

<TD>Port Link Time-Out Control CSR </TD>
</TR>

<TR>
<TD>0x24 </TD>

<TD>Port Response Time-Out Control CSR </TD>
</TR>

<TR>
<TD>0x28-38 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x3C </TD>

<TD>Port General Control CSR </TD>
</TR>

<TR>
<TH>Port 0 </TH>

<TD>0x40 </TD>

<TD>Port 0 Link Maintenance Request CSR </TD>
</TR>

<TR>
<TD>0x44 </TD>

<TD>Port 0 Link Maintenance Response CSR </TD>
</TR>

<TR>
<TD>0x48 </TD>

<TD>Port 0 Local ackID Status CSR </TD>
</TR>

<TR>
<TD>0x4C-54 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x58 </TD>

<TD>Port 0 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x5C </TD>

<TD>Port 0 Control CSR </TD>
</TR>

<TR>
<TH>Port 1 </TH>

<TD>0x60 </TD>

<TD>Port 1 Link Maintenance Request CSR </TD>
</TR>

<TR>
<TD>0x64 </TD>

<TD>Port 1 Link Maintenance Response CSR </TD>
</TR>

<TR>
<TD>0x68 </TD>

<TD>Port 1 Local ackID Status CSR </TD>
</TR>

<TR>
<TD>0x6C-74 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x78 </TD>

<TD>Port 1 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x7C </TD>

<TD>Port 1 Control CSR </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH/>

<TH>Block Byte Offset </TH>

<TH>Register Name </TH>
</TR>

<TR>
<TH>Ports 2-14</TH>

<TD>0x80–218 </TD>

<TD>Assigned to Port 2-14 CSRs </TD>
</TR>

<TR>
<TH>Port 15 </TH>

<TD>0x220 </TD>

<TD>Port 15 Link Maintenance Request CSR </TD>
</TR>

<TR>
<TD>0x224 </TD>

<TD>Port 15 Link Maintenance Response CSR </TD>
</TR>

<TR>
<TD>0x228 </TD>

<TD>Port 15 Local ackID Status CSR </TD>
</TR>

<TR>
<TD>0x22C-234 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x238 </TD>

<TD>Port 15 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x23C </TD>

<TD>Port 15 Control CSR </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30853">6.6.2 Command and Status Registers (CSRs) </P>

<P>Refer to 
<Link>Table 6-2 for the required behavior for accesses to reserved registers and </Link>
register bits. </P>

<P id="LinkTarget_30854">6.6.2.1 	1x/4x LP-Serial Register Block Header
(Block Offset 0x0) 
</P>

<P>The 1x/4x LP-Serial register block header register contains the EF_PTR to the next extended features block and the EF_ID that identifies this as the generic end point 1x/4x LP-Serial register block header. </P>

<Table>
<Caption>
<P>Table 6-12. Bit Settings for 1x/4x LP-Serial Register Block Header </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-15 </TD>

<TD>EF_PTR </TD>

<TD/>

<TD>Hard wired pointer to the next block in the data structure, if one exists </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>EF_ID </TD>

<TD>0x0002 </TD>

<TD>Hard wired Extended Features ID </TD>
</TR>
</Table>

<P id="LinkTarget_30855">6.6.2.2 	Port Link Time-out Control CSR (Block Offset 0x20) </P>

<P>The port link time-out control register contains the time-out timer value for all ports on a device. This time-out is for link events such as sending a packet to receiving the corresponding acknowledge and sending a link-request to receiving the corresponding link-response. The reset value is the maximum time-out interval, and represents between 3 and 6 seconds. </P>

<Table>
<Caption>
<P>Table 6-13. Bit Settings for Port Link Time-out Control CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–23 </TD>

<TD>time-out value </TD>

<TD>All 1s </TD>

<TD>time-out interval value </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30856">6.6.2.3 	Port Response Time-out Control CSR(Block Offset 0x24) </P>

<P>The port response time-out control register contains the time-out timer count for all ports on a device. This time-out is for sending a request packet to receiving the corresponding response packet.The reset value is the maximum time-out interval, and represents between 3 and 6 seconds. </P>

<Table>
<Caption>
<P>Table 6-14. Bit Settings for Port Response Time-out Control CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–23 </TD>

<TD>time-out value </TD>

<TD>All 1s </TD>

<TD>time-out interval value </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P id="LinkTarget_30857">6.6.2.4 	Port General Control CSR (Block Offset 0x3C) </P>

<P>The port general control register contains control register bits applicable to all ports on a processing element. </P>

<Table>
<Caption>
<P>Table 6-15. Bit Settings for Port General Control CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Host </TD>

<TD>see footnote1 </TD>

<TD>A Host device is a device that is responsible for system exploration, initialization, and maintenance. Agent or slave devices are initialized by Host devices. 0b0 - agent or slave device 0b1 - host device </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Master Enable </TD>

<TD>see footnote2 </TD>

<TD>The Master Enable bit controls whether or not a device is allowed to issue requests into the system. If the Master Enable is not set, the device may only respond to requests. 0b0 - processing element cannot issue requests 0b1 - processing element can issue requests </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>Discovered </TD>

<TD>see footnote3 </TD>

<TD>This device has been located by the processing element responsible for system configuration 0b0 - The device has not been previously discovered 0b1 - The device has been discovered by another processing element </TD>
</TR>

<TR>
<TD>3-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>1The Host reset value is implementation dependent 2The Master Enable reset value is implementation dependent 3The Discovered reset value is implementation dependent </P>

<P>RapidIO Trade Association </P>

<P>113 </P>

<P id="LinkTarget_30858">6.6.2.5 	Port n Link Maintenance Request CSRs
(Block Offsets 0x40, 60, ..., 220) 
</P>

<P>The port link maintenance request registers are accessible both by a local processor and an external device. A write to one of these registers generates a link-request control symbol on the corresponding RapidIO port interface. </P>

<Table>
<Caption>
<P>Table 6-16. Bit Settings for Port n Link Maintenance Request CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–28 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>29-31 </TD>

<TD>Command </TD>

<TD>0b000 </TD>

<TD>Command to be sent in the link-request control symbol. If read, this field returns the last written value. </TD>
</TR>
</Table>

<P id="LinkTarget_30859">6.6.2.6 	Port n Link Maintenance Response CSRs(Block Offsets 0x44, 64, ..., 224) </P>

<P>The port link maintenance response registers are accessible both by a local processor and an external device. A read to this register returns the status received in a link-response control symbol. The ackID_status and port_status fields are defined in 
<Link>Table 3-3 and Table 3-5. This register is read-only. </Link>
</P>

<Table>
<Caption>
<P>Table 6-17. Bit Settings for Port n Link Maintenance Response CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>response_valid </TD>

<TD>0b0 </TD>

<TD>If the link-request causes a link-response, this bit indicates that the link-response has been received and the status fields are valid. If the link-request does not cause a link-response, this bit indicates that the link-request has been transmitted. This bit automatically clears on read. </TD>
</TR>

<TR>
<TD>1-21 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>22-26 </TD>

<TD>ackID_status </TD>

<TD>0b00000 </TD>

<TD>ackID status field from the link-response control symbol </TD>
</TR>

<TR>
<TD>27-31 </TD>

<TD>link_status </TD>

<TD>0b00000 </TD>

<TD>link status field from the link-response control symbol </TD>
</TR>
</Table>

<P id="LinkTarget_30860">6.6.2.7 	Port n Local ackID CSRs (Block Offsets 0x48, 68, ..., 228) </P>

<P>The port link local ackID status registers are accessible both by a local processor and an external device. A read to this register returns the local ackID status for both the out and input ports of the device. </P>

<Table>
<Caption>
<P>Table 6-18. Bit Settings for Port n Local ackID Status CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Clr_outstanding_ackIDs </TD>

<TD>0b0 </TD>

<TD>Writing 0b1 to this bit causes all outstanding unacknowleged packets to be discarded. This bit should only be written when trying to recover a failed link. This bit is always logic 0 when read. </TD>
</TR>

<TR>
<TD>1-2 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>3-7 </TD>

<TD>Inbound_ackID </TD>

<TD>0b00000 </TD>

<TD>Input port next expected ackID value </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification Rev. 1.3 Table 6-18. Bit Settings for Port n Local ackID Status CSRs (Continued) </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>8-18 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>19-23 </TD>

<TD>Outstanding_ackID </TD>

<TD>0x00000 </TD>

<TD>Output port unacknowledged ackID status. Next expected acknowledge control symbol ackID field that indicates the ackID value expected in the next received acknowledge control symbol. </TD>
</TR>

<TR>
<TD>24-26 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>27-31 </TD>

<TD>Outbound_ackID </TD>

<TD>0b00000 </TD>

<TD>Output port next transmitted ackID value. Software writing this value can force retransmission of outstanding unacknowledged packets in order to manually implement error recovery. </TD>
</TR>
</Table>

<P id="LinkTarget_30861">6.6.2.8 	Port n Error and Status CSRs (Block Offset 0x58, 78, ..., 238) </P>

<P>These registers are accessed when a local processor or an external device wishes to examine the port error and status information. </P>

<Table>
<Caption>
<P>Table 6-19. Bit Settings for Port n Error and Status CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-10 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Output Retry-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered a retry condition.This bit is set when bit 13 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Output Retried </TD>

<TD>0b0 </TD>

<TD>Output port has received a packet-retry control symbol and can not make forward progress. This bit is set when bit 13 is set and is cleared when a packet-accepted or a packet-not-accepted control symbol is received (read-only). </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Output Retry-stopped </TD>

<TD>0b0 </TD>

<TD>Output port has received a packet-retry control symbol and is in the “output retry-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Output Error-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered (and possibly recovered from) a transmission error. This bit is set when bit 15 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>15 </TD>

<TD>Output Error-stopped </TD>

<TD>0b0 </TD>

<TD>Output is in the “output error-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>16-20 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>21 </TD>

<TD>Input Retry-stopped </TD>

<TD>0b0 </TD>

<TD>Input port is in the “input retry-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>22 </TD>

<TD>Input Error-encountered </TD>

<TD>0b0 </TD>

<TD>Input port has encountered (and possibly recovered from) a transmission error. This bit is set when bit 23 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>23 </TD>

<TD>Input Error-stopped </TD>

<TD>0b0 </TD>

<TD>Input port is in the “input error-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>24-26 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>27 </TD>

<TD>Port-write Pending </TD>

<TD>0b0 </TD>

<TD>Port has encountered a condition which required it to initiate a Maintenance Port-write operation This bit is only valid if the device is capable of issuing a maintenance port-write transaction. Once set remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>28 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>115 </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>29 </TD>

<TD>Port Error </TD>

<TD>0b0 </TD>

<TD>Input or output port has encountered an error from which hardware was unable to recover. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>30 </TD>

<TD>Port OK </TD>

<TD>0b0 </TD>

<TD>The input and output ports are initialized and the port is exchanging error-free control symbols with the attached device (read-only). </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Port Uninitialized </TD>

<TD>0b1 </TD>

<TD>Input and output ports are not initialized. This bit and bit 30 are mutually exclusive (read-only). </TD>
</TR>
</Table>

<P id="LinkTarget_30862">6.6.2.9 	Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C) </P>

<P>The port n control registers contain control register bits for individual ports on a processing element. </P>

<Table>
<Caption>
<P>Table 6-20. Bit Settings for Port n Control CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-1 </TD>

<TD>Port Width </TD>

<TD>see footnote1 </TD>

<TD>Hardware width of the port (read-only): 0b00 - Single-lane port 0b01 - Four-lane port 0b10 - 0b11 - Reserved </TD>
</TR>

<TR>
<TD>2-4 </TD>

<TD>Initialized Port Width </TD>

<TD>see footnote2 </TD>

<TD>Width of the ports after initialized (read only): 0b000 - Single-lane port, lane 0 0b001 - Single-lane port, lane 2 0b010 - Four-lane port 0b011 - 0b111 - Reserved </TD>
</TR>

<TR>
<TD>5-7 </TD>

<TD>Port Width Override </TD>

<TD>0b000 </TD>

<TD>Soft port configuration to override the hardware size: 0b000 - No override 0b001 - Reserved 0b010 - Force single lane, lane 0 0b011 - Force single lane, lane 2 0b100 - 0b111 - Reserved If the port size is overridden, the port will re-initialize to change to the requested size. </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>Port Disable </TD>

<TD>0b0 </TD>

<TD>Port disable: 0b0 - port receivers/drivers are enabled 0b1 - port receivers/drivers are disabled and are unable to receive/transmit any packets or control symbols </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>Output Port Enable </TD>

<TD>see footnote3 </TD>

<TD>Output port transmit enable: 0b0 - port is stopped and not enabled to issue any packets except to route or respond to I/O logical MAINTENANCE packets. Control symbols are not affected and are sent normally. This is the recommended state after device reset. 0b1 - port is enabled to issue any packets </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>10 </TD>

<TD>Input Port Enable </TD>

<TD>see footnote4 </TD>

<TD>Input port receive enable: 0b0 - port is stopped and only enabled to route or respond I/O logical MAINTENANCE packets. Other packets generate packet-not-accepted control symbols to force an error condition to be signaled by the sending device. Control symbols are not affected and are received and handled normally. This is the recommended state after device reset. 0b1 - port is enabled to respond to any packet </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Error Checking Disable </TD>

<TD>0b0 </TD>

<TD>This bit disables all RapidIO transmission error checking 0b0 - Error checking and recovery is enabled 0b1 - Error checking and recovery is disabled Device behavior when error checking and recovery is disabled and an error condition occurs is undefined </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Multicast-event Participant </TD>

<TD>see footnote5 </TD>

<TD>Send incoming Multicast-event control symbols to this port (multiple port devices only) </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Enumeration Boundary </TD>

<TD>see footnote6 </TD>

<TD>An enumeration boundary aware system enumeration algorithm shall honor this flag. The algorithm, on either the ingress or the egress port, shall not enumerate past a port with this bit set. This provides for software enforced enumeration domains within the RapidIO fabric. </TD>
</TR>

<TR>
<TD>15-19 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>20-27 </TD>

<TD>Re-transmit Suppression Mask </TD>

<TD>0x00 </TD>

<TD>Suppress packet re-transmission on CRC error. For devices that support CRF: 0b0000_0000 - Error recovery suppression disabled 0bxxxx_xxx1 - Suppress CRF=0, priority 0 re-transmission 0bxxxx_xx1x - Suppress CRF=0, priority 1 re-transmission 0bxxxx_x1xx - Suppress CRF=0, priority 2 re-transmission 0bxxxx_1xxx - Suppress CRF=0, priority 3 re-transmission 0bxxx1_xxxx - Suppress CRF=1, priority 0 re-transmission 0bxx1x_xxxx - Suppress CRF=1, priority 1 re-transmission 0bx1xx_xxxx - Suppress CRF=1, priority 2 re-transmission 0b1xxx_xxxx - Suppress CRF=1, priority 3 re-transmission For devices that do not support CRF: 0b0000_0000 - Error recovery suppression disabled 0b0000_xxx1 - Suppress priority 0 re-transmission 0b0000_xx1x - Suppress priority 1 re-transmission 0b0000_x1xx - Suppress priority 2 re-transmission 0b0000_1xxx - Suppress priority 3 re-transmission 0b0001_0000 - reserved ... 0b1111_1111 - reserved This field is only valid if bit 25 of the Processing Element Features CAR is set. </TD>
</TR>

<TR>
<TD>28-30 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Port Type </TD>

<TD/>

<TD>This indicates the port type (read only) 0b0 - Reserved 0b1 - Serial port </TD>
</TR>
</Table>

<P>1The Port Width reset value is implementation dependent 
2The Initialized Port Width reset value is implementation dependent 
3The Output Port Enable reset value is implementation dependent 
4The Input Port Enable reset value is implementation dependent 
</P>

<P>RapidIO Trade Association </P>

<P>117 </P>

<P>5The Multicast-Event Participant reset value is implementation dependent </P>

<P>6The Enumeration Boundary reset value is implementation dependent. Provision shall be made to allow the reset value of this bit to be configurable on a per system basis if this feature is supported. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30863">6.7 Generic End Point Free Devices </P>

<P>This section describes the 1x/4x LP-Serial registers for a general devices that do not contain end point functionality (i.e. switches). This Extended Features register block uses extended features block ID=0x0003. </P>

<P id="LinkTarget_30864">6.7.1 Register Map </P>

<P>
<Link>Table 6-21 shows the register map for generic RapidIO 1x/4x LP-Serial end </Link>
point-free devices. The Block Offset is the offset based on the Extended Features pointer (EF_PTR) to this block. This register map is currently only defined for devices with up to 16 RapidIO ports, but can be extended or shortened if more or less port definitions are required for a device. For example, a device with four RapidIO ports is only required to use register map space corresponding to offsets [EF_PTR + 0x00] through [EF_PTR + 0xBC]. Register map offset [EF_PTR + 0xC0] can be used for another Extended Features block. </P>

<Table>
<Caption>
<P>Table 6-21. LP-Serial Register Map - Generic End Point Free Devices </P>
</Caption>

<TR>
<TH/>

<TH>Block Byte Offset </TH>

<TH>Register Name </TH>
</TR>

<TR>
<TH>General </TH>

<TD>0x0 </TD>

<TD>1x/4x LP-Serial Register Block Header </TD>
</TR>

<TR>
<TD>0x4–1C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x20 </TD>

<TD>Port Link Time-Out Control CSR </TD>
</TR>

<TR>
<TD>0x24-38 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x3C </TD>

<TD>Port General Control CSR </TD>
</TR>

<TR>
<TH>Port 0</TH>

<TD>0x40-54 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x58 </TD>

<TD>Port 0 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x5C </TD>

<TD>Port 0 Control CSR </TD>
</TR>

<TR>
<TH>Port 1</TH>

<TD>0x60-74 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x78 </TD>

<TD>Port 1 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x7C </TD>

<TD>Port 1 Control CSR </TD>
</TR>

<TR>
<TH>Ports 2-14</TH>

<TD>0x80–218 </TD>

<TD>Assigned to Port 2-14 CSRs </TD>
</TR>

<TR>
<TH>Port 15</TH>

<TD>0x220-234 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x238 </TD>

<TD>Port 15 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x23C </TD>

<TD>Port 15 Control CSR </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30865">6.7.2 Command and Status Registers (CSRs) </P>

<P>Refer to 
<Link>Table 6-2 for the required behavior for accesses to reserved registers and </Link>
register bits. </P>

<P id="LinkTarget_30866">6.7.2.1 	1x/4x LP-Serial Register Block Header
(Block Offset 0x0) 
</P>

<P>The 1x/4x LP-Serial register block header register contains the EF_PTR to the next extended features block and the EF_ID that identifies this as the generic end point 1x/4x LP-Serial register block header. </P>

<Table>
<Caption>
<P>Table 6-22. Bit Settings for 1x/4x LP-Serial Register Block Header </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-15 </TD>

<TD>EF_PTR </TD>

<TD/>

<TD>Hard wired pointer to the next block in the data structure, if one exists </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>EF_ID </TD>

<TD>0x0003 </TD>

<TD>Hard wired Extended Features ID </TD>
</TR>
</Table>

<P id="LinkTarget_30867">6.7.2.2 	Port Link Time-out Control CSR (Block Offset 0x20) </P>

<P>The port link time-out control register contains the time-out timer value for all ports on a device. This time-out is for link events such as sending a packet to receiving the corresponding acknowledge and sending a link-request to receiving the corresponding link-response. The reset value is the maximum time-out interval, and represents between 3 and 6 seconds. </P>

<Table>
<Caption>
<P>Table 6-23. Bit Settings for Port Link Time-out Control CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–23 </TD>

<TD>time-out value </TD>

<TD>All 1s </TD>

<TD>time-out interval value </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30868">6.7.2.3 	Port General Control CSR (Block Offset 0x3C) </P>

<P>The port general control register contains control register bits applicable to all ports on a processing element. </P>

<Table>
<Caption>
<P>Table 6-24. Bit Settings for Port General Control CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-1 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>Discovered </TD>

<TD>0b0 </TD>

<TD>This device has been located by the processing element responsible for system configuration 0b0 - The device has not been previously discovered 0b1 - The device has been discovered by another processing element </TD>
</TR>

<TR>
<TD>3-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P id="LinkTarget_30869">6.7.2.4 	Port n Error and Status CSRs (Block Offsets 0x58, 78, .., 238) </P>

<P>These registers are accessed when a local processor or an external device wishes to examine the port error and status information. </P>

<Table>
<Caption>
<P>Table 6-25. Bit Settings for Port n Error and Status CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-10 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Output Retry-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered a retry condition.This bit is set when bit 13 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Output Retried </TD>

<TD>0b0 </TD>

<TD>Output port has received a packet-retry control symbol and can not make forward progress. This bit is set when bit 13 is set and is cleared when a packet-accepted or a packet-not-accepted control symbol is received (read-only). </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Output Retry-stopped </TD>

<TD>0b0 </TD>

<TD>Output port has received a packet-retry control symbol and is in the “output retry-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Output Error-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered (and possibly recovered from) a transmission error. This bit is set when bit 15 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>15 </TD>

<TD>Output Error-stopped </TD>

<TD>0b0 </TD>

<TD>Output is in the “output error-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>16-20 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>21 </TD>

<TD>Input Retry-stopped </TD>

<TD>0b0 </TD>

<TD>Input port is in the “input retry-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>22 </TD>

<TD>Input Error-encountered </TD>

<TD>0b0 </TD>

<TD>Input port has encountered (and possibly recovered from) a transmission error. This bit is set when bit 23 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>23 </TD>

<TD>Input Error-stopped </TD>

<TD>0b0 </TD>

<TD>Input port is in the “input error-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>24-26 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>121 </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>27 </TD>

<TD>Port-write Pending </TD>

<TD>0b0 </TD>

<TD>Port has encountered a condition which required it to initiate a Maintenance Port-write operation This bit is only valid if the device is capable of issuing a maintenance port-write transaction. Once set remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>28 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>29 </TD>

<TD>Port Error </TD>

<TD>0b0 </TD>

<TD>Input or output port has encountered an error from which hardware was unable to recover. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>30 </TD>

<TD>Port OK </TD>

<TD>0b0 </TD>

<TD>The input and output ports are initialized and the port is exchanging error-free control symbols with the attached device (read-only). </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Port Uninitialized </TD>

<TD>0b1 </TD>

<TD>Input and output ports are not initialized. This bit and bit 30 are mutually exclusive (read-only). </TD>
</TR>
</Table>

<P id="LinkTarget_30870">6.7.2.5 	Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C) </P>

<P>The port n control registers contain control register bits for individual ports on a processing element. </P>

<Table>
<Caption>
<P>Table 6-26. Bit Settings for Port n Control CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-1 </TD>

<TD>Port Width </TD>

<TD>see footnote1 </TD>

<TD>Hardware width of the port (read-only): 0b00 - Single-lane port 0b01 - Four-lane port 0b10 - 0b11 - Reserved </TD>
</TR>

<TR>
<TD>2-4 </TD>

<TD>Initialized Port Width </TD>

<TD>see footnote2 </TD>

<TD>Width of the ports after initialized (read only): 0b000 - Single-lane port, lane 0 0b001 - Single-lane port, lane 2 0b010 - Four-lane port 0b011 - 0b111 - Reserved </TD>
</TR>

<TR>
<TD>5-7 </TD>

<TD>Port Width Override </TD>

<TD>0b000 </TD>

<TD>Soft port configuration to override the hardware size: 0b000 - No override 0b001 - Reserved 0b010 - Force single lane, lane 0 0b011 - Force single lane, lane 2 0b100 - 0b111 - Reserved If the port size is overridden, the port will re-initialize to change to the requested size. </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>Port Disable </TD>

<TD>0b0 </TD>

<TD>Port disable: 0b0 - port receivers/drivers are enabled 0b1 - port receivers/drivers are disabled and are unable to receive/transmit any packets or control symbols </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>Output Port Enable </TD>

<TD>see footnote3 </TD>

<TD>Output port transmit enable: 0b0 - port is stopped and not enabled to issue any packets except to route or respond to I/O logical MAINTENANCE packets. Control symbols are not affected and are sent normally. This is the recommended state after device reset. 0b1 - port is enabled to issue any packets </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>10 </TD>

<TD>Input Port Enable </TD>

<TD>see footnote4 </TD>

<TD>Input port receive enable: 0b0 - port is stopped and only enabled to route or respond I/O logical MAINTENANCE packets. Other packets generate packet-not-accepted control symbols to force an error condition to be signaled by the sending device. Control symbols are not affected and are received and handled normally. This is the recommended state after device reset. 0b1 - port is enabled to respond to any packet </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Error Checking Disable </TD>

<TD>0b0 </TD>

<TD>This bit disables all RapidIO transmission error checking 0b0 - Error checking and recovery is enabled 0b1 - Error checking and recovery is disabled Device behavior when error checking and recovery is disabled and an error condition occurs is undefined </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Multicast Event Participant </TD>

<TD>see footnote5 </TD>

<TD>Send incoming Multicast-event control symbols to this port (multiple port devices only) </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Enumeration Boundary </TD>

<TD>see footnote6 </TD>

<TD>An enumeration boundary aware system enumeration algorithm shall honor this flag. The algorithm, on either the ingress or the egress port, shall not enumerate past a port with this bit set. This provides for software enforced enumeration domains within the RapidIO fabric. </TD>
</TR>

<TR>
<TD>15-19 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>20-27 </TD>

<TD>Re-transmit Suppression Mask </TD>

<TD>0x00 </TD>

<TD>Suppress packet re-transmission on CRC error. For devices that support CRF: 0b0000_0000 - Error recovery suppression disabled 0bxxxx_xxx1 - Suppress CRF=0, priority 0 re-transmission 0bxxxx_xx1x - Suppress CRF=0, priority 1 re-transmission 0bxxxx_x1xx - Suppress CRF=0, priority 2 re-transmission 0bxxxx_1xxx - Suppress CRF=0, priority 3 re-transmission 0bxxx1_xxxx - Suppress CRF=1, priority 0 re-transmission 0bxx1x_xxxx - Suppress CRF=1, priority 1 re-transmission 0bx1xx_xxxx - Suppress CRF=1, priority 2 re-transmission 0b1xxx_xxxx - Suppress CRF=1, priority 3 re-transmission For devices that do not support CRF: 0b0000_0000 - Error recovery suppression disabled 0b0000_xxx1 - Suppress priority 0 re-transmission 0b0000_xx1x - Suppress priority 1 re-transmission 0b0000_x1xx - Suppress priority 2 re-transmission 0b0000_1xxx - Suppress priority 3 re-transmission 0b0001_0000 - reserved ... 0b1111_1111 - reserved This field is only valid if bit 25 of the Processing Element Features CAR is set. </TD>
</TR>

<TR>
<TD>28-30 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Port Type </TD>

<TD/>

<TD>This indicates the port type (read only) 0b0 - Reserved 0b1 - Serial port </TD>
</TR>
</Table>

<P>1The Port Width reset value is implementation dependent 
2The Initialized Port Width reset value is implementation dependent 
3The Output Port Enable reset value is implementation dependent 
4The Input Port Enable reset value is implementation dependent 
</P>

<P>RapidIO Trade Association </P>

<P>123 </P>

<P>5The Multicast-event Participant reset value is implementation dependent </P>

<P>6The Enumeration Boundary reset value is implementation dependent. Provision shall be made to allow the reset value of this bit to be configurable on a per system basis if this feature is supported. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30871">6.8 	Generic End Point Free Devices, software assisted error recovery option </P>

<P>This section describes the 1x/4x LP-Serial registers for a general device that does not contain end point functionality with software assisted error recovery.Typically these devices are switches. This is most useful for devices that for whatever reason do not want to implement error recovery in hardware and to allow software to generate link-request control symbols and see the results of the responses. This Extended Features register block is assigned Extended Features block ID=0x0009. </P>

<P id="LinkTarget_30872">6.8.1 Register Map </P>

<P>
<Link>Table 6-27 shows the register map for generic RapidIO 1x/4x LP-Serial end </Link>
point-free devices with software assisted error recovery. The Block Offset is the offset based on the Extended Features pointer (EF_PTR) to this block. This register map is currently only defined for devices with up to 16 RapidIO ports, but can be extended or shortened if more or less port definitions are required for a device. For example, a device with four RapidIO ports is only required to use register map space corresponding to offsets [EF_PTR + 0x00] through [EF_PTR + 0xBC]. Register map offset [EF_PTR + 0xC0] can be used for another Extended Features block. </P>

<Table>
<Caption>
<P>Table 6-27. LP-Serial Register Map - Generic End Point-free Devices (SW assisted) </P>
</Caption>

<TR>
<TH/>

<TH>Block Byte Offset </TH>

<TH>Register Name </TH>
</TR>

<TR>
<TH>General </TH>

<TD>0x0 </TD>

<TD>1x/4x LP-Serial Register Block Header </TD>
</TR>

<TR>
<TD>0x4–1C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x20 </TD>

<TD>Port Link Time-Out Control CSR </TD>
</TR>

<TR>
<TD>0x24-38 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x3C </TD>

<TD>Port General Control CSR </TD>
</TR>

<TR>
<TH>Port 0 </TH>

<TD>0x40 </TD>

<TD>Port 0 Link Maintenance Request CSR </TD>
</TR>

<TR>
<TD>0x44 </TD>

<TD>Port 0 Link Maintenance Response CSR </TD>
</TR>

<TR>
<TD>0x48 </TD>

<TD>Port 0 Local ackID Status CSR </TD>
</TR>

<TR>
<TD>0x4C-54 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x58 </TD>

<TD>Port 0 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x5C </TD>

<TD>Port 0 Control CSR </TD>
</TR>

<TR>
<TH>Port 1 </TH>

<TD>0x60 </TD>

<TD>Port 1 Link Maintenance Request CSR </TD>
</TR>

<TR>
<TD>0x64 </TD>

<TD>Port 1 Link Maintenance Response CSR </TD>
</TR>

<TR>
<TD>0x68 </TD>

<TD>Port 1 Local ackID Status CSR </TD>
</TR>

<TR>
<TD>0x6C-74 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x78 </TD>

<TD>Port 1 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x7C </TD>

<TD>Port 1 Control CSR </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH/>

<TH>Block Byte Offset </TH>

<TH>Register Name </TH>
</TR>

<TR>
<TH>Ports 2-14</TH>

<TD>0x80–218 </TD>

<TD>Assigned to Port 2-14 CSRs </TD>
</TR>

<TR>
<TH>Port 15 </TH>

<TD>0x220 </TD>

<TD>Port 15 Link Maintenance Request CSR </TD>
</TR>

<TR>
<TD>0x224 </TD>

<TD>Port 15 Link Maintenance Response CSR </TD>
</TR>

<TR>
<TD>0x228 </TD>

<TD>Port 15 Local ackID Status CSR </TD>
</TR>

<TR>
<TD>0x22C-234 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x238 </TD>

<TD>Port 15 Error and Status CSR </TD>
</TR>

<TR>
<TD>0x23C </TD>

<TD>Port 15 Control CSR </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30873">6.8.2 Command and Status Registers (CSRs) </P>

<P>Refer to 
<Link>Table 6-2 for the required behavior for accesses to reserved registers and </Link>
register bits. </P>

<P id="LinkTarget_30874">6.8.2.1 	1x/4x LP-Serial Register Block Header
(Block Offset 0x0) 
</P>

<P>The 1x/4x LP-Serial register block header register contains the EF_PTR to the next extended features block and the EF_ID that identifies this as the generic end point 1x/4x LP-Serial register block header. </P>

<Table>
<Caption>
<P>Table 6-28. Bit Settings for 1x/4x LP-Serial Register Block Header </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-15 </TD>

<TD>EF_PTR </TD>

<TD/>

<TD>Hard wired pointer to the next block in the data structure, if one exists </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>EF_ID </TD>

<TD>0x0009 </TD>

<TD>Hard wired Extended Features ID </TD>
</TR>
</Table>

<P id="LinkTarget_30875">6.8.2.2 	Port Link Time-out Control CSR (Block Offset 0x20) </P>

<P>The port link time-out control register contains the time-out timer value for all ports on a device. This time-out is for link events such as sending a packet to receiving the corresponding acknowledge and sending a link-request to receiving the corresponding link-response. The reset value is the maximum time-out interval, and represents between 3 and 6 seconds. </P>

<Table>
<Caption>
<P>Table 6-29. Bit Settings for Port Link Time-out Control CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–23 </TD>

<TD>time-out value </TD>

<TD>All 1s </TD>

<TD>time-out interval value </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>127 </P>

<P id="LinkTarget_30876">6.8.2.3 	Port General Control CSR 
(Block Offset 0x3C) 
</P>

<P>The port general control register contains control register bits applicable to all ports on a processing element. </P>

<Table>
<Caption>
<P>Table 6-30. Bit Settings for Port General Control CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-1 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>Discovered </TD>

<TD>0b0 </TD>

<TD>This device has been located by the processing element responsible for system configuration 0b0 - The device has not been previously discovered 0b1 - The device has been discovered by another processing element </TD>
</TR>

<TR>
<TD>3-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P id="LinkTarget_30877">6.8.2.4 	Port n Link Maintenance Request CSRs(Block Offsets 0x40, 60, ..., 220) </P>

<P>The port link maintenance request registers are accessible both by a local processor and an external device. A write to one of these registers generates a link-request control symbol on the corresponding RapidIO port interface. </P>

<Table>
<Caption>
<P>Table 6-31. Bit Settings for Port n Link Maintenance Request CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–28 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>29-31 </TD>

<TD>Command </TD>

<TD>0b000 </TD>

<TD>Command to be sent in the link-request control symbol. If read, this field returns the last written value. </TD>
</TR>
</Table>

<P id="LinkTarget_30878">6.8.2.5 	Port n Link Maintenance Response CSRs(Block Offsets 0x44, 64, ..., 224) </P>

<P>The port link maintenance response registers are accessible both by a local processor and an external device. A read to this register returns the status received in a link-response control symbol. The ackID_status and port_status fields are defined in 
<Link>Table 3-3 and Table 3-5. This register is read-only. </Link>
</P>

<Table>
<Caption>
<P>Table 6-32. Bit Settings for Port n Link Maintenance Response CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>response_valid </TD>

<TD>0b0 </TD>

<TD>If the link-request causes a link-response, this bit indicates that the link-response has been received and the status fields are valid. If the link-request does not cause a link-response, this bit indicates that the link-request has been transmitted. This bit automatically clears on read. </TD>
</TR>

<TR>
<TD>1-21 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>22-26 </TD>

<TD>ackID_status </TD>

<TD>0b00000 </TD>

<TD>ackID status field from the link-response control symbol </TD>
</TR>

<TR>
<TD>27-31 </TD>

<TD>link_status </TD>

<TD>0b00000 </TD>

<TD>link status field from the link-response control symbol </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30879">6.8.2.6 	Port n Local ackID CSRs (Block Offsets 0x48, 68, ..., 228) </P>

<P>The port link local ackID status registers are accessible both by a local processor and an external device. A read to this register returns the local ackID status for both the out and input ports of the device. </P>

<Table>
<Caption>
<P>Table 6-33. Bit Settings for Port n Local ackID Status CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Clr_outstanding_ackIDs </TD>

<TD>0b0 </TD>

<TD>Writing 0b1 to this bit causes all outstanding unacknowleged packets to be discarded. This bit should only be written when trying to recover a failed link. This bit is always logic 0 when read. </TD>
</TR>

<TR>
<TD>1-2 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>3-7 </TD>

<TD>Inbound_ackID </TD>

<TD>0b00000 </TD>

<TD>Input port next expected ackID value </TD>
</TR>

<TR>
<TD>8-18 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>19-23 </TD>

<TD>Outstanding_ackID </TD>

<TD>0x00000 </TD>

<TD>Output port unacknowledged ackID status. Next expected acknowledge control symbol ackID field that indicates the ackID value expected in the next received acknowledge control symbol. </TD>
</TR>

<TR>
<TD>24-26 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>27-31 </TD>

<TD>Outbound_ackID </TD>

<TD>0b00000 </TD>

<TD>Output port next transmitted ackID value. Software writing this value can force retransmission of outstanding unacknowledged packets in order to manually implement error recovery. </TD>
</TR>
</Table>

<P id="LinkTarget_30880">6.8.2.7 	Port n Error and Status CSRs (Block Offset 0x58, 78, ..., 238) </P>

<P>These registers are accessed when a local processor or an external device wishes to examine the port error and status information. </P>

<Table>
<Caption>
<P>Table 6-34. Bit Settings for Port n Error and Status CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-10 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Output Retry-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered a retry condition.This bit is set when bit 13 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Output Retried </TD>

<TD>0b0 </TD>

<TD>Output port has received a packet-retry control symbol and can not make forward progress. This bit is set when bit 13 is set and is cleared when a packet-accepted or a packet-not-accepted control symbol is received (read-only). </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Output Retry-stopped </TD>

<TD>0b0 </TD>

<TD>Output port has received a packet-retry control symbol and is in the “output retry-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Output Error-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered (and possibly recovered from) a transmission error. This bit is set when bit 15 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>15 </TD>

<TD>Output Error-stopped </TD>

<TD>0b0 </TD>

<TD>Output is in the “output error-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>16-20 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>21 </TD>

<TD>Input Retry-stopped </TD>

<TD>0b0 </TD>

<TD>Input port is in the “input retry-stopped” state (read-only). </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>129 </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>22 </TD>

<TD>Input Error-encountered </TD>

<TD>0b0 </TD>

<TD>Input port has encountered (and possibly recovered from) a transmission error. This bit is set when bit 23 is set. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>23 </TD>

<TD>Input Error-stopped </TD>

<TD>0b0 </TD>

<TD>Input port is in the “input error-stopped” state (read-only). </TD>
</TR>

<TR>
<TD>24-26 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>27 </TD>

<TD>Port-write Pending </TD>

<TD>0b0 </TD>

<TD>Port has encountered a condition which required it to initiate a Maintenance Port-write operation This bit is only valid if the device is capable of issuing a maintenance port-write transaction. Once set remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>28 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>29 </TD>

<TD>Port Error </TD>

<TD>0b0 </TD>

<TD>Input or output port has encountered an error from which hardware was unable to recover. Once set, remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>30 </TD>

<TD>Port OK </TD>

<TD>0b0 </TD>

<TD>The input and output ports are initialized and the port is exchanging error-free control symbols with the attached device (read-only). </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Port Uninitialized </TD>

<TD>0b1 </TD>

<TD>Input and output ports are not initialized. This bit and bit 30 are mutually exclusive (read-only). </TD>
</TR>
</Table>

<P id="LinkTarget_30881">6.8.2.8 	Port n Control CSR (Block Offsets 0x5C, 7C, ..., 23C) </P>

<P>The port n control registers contain control register bits for individual ports on a processing element. </P>

<Table>
<Caption>
<P>Table 6-35. Bit Settings for Port n Control CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-1 </TD>

<TD>Port Width </TD>

<TD>see footnote1 </TD>

<TD>Hardware width of the port (read-only): 0b00 - Single-lane port 0b01 - Four-lane port 0b10 - 0b11 - Reserved </TD>
</TR>

<TR>
<TD>2-4 </TD>

<TD>Initialized Port Width </TD>

<TD>see footnote2 </TD>

<TD>Width of the ports after initialized (read only): 0b000 - Single-lane port, lane 0 0b001 - Single-lane port, lane 2 0b010 - Four-lane port 0b011 - 0b111 - Reserved </TD>
</TR>

<TR>
<TD>5-7 </TD>

<TD>Port Width Override </TD>

<TD>0b000 </TD>

<TD>Soft port configuration to override the hardware size: 0b000 - No override 0b001 - Reserved 0b010 - Force single lane, lane 0 0b011 - Force single lane, lane 2 0b100 - 0b111 - Reserved If the port size is overridden, the port will re-initialize to change to the requested size. </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>Port Disable </TD>

<TD>0b0 </TD>

<TD>Port disable: 0b0 - port receivers/drivers are enabled 0b1 - port receivers/drivers are disabled and are unable to receive/transmit any packets or control symbols </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>9 </TD>

<TD>Output Port Enable </TD>

<TD>see footnote3 </TD>

<TD>Output port transmit enable: 0b0 - port is stopped and not enabled to issue any packets except to route or respond to I/O logical MAINTENANCE packets. Control symbols are not affected and are sent normally. This is the recommended state after device reset. 0b1 - port is enabled to issue any packets </TD>
</TR>

<TR>
<TD>10 </TD>

<TD>Input Port Enable </TD>

<TD>see footnote4 </TD>

<TD>Input port receive enable: 0b0 - port is stopped and only enabled to route or respond I/O logical MAINTENANCE packets. Other packets generate packet-not-accepted control symbols to force an error condition to be signaled by the sending device. Control symbols are not affected and are received and handled normally. This is the recommended state after device reset. 0b1 - port is enabled to respond to any packet </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Error Checking Disable </TD>

<TD>0b0 </TD>

<TD>This bit disables all RapidIO transmission error checking 0b0 - Error checking and recovery is enabled 0b1 - Error checking and recovery is disabled Device behavior when error checking and recovery is disabled and an error condition occurs is undefined </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Multicast-event Participant </TD>

<TD>see footnote5 </TD>

<TD>Send incoming Multicast-event control symbols to this port (multiple port devices only) </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Enumeration Boundary </TD>

<TD>see footnote6 </TD>

<TD>An enumeration boundary aware system enumeration algorithm shall honor this flag. The algorithm, on either the ingress or the egress port, shall not enumerate past a port with this bit set. This provides for software enforced enumeration domains within the RapidIO fabric. </TD>
</TR>

<TR>
<TD>15-19 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>20-27 </TD>

<TD>Re-transmit Suppression Mask </TD>

<TD>0x00 </TD>

<TD>Suppress packet re-transmission on CRC error. For devices that support CRF: 0b0000_0000 - Error recovery suppression disabled 0bxxxx_xxx1 - Suppress CRF=0, priority 0 re-transmission 0bxxxx_xx1x - Suppress CRF=0, priority 1 re-transmission 0bxxxx_x1xx - Suppress CRF=0, priority 2 re-transmission 0bxxxx_1xxx - Suppress CRF=0, priority 3 re-transmission 0bxxx1_xxxx - Suppress CRF=1, priority 0 re-transmission 0bxx1x_xxxx - Suppress CRF=1, priority 1 re-transmission 0bx1xx_xxxx - Suppress CRF=1, priority 2 re-transmission 0b1xxx_xxxx - Suppress CRF=1, priority 3 re-transmission For devices that do not support CRF: 0b0000_0000 - Error recovery suppression disabled 0b0000_xxx1 - Suppress priority 0 re-transmission 0b0000_xx1x - Suppress priority 1 re-transmission 0b0000_x1xx - Suppress priority 2 re-transmission 0b0000_1xxx - Suppress priority 3 re-transmission 0b0001_0000 - reserved ... 0b1111_1111 - reserved This field is only valid if bit 25 of the Processing Element Features CAR is set. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>131 </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>28-30 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Port Type </TD>

<TD/>

<TD>This indicates the port type (read only) 0b0 - Reserved 0b1 - Serial port </TD>
</TR>
</Table>

<P>1The Port Width reset value is implementation dependent </P>

<P>2The Initialized Port Width reset value is implementation dependent </P>

<P>3The Output Port Enable reset value is implementation dependent </P>

<P>4The Input Port Enable reset value is implementation dependent </P>

<P>5The Multicast-Event Participant reset value is implementation dependent </P>

<P>6The Enumeration Boundary reset value is implementation dependent. Provision shall be made to allow the reset value of this bit to be configurable on a per system basis if this feature is supported. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30882">Chapter 7 Signal Descriptions </P>

<P id="LinkTarget_30883">7.1 Introduction </P>

<P>This chapter contains the signal pin descriptions for a RapidIO 1x/4x LP-Serial port. The interface is defined either as a single- or four-lane, full duplex, point-to-point interface using differential signaling. A single-lane implementation consists of 4 wires and a four-lane implementation consists of 16 wires. The electrical details are described in 
<Link>Chapter 8, “Electrical Specifications.” </Link>
</P>

<P id="LinkTarget_30884">7.2 Signal Definitions </P>

<P>
<Link>Table 7-1 provides a summary of the RapidIO 1x/4x LP-Serial signal pins as well as </Link>
a short description of their functionality. </P>

<Table>
<Caption>
<P>Table 7-1. 1x/4x LP-Serial Signal Description </P>
</Caption>

<TR>
<TH>Signal Name </TH>

<TH>I/O </TH>

<TH>Signal Meaning </TH>

<TH>Timing Comments </TH>
</TR>

<TR>
<TD>TD[0-3] </TD>

<TD>O </TD>

<TD>Transmit Data -The transmit data is a unidirectional point to point bus designed to transmit the packet information. The TD bus of one device is connected to the RD bus of the receiving device. TD[0] is used in 1x mode. </TD>

<TD>Clocking is embedded in data using 8B/10B encoding. </TD>
</TR>

<TR>
<TD>TD[0-3] </TD>

<TD>O </TD>

<TD>Transmit Data complement—These signals are the differential pairs of the TD signals. </TD>

<TD/>
</TR>

<TR>
<TD>RD[0-3] </TD>

<TD>I </TD>

<TD>Receive Data - The receive data is a unidirectional point to point bus designed to receive the packet information. The RD bus of one device is connected to the TD bus of the receiving device. RD[0] is used in 1x mode. </TD>

<TD/>
</TR>

<TR>
<TD>RD[0-3] </TD>

<TD>I </TD>

<TD>Receive Data complement—These signals are the differential pairs of the RD signals. </TD>

<TD/>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30885">7.3 Serial RapidIO Interface Diagrams </P>

<P>
<Link>Figure 7-1 shows the signal interface diagram connecting two 1x devices together </Link>
with the RapidIO 1x/4x LP-Serial interconnect. </P>

<P>1x DEVICE 1x DEVICE </P>

<P>TD[0] </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_150.jpg"/>
</Figure>
RD[0] 
TD[0] 
RD[0] 
</P>

<P>RD[0] 
</P>

<P>TD[0] RD[0] </P>

<P>TD[0] </P>

<P>Figure 7-1. RapidIO 1x Device to 1x Device Interface Diagram </P>

<P>
<Link>Figure 7-2 shows the signal interface diagram connecting two 4x devices together </Link>
with the RapidIO 1x/4x LP-Serial interconnect. </P>

<P>4x DEVICE 4x DEVICE </P>

<P>TD[0-3] </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_151.jpg"/>
</Figure>
RD[0-3] TD[0-3] RD[0-3] </P>

<P>RD[0–3] </P>

<P>TD[0–3] RD[0–3] </P>

<P>TD[0–3] </P>

<P>Figure 7-2. RapidIO 4x Device to 4x Device Interface Diagram </P>

<P>
<Link>Figure 7-3 shows the connections between a 4x LP-Serial device and a 1x LP-Serial </Link>
device. </P>

<P>4x DEVICE </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_152.jpg"/>
</Figure>
1x DEVICE </P>

<P>TD[0] </P>

<P>RD[0] TD[0] </P>

<P>RD[0] TD[1-3] TD[1-3] </P>

<P>RD[0] </P>

<P>TD[0] RD[0] </P>

<P>TD[0] RD[1-3] RD[1-3] </P>

<P>Figure 7-3. RapidIO 4x Device to 1x Device Interface Diagram </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30886">Chapter 8 Electrical Specifications </P>

<P id="LinkTarget_30887">8.1 Introduction </P>

<P>The chapter defines the electrical specifications for the LP-Serial physical layer. The electrical specifications covers both single and multiple-lane links. Two transmitters (short run and long run) and a single receiver are specified for each of three baud rates, 1.25, 2.50, and 3.125 GBaud. </P>

<P>Two transmitter specifications allow for solutions ranging from simple board-to-board interconnect to driving two connectors across a backplane. A single receiver specification is given that will accept signals from both the short run and long run transmitter specifications. </P>

<P>The short run transmitter should be used mainly for chip-to-chip connections on either the same printed circuit board or across a single connector. This covers the case where connections are made to a mezzanine (daughter) card. The minimum swings of the short run specification reduce the overall power used by the transceivers. </P>

<P>The long run transmitter specifications use larger voltage swings that are capable of driving signals across backplanes. This allows a user to drive signals across two connectors and a backplane. The specifications allow a distance of at least 50 cm at all baud rates. </P>

<P>All unit intervals are specified with a tolerance of +/- 100 ppm. The worst case frequency difference between any transmit and receive clock will be 200 ppm. </P>

<P>To ensure interoperability between drivers and receivers of different vendors and technologies, AC coupling at the receiver input must be used. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30888">8.2 Signal Definitions </P>

<P>LP-Serial links use differential signaling. This section defines terms used in the description and specification of differential signals. 
<Link>Figure 8-1 shows how the </Link>
signals are defined. The figures shows waveforms for either a transmitter output (TD and TD) or a receiver input (RD and RD). Each signal swings between A Volts and B Volts where A &gt; B. Using these waveforms, the definitions are as follows: </P>

<L>
<LI>
<LI_Label>5.</LI_Label>

<LI_Title> The transmitter output signals and the receiver input signals TD, TD, RD and RD each have a peak-to-peak swing of A - B Volts </LI_Title>
</LI>

<LI>
<LI_Label>6. </LI_Label>

<LI_Title>The differential output signal of the transmitter, VOD, is defined as VTD-VTD. </LI_Title>
</LI>

<LI>
<LI_Label>7.</LI_Label>

<LI_Title> The differential input signal of the receiver, VID, is defined as VRD-VRD. </LI_Title>
</LI>

<LI>
<LI_Label>8.</LI_Label>

<LI_Title> The differential output signal of the transmitter and the differential input signal of the receiver each range from A - B to -(A - B) Volts </LI_Title>
</LI>

<LI>
<LI_Label>9. </LI_Label>

<LI_Title>The peak value of the differential transmitter output signal and the differential receiver input signal is A - B Volts </LI_Title>
</LI>

<LI>
<LI_Label>10.</LI_Label>

<LI_Title> The peak-to-peak value of the differential transmitter output signal and the differential receiver input signal is 2*(A - B) Volts </LI_Title>
</LI>
</L>

<P>TD or RD </P>

<P>A Volts </P>

<P>TD or RD </P>

<P>B Volts </P>

<P>Differential Peak-Peak = 2 * (A-B) </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_153.jpg"/>
</Figure>

<P>Figure 8-1. Differential Peak-Peak Voltage of Transmitter or Receiver </P>

<P>To illustrate these definitions using real values, consider the case of a CML (Current Mode Logic) transmitter that has a common mode voltage of 2.25 V and each of its outputs, TD and TD, has a swing that goes between 2.5V and 2.0V. Using these values, the peak-to-peak voltage swing of the signals TD and TD is 500 mV p-p. The differential output signal ranges between 500 mV and -500 mV. The peak differential voltage is 500 mV. The peak-to-peak differential voltage is 1000 mV p-p. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30889">8.3 	Equalization </P>

<P>With the use of high speed serial links, the interconnect media will cause degradation of the signal at the receiver. Effects such as Inter-Symbol Interference (ISI) or data dependent jitter are produced. This loss can be large enough to degrade the eye opening at the receiver beyond what is allowed in the specification. To negate a portion of these effects, equalization can be used. The most common equalization techniques that can be used are: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Pre-emphasis on the transmitter </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A passive high pass filter network placed at the receiver. This is often referred to as passive equalization. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>The use of active circuits in the receiver. This is often referred to as adaptive equalization. </LI_Title>
</LI>
</L>

<P id="LinkTarget_30890">8.4 	Explanatory Note on Transmitter and Receiver Specifications </P>

<P>AC electrical specifications are given for transmitter and receiver. Long run and short run interfaces at three baud rates (a total of six cases) are described. </P>

<P>The parameters for the AC electrical specifications are guided by the XAUI electrical interface specified in Clause 47 of IEEE 802.3ae-2002. </P>

<P>
<Link>XAUI has similar application goals to serial RapidIO, as described in Section 8.1. </Link>
The goal of this standard is that electrical designs for serial RapidIO can reuse electrical designs for XAUI, suitably modified for applications at the baud intervals and reaches described herein. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30891">8.5 Transmitter Specifications </P>

<P>LP-Serial transmitter electrical and timing specifications are stated in the text and tables of this section. </P>

<P>The differential return loss, S11, of the transmitter in each case shall be better than </P>

<P>-10 dB for (Baud Frequency)/10 &lt; Freq(f) &lt; 625 MHz, and -10 dB + 10log(f/625 MHz) dB for 625 MHz &lt;= Freq(f) &lt;= Baud Frequency </P>

<P>The reference impedance for the differential return loss measurements is 100 Ohm resistive. Differential return loss includes contributions from on-chip circuitry, chip packaging and any off-chip components related to the driver. The output impedance requirement applies to all valid output levels. </P>

<P>It is recommended that the 20%-80% rise/fall time of the transmitter, as measured at the transmitter output, in each case have a minimum value 60 ps. </P>

<P>It is recommended that the timing skew at the output of an LP-Serial transmitter between the two signals that comprise a differential pair not exceed 25 ps at 1.25 GB, 20 ps at 2.50 GB and 15 ps at 3.125 GB.  </P>

<Table>
<Caption>
<P>Table 8-1. Short Run Transmitter AC Timing Specifications - 1.25 GBaud </P>
</Caption>

<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH/>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD/>

<TD>Max </TD>
</TR>

<TR>
<TH>Output Voltage, </TH>

<TD>VO </TD>

<TD>-0.40 </TD>

<TD/>

<TD>2.30 </TD>

<TD>Volts </TD>

<TD>Voltage relative to COMMON of either signal comprising a differential pair </TD>
</TR>

<TR>
<TH>Differential Output Voltage </TH>

<TD>VDIFFPP </TD>

<TD>500 </TD>

<TD/>

<TD>1000 </TD>

<TD>mV p-p </TD>

<TD/>
</TR>

<TR>
<TH>Deterministic Jitter </TH>

<TD>JD </TD>

<TD/>

<TD/>

<TD>0.17 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Total Jitter </TH>

<TD>JT </TD>

<TD/>

<TD/>

<TD>0.35 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Multiple output skew </TH>

<TD>SMO </TD>

<TD/>

<TD/>

<TD>1000 </TD>

<TD>ps </TD>

<TD>Skew at the transmitter output between lanes of a multilane link </TD>
</TR>

<TR>
<TH>Unit Interval </TH>

<TD>UI </TD>

<TD>800 </TD>

<TD/>

<TD>800 </TD>

<TD>ps</TD>

<TD> +/- 100 ppm </TD>
</TR>
</Table>

<P>Table 8-2. Short Run Transmitter AC Timing Specifications - 2.5 GBaud </P>

<Table>
<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH/>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD/>

<TD>Max </TD>
</TR>

<TR>
<TH>Output Voltage, </TH>

<TD>VO </TD>

<TD>-0.40 </TD>

<TD/>

<TD>2.30 </TD>

<TD>Volts </TD>

<TD>Voltage relative to COMMON of either signal comprising a differential pair </TD>
</TR>

<TR>
<TH>Differential Output Voltage </TH>

<TD>VDIFFPP </TD>

<TD>500 </TD>

<TD/>

<TD>1000 </TD>

<TD>mV p-p </TD>

<TD/>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification Rev. 1.3 Table 8-2. Short Run Transmitter AC Timing Specifications - 2.5 GBaud </P>

<Table>
<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH/>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD/>

<TD>Max </TD>
</TR>

<TR>
<TH>Deterministic Jitter </TH>

<TD>JD </TD>

<TD/>

<TD/>

<TD>0.17 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Total Jitter </TH>

<TD>JT </TD>

<TD/>

<TD/>

<TD>0.35 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Multiple Output skew </TH>

<TD>SMO </TD>

<TD/>

<TD/>

<TD>1000 </TD>

<TD>ps </TD>

<TD>Skew at the transmitter output between lanes of a multilane link </TD>
</TR>

<TR>
<TH>Unit Interval </TH>

<TD>UI </TD>

<TD>400 </TD>

<TD/>

<TD>400 </TD>

<TD>ps</TD>

<TD> +/- 100 ppm </TD>
</TR>

<Caption>
<P>Table 8-3. Short Run Transmitter AC Timing Specifications - 3.125 GBaud </P>
</Caption>
</Table>

<Table>
<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH/>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD/>

<TD>Max </TD>
</TR>

<TR>
<TH>Output Voltage, </TH>

<TD>VO </TD>

<TD>-0.40 </TD>

<TD/>

<TD>2.30 </TD>

<TD>Volts </TD>

<TD>Voltage relative to COMMON of either signal comprising a differential pair </TD>
</TR>

<TR>
<TH>Differential Output Voltage </TH>

<TD>VDIFFPP </TD>

<TD>500 </TD>

<TD/>

<TD>1000 </TD>

<TD>mV p-p </TD>

<TD/>
</TR>

<TR>
<TH>Deterministic Jitter </TH>

<TD>JD </TD>

<TD/>

<TD/>

<TD>0.17 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Total Jitter </TH>

<TD>JT </TD>

<TD/>

<TD/>

<TD>0.35 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Multiple output skew </TH>

<TD>SMO </TD>

<TD/>

<TD/>

<TD>1000 </TD>

<TD>ps </TD>

<TD>Skew at the transmitter output between lanes of a multilane link </TD>
</TR>

<TR>
<TH>Unit Interval </TH>

<TD>UI </TD>

<TD>320 </TD>

<TD/>

<TD>320 </TD>

<TD>ps</TD>

<TD> +/- 100 ppm </TD>
</TR>

<Caption>
<P>Table 8-4. Long Run Transmitter AC Timing Specifications - 1.25 GBaud </P>
</Caption>
</Table>

<Table>
<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH/>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD/>

<TD>Max </TD>
</TR>

<TR>
<TH>Output Voltage, </TH>

<TD>VO </TD>

<TD>-0.40 </TD>

<TD/>

<TD>2.30 </TD>

<TD>Volts </TD>

<TD>Voltage relative to COMMON of either signal comprising a differential pair </TD>
</TR>

<TR>
<TH>Differential Output Voltage </TH>

<TD>VDIFFPP </TD>

<TD>800 </TD>

<TD/>

<TD>1600 </TD>

<TD>mV p-p </TD>

<TD/>
</TR>

<TR>
<TH>Deterministic Jitter </TH>

<TD>JD </TD>

<TD/>

<TD/>

<TD>0.17 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Total Jitter </TH>

<TD>JT </TD>

<TD/>

<TD/>

<TD>0.35 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Multiple output skew </TH>

<TD>SMO </TD>

<TD/>

<TD/>

<TD>1000 </TD>

<TD>ps </TD>

<TD>Skew at the transmitter output between lanes of a multilane link </TD>
</TR>

<TR>
<TH>Unit Interval </TH>

<TD>UI </TD>

<TD>800 </TD>

<TD/>

<TD>800 </TD>

<TD>ps</TD>

<TD> +/- 100 ppm </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>139 </P>

<Table>
<Caption>
<P>Table 8-5. Long Run Transmitter AC Timing Specifications - 2.5 GBaud </P>
</Caption>

<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH/>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD/>

<TD>Max </TD>
</TR>

<TR>
<TH>Output Voltage, </TH>

<TD>VO </TD>

<TD>-0.40 </TD>

<TD/>

<TD>2.30 </TD>

<TD>Volts </TD>

<TD>Voltage relative to COMMON of either signal comprising a differential pair </TD>
</TR>

<TR>
<TH>Differential Output Voltage </TH>

<TD>VDIFFPP </TD>

<TD>800 </TD>

<TD/>

<TD>1600 </TD>

<TD>mV p-p </TD>

<TD/>
</TR>

<TR>
<TH>Deterministic Jitter </TH>

<TD>JD </TD>

<TD/>

<TD/>

<TD>0.17 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Total Jitter </TH>

<TD>JT </TD>

<TD/>

<TD/>

<TD>0.35 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Multiple output skew </TH>

<TD>SMO </TD>

<TD/>

<TD/>

<TD>1000 </TD>

<TD>ps </TD>

<TD>Skew at the transmitter output between lanes of a multilane link </TD>
</TR>

<TR>
<TH>Unit Interval </TH>

<TD>UI </TD>

<TD>400 </TD>

<TD/>

<TD>400 </TD>

<TD>ps</TD>

<TD> +/- 100 ppm </TD>
</TR>
</Table>

<P>Table 8-6. Long Run Transmitter AC Timing Specifications - 3.125 GBaud </P>

<Table>
<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH/>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD/>

<TD>Max </TD>
</TR>

<TR>
<TH>Output Voltage, </TH>

<TD>VO </TD>

<TD>-0.40 </TD>

<TD/>

<TD>2.30 </TD>

<TD>Volts </TD>

<TD>Voltage relative to COMMON of either signal comprising a differential pair </TD>
</TR>

<TR>
<TH>Differential Output Voltage </TH>

<TD>VDIFFPP </TD>

<TD>800 </TD>

<TD/>

<TD>1600 </TD>

<TD>mV p-p </TD>

<TD/>
</TR>

<TR>
<TH>Deterministic Jitter </TH>

<TD>JD </TD>

<TD/>

<TD/>

<TD>0.17 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Total Jitter </TH>

<TD>JT </TD>

<TD/>

<TD/>

<TD>0.35 </TD>

<TD>UI p-p </TD>

<TD/>
</TR>

<TR>
<TH>Multiple output skew </TH>

<TD>SMO </TD>

<TD/>

<TD/>

<TD>1000 </TD>

<TD>ps </TD>

<TD>Skew at the transmitter output between lanes of a multilane link </TD>
</TR>

<TR>
<TH>Unit Interval </TH>

<TD>UI </TD>

<TD>320 </TD>

<TD/>

<TD>320 </TD>

<TD>ps</TD>

<TD> +/- 100 ppm </TD>
</TR>
</Table>

<P>For each baud rate at which an LP-Serial transmitter is specified to operate, the output eye pattern of the transmitter shall fall entirely within the unshaded portion 
<Link>of the Transmitter Output Compliance Mask shown in Figure 8-2 with the </Link>
parameters specified in 
<Link>Table 8-7 when measured at the output pins of the device </Link>
and the device is driving a 100 Ohm +/- 5% differential resistive load. The output eye pattern of a LP-Serial transmitter that implements pre-emphasis (to equalize the link and reduce inter-symbol interference) need only comply with the Transmitter Output Compliance Mask when pre-emphasis is disabled or minimized. </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_154.jpg"/>
0 VDIFF min VDIFF max -VDIFF min -VDIFF max 0 B 1-B 1 Transmitter Differential Output Voltage A 1-A </Figure>

<P>Time in UI </P>

<P>Figure 8-2. Transmitter Output Compliance Mask 
Table 8-7. Transmitter Differential Output Eye Diagram Parameters 
</P>

<Table>
<TR>
<TH>Transmitter Type </TH>

<TH>VDIFFmin (mV) </TH>

<TH>VDIFFmax (mV) </TH>

<TH>A (UI) </TH>

<TH>B (UI) </TH>
</TR>

<TR>
<TH>1.25 GBaud short range </TH>

<TD>250 </TD>

<TD>500 </TD>

<TD>0.175 </TD>

<TD>0.39 </TD>
</TR>

<TR>
<TH>1.25 GBaud long range </TH>

<TD>400 </TD>

<TD>800 </TD>

<TD>0.175 </TD>

<TD>0.39 </TD>
</TR>

<TR>
<TH>2.5 GBaud short range </TH>

<TD>250 </TD>

<TD>500 </TD>

<TD>0.175 </TD>

<TD>0.39 </TD>
</TR>

<TR>
<TH>2.5 GBaud long range </TH>

<TD>400 </TD>

<TD>800 </TD>

<TD>0.175 </TD>

<TD>0.39 </TD>
</TR>

<TR>
<TH>3.125 GBaud short range </TH>

<TD>250 </TD>

<TD>500 </TD>

<TD>0.175 </TD>

<TD>0.39 </TD>
</TR>

<TR>
<TH>3.125 GBaud long range </TH>

<TD>400 </TD>

<TD>800 </TD>

<TD>0.175 </TD>

<TD>0.39 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30892">8.6 Receiver Specifications </P>

<P>LP-Serial receiver electrical and timing specifications are stated in the text and tables of this section. </P>

<P>Receiver input impedance shall result in a differential return loss better that 10 dB and a common mode return loss better than 6 dB from 100 MHz to (0.8)*(Baud Frequency). This includes contributions from on-chip circuitry, the chip package and any off-chip components related to the receiver. AC coupling components are included in this requirement. The reference impedance for return loss measurements is 100 Ohm resistive for differential return loss and 25 Ohm resistive for common mode. </P>

<Table>
<Caption>
<P>Table 8-8. Receiver AC Timing Specifications - 1.25 GBaud </P>
</Caption>

<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD>Max </TD>
</TR>

<TR>
<TH>Differential Input Voltage </TH>

<TD>VΙΝ </TD>

<TD>200 </TD>

<TD>1600 </TD>

<TD>mV p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Deterministic Jitter Tolerance </TH>

<TD>JD </TD>

<TD>0.37 </TD>

<TD/>

<TD>UI p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Combined Deterministic and Random Jitter Tolerance </TH>

<TD>JDR </TD>

<TD>0.55 </TD>

<TD/>

<TD>UI p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Total Jitter Tolerance1 </TH>

<TD>JT </TD>

<TD>0.65 </TD>

<TD/>

<TD>UI p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Multiple Input Skew </TH>

<TD>SMI </TD>

<TD/>

<TD>24 </TD>

<TD>ns </TD>

<TD>Skew at the receiver input between lanes of a multilane link </TD>
</TR>

<TR>
<TH>Bit Error Ratio </TH>

<TD>BER </TD>

<TD/>

<TD>10-12 </TD>

<TD/>

<TD/>
</TR>

<TR>
<TH>Unit Interval </TH>

<TD>UI </TD>

<TD>800 </TD>

<TD>800 </TD>

<TD>ps </TD>

<TD>+/- 100 ppm </TD>
</TR>

<TR>
<TH>
<Link>Notes 1. Total jitter is composed of three components, deterministic jitter, random jitter and single frequency sinusoidal jitter. The sinusoidal jitter may have any amplitude and frequency in the unshaded region of Figure 8-3. The sinusoidal jitter component is included to ensure margin for low frequency jitter, wander, noise, crosstalk and other variable system effects. </Link>
</TH>
</TR>
</Table>

<P>Table 8-9. Receiver AC Timing Specifications - 2.5 GBaud </P>

<Table>
<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH/>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD/>

<TD>Max </TD>
</TR>

<TR>
<TH>Differential Input Voltage </TH>

<TD>VΙΝ </TD>

<TD>200 </TD>

<TD/>

<TD>1600 </TD>

<TD>mV p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Deterministic Jitter Tolerance </TH>

<TD>JD </TD>

<TD>0.37 </TD>

<TD/>

<TD/>

<TD>UI p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Combined Deterministic and Random Jitter Tolerance </TH>

<TD>JDR </TD>

<TD>0.55 </TD>

<TD/>

<TD/>

<TD>UI p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Total Jitter Tolerance1 </TH>

<TD>JT </TD>

<TD>0.65 </TD>

<TD/>

<TD/>

<TD>UI p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Multiple Input Skew </TH>

<TD>SMI </TD>

<TD/>

<TD/>

<TD>24 </TD>

<TD>ns </TD>

<TD>Skew at the receiver input between lanes of a multilane link </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification Rev. 1.3 Table 8-9. Receiver AC Timing Specifications - 2.5 GBaud </P>

<Table>
<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD>Max </TD>
</TR>

<TR>
<TH>Bit Error Ratio </TH>

<TD>BER </TD>

<TD/>

<TD>10-12 </TD>

<TD/>

<TD/>
</TR>

<TR>
<TH>Unit Interval </TH>

<TD>UI </TD>

<TD>400 </TD>

<TD>400 </TD>

<TD>ps </TD>

<TD>+/- 100 ppm </TD>
</TR>

<TR>
<TH>
<Link>Notes 1. Total jitter is composed of three components, deterministic jitter, random jitter and single frequency sinusoidal jitter. The sinusoidal jitter may have any amplitude and frequency in the unshaded region of Figure 8-3. The sinusoidal jitter component is included to ensure margin for low frequency jitter, wander, noise, crosstalk and other variable system effects. </Link>
</TH>
</TR>

<Caption>
<P>Table 8-10. Receiver AC Timing Specifications - 3.125 GBaud </P>
</Caption>
</Table>

<Table>
<TR>
<TH>Characteristic </TH>

<TH>Symbol </TH>

<TH>Range </TH>

<TH>Unit </TH>

<TH>Notes </TH>
</TR>

<TR>
<TD>Min </TD>

<TD>Max </TD>
</TR>

<TR>
<TH>Differential Input Voltage </TH>

<TD>VΙΝ </TD>

<TD>200 </TD>

<TD>1600 </TD>

<TD>mV p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Deterministic Jitter Tolerance </TH>

<TD>JD </TD>

<TD>0.37 </TD>

<TD/>

<TD>UI p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Combined Deterministic and Random Jitter Tolerance </TH>

<TD>JDR </TD>

<TD>0.55 </TD>

<TD/>

<TD>UI p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Total Jitter Tolerance1 </TH>

<TD>JT </TD>

<TD>0.65 </TD>

<TD/>

<TD>UI p-p </TD>

<TD>Measured at receiver </TD>
</TR>

<TR>
<TH>Multiple Input Skew </TH>

<TD>SMI </TD>

<TD/>

<TD>22 </TD>

<TD>ns </TD>

<TD>Skew at the receiver input between lanes of a multilane link </TD>
</TR>

<TR>
<TH>Bit Error Ratio </TH>

<TD>BER </TD>

<TD/>

<TD>10-12 </TD>

<TD/>

<TD/>
</TR>

<TR>
<TH>Unit Interval </TH>

<TD>UI </TD>

<TD>320 </TD>

<TD>320 </TD>

<TD>ps </TD>

<TD>+/- 100 ppm </TD>
</TR>

<TR>
<TH>
<Link>Notes 1. Total jitter is composed of three components, deterministic jitter, random jitter and single frequency sinusoidal jitter. The sinusoidal jitter may have any amplitude and frequency in the unshaded region of Figure 8-3. The sinusoidal jitter component is included to ensure margin for low frequency jitter, wander, noise, crosstalk and other variable system effects. </Link>
</TH>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>143 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_155.jpg"/>
8.5 UI p-p 0.10 UI p-p Sinusoidal Jitter Amplitude </Figure>

<P>22.1 kHz Frequency 1.875 MHz 20 MHz </P>

<P>Figure 8-3. Single Frequency Sinusoidal Jitter Limits </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30893">8.7 Receiver Eye Diagrams </P>

<P>For each baud rate at which an LP-Serial receiver is specified to operate, the receiver 
<Link>shall meet the corresponding Bit Error Ratio specification (Table 8-8, </Link>

<Link>Table 8-9</Link>
, 
<Link>Table 8-10) when the eye pattern of the receiver test signal (exclusive of sinusoidal </Link>
jitter) falls entirely within the unshaded portion of the Receiver Input Compliance Mask shown in 
<Link>Figure 8-4 with the parameters specified in Table 8-11. The eye </Link>
pattern of the receiver test signal is measured at the input pins of the receiving device with the device replaced with a 100 Ohm +/- 5% differential resistive load. </P>

<P>VDIFF min 0 -VDIFF min </P>

<P>-VDIFF max </P>

<P>A B 1-B 1-A Time (UI) </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_156.jpg"/>
10 </Figure>

<P>Figure 8-4. Receiver Input Compliance Mask </P>

<P>VDIFF max </P>

<P>Receiver Differential Input Voltage</P>

<P>Table 8-11. Receiver Input Compliance Mask Parameters exclusive of Sinusoidal Jitter </P>

<Table>
<TR>
<TH>Receiver Type </TH>

<TH>VDIFFmin (mV) </TH>

<TH>VDIFFmax (mV) </TH>

<TH>A (UI) </TH>

<TH>B (UI) </TH>
</TR>

<TR>
<TH>1.25 GBaud </TH>

<TD>100 </TD>

<TD>800 </TD>

<TD>0.275 </TD>

<TD>0.400 </TD>
</TR>

<TR>
<TH>2.5 GBaud </TH>

<TD>100 </TD>

<TD>800 </TD>

<TD>0.275 </TD>

<TD>0.400 </TD>
</TR>

<TR>
<TH>3.125 GBaud </TH>

<TD>100 </TD>

<TD>800 </TD>

<TD>0.275 </TD>

<TD>0.400 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30894">8.8 Measurement and Test Requirements </P>

<P>Since the LP-Serial electrical specification are guided by the XAUI electrical interface specified in Clause 47 of IEEE 802.3ae-2002, the measurement and test requirements defined here are similarly guided by Clause 47. In addition, the CJPAT test pattern defined in Annex 48A of IEEE802.3ae-2002 is specified as the test pattern for use in eye pattern and jitter measurements. Annex 48B of IEEE802.3ae-2002 is recommended as a reference for additional information on jitter test methods. </P>

<P id="LinkTarget_30895">8.8.1 Eye template measurements </P>

<P>For the purpose of eye template measurements, the effects of a single-pole high pass filter with a 3 dB point at (Baud Frequency)/1667 is applied to the jitter. The data pattern for template measurements is the Continuous Jitter Test Pattern (CJPAT) defined in Annex 48A of IEEE802.3ae. All lanes of the LP-Serial link shall be active in both the transmit and receive directions, and opposite ends of the links shall use asynchronous clocks. Four lane implementations shall use CJPAT as defined in Annex 48A. Single lane implementations shall use the CJPAT sequence specified in Annex 48A for transmission on lane 0. The amount of data represented in the eye shall be adequate to ensure that the bit error ratio is less than 10-12. The eye pattern shall be measured with AC coupling and the compliance template centered at 0 Volts differential. The left and right edges of the template shall be aligned with the mean zero crossing points of the measured data eye. The load for this test shall be 100 Ohms resistive +/- 5% differential to 2.5 GHz. </P>

<P id="LinkTarget_30896">8.8.2 Jitter test measurements </P>

<P>For the purpose of jitter measurement, the effects of a single-pole high pass filter with a 3 dB point at (Baud Frequency)/1667 is applied to the jitter. The data pattern for jitter measurements is the Continuous Jitter Test Pattern (CJPAT) pattern defined in Annex 48A of IEEE802.3ae. All lanes of the LP-Serial link shall be active in both the transmit and receive directions, and opposite ends of the links shall use asynchronous clocks. Four lane implementations shall use CJPAT as defined in Annex 48A. Single lane implementations shall use the CJPAT sequence specified in Annex 48A for transmission on lane 0. Jitter shall be measured with AC coupling and at 0 Volts differential. Jitter measurement for the transmitter (or for calibration of a jitter tolerance setup) shall be performed with a test procedure resulting in a BER curve such as that described in Annex 48B of IEEE802.3ae. </P>

<P id="LinkTarget_30897">8.8.3 Transmit jitter </P>

<P>Transmit jitter is measured at the driver output when terminated into a load of 100 Ohms resistive +/- 5% differential to 2.5 GHz. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30898">8.8.4 Jitter tolerance </P>

<P>Jitter tolerance is measured at the receiver using a jitter tolerance test signal. This signal is obtained by first producing the sum of deterministic and random jitter defined in 
<Link>Section 8.6</Link>
 and then adjusting the signal amplitude until the data eye contacts the 6 points of the minimum eye opening of the receive template shown in Figure 8-4 and Table 8-11. Note that for this to occur, the test signal must have vertical waveform symmetry about the average value and have horizontal symmetry (including jitter) about the mean zero crossing. Eye template measurement requirements are as defined above. Random jitter is calibrated using a high pass filter with a low frequency corner at 20 MHz and a 20 dB/decade rolloff below this. 
<Link>The required sinusoidal jitter specified in Section 8.6 is then added to the signal and </Link>
the test load is replaced by the receiver being tested. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30899">Annex A Interface Management (Informative) </P>

<P id="LinkTarget_30900">A.1 Introduction </P>

<P>This appendix contains state machine descriptions that illustrate a number of behaviors that are described in the RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification. They are included as examples and are believed to be correct, however, actual implementations should not use the examples directly. </P>

<P id="LinkTarget_30901">A.2 Packet Retry Mechanism </P>

<P>This section contains the example packet retry mechanism state machine referred to in 
<Link>Section 5.6, “Packet Transmission Protocol”. </Link>
</P>

<P>Packet retry recovery actually requires two inter-dependent state machines in order to operate, one associated with the input port and the other with the output port on the two connected devices. The two state machines work together to attempt recovery from a retry condition. </P>

<P id="LinkTarget_30902">A.2.1 Input port retry recovery state machine </P>

<P>If a packet cannot be accepted by a receiver for reasons other than error conditions, such as a full input buffer, the receiver follows the state sequence shown in 
<Link>Figure A-1. </Link>
</P>

<P>RapidIO Trade Association </P>

<P>149 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_157.jpg"/>
stop_input retry_stopped 7 4 9 wait_for_retry 3 recovery_disabled 1 2 5 6 8 reset 
<Caption>
<P>
<Link>Table A-1 describes the state transition arcs for Figure A-1. The states referenced in </Link>
the comments in quotes are the RapidIO 1x/4x LP-Serial defined status states, not states in this state machine. </P>
</Caption>
</Figure>

<P>Figure A-1. Input Port Retry Recovery State Machine </P>

<Table>
<Caption>
<P>Table A-1. Input Port Retry Recovery State Machine Transition Table </P>
</Caption>

<TR>
<TH>Arc </TH>

<TH>Current State </TH>

<TH>Next state </TH>

<TH>cause </TH>

<TH>Comments </TH>
</TR>

<TR>
<TD>1 </TD>

<TD>recovery_disabled </TD>

<TD>recovery_disabled </TD>

<TD>Remain in this state until the input port is enabled to receive packets. </TD>

<TD>This is the initial state after reset. The input port can’t be enabled before the initialization sequence has been completed, and may be controlled through other mechanisms as well, such as a software enable bit. </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>recovery_disabled </TD>

<TD>wait_for_retry </TD>

<TD>Input port is enabled. </TD>

<TD/>
</TR>

<TR>
<TD>3 </TD>

<TD>wait_for_retry </TD>

<TD>wait_for_retry </TD>

<TD>Remain in this state until a packet retry situation has been detected. </TD>

<TD/>
</TR>

<TR>
<TD>4 </TD>

<TD>wait_for_retry </TD>

<TD>stop_input </TD>

<TD>A packet retry situation has been detected. </TD>

<TD>Usually this is due to an internal resource problem such as not having packet buffers available for low priority packets. </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>wait_for_retry </TD>

<TD>recovery_disabled </TD>

<TD>Input port is disabled. </TD>

<TD/>
</TR>

<TR>
<TD>6 </TD>

<TD>stop_input </TD>

<TD>stop_input </TD>

<TD>Remain in this state until described input port stop activity is completed. </TD>

<TD>Send a packet-retry control symbol with the expected ackID, discard the packet, and don’t change the expected ackID. This will force the attached device to initiate recovery starting at the expected ackID. Clear the “Port Normal” state and set the “Input Retry-stopped” state. </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>stop_input </TD>

<TD>retry_stopped </TD>

<TD>Input port stop activity is complete. </TD>

<TD/>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Arc </TH>

<TH>Current State </TH>

<TH>Next state </TH>

<TH>cause </TH>

<TH>Comments </TH>
</TR>

<TR>
<TD>8 </TD>

<TD>retry_stopped </TD>

<TD>retry_stopped </TD>

<TD>Remain in this state until a restart-from-retry or link request (restart-from-error) control symbol is received or an input port error is encountered. </TD>

<TD>The “Input Retry-stopped” state causes the input port to silently discard all incoming packets and not change the expected ackID value. </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>retry_stopped </TD>

<TD>wait_for_retry </TD>

<TD>Received a restart-from-retry or a link request (restart-from-error) control symbol or an input port error is encountered. </TD>

<TD>Clear the “Input Retry-stopped” state and set the “Port Normal” state. An input port error shall cause a clean transition between the retry recovery state machine and the error recovery state machine. </TD>
</TR>
</Table>

<P id="LinkTarget_30903">A.2.2 Output port retry recovery state machine </P>

<P>On receipt of an error-free packet-retry control symbol, the attached output port follows the behavior shown in 
<Link>Figure A-2. The states referenced in the comments in </Link>
quotes are the RapidIO 8/16 LP-LVDS defined status states, not states in this state machine. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_158.jpg"/>
stop_output 4 recover 7 9 6 wait_for_retry 3 recovery_disabled 1 2 5 8 reset </Figure>

<P>Figure A-2. Output Port Retry Recovery State Machine </P>

<P>RapidIO Trade Association </P>

<P>151 </P>

<P>
<Link>Table A-2 describes the state transition arcs for Figure A-2. </Link>
</P>

<Table>
<Caption>
<P>Table A-2. Output Port Retry Recovery State Machine Transition Table </P>
</Caption>

<TR>
<TH>Arc </TH>

<TH>Current State </TH>

<TH>Next state </TH>

<TH>cause </TH>

<TH>Comments </TH>
</TR>

<TR>
<TD>1 </TD>

<TD>recovery_disabled </TD>

<TD>recovery_disabled </TD>

<TD>Remain in this state until the output port is enabled to receive packets. </TD>

<TD>This is the initial state after reset. The output port can’t be enabled before the initialization sequence has been completed, and may be controlled through other mechanisms as well, such as a software enable bit. </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>recovery_disabled </TD>

<TD>wait_for_retry </TD>

<TD>Output port is enabled. </TD>

<TD/>
</TR>

<TR>
<TD>3 </TD>

<TD>wait_for_retry </TD>

<TD>wait_for_retry </TD>

<TD>Remain in this state until a packet-retry control symbol is received. </TD>

<TD>The packet-retry control symbol shall be error free. </TD>
</TR>

<TR>
<TD>4 </TD>

<TD>wait_for_retry </TD>

<TD>stop_output </TD>

<TD>A packet-retry control symbol has been received.</TD>

<TD> Start the output port stop procedure. </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>wait_for_retry </TD>

<TD>recovery_disabled </TD>

<TD>Output port is disabled. </TD>

<TD/>
</TR>

<TR>
<TD>6 </TD>

<TD>stop_output </TD>

<TD>stop_output </TD>

<TD>Remain in this state until the output port stop procedure is completed. </TD>

<TD>Clear the “Port Normal” state, set the “Output Retry-stopped” state, and stop transmitting new packets. </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>stop_output </TD>

<TD>recover </TD>

<TD>Output port stop procedure is complete. </TD>

<TD/>
</TR>

<TR>
<TD>8 </TD>

<TD>recover </TD>

<TD>recover </TD>

<TD>Remain in this state until the internal recovery procedure is completed. </TD>

<TD>The packet sent with the ackID value returned in the packet-retry control symbol and all subsequent packets shall be retransmitted. Output port state machines and the outstanding ackID scoreboard shall be updated with this information, then clear the “Output Retry-stopped” state and set the “Port Normal” state to restart the output port. Receipt of a packet-not-accepted control symbol or other output port error during this procedure shall cause a clean transition between the retry recovery state machine and the error recovery state machine. Send restart-from-retry control symbol. </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>recover </TD>

<TD>wait_for_retry </TD>

<TD>Internal recovery procedure is complete. </TD>

<TD>Retransmission has started, so return to the wait_for_retry state to wait for the next packet-retry control symbol. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30904">A.3 Error Recovery </P>

<P>This section contains the error recovery state machine referred to in 
<Link>Section 5.11.2, </Link>

<Link>“Link Behavior Under Error.” </Link>
</P>

<P>Error recovery actually requires two inter-dependent state machines in order to operate, one associated with the input port and the other with the output port on the two connected devices. The two state machines work together to attempt recovery. </P>

<P id="LinkTarget_30905">A.3.1 Input port error recovery state machine </P>

<P>There are a variety of recoverable error types described in detail in 
<Link>Section 5.11.2, </Link>

<Link>“Link Behavior Under Error</Link>
”. The first group of errors are associated with the input port, and consists mostly of corrupt packet and control symbols. An example of a corrupt packet is a packet with an incorrect CRC. An example of a corrupt control symbol is a control symbol with error on the 5-bit CRC control symbol. The 
<Link>recovery state machine for the input port of a RapidIO link is shown in Figure A-3. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_159.jpg"/>
stop_input error_stopped 7 4 9 recovery_disabled 1 2 wait_for_error 3 5 8 6 reset 
<Caption>
<P>
<Link>Table A-3 describes the state transition arcs for Figure A-3. The states referenced in </Link>
the comments in quotes are the RapidIO 1x/4x LP-Serial defined status states, not states in this state machine. </P>
</Caption>
</Figure>

<P>Figure A-3. Input Port Error Recovery State Machine </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Arc </TH>

<TH>Current State </TH>

<TH>Next state </TH>

<TH>cause </TH>

<TH>Comments </TH>
</TR>

<TR>
<TD>1 </TD>

<TD>recovery_disabled </TD>

<TD>recovery_disabled </TD>

<TD>Remain in this state until error recovery is enabled. </TD>

<TD>This is the initial state after reset. Error recovery can’t be enabled before the initialization sequence has been completed, and may be controlled through other mechanisms as well, such as a software enable bit. </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>recovery_disabled </TD>

<TD>wait_for_error </TD>

<TD>Error recovery is enabled. </TD>

<TD/>
</TR>

<TR>
<TD>3 </TD>

<TD>wait_for_error </TD>

<TD>wait_for_error </TD>

<TD>Remain in this state until a recoverable error is detected. </TD>

<TD>Detected errors and the level of coverage is implementation dependent. </TD>
</TR>

<TR>
<TD>4 </TD>

<TD>wait_for_error </TD>

<TD>stop_input </TD>

<TD>A recoverable error has been detected. </TD>

<TD>An output port associated error will not cause this transition, only an input port associated error. </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>wait_for_error </TD>

<TD>recovery_disabled </TD>

<TD>Error recovery is disabled. </TD>

<TD/>
</TR>

<TR>
<TD>6 </TD>

<TD>stop_input </TD>

<TD>stop_input </TD>

<TD>Remain in this state until described input port stop activity is completed. </TD>

<TD>Send a packet-not-accepted control symbol and, if the error was on a packet, discard the packet and don’t change the expected ackID value. This will force the attached device to initiate recovery. Clear the “Port Normal” state and set the “Input Error-stopped” state. </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>stop_input </TD>

<TD>error_stopped </TD>

<TD>Input port stop activity is complete. </TD>

<TD/>
</TR>

<TR>
<TD>8 </TD>

<TD>error_stopped </TD>

<TD>error_stopped </TD>

<TD>Remain in this state until a link request (restart-from-error) control symbol is received. </TD>

<TD>The “Input Error-stopped” state causes the input port to silently discard all subsequent incoming packets and ignore all subsequent input port errors. </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>error_stopped </TD>

<TD>wait_for_error </TD>

<TD>Received a link request (restart-from-error) control symbol. </TD>

<TD>Clear the “Input Error-stopped” state and set the “Port Normal” state, which will put the input port back in normal operation. </TD>
</TR>
</Table>

<P id="LinkTarget_30906">A.3.2 Output port error recovery state machine </P>

<P>
<Link>The second recoverable group of errors described in Section 5.11.2, “Link Behavior </Link>

<Link>Under Error</Link>
” is associated with the output port, and is comprised of control symbols that are error-free and indicate that the attached input port has detected a transmission error or some other unusual situation has occurred. An example of this situation is indicated by the receipt of a packet-not-accepted control symbol. The 
<Link>state machine for the output port is shown in Figure A-4. </Link>
</P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_160.jpg"/>
stop_output fatal_error 8 4 12 recover 7 10 6 wait_for_error 3 recovery_disabled 1 2 5 9 11 reset 
<Caption>
<P>
<Link>Table A-4 describes the state transition arcs for Figure A-4. The states referenced in </Link>
the comments in quotes are the RapidIO 8/16 LP-LVDS defined status states, not states in this state machine. </P>
</Caption>
</Figure>

<P>Figure A-4. Output Port Error Recovery State Machine </P>

<Table>
<Caption>
<P>Table A-4. Output Port Error Recovery State Machine Transition Table </P>
</Caption>

<TR>
<TH>Arc </TH>

<TH>Current State </TH>

<TH>Next state </TH>

<TH>cause </TH>

<TH>Comments </TH>
</TR>

<TR>
<TD>1 </TD>

<TD>recovery_disabled </TD>

<TD>recovery_disabled </TD>

<TD>Remain in this state until error recovery is enabled. </TD>

<TD>This is the initial state after reset. Error recovery can’t be enabled before the initialization sequence has been completed, and may be controlled through other mechanisms as well, such as a software enable bit. </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>recovery_disabled </TD>

<TD>wait_for_error </TD>

<TD>Error recovery is enabled. </TD>

<TD/>
</TR>

<TR>
<TD>3 </TD>

<TD>wait_for_error </TD>

<TD>wait_for_error </TD>

<TD>Remain in this state until a recoverable error is detected. </TD>

<TD>Detected errors and the level of coverage is implementation dependent. </TD>
</TR>

<TR>
<TD>4 </TD>

<TD>wait_for_error </TD>

<TD>stop_output </TD>

<TD>A recoverable error has been detected. </TD>

<TD>An input port associated error will not cause this transition, only an output port associated error. </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>wait_for_error </TD>

<TD>recovery_disabled </TD>

<TD>Error recovery is disabled. </TD>

<TD/>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>155 </P>

<Table>
<TR>
<TH>Arc </TH>

<TH>Current State </TH>

<TH>Next state </TH>

<TH>cause </TH>

<TH>Comments </TH>
</TR>

<TR>
<TD>6 </TD>

<TD>stop_output </TD>

<TD>stop_output </TD>

<TD>Remain in this state until an exit condition occurs. </TD>

<TD>Clear the “Port Normal” state, set the “Output Error-stopped” state, stop transmitting new packets, and send a link-request/input-status control symbol. Ignore all subsequent output port errors. The input on the attached device is in the “Input Error-stopped” state and is waiting for a link-request/input-status in order to be re-enabled to receive packets. An implementation may wish to time-out several times before regarding a time-out as fatal using a threshold counter or some other mechanism. </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>stop_output </TD>

<TD>recover </TD>

<TD>The link-response is received and returned an outstanding ackID value </TD>

<TD>An outstanding ackID is a value sent out on a packet that has not been acknowledged yet. In the case where no ackID is outstanding the returned ackID value shall match the next expected/next assigned ackID value, indicating that the devices are synchronized. Recovery is possible, so follow recovery procedure. </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>stop_output </TD>

<TD>fatal_error </TD>

<TD>The link-response is received and returned an ackID value that is not outstanding, or timed out waiting for the link-response. </TD>

<TD>Recovery is not possible, so start error shutdown procedure. </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>recover </TD>

<TD>recover </TD>

<TD>Remain in this state until the internal recovery procedure is completed. </TD>

<TD>The packet sent with the ackID value returned in the link-response and all subsequent packets shall be retransmitted. All packets transmitted with ackID values preceding the returned value were received by the attached device, so they are treated as if packet-accepted control symbols have been received for them. Output port state machines and the outstanding ackID scoreboard shall be updated with this information, then clear the “Output Error-stopped” state and set the ‘Port Normal” state to restart the output port. </TD>
</TR>

<TR>
<TD>10 </TD>

<TD>recover </TD>

<TD>wait_for_error </TD>

<TD>The internal recovery procedure is complete. </TD>

<TD>retransmission (if any was necessary) has started, so return to the wait_for_error state to wait for the next error. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Arc </TH>

<TH>Current State </TH>

<TH>Next state </TH>

<TH>cause </TH>

<TH>Comments </TH>
</TR>

<TR>
<TD>11 </TD>

<TD>fatal_error </TD>

<TD>fatal_error </TD>

<TD>Remain in this state until error shutdown procedure is completed. </TD>

<TD>Clear the “Output Error-stopped” state, set the “Port Error” state, and signal a system error. </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>fatal_error </TD>

<TD>wait_for_error </TD>

<TD>Error shutdown procedure is complete. </TD>

<TD>Return to the wait_for_error state. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>157 </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30907">Annex B Critical Resource Performance Limits (Informative) </P>

<P>The RapidIO LP-Serial layer is intended for use over links whose length ranges from centimeters to tens of meters. The shortest length links will almost certainly use copper printed circuit board traces. The longer lengths will require the use of fiber optics (optical fiber and electro-optical converters) to overcome the high frequency losses of long copper printed circuit board traces or cable. The longer lengths will also have significant propagation delay which can degrade the usable bandwidth of a link. </P>

<P>The serial protocol is a handshake protocol. Each packet transmitted by a port is assigned an ID (the ackID) and a copy of the packet is retained by the port in a holding buffer until the packet is accepted by the port’s link partner. The number of packets that a port can transmit without acknowledgment is limited to the lesser of the number of distinct ackIDs and the number of buffers available to hold unacknowledged packets. Which ever is the limiting resource, ackIDs or holding buffers, will be called the “critical resource”. </P>

<P>The concern is the time between the assignment of a critical resource to a packet and the release of that resource as a consequence of the packet being accepted by the link partner. Call this time the resource_release_delay. When the resource_release_delay is less than the time it takes to transmit a number of packets equal to the number of distinct critical resource elements, there is no degradation of link performance. When the resource_release_delay is greater than the time it takes to transmit a number of packets equal to the number of distinct critical resource elements, the transmitter may have to stall from time to time waiting for a free critical resource. This will degraded the usable link bandwidth. The onset of degradation will depend on the average length of transmitted packets and the physical length of the link as reflected in the resource_release_delay. </P>

<P>The following example provides some idea of the impact on link performance of the interaction between link length and a critical resource. For purposes of this example, the following assumptions are made. </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> The link is a 4 lane (4x) link. </LI_Title>
</LI>

<LI>
<LI_Label>2.</LI_Label>

<LI_Title> The link uses optical fiber and electro-optical transceivers to allow link lengths of tens of meters. The propagation delay of the optical fiber is 0.45c. </LI_Title>
</LI>

<LI>
<LI_Label>3.</LI_Label>

<LI_Title> The width of the data path within the port is 4 bytes. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P>159 </P>

<L>
<LI>
<LI_Label>4.</LI_Label>

<LI_Title> The data path and logic within the port run at a clock rate equal to the aggregate unidirectional data rate of the link divided by 32. This is referred to as the logic clock. One cycle of this clock is referred to a one logic clock cycle. (If the aggregate unidirectional baud rate of the link was used to compute the logic clock, the baud rate would be divided by 40. With 8B/10B encoding, the baud rate is 1.25 times the data rate.) </LI_Title>
</LI>

<LI>
<LI_Label>5.</LI_Label>

<LI_Title> The minimum length packet header is used. Write request packets have a length of 12 bytes plus a payload containing an integer multiple of 8 bytes. Read request packets have a length of 12 bytes. Read response packets have a length of 8 bytes plus a payload containing an integer multiple of 8 bytes. </LI_Title>
</LI>

<LI>
<LI_Label>6.</LI_Label>

<LI_Title> The beginning and end of each packet is delimited by a control symbol. A single control symbol may delimit both the end of one packet and the beginning of the next packet. </LI_Title>
</LI>

<LI>
<LI_Label>7.</LI_Label>

<LI_Title> Packet acknowledgments are carried in packet delimiter control symbols when ever possible to achieve the efficiency provided by the dual stype control symbol. This implies that a packet acknowledgment must wait for an end-of-packet control symbol if packet transmission is in progress when the packet acknowledgment becomes available. </LI_Title>
</LI>

<LI>
<LI_Label>8.</LI_Label>

<LI_Title> The logic and propagation delay in the packet transmission direction is comprised of the following components. </LI_Title>
</LI>
</L>

<Table>
<Caption>
<P>Table B-12. Packet Transmission Delay Components </P>
</Caption>

<TR>
<TD>Item </TD>

<TD>Time required </TD>
</TR>

<TR>
<TD>Generate start-of-packet control symbol (critical resource is available) </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>Generate start-of-packet control symbol CRC </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>8B/10B encode delimiter and start-of-packet control symbol </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>Serialize and transmit delimiter and start-of-packet control symbol </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>PCB copper and electro-optical transmitter delay </TD>

<TD>2 ns </TD>
</TR>

<TR>
<TD>Optical fiber delay </TD>

<TD>fiber_length/0.45c </TD>
</TR>

<TR>
<TD>Electro-optical receiver and pcb copper delay </TD>

<TD>2 ns </TD>
</TR>

<TR>
<TD>Receive and deserialize delimiter and start-of-packet control symbol </TD>

<TD>0.5 logic clock cycles </TD>
</TR>

<TR>
<TD>Receive and deserialize packet </TD>

<TD>depends on packet </TD>
</TR>

<TR>
<TD>Receive and deserialize delimiter and end-of-packet control symbol </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>8B/10B decode delimiter and end-of-packet control symbol </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>Check CRC of end-of-packet control symbol </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>Make packet acceptance decision </TD>

<TD>1 logic clock cycle </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>9. The logic and propagation delay in the packet acknowledgment direction is comprised of the following. </P>

<Table>
<Caption>
<P>Table B-13. Packet Acknowledgment Delay Components </P>
</Caption>

<TR>
<TD>Item </TD>

<TD>Time required </TD>
</TR>

<TR>
<TD>Wait for end-of-packet if packet transmission is in progress, generate packet-acknowledgment control symbol and control symbol CRC </TD>

<TD>depends on packet &gt;= 2 logic clock cycles </TD>
</TR>

<TR>
<TD>8B/10B encode delimiter and packet-acknowledgment control symbol </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>Serialize and transmit delimiter and packet-acknowledgment control symbol </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>PCB copper and electro-optical transmitter delay </TD>

<TD>2 ns </TD>
</TR>

<TR>
<TD>Optical fiber delay </TD>

<TD>fiber_length/0.45c </TD>
</TR>

<TR>
<TD>Electro-optical receiver and pcb copper delay </TD>

<TD>2 ns </TD>
</TR>

<TR>
<TD>Receive and deserialize delimiter and packet-acknowledgment control symbol </TD>

<TD>0.5 logic clock cycles </TD>
</TR>

<TR>
<TD>8B/10B decode delimiter and packet-acknowledgment control symbol </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>Check CRC of packet-acknowledgment control symbol </TD>

<TD>1 logic clock cycle </TD>
</TR>

<TR>
<TD>Make decision to free critical resource </TD>

<TD>1 logic clock cycle </TD>
</TR>
</Table>

<P>The packet times in the above tables depend on packet length which in turn depends on packet type and payload size. Since packet traffic will typically involve a mixture of packet types and payload sizes, the traffic in each direction will be assumed to contain an equal number of read, write and response packets and average payloads of 8, 32, and 64 bytes. </P>

<P>The number of logic clock cycles required to transmit or receive a packet is given in the following table as a function of packet type and payload size. </P>

<Table>
<Caption>
<P>Table B-14. Packet Delays </P>
</Caption>

<TR>
<TH>Packet Type </TH>

<TH>Packet Header bytes </TH>

<TH>Data Payload bytes </TH>

<TH>Transmit/Receive Time logic clock cycles </TH>
</TR>

<TR>
<TH>Read </TH>

<TD>12 </TD>

<TD>0 </TD>

<TD>3 </TD>
</TR>

<TR>
<TH>Response </TH>

<TD>8 </TD>

<TD>8 </TD>

<TD>4 </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>32 </TD>

<TD>10 </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>64 </TD>

<TD>18 </TD>
</TR>

<TR>
<TH>Write </TH>

<TD>12 </TD>

<TD>8 </TD>

<TD>5 </TD>
</TR>

<TR>
<TD>32 </TD>

<TD>11 </TD>
</TR>

<TR>
<TD>64 </TD>

<TD>19 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>Using the above table and the assumed equal number of read, write and response packets, the average number of logic clock cycles to transmit or received a packet is 4, 8, and 13.3 respectively for packet payloads of 8, 32, and 64 bytes. The average wait for the completion of a packet being transmitted is assumed to be 1/2 the transmit time. </P>

<P>The following table gives the maximum length of the optical fiber before the packet transmission rate becomes limited by the critical resource for a 4x link operating at unidirectional data rates of 4.0, 8.0 and 10.0 Gb/s. </P>

<Table>
<Caption>
<P>Table B-15. Maximum Transmission Distances </P>
</Caption>

<TR>
<TH>Number of Critical Resources Available </TH>

<TH>Data Payload (Bytes) </TH>

<TH>Maximum Fiber Length Before Critical Resource Limited (Meters) </TH>
</TR>

<TR>
<TH>4.0 Gb/s link </TH>

<TH>8.0 Gb/s link </TH>

<TH>10.0 Gb/s link </TH>
</TR>

<TR>
<TH>4 </TH>

<TD>8 </TD>

<TD>-</TD>

<TD>-</TD>

<TD>-</TD>
</TR>

<TR>
<TD>32 </TD>

<TD>4.3 </TD>

<TD>1.9 </TD>

<TD>1.4 </TD>
</TR>

<TR>
<TD>64 </TD>

<TD>11.4 </TD>

<TD>5.5 </TD>

<TD>4.3 </TD>
</TR>

<TR>
<TH>8 </TH>

<TD>8 </TD>

<TD>9.7 </TD>

<TD>4.6 </TD>

<TD>3.5 </TD>
</TR>

<TR>
<TD>32 </TD>

<TD>23.6 </TD>

<TD>11.5 </TD>

<TD>9.1 </TD>
</TR>

<TR>
<TD>64 </TD>

<TD>42.2 </TD>

<TD>20.8 </TD>

<TD>16.6 </TD>
</TR>

<TR>
<TH>16 </TH>

<TD>8 </TD>

<TD>31.1 </TD>

<TD>15.3 </TD>

<TD>12.1 </TD>
</TR>

<TR>
<TD>32 </TD>

<TD>62.2 </TD>

<TD>30.8 </TD>

<TD>24.6 </TD>
</TR>

<TR>
<TD>64 </TD>

<TD>103.7 </TD>

<TD>51.6 </TD>

<TD>41.1 </TD>
</TR>

<TR>
<TH>24 </TH>

<TD>8 </TD>

<TD>52.5 </TD>

<TD>26.0 </TD>

<TD>20.7 </TD>
</TR>

<TR>
<TD>32 </TD>

<TD>100.8 </TD>

<TD>50.2 </TD>

<TD>40.0 </TD>
</TR>

<TR>
<TD>64 </TD>

<TD>165.2 </TD>

<TD>82.3 </TD>

<TD>65.7 </TD>
</TR>

<TR>
<TH>32 </TH>

<TD>8 </TD>

<TD>74.0 </TD>

<TD>36.7 </TD>

<TD>29.3 </TD>
</TR>

<TR>
<TD>32 </TD>

<TD>139.5 </TD>

<TD>69.5 </TD>

<TD>55.5 </TD>
</TR>

<TR>
<TD>64 </TD>

<TD>226.7 </TD>

<TD>113.1 </TD>

<TD>90.3 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30908">Annex C Manufacturability and Testability (Informative) </P>

<P>It is not possible in many cases for assembly vendors to verify the integrity of soldered connections between components and the printed circuit boards to which they are attached. Alternative methods to direct probing are needed to insure high yields for printed circuit assemblies which include LP-Serial RapidIO devices. </P>

<P>It is recommended that component vendors support IEEE Std. 1149.6 (commonly known as “AC-JTAG”) on all connections to LP-Serial RapidIO links. (Note: IEEE Std. 1149.6 is needed, in addition to IEEE Std. 1149.1, due the fact that RapidIO LP-Serial lanes are AC-coupled.) This provides boundary scan capability on all TD, TDN, RD, and RDN pins on a component which supports one or more LP-Serial RapidIO ports. </P>

<P>The IEEE Std. 1149.6 is available from the IEEE. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30909">Glossary of Terms and Abbreviations 
</P>

<Table>
<TR>
<TH>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </TH>
</TR>

<TR>
<TH>A </TH>

<TD>AC Coupling. A method of connecting two devices together that does not pass DC. Agent. A processing element that provides services to a processor. ANSI. American National Standards Institute. </TD>
</TR>

<TR>
<TH>B </TH>

<TD>Big-endian. A byte-ordering method in memory where the address n of a word corresponds to the most significant byte. In an addressed memory word, the bytes are ordered (left to right) 0, 1, 2, 3, with 0 being the most significant byte. Bridge. A processing element that connects one computer bus to another, allowing a processing element on one bus to access an processing element on the other. </TD>
</TR>

<TR>
<TH>C </TH>

<TD>Capability registers (CARs). A set of read-only registers that allow a processing element to determine another processing element’s capabilities. Code-group. A 10-bit entity produced by the 8B/10B encoding process and the input to the 8B/10B decoding process. Command and status registers (CSRs). A set of registers that allow a processing element to control and determine the status of another processing element’s internal hardware. Control symbol. A quantum of information transmitted between two linked devices to manage packet flow between the devices. CRC. Cyclic redundancy code </TD>
</TR>

<TR>
<TH>D </TH>

<TD>Deadlock. A situation in which two processing elements that are sharing resources prevent each other from accessing the resources, resulting in a halt of system operation. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>Deferred or delayed transaction. The process of the target of a transaction capturing the transaction and completing it after responding to the the source with a retry. </P>

<P>Destination. The termination point of a packet on the RapidIO interconnect, also referred to as a target. </P>

<P>Device. A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a processing element. </P>

<P>Device ID. The identifier of a processing element connected to the RapidIO interconnect. </P>

<P>Direct Memory Access (DMA). A process element that can independently read and write system memory. </P>

<P>Distributed memory. System memory that is distributed throughout the system, as opposed to being centrally located. </P>

<P>Double word. An eight byte quantity, aligned on eight byte boundaries. </P>

<P>E 
</P>

<P>EMI. Electromagnetic Interference. </P>

<P>End point. A processing element which is the source or destination of transactions through a RapidIO fabric. </P>

<P>End point device. A processing element which contains end point functionality. </P>

<P>End point free device. A processing element which does not contain end </P>

<P>point functionality. </P>

<P>Ethernet. A common local area network (LAN) technology. </P>

<P>External processing element. A processing element other than the </P>

<P>processing element in question. </P>

<P>F 
</P>

<P>Fabric. A series of interconnected switch devices, typically used in reference to a switch fabric. </P>

<P>Field or Field name. A sub-unit of a register, where bits in the register are named and defined. </P>

<P>FIFO. First in, first out. </P>

<P>Full-duplex. Data can be transmitted in both directions between connected processing elements at the same time. </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification Rev. 1.3 </TH>
</TR>

<TR>
<TH>G </TH>

<TD>Globally shared memory (GSM). Cache coherent system memory that can be shared between multiple processors in a system. </TD>
</TR>

<TR>
<TH>H </TH>

<TD>Half-word. A two byte or 16-bit quantity, aligned on two byte boundaries. Header. Typically the first few bytes of a packet, containing control information. </TD>
</TR>
</Table>

<P>Initiator. The origin of a packet on the RapidIO interconnect, also referred to as a source. </P>

<P>I/O. Input-output. </P>

<P>IP. Intellectual Property </P>

<P>ITU. International Telecommunication Union. </P>

<P>Little-endian. A byte-ordering method in memory where the address n of a word corresponds to the least significant byte. In an addressed memory word, the bytes are ordered (left to right) 3, 2, 1, 0, with 3 being the most significant byte. </P>

<P>Local memory. Memory associated with the processing element in question. </P>

<P>LP. Link Protocol </P>

<P>LSB. Least significant byte. </P>

<P>LVDS. Low voltage differential signaling. </P>

<P>M 
</P>

<P>Message passing. An application programming model that allows processing elements to communicate through special hardware instead of through memory as with the globally shared memory programming model. </P>

<P>MSB. Most significant byte. </P>

<Table>
<TR>
<TD>N </TD>

<TD>Non-coherent. A transaction that does not participate in any system globally shared memory cache coherence mechanism. </TD>
</TR>

<TR>
<TD>O </TD>

<TD>Operation. A set of transactions between end point devices in a RapidIO system (requests and associated responses) such as a read or a write. </TD>
</TR>
</Table>

<P>P Packet. A set of information transmitted between devices in a RapidIO system. </P>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification Rev. 1.3 Payload. The user data embedded in the RapidIO packet. PCB. Printed circuit board. PCS. Physical Coding Sublayer. PMA. Physical Media Attachment. Port-write. An address-less write operation. Priority. The relative importance of a transaction or packet; in most systems a higher priority transaction or packet will be serviced or transmitted before one of lower priority. Processing Element (PE). A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a device. Processor. The logic circuitry that responds to and processes the basic instructions that drive a computer. </P>

<P>R Receiver. The RapidIO interface input port on a processing element. </P>

<P>S 
</P>

<P>Sender. The RapidIO interface output port on a processing element. </P>

<P>Semaphore. A technique for coordinating activities in which multiple processing elements compete for the same resource. </P>

<P>Serializer. A device which converts parallel data (such as 8-bit data) to a single bit-wide datastream. </P>

<P>Source. The origin of a packet on the RapidIO interconnect, also referred to </P>

<P>as an initiator. SRAM. Static random access memory. Switch. A multiple port processing element that directs a packet received on </P>

<P>one of its input ports to one of its output ports. </P>

<P>T 
</P>

<P>Target. The termination point of a packet on the RapidIO interconnect, also referred to as a destination. </P>

<P>Transaction. A specific request or response packet transmitted between end point devices in a RapidIO system. </P>

<P>Transaction request flow. A sequence of transactions between two processing elements that have a required completion order at the destination processing element. There are no ordering requirements between transaction request flows. </P>

<P>RapidIO Trade Association </P>

<P>Word. A four byte or 32 bit quantity, aligned on four byte boundaries. </P>

<P>W </P>

<P>Write port. Hardware within a processing element that is the target of a port-write operation. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30910">RapidIOTM Interconnect SpecificationPart 7: System and DeviceInter-operability Specification </P>

<P>Rev. 1.3, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_0.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>
</TR>

<TR>
<TH>1.1 </TH>

<TH>First public release </TH>

<TD>04/06/2001 </TD>
</TR>

<TR>
<TH>1.2 </TH>

<TH>Technical changes: incorporate Rev. 1.1 errata rev. 1.1.1, errata 3 </TH>

<TD>06/26/2002 </TD>
</TR>

<TR>
<TH>1.3 </TH>

<TH>Technical changes: incorporate Rev 1.2 errata 1 as applicable, the following errata showings: 004-05-00002.002 Converted to ISO-friendly templates </TH>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TH>1.3 </TH>

<TH>Removed confidentiality markings for public release </TH>

<TD>06/07/2005 </TD>
</TR>
</Table>

<P>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE 
ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND 
CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO 
WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.  USER AGREES TO 
ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE 
GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR 
RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER 
SUCH USE OF THE SPECIFICATION. 
</P>

<P>DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, 
INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST 
PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION 
WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE 
RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. 
</P>

<P>Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: 
RapidIO Trade Association 
Suite 325, 3925 W. Braker Lane 
Austin, TX 78759 
512-305-0070 Tel. 
512-305-0009 FAX. 
</P>

<P>RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their 
respective owners. 
</P>

<P>RapidIO Trade Association RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 1 Overview </Link>
</P>

<P>
<Link>1.1 Introduction........................................................................................................... 11 
</Link>
</P>

<P>
<Link>1.2 Overview............................................................................................................... 11 
</Link>
</P>

<P>
<Link>Chapter 2 System Exploration and Initialization </Link>
</P>

<P>
<Link>2.1 Introduction........................................................................................................... 13 
</Link>
</P>

<P>
<Link>2.2 Boot code access ................................................................................................... 13 
</Link>
</P>

<P>
<Link>2.3 Exploration and initialization................................................................................ 15 
</Link>
</P>

<P>
<Link>2.3.1 Exploration and initialization rules ................................................................... 15 
</Link>
</P>

<P>
<Link>2.3.2 Exploration and initialization algorithm ........................................................... 16 
</Link>
</P>

<P>
<Link>2.3.3 Exploration and initialization example ............................................................. 16 
</Link>
</P>

<P>
<Link>Chapter 3 RapidIO Device Class Requirements </Link>
</P>

<P>
<Link>3.1 Introduction........................................................................................................... 21 
</Link>
</P>

<P>
<Link>3.2 Class Partitioning .................................................................................................. 21 
</Link>
</P>

<P>
<Link>3.2.1 Generic: All devices.......................................................................................... 21 
</Link>
</P>

<P>
<Link>3.2.1.1 General requirements .................................................................................... 21 
</Link>
</P>

<P>
<Link>3.2.1.2 Operation support as target ........................................................................... 22 
</Link>
</P>

<P>
<Link>3.2.1.3 Operation support as source.......................................................................... 23 
</Link>
</P>

<P>
<Link>3.2.2 Class 1: Simple target device ............................................................................ 23 
</Link>
</P>

<P>
<Link>3.2.2.1 General requirements .................................................................................... 23 
</Link>
</P>

<P>
<Link>3.2.2.2 Operation support as target ........................................................................... 23 
</Link>
</P>

<P>
<Link>3.2.2.3 Operation support as source.......................................................................... 23 
</Link>
</P>

<P>
<Link>3.2.3 Class 2: Simple mastering device ..................................................................... 23 
</Link>
</P>

<P>
<Link>3.2.3.1 General requirements .................................................................................... 23 
</Link>
</P>

<P>
<Link>3.2.3.2 Operation support as target ........................................................................... 23 
</Link>
</P>

<P>
<Link>3.2.3.3 Operation support as source.......................................................................... 24 
</Link>
</P>

<P>
<Link>3.2.4 Class 3: Complex mastering device.................................................................. 24 
</Link>
</P>

<P>
<Link>3.2.4.1 General requirements .................................................................................... 24 
</Link>
</P>

<P>
<Link>3.2.4.2 Operation support as target ........................................................................... 24 
</Link>
</P>

<P>
<Link>3.2.4.3 Operation support as source.......................................................................... 25 
</Link>
</P>

<P>
<Link>Chapter 4 PCI Considerations </Link>
</P>

<P>
<Link>4.1 Introduction........................................................................................................... 27 
</Link>
</P>

<P>
<Link>4.2 Address Map Considerations ................................................................................ 28 
</Link>
</P>

<P>
<Link>4.3 Transaction Flow .................................................................................................. 29 
</Link>
</P>

<P>
<Link>4.3.1 PCI 2.2 Transaction Flow ................................................................................. 29 
</Link>
</P>

<P>
<Link>4.3.2 PCI-X Transaction Flow ................................................................................... 32 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>4.4 RapidIO to PCI Transaction Mapping .................................................................. 33 
</Link>
</P>

<P>
<Link>4.5 Operation Ordering and Transaction Delivery ..................................................... 35 
</Link>
</P>

<P>
<Link>4.5.1 Operation Ordering ........................................................................................... 35 
</Link>
</P>

<P>
<Link>4.5.2 Transaction Delivery Ordering ......................................................................... 36 
</Link>
</P>

<P>
<Link>4.5.3 PCI-X Relaxed Ordering Considerations ......................................................... 36 
</Link>
</P>

<P>
<Link>4.6 Interactions with Globally Shared Memory.......................................................... 37 
</Link>
</P>

<P>
<Link>4.6.1 I/O Read Operation Details............................................................................... 40 
</Link>
</P>

<P>
<Link>4.6.1.1 Internal Request State Machine .................................................................... 40 
</Link>
</P>

<P>
<Link>4.6.1.2 Response State Machine ............................................................................... 40 
</Link>
</P>

<P>
<Link>4.6.2 Data Cache Flush Operation Details................................................................. 41 
</Link>
</P>

<P>
<Link>4.6.2.1 Internal Request State Machine .................................................................... 41 
</Link>
</P>

<P>
<Link>4.6.2.2 Response State Machine ............................................................................... 41 
</Link>
</P>

<P>
<Link>4.7 Byte Lane and Byte Enable Usage ....................................................................... 41 
</Link>
</P>

<P>
<Link>4.8 Error Management ................................................................................................ 41 
</Link>
</P>

<P>
<Link>Chapter 5 Globally Shared Memory Devices </Link>
</P>

<P>
<Link>5.1 Introduction........................................................................................................... 43 
</Link>
</P>

<P>
<Link>5.2 Processing Element Behavior ............................................................................... 43 
</Link>
</P>

<P>
<Link>5.2.1 Processor-Memory Processing Element ........................................................... 44 
</Link>
</P>

<P>
<Link>5.2.1.1 I/O Read Operations ..................................................................................... 44 
</Link>
</P>

<P>
<Link>5.2.1.1.1 Response State Machine ........................................................................... 44 
</Link>
</P>

<P>
<Link>5.2.1.1.2 External Request State Machine ............................................................... 45 
</Link>
</P>

<P>
<Link>5.2.2 Memory-only Processing Element.................................................................... 46 
</Link>
</P>

<P>
<Link>5.2.2.1 Read Operations............................................................................................ 46 
</Link>
</P>

<P>
<Link>5.2.2.1.1 Response State Machine ........................................................................... 46 
</Link>
</P>

<P>
<Link>5.2.2.1.2 External Request State Machine ............................................................... 46 
</Link>
</P>

<P>
<Link>5.2.2.2 Instruction Read Operations ......................................................................... 47 
</Link>
</P>

<P>
<Link>5.2.2.2.1 Response State Machine ........................................................................... 47 
</Link>
</P>

<P>
<Link>5.2.2.2.2 External Request State Machine ............................................................... 48 
</Link>
</P>

<P>
<Link>5.2.2.3 Read for Ownership Operations ................................................................... 48 
</Link>
</P>

<P>
<Link>5.2.2.3.1 Response State Machine ........................................................................... 48 
</Link>
</P>

<P>
<Link>5.2.2.3.2 External Request State Machine ............................................................... 49 
</Link>
</P>

<P>
<Link>5.2.2.4 Data Cache and Instruction Cache Invalidate Operations ............................ 50 
</Link>
</P>

<P>
<Link>5.2.2.4.1 Response State Machine ........................................................................... 50 
</Link>
</P>

<P>
<Link>5.2.2.4.2 External Request State Machine ............................................................... 50 
</Link>
</P>

<P>
<Link>5.2.2.5 Castout Operations........................................................................................ 51 
</Link>
</P>

<P>
<Link>5.2.2.5.1 External Request State Machine ............................................................... 51 
</Link>
</P>

<P>
<Link>5.2.2.6 Data Cache Flush Operations ....................................................................... 51 
</Link>
</P>

<P>
<Link>5.2.2.6.1 Response State Machine ........................................................................... 51 
</Link>
</P>

<P>
<Link>5.2.2.6.2 External Request State Machine ............................................................... 52 
</Link>
</P>

<P>
<Link>5.2.2.7 I/O Read Operations ..................................................................................... 53 
</Link>
</P>

<P>
<Link>5.2.2.7.1 Response State Machine ........................................................................... 53 
</Link>
</P>

<P>
<Link>5.2.2.7.2 External Request State Machine ............................................................... 53 
</Link>
</P>

<P>
<Link>5.2.3 Processor-only Processing Element .................................................................. 55 
</Link>
</P>

<P>
<Link>5.2.3.1 Read Operations............................................................................................ 55 
</Link>
</P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>Table of Contents 
</P>

<P>
<Link>5.2.3.1.1 Internal Request State Machine ................................................................ 55 
</Link>
</P>

<P>
<Link>5.2.3.1.2 Response State Machine ........................................................................... 55 
</Link>
</P>

<P>
<Link>5.2.3.1.3 External Request State Machine ............................................................... 56 
</Link>
</P>

<P>
<Link>5.2.3.2 Instruction Read Operations ......................................................................... 56 
</Link>
</P>

<P>
<Link>5.2.3.2.1 Internal Request State Machine ................................................................ 56 
</Link>
</P>

<P>
<Link>5.2.3.2.2 Response State Machine ........................................................................... 56 
</Link>
</P>

<P>
<Link>5.2.3.2.3 External Request State Machine ............................................................... 57 
</Link>
</P>

<P>
<Link>5.2.3.3 Read for Ownership Operations ................................................................... 58 
</Link>
</P>

<P>
<Link>5.2.3.3.1 Internal Request State Machine ................................................................ 58 
</Link>
</P>

<P>
<Link>5.2.3.3.2 Response State Machine ........................................................................... 58 
</Link>
</P>

<P>
<Link>5.2.3.3.3 External Request State Machine ............................................................... 58 
</Link>
</P>

<P>
<Link>5.2.3.4 Data Cache and Instruction Cache Invalidate Operations ............................ 59 
</Link>
</P>

<P>
<Link>5.2.3.4.1 Internal Request State Machine ................................................................ 59 
</Link>
</P>

<P>
<Link>5.2.3.4.2 Response State Machine ........................................................................... 59 
</Link>
</P>

<P>
<Link>5.2.3.4.3 External Request State Machine ............................................................... 60 
</Link>
</P>

<P>
<Link>5.2.3.5 Castout Operations........................................................................................ 60 
</Link>
</P>

<P>
<Link>5.2.3.5.1 Internal Request State Machine ................................................................ 60 
</Link>
</P>

<P>
<Link>5.2.3.5.2 Response State Machine ........................................................................... 60 
</Link>
</P>

<P>
<Link>5.2.3.6 TLB Invalidate Entry, TLB Invalidate Entry Synchronize Operations ........ 61 
</Link>
</P>

<P>
<Link>5.2.3.6.1 Internal Request State Machine ................................................................ 61 
</Link>
</P>

<P>
<Link>5.2.3.6.2 Response State Machine ........................................................................... 61 
</Link>
</P>

<P>
<Link>5.2.3.6.3 External Request State Machine ............................................................... 61 
</Link>
</P>

<P>
<Link>5.2.3.7 Data Cache Flush Operations ....................................................................... 61 
</Link>
</P>

<P>
<Link>5.2.3.7.1 Internal Request State Machine ................................................................ 61 
</Link>
</P>

<P>
<Link>5.2.3.7.2 Response State Machine ........................................................................... 62 
</Link>
</P>

<P>
<Link>5.2.3.7.3 External Request State Machine ............................................................... 62 
</Link>
</P>

<P>
<Link>5.2.3.8 I/O Read Operations ..................................................................................... 62 
</Link>
</P>

<P>
<Link>5.2.3.8.1 External Request State Machine ............................................................... 62 
</Link>
</P>

<P>
<Link>5.2.4 I/O Processing Element .................................................................................... 64 
</Link>
</P>

<P>
<Link>5.2.4.1 I/O Read Operations ..................................................................................... 64 
</Link>
</P>

<P>
<Link>5.2.4.1.1 Internal Request State Machine ................................................................ 64 
</Link>
</P>

<P>
<Link>5.2.4.1.2 Response State Machine ........................................................................... 64 
</Link>
</P>

<P>
<Link>5.2.4.2 Data Cache Flush Operations ....................................................................... 64 
</Link>
</P>

<P>
<Link>5.2.4.2.1 Internal Request State Machine ................................................................ 65 
</Link>
</P>

<P>
<Link>5.2.4.2.2 Response State Machine ........................................................................... 65 
</Link>
</P>

<P>
<Link>5.2.5 Switch Processing Element............................................................................... 65 
</Link>
</P>

<P>
<Link>5.3 Transaction to Priority Mappings ......................................................................... 65 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>Blank page </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>List of Figures 
</P>

<P>
<Link>2-1 Example system with boot ROM ....................................................................................14 
</Link>

<Link>2-2 Automatically finding the boot ROM .............................................................................14 
</Link>

<Link>2-3 Example system ..............................................................................................................16 
</Link>

<Link>2-4 Finding the adjacent device ............................................................................................17 
</Link>

<Link>2-5 Finding the device on switch port 0 ................................................................................18 
</Link>

<Link>2-6 Finding the device on switch port 1 ................................................................................18 
</Link>

<Link>2-7 Finding the device on switch port 3 ................................................................................19 
</Link>

<Link>2-8 Final initialized system state ...........................................................................................19 
</Link>

<Link>4-1 Example System with PCI and RapidIO.........................................................................27 
</Link>

<Link>4-2 Host segment PCI Memory Map Example .....................................................................28 
</Link>

<Link>4-3 AMT and Memory Mapping...........................................................................................29 
</Link>

<Link>4-4 PCI Mastered Posted Write Transaction Flow Diagram ................................................30 
</Link>

<Link>4-5 PCI Mastered non-posted (delayed) Transaction Flow Diagram ...................................31 
</Link>

<Link>4-6 RapidIO Mastered Transaction .......................................................................................32 
</Link>

<Link>4-7 PCI-X Mastered Split Response Transaction .................................................................33 
</Link>

<Link>4-8 Traditional Non-coherent I/O Access Example ..............................................................37 
</Link>

<Link>4-9 Traditional Globally Coherent I/O Access Example ......................................................38 
</Link>

<Link>4-10 RapidIO Locally Coherent I/O Access Example ............................................................39 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>Blank page </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>List of Tables </P>

<P>
<Link>4-1 PCI 2.2 to RapidIO Transaction Mapping ......................................................................33 
</Link>

<Link>4-2 PCI-X to RapidIO Transaction Mapping ........................................................................34 
</Link>

<Link>4-3 Packet priority assignments for PCI ordering .................................................................36 
</Link>

<Link>4-4 Packet priority assignments for PCI-X ordering.............................................................37 
</Link>

<Link>5-1 Transaction to Priority Mapping ....................................................................................66 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>Blank page </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_30911">Chapter 1 Overview </P>

<P id="LinkTarget_30912">1.1 Introduction </P>

<P>This chapter provides an overview of the RapidIO Part 7: System and Device Inter-operability Specification document. This document assumes that the reader is familiar with the RapidIO specifications, conventions, and terminology. </P>

<P id="LinkTarget_30913">1.2 Overview </P>

<P>The RapidIO Architectural specifications set a framework to allow a wide variety of 
implementations. This document provides a standard set of device and system 
design solutions to provide for inter-operability. 
</P>

<P>Each chapter addresses a different design topic. This revision of the system and 
device inter-operability specification document covers the following issues: 

<Link>Chapter 2, “System Exploration and Initialization” 
</Link>

<Link>Chapter 3, “RapidIO Device Class Requirements” 
</Link>

<Link>Chapter 4, “PCI Considerations” 
</Link>

<Link>Chapter 5, “Globally Shared Memory Devices” 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_30914">Chapter 2 System Exploration and Initialization </P>

<P id="LinkTarget_30915">2.1 Introduction </P>

<P>There are several basic ways of exploring and initializing a RapidIO system. The simplest method is to somehow define the power-up state of the system components such that all devices have adequate knowledge of the rest of the system to communicate as needed. This is frequently accomplished by shifting initialization information into all of the devices in the machine at boot time from serial ROMs or similar devices. This method is most applicable for relatively static systems and systems where boot-up time is important. A second method, having processors explore and configure the system at boot time, requires more time but is much more flexible in order to support relatively fast changing plug-and-play or hot-swap systems. This document describes a simple form of this second method. A much more detailed multiple host exploration and configuration algorithm utilizing the same system reset requirements is specified in the RapidIO Interconnect Specification Annex 1: Software/System Bring Up Specification. </P>

<P id="LinkTarget_30916">2.2 Boot code access </P>

<P>In most RapidIO applications system initialization requires software for exploring and initializing devices. This is typically done by a processor or set of processors in the system. The boot code for the processor(s) may reside in a ROM local to the processor(s) or on a remote RapidIO agent device. A method of accessing the boot code through an uninitialized system is required if the boot code is located on a remote RapidIO agent device. </P>

<P>After resetting, a processor typically vectors to a fixed address and issues a code fetch. The agent hardware between the processor and the RapidIO fabric is required to take this read request and map it automatically to a NREAD transaction. The transaction is also mapped to a dedicated device ID at the proper address offset to find the boot code. All devices between the processor and the agent device where the boot ROM resides shall default to a state that will route the NREAD transaction to the boot ROM device and route the response back to the processor. The device ID for the agent device where the boot ROM resides is device ID=0xFE (0x00FE for 16-bit device IDs). The processor default device IDs are assigned sequentially starting at 0x00 (0x0000 for 16-bit device IDs). </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_161.jpg"/>
Processor Switch AgentAgent Agent Port 0 Port 1 Port 2 Port 3 device ID=0x?? device ID=0xFE device ID=0x?? device ID=0x?? boot ROM </Figure>

<P>Figure 2-1. Example system with boot ROM </P>

<P>
<Link>Figure 2-1 shows an example system with the boot ROM residing on an Agent </Link>
device. The default routing state for the switch device between the processor and the agent shall allow all requests to device ID=0xFE to get to the agent device and all response packets to get from the agent device back to the processor. This means that the switch may also have to know the device ID that the processor will be using while fetching boot code (processor device IDs are assigned starting at 0x00 as 
<Link>described above). For the example in Figure 2-2, the system processor defaults to </Link>
device ID=0x00, and the switch’s default state routes device ID=0x00 to port 2. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_162.jpg"/>
Processor Switch AgentAgent Agent Port 0 Port 1 Port 2 Port 3 device ID=0x00 device ID=0xFE device ID=0x?? device ID=0x?? boot ROM RequestResponse </Figure>

<P>Figure 2-2. Automatically finding the boot ROM </P>

<P>Once the processor is able to begin running boot code, it can begin executing the exploration and initialization of the rest of the system. </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_30917">2.3 Exploration and initialization </P>

<P>This example algorithm addresses the simple case of a system with a single processor that is responsible for exploring and initializing a system, termed a Host. The exploration and initialization process starts with a number of rules that the component and system designers shall follow. </P>

<P id="LinkTarget_30918">2.3.1 Exploration and initialization rules </P>

<L>
<LI>
<LI_Label>1. </LI_Label>

<LI_Title>A Host shall be able to “reach” all agent devices that it is to be responsible for. This may require mechanisms to generate third party transactions to reach devices that are not transparently visible. </LI_Title>
</LI>

<LI>
<LI_Label>2. </LI_Label>

<LI_Title>Maintenance responses generated by agent and switch devices shall be sent to the port that the maintenance request was received on. For example, consider a device that implements a 5 port switch. The system Host issues a maintenance read request to the switch device, which is received on input port 3. The switch, upon generating the maintenance response to the maintenance read request, must route it to output port 3 even though the switch may have been configured by default to route the response to a port other than port 3 (when the switch is configured it should also route the response to port 3). </LI_Title>
</LI>

<L>
<LI>
<LI_Label>3. </LI_Label>

<LI_Title>All devices have CSRs to assist with exploration and initialization procedures. The registers used in this example contain the following information: </LI_Title>
</LI>

<L>
<LI>
<LI_Label>– </LI_Label>

<LI_Title>Base device ID register - This is the default device ID for the device, and it resides in a standard register in the CSR space at offset 0x60. At power-up, the base device ID defaults to logic 0xFF for all agent devices (0xFFFF for 16-bit route fields), with the exception of the boot code device and the Host device. The boot code device (if present) will have it’s device ID default to 0xFE and the Host device 
<Link>will have it’s device ID default to 0x00 as described in Section 2.2. A </Link>
device may have multiple device IDs, but only this architecturally defined device ID is used in the exploration and initialization procedure. </LI_Title>
</LI>

<LI>
<LI_Label>– </LI_Label>

<LI_Title>Master Enable bit - the Master Enable bit is reset at power-up for agent devices and set for Host devices. The Master Enable bit is located in the RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification or the RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification Port General Control CSR at block offset 0x3C. If the Master Enable bit is clear the agent device is not allowed to issue requests and is only able to respond to received requests. This bit is used by the system Host to control when agents are allowed to issue transactions into the system. Switches are by default enabled and do not have a Master Enable bit. </LI_Title>
</LI>

<LI>
<LI_Label>–</LI_Label>

<LI_Title> Discovered bit - the Discovered bit is reset at power-up for agent devices and set for the Host device, and is located in the 8/16 LP-LVDS or 1x/4x LP-Serial physical layer Port General Control </LI_Title>
</LI>
</L>
</L>
</L>

<P>RapidIO Trade Association </P>

<P>CSR at block offset 0x3C. The system Host device sets this bit when the device has been discovered through the exploration mechanism. The Discovered bit is useful for detecting routing loops, and for hot plug or swap environments. </P>

<P id="LinkTarget_30919">2.3.2 Exploration and initialization algorithm </P>

<P>If the above rules are followed, all agent devices are now accessible either as an end point that responds to any maintenance transaction or, for switches, via the hop_count mechanism. </P>

<P>The basic algorithm is to explore the system through each end point in sequence by first locating the adjacent device by sending a maintenance read to device ID=0xFF and hop count= 0x00, which is guaranteed to cause the adjacent device to respond. That device is then configured to reach the next device by assigning it a unique base device ID other than 0xFF, setting up route tables to reach the next device, etc. </P>

<P>When all devices in the system have been identified and have unique base device IDs assigned (no devices have a base device ID value=0xFF), the Host can then complete the final device ID assignment and configuration required for the application and enable agent devices to issue requests. </P>

<P id="LinkTarget_30920">2.3.3 Exploration and initialization example </P>

<P>
<Link>Figure 2-3 shows the previous example of a small single Host system. </Link>
</P>

<P>Following the rules defined above, the base device ID value for all devices except the Host and boot ROM device after reset is applied is 0xFF, the Host has it’s Master Enable and Discovered bits set, and the agent devices have their Master Enable and Discovered bits cleared. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_163.jpg"/>
Host Switch AgentAgent Agent Port 0 Port 1 Port 2 Port 3 device ID=0x00 device ID=0xFE device ID=0xFF device ID=0xFF boot ROM </Figure>

<P>Figure 2-3. Example system </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>Assigning the Host’s base device ID=0x00 is the first step in the process. The next step is to find the adjacent device, so the Host sends a maintenance read of offset 0x00_0000 to device ID=0xFF and hop_count=0x00. The switch consumes the request because the hop_count field is equal to zero and responds by sending the contents of it’s Device Identity and Information CARs back to the port the request came from. From the returned information, the software on the Host can identify this as a switch. The Host then reads the switch port information CAR at offset 0x00_0014 to find out which port it is connected to. The response indicates a 4 port switch (which the Host may have already known from the device information register), connected to port 2. </P>

<P>The Host then examines the default routing tables for the switch to find the port route for the boot device ID=0xFE so it can preserve the path to the boot code (which it may still be running), and discovers that the boot device is located through port 1 of the switch. It also sets the switch’s Discovered bit. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_164.jpg"/>
Host Switch AgentAgent Agent Port 0 Port 1 Port 2 Port 3 RequestResponse device ID=0x00 device ID=0xFE device ID=0xFF device ID=0xFF boot ROM </Figure>

<P>Figure 2-4. Finding the adjacent device </P>

<P>The next step is for the Host to configure the switch to route device ID=0xFF to port 0 and device ID=0x00 to port 2 (which it already was because of the boot device in the system) via maintenance write requests to hop_count=0x00. The Host then issues another maintenance read request, this time to device ID=0xFF and hop_count=0x01. The switch discovers that it is not the final destination of the maintenance request packet, so it decrements the hop_count and routes the packet to port 0 and on to the attached agent device. The agent device responds, and the switch routes the response packet to device ID=0x00 back through port 2 to the Host. Again, software identifies the device, sets its Discovered bit, configures it as required, and assigns the base device ID=0x01. </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_165.jpg"/>
Host Switch AgentAgent Agent Port 0 Port 1 Port 2 Port 3 RequestResponse base device ID=0x00 base device ID=0xFE device ID=0xFF base device ID=0xFF boot ROM </Figure>

<P>Figure 2-5. Finding the device on switch port 0 </P>

<P>The Host then modifies the routing tables to now route device ID=0x01 to port 0. Since the boot device is located through port 1, instead of modifying the routing tables to route device ID=0xFF to port 1, the Host issues a maintenance read of device ID=0xFE (the boot device) and hop_count=0x01. The response identifies the agent on port 1, sets the agent’s Discovered bit, and configures it as necessary, leaving the base device ID=0xFE so the Host can continue to execute the boot code. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_166.jpg"/>
Host Switch AgentAgent Agent Port 0 Port 1 Port 2 Port 3 RequestResponse base device ID=0x00 base device ID=0xFE base device ID=0xFF base device ID=0x01 boot ROM </Figure>

<P>Figure 2-6. Finding the device on switch port 1 </P>

<P>For the next iteration, the Host sets the switch device routing table entry for device ID=0xFF to route to port 3 (the Host already knows it is directly connected to port 2), and issues the maintenance read transaction as before. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_167.jpg"/>
Host Switch AgentAgent Agent Port 0 Port 1 Port 2 Port 3 RequestResponse base device ID=0x00 base device ID=0xFE base device ID=0xFF base device ID=0x01 boot ROM </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_168.jpg"/>
Host Switch AgentAgent Agent Port 0 Port 1 Port 2 Port 3 base device ID=0x00 base device ID=0x04 base device ID=0x02 base device ID=0x01 boot ROM </Figure>

<P>base device ID Lock Register and the Component Tag Register in standard registers in the CSR space at offsets 0x68 and 0x6C. </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_30921">Chapter 3  RapidIO Device Class Requirements </P>

<P id="LinkTarget_30922">3.1 Introduction </P>

<P>The RapidIO Architecture specifications allow for a variety of implementations. In order to form standard points of support for RapidIO, this chapter describes the requirements for RapidIO devices adhering to the RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification or the RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification and corresponding to different measures of functionality. Three device “classes” are defined, each with a minimum defined measure of support. The first class defines the functionality of the least capable device, with subsequent classes expanding the measure of support, in order to establish levels of inter-operability. </P>

<P id="LinkTarget_30923">3.2 Class Partitioning </P>

<P>Each class includes the functionality defined in all previous class devices and defines the minimum additional functionality for that class. A device is not required to comply exactly with a class, but may optionally supply additional features as a value-add for that device. All functions that are not required in any class list are also optional value-adds for a device. </P>

<P>First is a set of requirements that are applicable to all RapidIO compliant devices, including switch devices without end point functionality. </P>

<P id="LinkTarget_30924">3.2.1 Generic: All devices </P>

<P id="LinkTarget_30925">3.2.1.1 General requirements </P>

<L>
<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>One or more 8/16 LP-LVDS and/or 1x/4x LP-Serial ports </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification and/or RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for small (8-bit) transport device ID fields </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 3: Common Transport Specification, Section 1.3) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for recovery from a single corrupt packet or control symbol </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification, Section 1.3.5) and/or RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification, Section 5.10.2) </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for packet retry protocol </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P>— (refer to RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification, Section 1.2.4) and/or RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification, Section 5.6) </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for throttle based flow control on 8/16 LP-LVDS physical layer ports </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification, Section 2.3) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for transaction ordering for flowID B </LI_Title>
</LI>

<L>
<LI>
<LI_Label>— </LI_Label>

<LI_Title>(end point programmability for all flow levels is recommended) </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> (refer to RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification, Section 1.2.2) and/or RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification, Section 5.3.3) </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Switch devices maintain error coverage internally </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification, Section 1.3.6) and/or RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification, Section 5.5) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for maximum size (276 byte) packets for switch devices </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification, Section 1.4) and/or RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification, Section 2.4) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for maximum size (256 byte) data payloads for end point devices </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 3.1.2) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Device must contain the following registers: </LI_Title>
</LI>

<L>
<LI>
<LI_Label>– </LI_Label>

<LI_Title>Device Identity CAR </LI_Title>
</LI>

<LI>
<LI_Label>–</LI_Label>

<LI_Title> Device Information CAR </LI_Title>
</LI>

<LI>
<LI_Label>–</LI_Label>

<LI_Title> Assembly Identity CAR </LI_Title>
</LI>

<LI>
<LI_Label>–</LI_Label>

<LI_Title> Assembly Information CAR </LI_Title>
</LI>

<LI>
<LI_Label>– </LI_Label>

<LI_Title>Processing Element Features CAR </LI_Title>
</LI>

<LI>
<LI_Label>– </LI_Label>

<LI_Title>Source Operations CAR </LI_Title>
</LI>

<LI>
<LI_Label>– </LI_Label>

<LI_Title>Destination Operations CAR </LI_Title>
</LI>
</L>
</L>
</L>

<P>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 4.4) </P>

<P id="LinkTarget_30926">3.2.1.2 Operation support as target </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Maintenance read </LI_Title>
</LI>

<L>
<LI>
<LI_Label>— </LI_Label>

<LI_Title>(switch targeted by hop_count transport field) </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.3.1, Section 3.1.10) </LI_Title>
</LI>
</L>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Maintenance write </LI_Title>
</LI>
</L>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<L>
<LI>
<LI_Label>— </LI_Label>

<LI_Title>(switch targeted by hop_count transport field) </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.3.1, Section 3.1.10) </LI_Title>
</LI>
</L>

<P id="LinkTarget_30927">3.2.1.3 Operation support as source </P>

<P>• &lt;none&gt; </P>

<P id="LinkTarget_30928">3.2.2 Class 1: Simple target device </P>

<P id="LinkTarget_30929">3.2.2.1 General requirements </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> all Generic requirements </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for 34-bit address packet formats </LI_Title>
</LI>
</L>

<P>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 4.4.5) </P>

<P id="LinkTarget_30930">3.2.2.2 Operation support as target </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> all Generic requirements </LI_Title>
</LI>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Write </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.2, Section 3.1.7) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Streaming-write </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.2, Section 3.1.8) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Write-with-response </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.3, Section 3.1.7) </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Read </LI_Title>
</LI>
</L>

<P>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.1, Section 3.1.5) </P>

<P id="LinkTarget_30931">3.2.2.3 Operation support as source </P>

<P>• all Generic requirements </P>

<P id="LinkTarget_30932">3.2.3 Class 2: Simple mastering device </P>

<P id="LinkTarget_30933">3.2.3.1 General requirements </P>

<P>• all Class 1 requirements </P>

<P id="LinkTarget_30934">3.2.3.2 Operation support as target </P>

<P>• all Class 1 requirements </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30935">3.2.3.3 Operation support as source </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> all Class 1 requirements </LI_Title>
</LI>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Maintenance read </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.3.1, Section 3.1.10) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Maintenance write </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.3.1, Section 3.1.10) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Write </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.2, Section 3.1.7) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Streaming-write </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.2, Section 3.1.8) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Write-with-response </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.3, Section 3.1.7) </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Read </LI_Title>
</LI>
</L>

<P>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.1, Section 3.1.5) </P>

<P id="LinkTarget_30936">3.2.4 Class 3: Complex mastering device </P>

<P id="LinkTarget_30937">3.2.4.1 General requirements </P>

<P>• all Class 2 requirements </P>

<P id="LinkTarget_30938">3.2.4.2 Operation support as target </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> all Class 2 requirements </LI_Title>
</LI>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Atomic set </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.4, Section 3.1.7) </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Maintenance port-write </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.3.1, Section 3.1.10) </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Data message mailbox 0, letter 0, single segment, 8 byte payload </LI_Title>
</LI>
</L>

<P>— (refer to RapidIO Part 2: Message Passing Logical Specification, Section 2.2.2, Section 3.1.5) </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_30939">3.2.4.3 Operation support as source </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> all Class 2 requirements </LI_Title>
</LI>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Atomic set </LI_Title>
</LI>

<LI>— (refer to RapidIO Part 1: Input/Output Logical Specification, Section 2.2.4, Section 3.1.7) </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Data message mailbox 0, letter 0, single segment, 8 byte payload </LI_Title>
</LI>
</L>

<P>— (refer to RapidIO Part 2: Message Passing Logical Specification, Section 2.2.2, Section 3.1.5) </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_30940">Chapter 4 PCI Considerations </P>

<P id="LinkTarget_30941">4.1 Introduction </P>

<P>RapidIO contains a rich enough set of operations and capabilities to allow transport of legacy interconnects such as PCI1. While RapidIO and PCI share similar functionality, the two interconnects have different protocols thus requiring a translation function to move transactions between them. A RapidIO to PCI bridge processing element is required to make the necessary translation between the two interconnects. This chapter describes architectural considerations for an implementation of a RapidIO to PCI bridge processing element. This chapter is not intended as an implementation instruction manual, rather, it is to provide direction to the bridge processing element architect and aid in the development of interoperable devices. For this chapter it is assumed that the reader has a thorough understanding of the PCI 2.2 and/or the PCI-X 1.0 specifications. </P>

<P>
<Link>Figure 4-1 shows a typical system with devices connected using various RapidIO </Link>
and PCI bus segments. A host bridge is connected to various peripherals via a PCI bus. A RapidIO bridge is used to translate PCI formatted transactions to the equivalent RapidIO operations to allow access to the rest of the system, including additional subordinate PCI bus segments. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_169.jpg"/>
Host CPU Bridge Host Host Mem Periph 1 Periph 2 RapidIOto PCI RapidIO Switch PCI 2 PCI 0 Periph 3 Periph 4 Periph 5 bridge RapidIOto PCI bridge RapidIOto PCI bridge </Figure>

<P>Host Bus Segment PCI 1 </P>

<P>Figure 4-1. Example System with PCI and RapidIO </P>

<P>1For additional information on the Peripheral Component Interconnect PCI refer to the PCI 2.2 and the PCI-X 1.0 specifications. </P>

<P>RapidIO Trade Association </P>

<P>Where RapidIO is introduced into a legacy system, it is desirable to limit changes to software. For transactions which must travel between RapidIO and PCI it is necessary to map address spaces defined on the PCI bus to those of RapidIO, translate PCI transaction types to RapidIO operations, and maintain the producer/consumer requirements of the PCI bus. This chapter will address each of these considerations for both PCI version 2.2 and PCI-X. </P>

<P id="LinkTarget_30942">4.2 Address Map Considerations </P>

<P>PCI defines three physical address spaces, specifically, the memory, I/O memory, and configuration spaces. RapidIO, on the other hand, only addresses memory and configuration space. This section discusses memory space. Configuration space is discussed in 
<Link>Section 4.4</Link>
. 
<Link>Figure 4-2 shows a simple example of the PCI memory and </Link>
I/O address spaces for a host bus segment. In order for devices on the PCI bus to communicate with those connected through RapidIO, it is necessary to provide a memory mapping function. The example PCI host memory map uses a 32-bit physical address space resulting in 4 Gbytes of total address space. Host memory is shown at the bottom of the address map and peripheral devices at the top. Consider that the RapidIO to PCI bridge processing element contains a specified window(s) of address space mapped to it using the PCI base address register(s)1. The example shown in 
<Link>Figure 4-2 illustrates the RapidIO bridge address window located in an </Link>
arbitrary software defined location. Likewise, if it was desired to communicate with PCI legacy I/O devices over RapidIO an I/O window would be assigned to the RapidIO to PCI bridge as shown. </P>

<P>PCI Memory Space PCI I/O Space</P>

<P>0 </P>

<P>
<Table>
<TR>
<TH>Host Memory </TH>
</TR>

<TR>
<TH/>
</TR>

<TR>
<TH>RapidIO Bridge Window </TH>
</TR>

<TR>
<TH/>
</TR>

<TR>
<TH>Peripheral 1 </TH>
</TR>

<TR>
<TH>Peripheral 2 </TH>
</TR>
</Table>
0 </P>

<P>4G </P>

<Table>
<TR>
<TH/>
</TR>

<TR>
<TH>RapidIOBridge Window </TH>
</TR>

<TR>
<TH/>
</TR>
</Table>

<P>4G </P>

<P>Figure 4-2. Host segment PCI Memory Map Example </P>

<P>Any transactions issued to the bus segment with an address that matches the RapidIO bridge window will be captured by the RapidIO to PCI bridge for forwarding. Once the transaction has been accepted by the RapidIO to PCI bridge processing element it must be translated to the proper RapidIO context as shown in </P>

<P>1Refer to the PCI 2.2 Specification Chapter 6 for a discussion on PCI address maps and configuration registers </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>
<Link>Figure 4-3. For the purposes of this discussion this function is called the Address </Link>
Mapping and Translation function (AMT). The AMT function is responsible for translating PCI addresses to RapidIO addresses as well as the translation and assignment of the respective PCI and RapidIO transaction types. The address space defined by the RapidIO bridge window may represent more than one subordinate 
<Link>RapidIO target device. A device on PCI bus segment 0 shown in Figure 4-1 may </Link>
require access to a peripheral on PCI bus 1, bus 2, or RapidIO Peripheral 5. Because RapidIO uses source addressing (device IDs), the AMT is responsible for translating the PCI address to both a target device ID and associated offset address. In addition to address translation, RapidIO attributes, transaction types, and other necessary delivery information are established. </P>

<P>Similarly, transactions traveling from a RapidIO bus to a PCI bus must also pass through the AMT function. The address and transaction type are translated back into PCI format, and the AMT selects the appropriate address for the transaction. Memory mapping is relied upon for all transactions bridged between PCI and RapidIO. </P>

<P>PCI</P>

<P>PCI</P>

<P>Memory </P>

<P>Memory </P>

<Table>
<TR>
<TH>I/O CFG RapidIO bridge Address block </TH>

<TH>Figure 4-3. AMT and Memory Mapping Device ID OxXX RapidIO AMTAMT </TH>

<TH>I/O CFG </TH>
</TR>
</Table>

<P id="LinkTarget_30943">4.3 Transaction Flow </P>

<P>In considering the mapping of the PCI bus to RapidIO it is important to understand the transaction flow of PCI transactions through RapidIO. </P>

<P id="LinkTarget_30944">4.3.1 PCI 2.2 Transaction Flow </P>

<P>The PCI 2.2 specification defines two classes of transaction types, posted and non-posted. 
<Link>Figure 4-4 shows the route taken by a PCI-RapidIO posted write </Link>
transaction. Once the request is sent from the PCI Master on the bus, it is claimed by </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_170.jpg"/>
P3 P3 Mem I/O CFG </Figure>

<P>RapidIO Trade Association </P>

<P>the bridge processing element which uses the AMT to translate it into a RapidIO request. Only when the transaction is in RapidIO format can it be posted to the RapidIO target. In some cases it may be desirable to guarantee end to end delivery of the posted write transaction. For this case the RapidIO NWRITE_R transaction is used which results in a response as shown in the figure. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_171.jpg"/>
PCI Master PCI Posted RapidIO Request RapidIO Target Translation to RapidIORequest PCI Bus Bridge Processing Element PCI RapidIO PCI to RapidIO Request Response RapidIOTransaction Completion RapidIOOptional </Figure>

<P>Figure 4-4. PCI Mastered Posted Write Transaction Flow Diagram </P>

<P>
<Link>A non-posted PCI transaction is shown in Figure 4-5. The transaction is mastered by </Link>
the PCI agent on the PCI bus and accepted by the RapidIO to PCI bridge. The transaction is retried on the PCI bus if the bridge is unable to complete it within the required time-out period. In this case the transaction is completed as a delayed transaction. The transaction is translated to the appropriate RapidIO operation and issued on the RapidIO port. At some time later a RapidIO response is received and the results are translated back to PCI format. When the PCI master subsequently retries the transaction, the delayed results are returned and the operation is completed. </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_172.jpg"/>
PCI Master PCI Transaction Translation to RapidIORequest (Delayed) Transaction Results RapidIOto PCI Translation PCI Bus Bridge Processing Element PCI PCI to RapidIO Request </Figure>

<P>RapidIO </P>

<P>RapidIO 
Request 
</P>

<P>RapidIO 
Response 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_173.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_174.jpg"/>
</Figure>

<P>RapidIO 
Target 
</P>

<P>Figure 4-5. PCI Mastered non-posted (delayed) Transaction Flow Diagram </P>

<P>Because PCI allows unbounded transaction data tenures, it may be necessary for the RapidIO to PCI bridge to break the single PCI transaction into multiple RapidIO operations. In addition, RapidIO does not have byte enables and therefore does not support sparse byte transactions. For this case the transaction must be broken into 
<Link>multiple operations as well. “Section 4.7, Byte Lane and Byte Enable Usage” on </Link>

<Link>page 41 describes this situation in more detail. </Link>
</P>

<P>
<Link>A RapidIO mastered operation is shown in Figure 4-6. For this case the RapidIO </Link>
request transaction is received at the RapidIO to PCI bridge. The bridge translates the request into the appropriate PCI command which is then issued to the PCI bus. The PCI target may complete the transaction as a posted, non-posted, or delayed non-posted transaction depending on the command type. Once the command is successfully completed on the PCI bus the results are translated back into the RapidIO format and a response transaction is issued back to the RapidIO Master. </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_175.jpg"/>
</Figure>

<P>Master 
RapidIO 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_176.jpg"/>
</Figure>

<P>RapidIO </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_177.jpg"/>
RapidIO Request </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_178.jpg"/>
RapidIO Response </Figure>

<P>Request </P>

<P>Translation </P>

<P>Transaction</P>

<P>to </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_179.jpg"/>
PCITarget PCI Translation RapidIO (Delayed) Transaction Results RapidIO PCI Bus Bridge Processing Element PCI PCI to RapidIO Request </Figure>

<P>Figure 4-6. RapidIO Mastered Transaction </P>

<P id="LinkTarget_30945">4.3.2 PCI-X Transaction Flow </P>

<P>The flow of transactions described in the previous section applies to the PCI-X bus as well. PCI-X supports split transactions instead of delayed transactions. The example shown in 
<Link>Figure 4-7</Link>
 illustrates a transaction completed with a PCI-X split completion. The PCI-X master issues a transaction. The RapidIO to PCI-X bridge determines that it must complete the transaction as a split transaction, and responds with a split response. The transaction is translated to RapidIO and a request is issued on the RapidIO port. The RapidIO target returns a response transaction which is translated to a PCI-X Split Completion transaction completing the operation. PCI-X allows up to a 4 Kilobyte request. Larger PCI-X requests must be broken into multiple RapidIO operations. The RapidIO to PCI-X bridge may return the results back to the PCI-X Master using multiple Split Completion transactions in a pipelined fashion. Since PCI-X only allows devices to disconnect on 128 byte boundaries it is advantageous to break the large PCI-X request into either 128 or 256 byte RapidIO operations. </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>PCI PCI Bus </P>

<P>PCI to RapidIO Bridge Processing Element Translation to RapidIO</P>

<P>Request </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_180.jpg"/>
PCI-X Master Split CompletionTransaction(s) RapidIOto PCI-X Translation PCI-X Split Response PCI-X Transaction Request </Figure>

<P>RapidIO </P>

<P>RapidIO 
Request(s) 
</P>

<P>RapidIO 
Response(s) 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_181.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_182.jpg"/>
</Figure>

<P>RapidIO 
Target 
</P>

<P>Figure 4-7. PCI-X Mastered Split Response Transaction </P>

<P id="LinkTarget_30946">4.4 RapidIO to PCI Transaction Mapping </P>

<P>The RapidIO I/O and GSM specifications include the necessary transactions types 
<Link>to map all PCI transactions. Table 4-1 lists the map of transactions between PCI and </Link>

<Link>RapidIO. A mapping mechanism such as the AMT function described in Section 4.2 </Link>
is necessary to assign the proper transaction type based on the address space for which the transaction is targeted. </P>

<Table>
<Caption>
<P>Table 4-1. PCI 2.2 to RapidIO Transaction Mapping </P>
</Caption>

<TR>
<TH>PCI Command </TH>

<TH>RapidIO Transaction </TH>

<TH>Comment </TH>
</TR>

<TR>
<TD>Interrupt-acknowledge </TD>

<TD>NREAD </TD>

<TD/>
</TR>

<TR>
<TD>Special-cycle </TD>

<TD>NWRITE </TD>

<TD/>
</TR>

<TR>
<TD>I/O-read </TD>

<TD>NREAD </TD>

<TD/>
</TR>

<TR>
<TD>I/O-write </TD>

<TD>NWRITE_R </TD>

<TD/>
</TR>

<TR>
<TD>Memory-read, Memory-Read-Line, Memory-Read-Multiple </TD>

<TD>NREAD or IO_READ_HOME </TD>

<TD>
<Link>The PCI memory read transactions can be represented by the NREAD operation. If the operation is targeted to hardware maintained globally coherent memory address space then the I/O Read operation must be used (see “Section 4.6, Interactions with Globally Shared Memory” on page 37.) </Link>
</TD>
</TR>

<TR>
<TD>Memory-write, Memory-write-andinvalidate </TD>

<TD>NWRITE, NWRITE_R, or FLUSH </TD>

<TD>
<Link>The PCI Memory Write and Memory-Write-and-Invalidate can be represented by the NWRITE operation. If reliable delivery of an individual write transaction is desired then the NWRITE_R is used. If the operation is targeted to hardware maintained globally coherent memory address space then the Data Cache Flush operation must be used (refer to “Section 4.6, Interactions with Globally Shared Memory” on page 37.) </Link>
</TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>PCI Command </TH>

<TH>RapidIO Transaction </TH>

<TH>Comment </TH>
</TR>

<TR>
<TD>Configuration-read </TD>

<TD>NREAD </TD>

<TD/>
</TR>

<TR>
<TD>Configuration-write </TD>

<TD>NWRITE_R </TD>

<TD/>
</TR>
</Table>

<P>PCI 2.2 memory transactions do not specify a size. It is possible for a PCI master to read a continuous stream of data from a target or to write a continuous stream of data to a target. Because RapidIO is defined to have a maximum data payload of 256 bytes, PCI transactions that are longer than 256 bytes must be broken into multiple RapidIO operations. </P>

<P>
<Link>Table 4-2 shows the transaction mapping between PCI-X and RapidIO. </Link>
</P>

<Table>
<Caption>
<P>Table 4-2. PCI-X to RapidIO Transaction Mapping </P>
</Caption>

<TR>
<TH>PCI-X Command </TH>

<TH>RapidIO Transaction </TH>

<TH>Comment </TH>
</TR>

<TR>
<TD>Interrupt-acknowledge </TD>

<TD>NREAD </TD>

<TD/>
</TR>

<TR>
<TD>Special-cycle </TD>

<TD>NWRITE </TD>

<TD/>
</TR>

<TR>
<TD>I/O-read </TD>

<TD>NREAD </TD>

<TD/>
</TR>

<TR>
<TD>I/O-write </TD>

<TD>NWRITE_R </TD>

<TD/>
</TR>

<TR>
<TD>Memory-read DWORD </TD>

<TD>NREAD or IO_READ_HOME </TD>

<TD>
<Link>The PCI-X memory read DWORD transactions can be represented by the NREAD operation. If the operation is targeted to hardware maintained coherent memory address space then the I/O Read operation must be used (refer to “Section 4.6, Interactions with Globally Shared Memory” on page 37.) This is indicated in PCI-X using the No Snoop (NS) bit described in Section 2.5 of the PCI-X 1.0 specification. </Link>
</TD>
</TR>

<TR>
<TD>Memory-write </TD>

<TD>NWRITE, NWRITE_R, or FLUSH </TD>

<TD>
<Link>The PCI-X Memory Write and Memory-Write-and-Invalidate can be represented by the NWRITE operation. If reliable delivery of an individual write transaction is desired then the NWRITE_R is used. If the operation is targeted to hardware maintained coherent memory address space then the Data Cache Flush operation must be used (refer to “Section 4.6, Interactions with Globally Shared Memory” on page 37.) This is indicated in PCI-X using the No Snoop (NS) bit described in Section 2.5 of the PCI-X 1.0 specification. </Link>
</TD>
</TR>

<TR>
<TD>Configuration-read </TD>

<TD>NREAD </TD>

<TD/>
</TR>

<TR>
<TD>Configuration-write </TD>

<TD>NWRITE_R </TD>

<TD/>
</TR>

<TR>
<TD>Split Completion </TD>

<TD>-</TD>

<TD>The Split Completion transaction is the result of a request on the PCI-X bus that was terminated by the target with a Split Response. In the case of the RapidIO to PCI-X bridge this would be the artifact of a transaction that either the bridge mastered and received a split response or was the target and issued a split response. This command is equivalent to a RapidIO response transaction and does not traverse the bridge. </TD>
</TR>
</Table>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 Table 4-2. PCI-X to RapidIO Transaction Mapping </P>

<Table>
<TR>
<TH>PCI-X Command </TH>

<TH>RapidIO Transaction </TH>

<TH>Comment </TH>
</TR>

<TR>
<TD>Memory-read-block </TD>

<TD>NREAD or IO_READ_HOME </TD>

<TD>
<Link>The PCI-X memory read transactions can be represented by the NREAD operation. If the operation is targeted to hardware maintained globally coherent memory address space then the I/O Read operation must be used (refer to “Section 4.6, Interactions with Globally Shared Memory” on page 37.) This is indicated in PCI-X using the No Snoop (NS) bit described in Section 2.5 of the PCI-X 1.0 specification. </Link>
</TD>
</TR>

<TR>
<TD>Memory-write-block </TD>

<TD>NWRITE, NWRITE_R, or FLUSH </TD>

<TD>
<Link>The PCI-X Memory Write and Memory-Write-and-Invalidate can be represented by the NWRITE operation. If reliable delivery of an individual write transaction is desired then the NWRITE_R is used. If the operation is targeted to hardware maintained globally coherent memory address space then the Data Cache Flush operation must be used (refer to “Section 4.6, Interactions with Globally Shared Memory” on page 37.) This is indicated in PCI-X using the No Snoop (NS) bit described in Section 2.5 of the PCI-X 1.0 specification. </Link>
</TD>
</TR>
</Table>

<P>The PCI-X addendum to the PCI specification adds the ability to do split operations. This results in an operation being broken into a Split Request and one or more Split Completions. As a target of a PCI-X Split Request, the RapidIO to PCI bridge may reply with a Split Response and complete the request using multiple RapidIO operations. The results of these operations are issued on the PCI-X bus as Split Completions. If the RapidIO to PCI-X bridge is the initiator of a Split Request, the target may also indicate that it intends to run the operation as a split transaction with a Split Response. In this case the target would send the results to the RapidIO to PCI-X bridge using Split Completions. </P>

<P id="LinkTarget_30947">4.5 Operation Ordering and Transaction Delivery </P>

<P>This section discusses what the RapidIO to PCI bridge must do to address the requirements of the ordering rules of the PCI specifications. </P>

<P id="LinkTarget_30948">4.5.1 Operation Ordering </P>

<P>Section 1.2.1 of the RapidIO Part 1: Input/Output Logical Specification describes a set of ordering rules. The rules guarantee ordered delivery of write data and that results of read operations will contain any data that was previously written to the same location. </P>

<P>For bridge devices, the PCI 2.2 specification has the additional requirement that the results of a read command push ahead posted writes in both directions. </P>

<P>In order for the RapidIO to PCI bridge to be consistent with the PCI 2.2 ordering rules it is necessary to follow the transaction ordering rules listed in section 1.2.1 of the I/O logical specification. In addition, the RapidIO to PCI bridge is required to adhere to the following RapidIO rule: </P>

<P>Read responses must push ahead all write requests and write responses. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30949">4.5.2 Transaction Delivery Ordering </P>

<P>The RapidIO 8/16 LP-LVDS and 1x/4x LP-Serial physical layer specifications describe the mechanisms by which transaction ordering and delivery occur through the system. When considering the requirements for the RapidIO to PCI bridge it is first necessary to follow the transaction delivery ordering rules in section 1.2.4.1 of the 8/16 LP-LVDS specification and/or Section 5.8 of the 1x/4x LP-Serial specification. Further, it is necessary to add additional constraints to maintain programming model compatibility with PCI. </P>

<P>
<Link>As described in Section 4.5.1 above, PCI has an additional transaction ordering </Link>
requirement over RapidIO. In order to guarantee inter-operability, transaction ordering, and deadlock free operation, it is recommended that devices be restricted to utilizing transaction request flow level 0. In addition, it is recommended that 
<Link>response transactions follow a more strict priority assignment. Table 4-3 illustrates </Link>
the priority assignment requirements for transactions in the PCI to RapidIO environment. </P>

<Table>
<Caption>
<P>Table 4-3. Packet priority assignments for PCI ordering </P>
</Caption>

<TR>
<TH>RapidIO packet type </TH>

<TH>priority </TH>

<TH>comment </TH>
</TR>

<TR>
<TD>read request </TD>

<TD>0 </TD>

<TD>This will push write requests and responses ahead </TD>
</TR>

<TR>
<TD>write request </TD>

<TD>1 </TD>

<TD>Forces writes to complete in order, but allows write requests to bypass read requests </TD>
</TR>

<TR>
<TD>read response </TD>

<TD>1 </TD>

<TD>Will force completion of preceding write requests and allows bypass of read requests </TD>
</TR>

<TR>
<TD>write response </TD>

<TD>2 </TD>

<TD>Will prevent NWRITE_R request based deadlocks </TD>
</TR>
</Table>

<P>The PCI transaction ordering model requires that a RapidIO device not issue a read request into the system unless it has sufficient resources available to receive and process a higher priority write or response packet in order to prevent deadlock. PCI </P>

<P>2.2 states that read responses cannot pass write transactions. The RapidIO specification provides PCI ordering by issuing priority 0 to read requests, and priority 1 to read responses and PCI writes. Since read responses and writes are issued at the same priority, the read responses will not pass writes. </P>

<P id="LinkTarget_30950">4.5.3 PCI-X Relaxed Ordering Considerations </P>

<P>The PCI-X specification defines an additional ordering feature called relaxed ordering. If the PCI-X relaxed ordering attribute is set for a read transaction, the results for the read transaction are allowed to pass posted write transactions. PCI-X read transactions with this bit set allow the PCI-X to RapidIO bridge to ignore the 
<Link>rule described in Section 4.5.1. Table 4-4 shows the results of this additional </Link>
</P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>function. </P>

<Table>
<Caption>
<P>Table 4-4. Packet priority assignments for PCI-X ordering </P>
</Caption>

<TR>
<TH>RapidIO packet type </TH>

<TH>priority </TH>

<TH>comment </TH>
</TR>

<TR>
<TD>read request </TD>

<TD>0 </TD>

<TD>This will push write requests and responses ahead </TD>
</TR>

<TR>
<TD>write request </TD>

<TD>1 </TD>

<TD>Forces writes to complete in order, but allows write requests to bypass of read requests </TD>
</TR>

<TR>
<TD>read response </TD>

<TD>1 </TD>

<TD>When PCI-X Relaxed Ordering attribute is set to 0. Will force completion of preceding write requests and allows bypass of read requests </TD>
</TR>

<TR>
<TD>read response </TD>

<TD>2, 3 </TD>

<TD>When PCI-X Relaxed Ordering attribute is set to 1. The endpoint may promote the read response to higher priority to allow it to move ahead of posted writes. </TD>
</TR>

<TR>
<TD>write response </TD>

<TD>2 </TD>

<TD/>
</TR>
</Table>

<P id="LinkTarget_30951">4.6 Interactions with Globally Shared Memory </P>

<P>Traditional systems have two notions of system or subsystem cache coherence. The first, non-coherent, means that memory accesses have no effect on the caches in the system. The memory controller reads and writes memory directly, and any cached address becomes incoherent in the system. This behavior requires that all cache coherence with I/O be managed using software mechanisms, as illustrated in 
<Link>Figure 4-8. </Link>
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_183.jpg"/>
Processor Local Interconnect Processor cache cache </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_184.jpg"/>
Agent Memory RapidIO </Figure>

<P>Interconnect <Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_185.jpg"/>
</Figure>
</P>

<P>Request</P>

<P>Fabric </P>

<P>Response </P>

<P>Figure 4-8. Traditional Non-coherent I/O Access Example </P>

<P>The second notion of system cache coherence is that of global coherence. An I/O access to memory causes a snoop cycle to be issued on the processor bus, keeping 
<Link>all of the system caches coherent with the memory, as illustrated in Figure 4-9. </Link>
</P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_186.jpg"/>
Figure 4-9. Traditional Globally Coherent I/O Access Example Agent Memory Processor Local Interconnect Processor cache cache snoop RapidIO Interconnect Fabric </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_187.jpg"/>
</Figure>

<P>Request </P>

<P>Response </P>

<P>With RapidIO globally shared systems, there is no common bus that can be used in order to issue the snoop, so global coherence requires special hardware support beyond simply snooping the bus. This leads to a third notion of cache coherence, termed local coherence. For local coherence, a snoop on a processor bus local to the targeted memory controller can be used to keep those caches coherent with that part of memory, but not caches associated with other memory controllers, as illustrated in 
<Link>Figure 4-10.</Link>
 Therefore, what once was regarded in a system as a “coherent access” is no longer globally coherent, but only locally coherent. Typically, deciding to snoop or not snoop the local processor caches is either determined by design or system architecture policy (always snoop or never snoop), or by an attribute associated with the physical address being accessed. In PCI-X, this attribute is the No Snoop (NS) bit described in Section 2.5 of the PCI-X 1.0 specification. </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_188.jpg"/>
Agent Memory Processor Request Response cache RapidIO Interconnect Fabric snoop Agent Memory Processor cache snoop </Figure>

<P>Figure 4-10. RapidIO Locally Coherent I/O Access Example </P>

<P>In order to preserve the concept of global cache coherence for a system, the RapidIO Part 5: Globally Shared Memory Logical Specification defines several operations that allow a RapidIO to PCI bridge processing element to access data in the globally shared space without having to implement all of the cache coherence protocol. These operations are the I/O Read and Data Cache Flush operations (globally shared memory specification, sections 3.2.9 and 3.2.10). For PCI-X bridging, these operations can also be used as a way to encode the NO SNOOP attribute for locally as well as globally coherent transactions. The targeted memory controller can be designed to understand the required behavior of such a transaction. These encodings also are useful for tunneling PCI-X transactions between PCI-X bridge devices. </P>

<P>The data payload for an I/O Read operation is defined as the size of the coherence granule for the targeted globally shared memory domain. However, the Data Cache Flush operation allows coherence granule, sub-coherence granule, and sub-double-word writes to be performed. </P>

<P>The IO_READ_HOME transaction is used to indicate to the GSM memory controller that the memory access is globally coherent, so the memory controller finds the latest copy of the requested data within the coherence domain (the requesting RapidIO to PCI bridge processing element is, by definition, not in the coherence domain) without changing the state of the participant caches. Therefore, the I/O Read operation allows the RapidIO to PCI bridge to cleanly extract data from a coherent portion of the system with minimal disruption and without having to be a full participant in the coherence domain. </P>

<P>The Data Cache Flush operation has several uses in a coherent part of a system. One </P>

<P>RapidIO Trade Association </P>

<P>such use is to allow a RapidIO to PCI bridge processing element to write to globally shared portions of the system memory. Analogous to the IO_READ_HOME transaction, the FLUSH transaction is used to indicate to the GSM memory controller that the access is globally coherent. The memory controller forces all of the caches in the coherence domain to invalidate the coherence granule if they have a shared copy (or return the data to memory if one had ownership of the data), and then writes memory with the data supplied with the FLUSH request. This behavior allows the I/O device to cleanly write data to the globally shared address space without having to be a full participant in the coherence domain. </P>

<P>Since the RapidIO to PCI bridge processing element is not part of the coherence domain, it is never the target of a coherent operation. </P>

<P id="LinkTarget_30952">4.6.1 I/O Read Operation Details </P>

<P>Most of the complexity of the I/O Read operation resides in the memory controller. For the RapidIO to PCI Bridge processing element the I/O Read operation requires some additional attention over the non-coherent read operation. The necessary portions of the I/O Read state machine description in Section 6.10 of the globally shared memory specification are extracted below. Refer to Chapter 6 of the GSM specification for state machine definitions and conventions. The GSM specification takes precedence in the case of any discrepancies between the corresponding portions of the GSM specification and this description. </P>

<P id="LinkTarget_30953">4.6.1.1 Internal Request State Machine </P>

<P>This state machine handles requests to the remote globally shared memory space. </P>

<P>remote_request(IO_READ_HOME, mem_id, my_id); </P>

<P id="LinkTarget_30954">4.6.1.2 Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect. </P>

<P>switch(remote_response)</P>

<P>case DONE: 
return_data();
free_entry();
</P>

<P>case DONE_INTERVENTION: // must be from third party 
set_received_done_message();
if (received_data_only_message)
</P>

<P>free_entry(); </P>

<P>else 
// wait for a DATA_ONLY 
</P>

<P>endif; </P>

<P>case DATA_ONLY: 	// this is due to an intervention, a
// DONE_INTERVENTION should come
// separately 
</P>

<P>set_received_data_only_message();</P>

<P>if (received_done_message)
return_data();
free_entry(); 
</P>

<P>else return_data(); // OK for weak ordering </P>

<P>endif; </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>case RETRY: 
remote_request(IO_READ_HOME, received_srcid, my_id); 
default 
error(); 
</P>

<P id="LinkTarget_30955">4.6.2 Data Cache Flush Operation Details </P>

<P>As with the I/O Read operation, the complexity for the Data Cache Flush operation resides in the memory controller. The necessary portions of the Data Cache Flush state machine description from Section 6.10 of the GSM logical specification are extracted below. Refer to Chapters 2 and 3 of the GSM specification to determine the size of data payloads for the FLUSH transaction. The GSM specification takes precedence in the case of any discrepancies between the corresponding portions of the GSM specification and this description. </P>

<P id="LinkTarget_30956">4.6.2.1 Internal Request State Machine </P>

<P>This state machine handles requests to the remote globally shared memory space. </P>

<P>remote_request(FLUSH, mem_id, my_id, data); </P>

<P id="LinkTarget_30957">4.6.2.2 Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect. </P>
</Div>

<Div>
<P>switch (received_response)</P>

<P>case DONE: 
local_response(OK);
free_entry(); 
</P>

<P>case RETRY: 
remote_request(FLUSH, received_srcid, my_id, data); 
default: 
error(); 
</P>

<P id="LinkTarget_30958">4.7 Byte Lane and Byte Enable Usage </P>

<P>PCI makes use of byte enables and allows combining and merging of transactions. This may have the result of write transactions with sparse valid bytes. In order to save on transaction overhead, RapidIO does not include byte enables. RapidIO does, however, support a set of byte encodings defined in Chapter 3 of the RapidIO Part </P>

<P>1: Input/Output Logical Specification. PCI to RapidIO operations may be issued with sparse bytes. Should a PCI write transaction with byte enables that do not match a RapidIO byte encoding be issued to a RapidIO to PCI bridge, that operation must be broken into multiple valid RapidIO operations. </P>

<P id="LinkTarget_30959">4.8 Error Management </P>

<P>Errors that are detected on a PCI bus are signaled using side band signals. The treatment of these signals is left to the system designer and is outside of the PCI specifications. Likewise, this document does not recommend any practices for the delivery of error interrupts in the system. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_30960">Chapter 5  Globally Shared Memory Devices </P>

<P id="LinkTarget_30961">5.1 Introduction </P>

<P>Different processing elements have different requirements when participating in a RapidIO GSM environment. The GSM protocols and address collision tables are written from the point of view of a fully integrated processing element comprised of a local processor, a memory controller, and an I/O controller. Obviously, the complexity and implementation requirements for this assumed device are much greater than required for a typical design. This chapter assumes that the reader is familiar with the RapidIO Part 5: Globally Shared Memory Logical Specification. </P>

<P>Additionally, this chapter contains the 8/16 LP-LVDS and 1x/4x LP-Serial physical layer transaction to priority mappings to guarantee that a system maintains cache coherence and is deadlock free. </P>

<P id="LinkTarget_30962">5.2 Processing Element Behavior </P>

<P>In Chapter 2 of the globally shared memory specification are a number of examples of possible processing elements: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> A processor-memory processing element </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A memory-only processing element </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A processor-only processing element </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> An I/O processing element </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A switch processing element </LI_Title>
</LI>
</L>

<P>Of all of these, only the switch processing element does not have to implement anything additional to exist in a GSM system or sub-system. All of the remaining processing element types are of interest, and all are likely to exist in some form in the marketplace. This chapter is intended to define the portions of the protocol necessary to implement each of these devices. Other processing elements are allowed by the globally shared memory specification, for example, a memory-I/O processing element. The portions of the protocol necessary to implement these devices are not addressed in this chapter. </P>

<P>The behaviors described in this chapter have been extracted directly from revision </P>

<P>1.1 of the globally shared memory specification, and may be out of date with respect to the latest revision of that document. The GSM specification takes precedence in </P>

<P>RapidIO Trade Association </P>

<P>the case that there are discrepancies between it and this chapter. </P>

<P id="LinkTarget_30963">5.2.1 Processor-Memory Processing Element </P>

<P>This processing element is very nearly the same as the assumed processing element used for the state machine description in Chapter 6, and requires nearly all of the described functionality. The following operation behavior is not changed from the Chapter 6 descriptions: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Read </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Instruction read </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Read for ownership </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Data cache and instruction cache invalidate </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Castout </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> TLB invalidate entry and TLB invalidate entry synchronize </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Data cache flush </LI_Title>
</LI>
</L>

<P>This leaves the I/O Read operation. Since the processor-memory processing element does not contain an I/O device, this processing element will not generate the I/O read operation, but is required to respond to it. This removes the internal request state machine and portions of the response state machine, requiring the behavior described in Section 2.1.1 below. The only exception to this is the special case where there exists multiple coherence domains. It is possible that a processor in one coherence domain may wish to read data in another coherence domain and thus would require support of the I/O Read operation. </P>

<P id="LinkTarget_30964">5.2.1.1 I/O Read Operations </P>

<P>This operation is used for I/O reads of globally shared memory space. </P>

<P id="LinkTarget_30965">5.2.1.1.1  Response State Machine </P>

<P>This machine handles responses to requests made to the RapidIO interconnect made on behalf of a third party. </P>

<P>switch(remote_response)</P>

<P>case INTERVENTION: 
update_memory();
remote_response(DONE_INTERVENTION, original_srcid, my_id);
free_entry();
</P>

<P>case NOT_OWNER, 	// data comes from memory, mimic// intervention </P>

<P>case RETRY: 
switch(directory_state)
case LOCAL_MODIFIED, 
case LOCAL_SHARED: 
</P>

<P>remote_response(DATA_ONLY, original_srcid, my_id,data);remote_response(DONE_INTERVENTION, original_srcid,my_id);free_entry();case REMOTE_MODIFIED: // spin or wait for castout </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>remote_request(IO_READ_OWNER, received_srcid, my_id,
my_id);
default: 
error();
default: 
error(); 
</P>

<P id="LinkTarget_30966">5.2.1.1.2  External Request State Machine </P>

<P>This machine handles requests from the system to the local memory or the local processor. This may require making further external requests. </P>

<P>if (address_collision) // use collision tables in</P>

<P>// Chapter 7, “Address Collision Resolution Tables” elseif (IO_READ_HOME) // remote request to our local memory </P>

<P>assign_entry();
switch (directory_state)
case LOCAL_MODIFIED: 
</P>

<P>local_request(READ_LATEST);remote_response(DONE, received_srcid, my_id, data);// after push completes free_entry();</P>

<P>case LOCAL_SHARED: remote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case REMOTE_MODIFIED: remote_request(IO_READ_OWNER, mask_id, my_id, received_srcid);</P>

<P>case SHARED: remote_response(DONE, received_srcid, my_id, data);free_entry(); </P>

<P>default: 
error();
</P>

<P>else // IO_READ_OWNER request to our caches assign_entry();local_request(READ_LATEST); // spin until a valid response from</P>

<P>// the caches switch (local_response)case MODIFIED: // processor indicated a push;</P>

<P>// wait for it</P>

<P>if (received_srcid == received_secid)// original requestor is also home// module</P>

<P>remote_response(INTERVENTION, received_srcid, my_id,
data);
else 
remote_response(DATA_ONLY, received_secid, my_id,
data);
remote_response(INTERVENTION, received_srcid, my_id); 
endif; 
case INVALID:  // must have cast it out during
// an address collision
remote_response(NOT_OWNER, received_srcid, my_id); 
default: 
error();
free_entry(); 
endif; 
</P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30967">5.2.2 Memory-only Processing Element </P>

<P>This processing element is simpler than the assumed processing element used in Chapter 6, removing all of the internal request state machines and portions of all of the external request and response state machines. A memory-only processing element does not receive TLB invalidate entry or TLB invalidate synchronize operations. The required behavior for each operation is described below. </P>

<P id="LinkTarget_30968">5.2.2.1 Read Operations </P>

<P>This operation is a coherent data cache read. </P>

<P id="LinkTarget_30969">5.2.2.1.1  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of a third party. </P>

<P>switch(remote_response)</P>

<P>case INTERVENTION: update_memory();update_state(SHARED, original_srcid);remote_response(DONE_INTERVENTION, original_srcid, my_id);free_entry();</P>

<P>case NOT_OWNER, 	// data comes from memory,// mimic intervention </P>

<P>case RETRY: switch(directory_state)case LOCAL_SHARED: </P>

<P>update_state(SHARED, original_srcid);remote_response(DATA_ONLY, original_srcid,my_id, data);remote_response(DONE_INTERVENTION, original_srcid,my_id);free_entry();</P>

<P>case LOCAL_MODIFIED: update_state(SHARED, original_srcid);remote_response(DATA_ONLY, original_srcid,</P>

<P>my_id, data);remote_response(DONE_INTERVENTION, original_srcid,my_id);free_entry();case REMOTE_MODIFIED: // spin or wait for castoutremote_request(READ_OWNER, received_srcid,my_id, my_id);default: error();default: error(); </P>

<P id="LinkTarget_30970">5.2.2.1.2  External Request State Machine </P>

<P>This state machine handles read requests from the system to the local memory. This </P>

<Table>
<TR>
<TH>may require making further external requests. </TH>
</TR>

<TR>
<TH>if (address_collision) Tables” </TH>

<TD>// use collision tables in// Chapter 7, “Address Collision Resolution </TD>
</TR>

<TR>
<TH>else </TH>

<TD>assign_entry();switch (directory_state)case LOCAL_MODIFIED: </TD>

<TD>// READ_HOME </TD>
</TR>

<TR>
<TH>local_request(READ); </TH>

<TD/>
</TR>
</Table>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>update_state(SHARED, received_srcid);</P>

<P>// after possible push completesremote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case LOCAL_SHARED, </P>

<P>case SHARED: update_state(SHARED, received_srcid);remote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case REMOTE_MODIFIED: if (mask_id ~= received_srcid) // intervention caseremote_request(READ_OWNER, mask_id,my_id, received_srcid); else </P>

<P>error(); 	// he already owned it; // cache paradox (or I-fetch after d// store if not fixed elsewhere) </P>

<P>endif; 
default: 
error();
endif; 
</P>

<P id="LinkTarget_30971">5.2.2.2 Instruction Read Operations </P>

<P>This operation is a partially coherent instruction cache read. </P>

<P id="LinkTarget_30972">5.2.2.2.1  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of a third party. </P>

<P>switch(remote_response)</P>

<P>case INTERVENTION: 
update_memory();
update_state(SHARED, original_srcid);
remote_response(DONE, original_srcid, my_id);
free_entry();
</P>

<P>case NOT_OWNER, 	// data comes from memory,
// mimic intervention 
</P>

<P>case RETRY: 
switch(directory_state)
case LOCAL_SHARED: 
</P>

<P>update_state(SHARED, original_srcid);remote_response(DONE, original_srcid, my_id);free_entry();</P>

<P>case LOCAL_MODIFIED: update_state(SHARED, original_srcid);remote_response(DONE, original_srcid, my_id);free_entry();</P>

<P>case REMOTE_MODIFIED: // spin or wait for castout
remote_request(READ_OWNER, received_srcid,
my_id, my_id);
default: 
error();
default: 
error(); 
</P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30973">5.2.2.2.2  External Request State Machine </P>

<P>This state machine handles instruction read requests from the system to the local memory. This may require making further external requests. </P>

<P>if (address_collision) // use collision tables in</P>

<P>// Chapter 7, “Address Collision Resolution Tables” else // IREAD_HOME </P>

<P>assign_entry();
switch (directory_state)
case LOCAL_MODIFIED: 
</P>

<P>local_request(READ);update_state(SHARED, received_srcid);</P>

<P>// after possible push completesremote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case LOCAL_SHARED, </P>

<P>case SHARED: update_state(SHARED, received_srcid);remote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case REMOTE_MODIFIED: if (mask_id ~= received_srcid) // intervention caseremote_request(READ_OWNER, mask_id,my_id, received_srcid); else // he already owned it in his //data cache; cache paradox caseremote_request(READ_OWNER, mask_id, my_id, my_id); endif; default: error();endif; </P>

<P id="LinkTarget_30974">5.2.2.3 Read for Ownership Operations </P>

<P>This is the coherent cache store miss operation. </P>

<P id="LinkTarget_30975">5.2.2.3.1  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of a third party. </P>

<P>switch(received_response)
case DONE: // invalidates for shared 
// directory states
if ((mask ~= (my_id OR received_id)) == 0) 
</P>

<P>// this is the last DONEupdate_state(REMOTE_MODIFIED, original_srcid);remote_response(DONE, original_srcid, my_id, data);free_entry(); </P>

<P>else mask &lt;= (mask ~= received_srcid); // flip the responder’s shared bit endif; // and wait for next DONEcase INTERVENTION: // remote_modified case update_memory(); // for possible coherence error</P>

<P>// recoveryupdate_state(REMOTE_MODIFIED, original_id);remote_response(DONE_INTERVENTION, original_id, my_id);free_entry();</P>

<P>case NOT_OWNER: // data comes from memory, mimic </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>// intervention switch(directory_state)case LOCAL_SHARED: case LOCAL_MODIFIED: </P>

<P>update_state(REMOTE_MODIFIED, original_srcid);remote_response(DATA_ONLY, original_srcid, my_id,</P>

<P>data);remote_response(DONE, original_srcid, my_id);free_entry();</P>

<P>case REMOTE_MODIFIED: remote_request(READ_TO_OWN_OWNER, received_srcid,my_id, original_srcid);default: error();</P>

<P>case RETRY: 
switch (directory_state)
case LOCAL_MODIFIED, 
case LOCAL_SHARED: 
</P>

<P>update_state(REMOTE_MODIFIED, original_srcid);remote_response(DATA_ONLY, original_srcid, my_id,</P>

<P>data);remote_response(DONE, original_srcid, my_id);free_entry();</P>

<P>case REMOTE_MODIFIED: // mask_id must match received_srcid
// or error condition
remote_request(READ_TO_OWN_OWNER, received_srcid,
my_id, my_id);
case SHARED: 
remote_request(DKILL_SHARER, received_srcid, my_id,
my_id);
default: 
error();
default: 
error(); 
</P>

<P id="LinkTarget_30976">5.2.2.3.2  External Request State Machine </P>

<P>This state machine handles requests from the interconnect to the local memory. This may require making further external requests. </P>

<P>if (address_collision) // use collision tables</P>

<P>// in Chapter 7, “Address Collision Resolution Tables” else // READ_TO_OWN_HOME </P>

<P>assign_entry();
switch (directory_state)
case LOCAL_MODIFIED, 
case LOCAL_SHARED: 
</P>

<P>local_request(READ_TO_OWN);remote_response(DONE, received_srcid, my_id, data);</P>

<P>// after possible pushupdate_state(REMOTE_MODIFIED, received_srcid);free_entry();</P>

<P>case REMOTE_MODIFIED: if (mask_id ~= received_srcid) //intervention caseremote_request(READ_TO_OWN_OWNER, mask_id, my_id,received_srcid);else error(); // he already owned it! endif; </P>

<P>case SHARED: 
local_request(READ_TO_OWN);
if (mask == received_srcid) 
</P>

<P>//requestor is only remote sharerupdate_state(REMOTE_MODIFIED, received_srcid); </P>

<P>RapidIO Trade Association </P>

<P>remote_response(DONE, received_srcid, my_id, data);// from memory free_entry();else //there are other remote sharersremote_request(DKILL_SHARER, (mask ~= received_srcid),my_id, my_id);endif; default: error();endif; </P>

<P id="LinkTarget_30977">5.2.2.4 Data Cache and Instruction Cache Invalidate Operations </P>

<P>This operation is used with coherent cache store-hit-on-shared, cache operations. </P>

<P id="LinkTarget_30978">5.2.2.4.1  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of a third party. </P>

<P>switch(received_response)
case DONE: // invalidates for shared 
// directory states
if ((mask ~= (my_id OR received_id)) == 0) 
</P>

<P>// this is the last DONEupdate_state(REMOTE_MODIFIED, original_srcid);remote_response(DONE, original_srcid, my_id);free_entry(); </P>

<P>else mask &lt;= (mask ~= received_srcid); // flip the responder’s shared bit endif; // and wait for next DONEcase RETRY: remote_request({DKILL_SHARER, IKILL_SHARER}, received_srcid,my_id); // retry default: error(); </P>

<P id="LinkTarget_30979">5.2.2.4.2  External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory. This may require making further external requests. </P>

<P>if (address_collision) // use collision tables in</P>

<P>// Chapter 7, “Address Collision Resolution Tables” else // DKILL_HOME or IKILL_HOME </P>

<P>assign_entry();</P>

<P>if (DKILL_HOME)switch (directory_state)case LOCAL_MODIFIED, // cache paradoxes; DKILL is</P>

<P>// write-hit-on-shared case LOCAL_SHARED, case REMOTE_MODIFIED: </P>

<P>error();case SHARED: // this is the right case, send</P>

<P>// invalidates to the sharing list local_request(DKILL);if (mask == received_srcid</P>

<P>// requestor is only remote sharerupdate_state(REMOTE_MODIFIED, received_srcid);remote_response(DONE, received_srcid, my_id);free_entry();</P>

<P>else // there are other remote sharersremote_request(DKILL_SHARER, </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>(mask ~= received_srcid), my_id, NULL); endif; default: error();else // IKILL goes to everyone except the// requestor</P>

<P>remote_request(IKILL_SHARER,(mask &lt;= (participant_list ~=(received_srcid AND my_id), my_id); endif; </P>

<P id="LinkTarget_30980">5.2.2.5 Castout Operations </P>

<P>This operation is used to return ownership of a coherence granule to home memory, leaving it invalid in the cache. </P>

<P id="LinkTarget_30981">5.2.2.5.1  External Request State Machine </P>

<P>This machine handles requests from the system to the local memory. This may require making further external requests. </P>

<P>assign_entry();
update_memory();
state_update(LOCAL_SHARED, my_id); // may be LOCAL_MODIFIED if the
</P>

<P>// default is owned locally 
remote_response(DONE, received_srcid, my_id);
free_entry(); 
</P>

<P id="LinkTarget_30982">5.2.2.6 Data Cache Flush Operations </P>

<P>This operation returns ownership of a coherence granule to home memory and performs a coherent write. </P>

<P id="LinkTarget_30983">5.2.2.6.1  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of a third party. </P>

<P>switch(received_response)
case DONE: // invalidates for shared directory
// states 
if ((mask ~= (my_id OR received_id)) == 0) 
</P>

<P>// this is the last DONEremote_response(DONE, original_srcid, my_id, my_id);if (received_data) </P>

<P>// with original request or response </P>

<P>update_memory();endif; update_state(LOCAL_SHARED); // or LOCAL_MODIFIEDfree_entry(); </P>

<P>else mask &lt;= (mask ~= received_srcid); // flip responder’s shared bit endif; // and wait for next DONE</P>

<P>case NOT_OWNER: 
switch(directory_state)
case LOCAL_SHARED, 
case LOCAL_MODIFIED: 
</P>

<P>remote_response(DONE, original_srcid, my_id);if (received_data) // with original request update_memory();endif; </P>

<P>RapidIO Trade Association </P>

<P>free_entry();case REMOTE_MODIFIED: remote_request(READ_TO_OWN_OWNER, received_srcid,my_id, original_srcid);default: error();</P>

<P>case RETRY: 
switch(directory_state)
case LOCAL_SHARED, 
case LOCAL_MODIFIED: 
</P>

<P>remote_response(DONE, original_srcid, my_id);if (received_data) // with original request </P>

<P>update_memory();endif; free_entry();</P>

<P>case REMOTE_MODIFIED: 
remote_request(READ_TO_OWN_OWNER, received_srcid,
my_id, original_srcid);
case SHARED: 
remote_request(DKILL_SHARER, received_srcid, my_id); 
default: 
error();
default: 
error(); 
</P>

<P id="LinkTarget_30984">5.2.2.6.2  External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory. This may require making further external requests. </P>

<P>if (address_collision) // use collision tables in</P>

<P>// Chapter 7, “Address Collision Resolution Tables” else // FLUSH </P>

<P>assign_entry();
switch (directory_state)
case LOCAL_MODIFIED, 
case LOCAL_SHARED: 
</P>

<P>local_request(READ_TO_OWN);remote_response(DONE, received_srcid, my_id);// after snoop completes if (received_data) // from request or local response </P>

<P>update_memory();endif; update_state(LOCAL_SHARED, my_id);</P>

<P>// or LOCAL_MODIFIED free_entry();case REMOTE_MODIFIED: if (mask_id ~= received_srcid) // owned elsewhereremote_request(READ_TO_OWN_OWNER, mask_id, my_id,received_srcid);else // requestor owned it; shouldn’t // generate a flush error();endif; </P>

<P>case SHARED: local_request(READ_TO_OWN);if (mask == received_srcid) // requestor is only remote sharer</P>

<P>remote_response(DONE, received_srcid, my_id);// after snoop completes if (received_data) // from request or response</P>

<P>update_memory(); endif; update_state(LOCAL_SHARED, my_id); // or LOCAL_MODIFIEDfree_entry(); </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>else //there are other remote sharersremote_request(DKILL_SHARER, (mask ~= received_srcid), my_id,my_id);endif; default: error();endif; </P>

<P id="LinkTarget_30985">5.2.2.7 I/O Read Operations </P>

<P>This operation is used for I/O reads of globally shared memory space. </P>

<P id="LinkTarget_30986">5.2.2.7.1  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of a third party. </P>

<P>switch(remote_response)</P>

<P>case INTERVENTION: update_memory();remote_response(DONE_INTERVENTION, original_srcid, my_id);free_entry();</P>

<P>case NOT_OWNER, 	// data comes from memory, mimic// intervention </P>

<P>case RETRY: switch(directory_state)case LOCAL_MODIFIED, case LOCAL_SHARED: </P>

<P>remote_response(DATA_ONLY, original_srcid, my_id,data);remote_response(DONE_INTERVENTION, original_srcid,my_id);free_entry();case REMOTE_MODIFIED: // spin or wait for castoutremote_request(IO_READ_OWNER, received_srcid, my_id,my_id);default: error();default: error(); </P>

<P id="LinkTarget_30987">5.2.2.7.2  External Request State Machine </P>

<P>This machine handles requests from the system to the local memory. This may </P>

<P>remote_response(DONE, received_srcid, my_id, data);</P>

<Table>
<TR>
<TH>require making further external requests. </TH>
</TR>

<TR>
<TH>if (address_collision) Tables” </TH>

<TD>// use collision tables in// Chapter 7, “Address Collision Resolution </TD>
</TR>

<TR>
<TH>else </TH>

<TD>assign_entry();switch (directory_state)case LOCAL_MODIFIED: </TD>

<TD>// IO_READ_HOME </TD>
</TR>

<TR>
<TH>local_request(READ_LATEST);</TH>

<TD/>
</TR>
</Table>

<P>// after push completes free_entry();</P>

<P>case LOCAL_SHARED: remote_response(DONE, received_srcid, my_id, data);free_entry();</P>

<P>case REMOTE_MODIFIED: remote_request(IO_READ_OWNER, mask_id, my_id, received_srcid);</P>

<P>case SHARED: remote_response(DONE, received_srcid, my_id, data);free_entry(); </P>

<P>RapidIO Trade Association </P>

<P>default: </P>

<P>error();</P>

<P>endif; </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_30988">5.2.3 Processor-only Processing Element </P>

<P>A processor-only processing element is much simpler than the assumed combined processing described in Chapter 6. Much of the internal request, response, and external request state machines are removed. </P>

<P id="LinkTarget_30989">5.2.3.1 Read Operations </P>

<P>This operation is a coherent data cache read. </P>

<P id="LinkTarget_30990">5.2.3.1.1 Internal Request State Machine </P>

<P>This state machine handles requests to remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external request// in progress or a cache local_response(RETRY); // index hazard from a previous request else // remote - we’ve got to go </P>

<P>// to another module assign_entry();local_response(RETRY); // can’t guarantee data before a</P>

<P>// snoop yet
remote_request(READ_HOME, mem_id, my_id); 
endif; 
</P>

<P id="LinkTarget_30991">5.2.3.1.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local processor. </P>

<P>switch(remote_response)</P>

<P>case DONE: 
local_response(SHARED); // when processor re-requests 
return_data();
free_entry();
</P>

<P>case DONE_INTERVENTION: // must be from third party 
set_received_done_message();
if (received_data_only_message)
</P>

<P>free_entry(); else // wait for a DATA_ONLY endif; </P>

<P>case DATA_ONLY: 	// this is due to an intervention, a// DONE_INTERVENTIONshould come// separately </P>

<P>local_response(SHARED);
set_received_data_only_message();
if (received_done_message)
</P>

<P>return_data();
free_entry(); 
else 
return_data(); // OK for weak ordering 
endif; 
case RETRY: 
remote_request(READ_HOME, received_srcid, my_id); 
default 
error(); 
</P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30992">5.2.3.1.3  External Request State Machine </P>

<P>This state machine handles read requests from the system to the local processor. This </P>

<Table>
<TR>
<TH>may require making further external requests. </TH>
</TR>

<TR>
<TH>if (address_collision) Tables” </TH>

<TD>// use collision tables in// Chapter 7, “Address Collision Resolution </TD>
</TR>

<TR>
<TH>else </TH>

<TD>assign_entry();local_request(READ); switch (local_response)case MODIFIED: </TD>

<TD>// READ_OWNER // spin until a valid response// from caches // processor indicated a push;// wait for it</TD>
</TR>
</Table>

<P>cache_state(SHARED or INVALID);</P>

<P>// surrender ownershipif (received_srcid == received_secid)// original requestor is also homeremote_response(INTERVENTION, received_srcid,my_id, data);else remote_response(DATA_ONLY, received_secid,my_id, data);remote_response(INTERVENTION, received_srcid,my_id, data);endif; case INVALID: // must have cast it outremote_response(NOT_OWNER, received_srcid, my_id); default: error();free_entry(); endif; </P>

<P id="LinkTarget_30993">5.2.3.2 Instruction Read Operations </P>

<P>This operation is a partially coherent instruction cache read. </P>

<P id="LinkTarget_30994">5.2.3.2.1 Internal Request State Machine </P>

<P>This state machine handles requests to remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external// request in progress or a cache local_response(RETRY); // index hazard from a previous requestelse // remote - we’ve got to go</P>

<P>// to another module assign_entry();local_response(RETRY); </P>

<P>// can’t guarantee data before a// snoop yetremote_request(IREAD_HOME, mem_id, my_id); endif; </P>

<P id="LinkTarget_30995">5.2.3.2.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local processor. </P>

<P>switch(remote_response)</P>

<P>case DONE: local_response(SHARED); // when processor re-requests return_data();free_entry(); </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>case DONE_INTERVENTION: // must be from third party set_received_done_message();if (received_data_only_message)</P>

<P>free_entry(); 
else 
</P>

<P>// wait for a DATA_ONLY </P>

<P>endif; </P>

<P>case DATA_ONLY: // this is due to an intervention; a</P>

<P>// DONE_INTERVENTION should come</P>

<P>// separately local_response(SHARED);set_received_data_only_message();if (received_done_message)</P>

<P>return_data();</P>

<Table>
<TR>
<TH>else </TH>

<TH>free_entry(); </TH>
</TR>

<TR>
<TD>endif; case RETRY: </TD>

<TD>return_data(); </TD>

<TD>// OK for weak ordering </TD>
</TR>
</Table>

<P>remote_request(IREAD_HOME, received_srcid, my_id); default error(); </P>

<P id="LinkTarget_30996">5.2.3.2.3  External Request State Machine </P>

<P>This state machine handles instruction read requests from the system to the local processor. </P>

<P>if (address_collision) // use collision tables in</P>

<P>// Chapter 7, “Address Collision Resolution Tables” else // READ_OWNER request to our caches </P>

<P>assign_entry();
local_request(READ); // spin until a valid response
</P>

<P>// from cachesswitch (local_response)case MODIFIED: // processor indicated a push;</P>

<P>// wait for itcache_state(SHARED or INVALID);// surrender ownershipif (received_srcid == received_secid)// original requestor is also homeremote_response(INTERVENTION, received_srcid,my_id, data);else remote_response(DATA_ONLY, received_secid,my_id, data);remote_response(INTERVENTION, received_srcid,my_id, data);endif; case INVALID: // must have cast it outremote_response(NOT_OWNER, received_srcid, my_id); default: error();free_entry(); endif; </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_30997">5.2.3.3 Read for Ownership Operations </P>

<P>This is the coherent cache store miss operation. </P>

<P id="LinkTarget_30998">5.2.3.3.1 Internal Request State Machine </P>

<P>This state machine handles requests to remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external request// in progress or a cache index local_response(RETRY); // hazard from a previous request else // remote - we’ve got to go to another</P>

<P>// moduleassign_entry();local_response(RETRY);remote_request(READ_TO_OWN_HOME, mem_id, my_id); endif; </P>

<P id="LinkTarget_30999">5.2.3.3.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local processor. </P>

<P>switch (received_response)</P>

<P>case DONE: 
local_response(EXCLUSIVE);
return_data();
free_entry();
</P>

<P>case DONE_INTERVENTION: 
set_received_done_message();
if (received_data_message)
</P>

<P>free_entry(); else // wait for DATA_ONLY endif; </P>

<P>case DATA_ONLY: 
set_received_data_message();
local_response(EXCLUSIVE);
if (received_done_message)
</P>

<P>return_data();free_entry(); else return_data(); // OK for weak ordering endif; // and wait for a DONE case RETRY: // lost at remote memory so retryremote_request(READ_TO_OWN_HOME, mem_id, my_id); default: error(); </P>

<P id="LinkTarget_31000">5.2.3.3.3  External Request State Machine </P>

<P>This state machine handles requests from the interconnect to the local processor. </P>

<P>if (address_collision) // use collision tables</P>

<P>// in Chapter 7, “Address Collision Resolution Tables” elseif(READ_TO_OWN_OWNER // request to our caches </P>

<P>assign_entry();
local_request(READ_TO_OWN); // spin until a valid response from
</P>

<P>// the caches switch (local_response)case MODIFIED: // processor indicated a push </P>

<P>cache_state(INVALID); // surrender ownershipif (received_srcid == received_secid) </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>//the original request is from the homeremote_response(INTERVENTION, received_srcid, my_id,data);else // the original request is from a// third partyremote_response(DATA_ONLY, received_secid, my_id,data);remote_response(INTERVENTION, received_srcid, my_id,</P>

<P>data);endif; free_entry();</P>

<P>case INVALID: // castout address collisionremote_response(NOT_OWNER, received_srcid, my_id); default: error();</P>

<P>else // DKILL_SHARER request to our caches assign_entry();local_request(READ_TO_OWN); </P>

<P>// spin until a valid response from the</P>

<P>// caches switch (local_response)case SHARED, case INVALID: // invalidating for shared cases </P>

<P>cache_state(INVALID); // surrender copyremote_response(DONE, received_srcid, my_id);free_entry(); </P>

<P>default: 
error(); 
</P>

<P>endif; </P>

<P id="LinkTarget_31001">5.2.3.4 Data Cache and Instruction Cache Invalidate Operations </P>

<P>This operation is used with coherent cache store-hit-on-shared, cache operations. </P>

<P id="LinkTarget_31002">5.2.3.4.1 Internal Request State Machine </P>

<P>This state machine handles requests to remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external request in 
// progress or a cache index 
local_response(RETRY); // hazard from a previous request 
else // remote - we’ve got to go to another
</P>

<P>// moduleassign_entry();local_response(RETRY);remote_request({DKILL_HOME, IKILL_HOME}, mem_id, my_id); </P>

<P>endif; </P>

<P id="LinkTarget_31003">5.2.3.4.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local processor. </P>

<P>switch (received_response)</P>

<P>case DONE: 
local_response(EXCLUSIVE);
free_entry(); 
</P>

<P>case RETRY: 
remote_request({DKILL_HOME, IKILL_HOME}, received_srcid,
my_id); // retry the transaction 
default: 
error(); 
</P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31004">5.2.3.4.3  External Request State Machine </P>

<P>This state machine handles requests from the system to the local processor. </P>

<P>if (address_collision) // use collision tables in</P>

<P>// Chapter 7, “Address Collision Resolution Tables” else // DKILL_SHARER or IKILL_SHARER request to our caches </P>

<P>assign_entry();</P>

<P>local_request({READ_TO_OWN, IKILL}); // spin until a valid response from the// caches </P>

<P>switch (local_response)
case SHARED, 
case INVALID: // invalidating for shared cases 
</P>

<P>cache_state(INVALID); // surrender copyremote_response(DONE, received_srcid, my_id);free_entry(); </P>

<P>default: 
error();
endif; 
</P>

<P id="LinkTarget_31005">5.2.3.5 Castout Operations </P>

<P>This operation is used to return ownership of a coherence granule to home memory, leaving it invalid in the cache. A processor-only processing element is never the target of a castout operation. </P>

<P id="LinkTarget_31006">5.2.3.5.1 Internal Request State Machine </P>

<P>A castout may require local activity to flush all caches in the hierarchy and break possible reservations. </P>

<P>assign_entry();
local_response(OK);
remote_request(CASTOUT, mem_id, my_id, data); 
</P>

<P id="LinkTarget_31007">5.2.3.5.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local processor. </P>

<P>switch (received_response)
case DONE: 
free_entry(); 
default: 
error(); 
</P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_31008">5.2.3.6 	TLB Invalidate Entry, TLB Invalidate Entry Synchronize Operations </P>

<P>These operations are used for software coherence management of the TLBs. </P>

<P id="LinkTarget_31009">5.2.3.6.1 Internal Request State Machine </P>

<P>The TLBIE and TLBSYNC transactions are always sent to all domain participants except the sender and are always to the processor, not home memory. </P>

<P>assign_entry();
remote_request({TLBIE, TLBSYNC}, participant_id, my_id);
endif; 
</P>

<P id="LinkTarget_31010">5.2.3.6.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local processor. The responses are always from a coherence participant, not a home memory. </P>

<P>switch (received_response)
case DONE: 
if ((mask ~= (my_id OR received_id)) == 0) 
// this is the last DONE 
free_entry(); 
else 
</P>

<P>mask &lt;= (mask ~= received_srcid); // flip the responder’s participant// bit and wait for next DONE </P>

<P>endif; 
case RETRY: 
remote_request({TLBIE, TLBSYNC}, received_srcid, my_id, my_id); 
default 
error(); 
</P>

<P id="LinkTarget_31011">5.2.3.6.3  External Request State Machine </P>

<P>This state machine handles requests from the system to the local memory or the local processor. The requests are always to the local caching hierarchy. </P>

<P>assign_entry();
local_request({TLBIE, TLBSYNC}); // spin until a valid response
</P>

<P>// from the caches 
remote_response(DONE, received_srcid, my_id);
free_entry(); 
</P>

<P id="LinkTarget_31012">5.2.3.7 Data Cache Flush Operations </P>

<P>This operation returns ownership of a coherence granule to home memory and performs a coherent write. </P>

<P id="LinkTarget_31013">5.2.3.7.1 Internal Request State Machine </P>

<P>This state machine handles requests to remote memory from the local processor. </P>

<P>if (address_collision) // this is due to an external
// request in progress or a cache index 
local_response(RETRY); // hazard from a previous request 
else // remote - we’ve got to go to
</P>

<P>// another module assign_entry();remote_request(FLUSH, mem_id, my_id, data); </P>

<P>RapidIO Trade Association </P>

<P>// data is optional 
endif; 
</P>

<P id="LinkTarget_31014">5.2.3.7.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect on behalf of the local processor. </P>

<P>switch (received_response)</P>

<P>case DONE: 
local_response(OK);
free_entry(); 
</P>

<P>case RETRY: 
remote_request(FLUSH, received_srcid, my_id, data);
// data is optional 
default: 
error(); 
</P>

<P id="LinkTarget_31015">5.2.3.7.3  External Request State Machine </P>

<P>This state machine handles requests from the system to the local processor. </P>

<P>if (address_collision) // use collision tables in</P>

<P>// Chapter 7, “Address Collision Resolution Tables” elseif (READ_TO_OWN_OWNER) // remote request to our caches </P>

<P>assign_entry();
local_request(READ_TO_OWN); // spin until a valid response 
</P>

<P>// from the caches switch (local_response)case MODIFIED: // processor indicated a push, </P>

<P>// wait for it cache_state(INVALID); // surrender ownershipremote_response(DONE, received_srcid, my_id, data);</P>

<P>case INVALID: // must have cast it out during an// address collision</P>

<P>remote_response(NOT_OWNER, received_srcid, my_id); default: error();free_entry(); else // DKILL_SHARER remote request</P>

<P>// to our caches assign_entry();local_request(DKILL); // spin until a valid response from</P>

<P>// the caches switch (local_response)case MODIFIED: // cache paradox</P>

<P>remote_response(ERROR, received_srcid, my_id);
case INVALID: 
remote_response(DONE, received_srcid, my_id); 
default: 
error();
free_entry(); 
endif; 
</P>

<P id="LinkTarget_31016">5.2.3.8 I/O Read Operations </P>

<P>This operation is used for I/O reads of globally shared memory space. A processor-only processing element never initiates an I/O read operation. </P>

<P id="LinkTarget_31017">5.2.3.8.1  External Request State Machine </P>

<P>This machine handles requests from the system to the local memory or the local </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>processor. This may require making further external requests. </P>

<P>if (address_collision) // use collision tables in</P>

<P>// Chapter 7, “Address Collision Resolution Tables” else // IO_READ_OWNER request to our caches </P>

<P>assign_entry();
local_request(READ_LATEST); // spin until a valid response from
</P>

<P>// the caches switch (local_response)case MODIFIED: // processor indicated a push;</P>

<P>// wait for it</P>

<P>if (received_srcid == received_secid)// original requestor is also home// module</P>

<P>remote_response(INTERVENTION, received_srcid, my_id,data);else remote_response(DATA_ONLY, received_secid, my_id,data);remote_response(INTERVENTION, received_srcid, my_id); endif; case INVALID:  // must have cast it out during// an address collisionremote_response(NOT_OWNER, received_srcid, my_id); default: error();free_entry(); endif; </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31018">5.2.4 I/O Processing Element </P>

<P>The simplest GSM processing element is an I/O device. A RapidIO I/O processing element does not actually participate in the globally shared memory environment (it is defined as not in the coherence domain), but is able to read and write data into the GSM address space through special I/O operations that provide for this behavior. These operations are the I/O Read and Data Cache Flush operations. Other than the ability to read and write into the GSM address space, an I/O device has no other operational requirements. Since the I/O processing element is not part of the coherence domain, it is never the target of a coherence transaction and thus does not have to implement any of the related behavior, including the address collision tables. </P>

<P>Requirements for a specific I/O processing element, a RapidIO to PCI/PCI-X 
<Link>bridge, is discussed in Chapter  4, “PCI Considerations,” on page 4-27. </Link>
</P>

<P id="LinkTarget_31019">5.2.4.1 I/O Read Operations </P>

<P>This operation is used for I/O reads of globally shared memory space. </P>

<P id="LinkTarget_31020">5.2.4.1.1 Internal Request State Machine </P>

<P>This state machine handles requests to remote memory. </P>

<P>remote_request(IO_READ_HOME, mem_id, my_id); </P>

<P id="LinkTarget_31021">5.2.4.1.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect. </P>

<P>switch(remote_response)</P>

<P>case DONE: return_data();</P>

<P>free_entry();case DONE_INTERVENTION: // must be from third party </P>

<P>set_received_done_message();</P>

<P>if (received_data_only_message)</P>

<P>free_entry(); else </P>

<P>// wait for a DATA_ONLY endif; </P>

<P>case DATA_ONLY: // this is due to an intervention, a</P>

<P>// DONE_INTERVENTION should come</P>

<P>// separately set_received_data_only_message();if (received_done_message)</P>

<P>return_data();</P>

<Table>
<TR>
<TH>else </TH>

<TH>free_entry(); </TH>
</TR>

<TR>
<TD>endif; case RETRY: </TD>

<TD>return_data(); </TD>

<TD>// OK for weak ordering </TD>
</TR>
</Table>

<P>remote_request(IO_READ_HOME, received_srcid, my_id); default </P>

<P>error(); </P>

<P id="LinkTarget_31022">5.2.4.2 Data Cache Flush Operations </P>

<P>This operation returns ownership of a coherence granule to home memory and performs a coherent write. </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_31023">5.2.4.2.1 Internal Request State Machine </P>

<P>This state machine handles requests to remote memory. </P>

<P>remote_request(FLUSH, mem_id, my_id, data); </P>

<P id="LinkTarget_31024">5.2.4.2.2  Response State Machine </P>

<P>This state machine handles responses to requests made to the RapidIO interconnect. </P>

<P>switch (received_response)</P>

<P>case DONE: 
local_response(OK);
free_entry(); 
</P>

<P>case RETRY: 
remote_request(FLUSH, received_srcid, my_id, data); 
</P>

<P>default: 
error(); 
</P>

<P id="LinkTarget_31025">5.2.5 Switch Processing Element </P>

<P>A switch processing element is required to be able to route all defined packets. Since it is not necessary for a switch to analyze a packet in order to determine how it should be treated outside of examining the priority and the destination device ID, a switch processing element does not have any additional requirements to be used in a globally shared memory environment. </P>

<P id="LinkTarget_31026">5.3 Transaction to Priority Mappings </P>

<P>The Globally Shared Memory model does not have the concept of an end point to end point request transaction flow like the I/O programming model. Instead, all transaction ordering is managed by the load-store units of the processors participating in the globally shared memory protocol. The GSM logical specification behaviors assume an unordered and resource unconstrained communication fabric. The ordered fabric of the 8/16 LP-LVDS and the 1x/4x LP-Serial physical layers requires the proper transaction to priority mappings to mimic the effect of an unordered fabric to suit the GSM model. These mappings leverage the physical layer ordering and deadlock avoidance rules that are required by the I/O Logical layer. In addition, it is assumed that the latency-critical GSM operations are of necessity higher priority than non-coherent I/O traffic, therefore I/O operations are recommended to be assigned to the lowest system priority flow. </P>

<P>RapidIO Trade Association </P>

<P>
<Link>Table 5-1 shows the GSM transaction to priority mappings. </Link>
</P>

<Table>
<Caption>
<P>Table 5-1. Transaction to Priority Mapping </P>
</Caption>

<TR>
<TH>Request transaction </TH>

<TH>Request Packet Priority </TH>

<TH>Response Packet Priority </TH>
</TR>

<TR>
<TD>READ_TO_OWN_HOME </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>READ_HOME </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>IO_READ_HOME </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>IREAD_HOME </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>DKILL_HOME </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>IKILL_HOME </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>FLUSH (without data) </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>FLUSH (with data) </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>TLBIE </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>TLBSYNC </TD>

<TD>1 </TD>

<TD>2 or 3 </TD>
</TR>

<TR>
<TD>READ_OWNER </TD>

<TD>2 </TD>

<TD>3 </TD>
</TR>

<TR>
<TD>READ_TO_OWN_OWNER </TD>

<TD>2 </TD>

<TD>3 </TD>
</TR>

<TR>
<TD>IO_READ_OWNER </TD>

<TD>2 </TD>

<TD>3 </TD>
</TR>

<TR>
<TD>DKILL_SHARER </TD>

<TD>2 </TD>

<TD>3 </TD>
</TR>

<TR>
<TD>IKILL_SHARER </TD>

<TD>2 </TD>

<TD>3 </TD>
</TR>

<TR>
<TD>CASTOUT </TD>

<TD>2 </TD>

<TD>3 </TD>
</TR>
</Table>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P id="LinkTarget_31027">Glossary of Terms and Abbreviations 
</P>

<P>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </P>

<Table>
<TR>
<TD>A B </TD>

<TD>Agent. A processing element that provides services to a processor. Bridge. A processing element that connects one computer bus to another, allowing a processing element on one bus to access an processing element on the other. </TD>
</TR>

<TR>
<TD>C D </TD>

<TD>Cache. High-speed memory containing recently accessed data and/or instructions (subset of main memory) associated with a processor. Cache coherence. Caches are coherent if a processor performing a read from its cache is supplied with data corresponding to the most recent value written to memory or to another processor’s cache. In other words, a write operation to an address in the system is visible to all other caches in the system. Capability registers (CARs). A set of read-only registers that allows a processing element to determine another processing element’s capabilities. Command and status registers (CSRs). A set of registers that allows a processing element to control and determine the status of another processing element’s internal hardware. Control symbol. A quantum of information transmitted between two linked devices to manage packet flow between the devices. Deadlock. A situation in which two processing elements that are sharing resources prevent each other from accessing the resources, resulting in a halt of system operation. Delayed transaction. The process of the target of a transaction capturing the transaction and completing it after responding to the source with a retry. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 Destination. The termination point of a packet on the RapidIO interconnect, also referred to as a target. Device. A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a processing element. Device ID. The identifier of an end point processing element connected to the RapidIO interconnect. Double-word. An eight byte quantity, aligned on eight byte boundaries. </P>

<Table>
<TR>
<TH>E </TH>

<TD>End point. A processing element which is the source or destination of transactions through a RapidIO fabric. End point device. A processing element which contains end point functionality. </TD>
</TR>

<TR>
<TH>F </TH>

<TD>Field or Field name. A sub-unit of a register, where bits in the register are named and defined. </TD>
</TR>

<TR>
<TH>G H I L </TH>

<TD>Globally shared memory (GSM). Cache coherent system memory that can be shared between multiple processors in a system. Host. A processing element responsible for exploring and initializing all or a portion of a RapidIO based system. Initiator. The origin of a packet on the RapidIO interconnect, also referred to as a source. I/O. Input-output. Local memory. Memory associated with the processing element in question. LVDS. Low voltage differential signaling. </TD>
</TR>
</Table>

<P>M 
</P>

<P>Mailbox. Dedicated hardware that receives messages. </P>

<P>Message passing. An application programming model that allows processing elements to communicate via messages to mailboxes instead of via GSM. Message senders do not write to a memory address in the target. </P>

<Table>
<TR>
<TD>N </TD>

<TD>Non-coherent. A transaction that does not participate in any system globally </TD>
</TR>

<TR>
<TD/>

<TD>shared memory cache coherence mechanism. </TD>
</TR>

<TR>
<TD>68 </TD>

<TD>RapidIO Trade Association </TD>
</TR>
</Table>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>O Operation. A set of transactions between end point devices in a RapidIO system (requests and associated responses) such as a read or a write. </P>

<P>P 
</P>

<P>Packet. 	A set of information transmitted between devices in a RapidIO system. </P>

<P>Peripheral component interface (PCI). A bus commonly used for connecting I/O devices in a system. </P>

<P>Port-write. An address-less maintenance write operation. </P>

<P>Priority. The relative importance of a transaction or packet; in most systems a higher priority transaction or packet will be serviced or transmitted before one of lower priority. </P>

<P>Processing Element (PE). A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a device. </P>

<P>Processor. The logic circuitry that responds to and processes the basic instructions that drive a computer. </P>

<P>R Remote memory. Memory associated with a processing element other than the processing element in question. </P>

<P>ROM. Read-only memory. </P>

<P>S 
</P>

<P>Sender. The RapidIO interface output port on a processing element. </P>

<P>Source. The origin of a packet on the RapidIO interconnect, also referred to as an initiator. </P>

<P>Switch. A multiple port processing element that directs a packet received on one of its input ports to one of its output ports. </P>

<P>Symbol. A 16-bit quantity. </P>

<P>T 
</P>

<P>Target. The termination point of a packet on the RapidIO interconnect, also referred to as a destination. </P>

<P>Transaction. A specific request or response packet transmitted between end point devices in a RapidIO system. </P>

<P>Transaction request flow. A sequence of transactions between two processing elements that have a required completion order at the destination processing element. There are no ordering requirements between transaction request flows. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Part 7: System and Device Inter-operability Specification Rev. 1.3 </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P id="LinkTarget_31028">RapidIO™ Interconnect SpecificationPart 8: Error ManagementExtensions Specification </P>

<P>Rev. 1.3, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_97.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>
</TR>

<TR>
<TD>1.2 </TD>

<TD>First public release </TD>

<TD>09/13/2002 </TD>
</TR>

<TR>
<TD>1.3 </TD>

<TD>Technical changes: the following errata showings: 04-02-00002.001 and the following new features showings: 04-09-00022.002 Converted to ISO-friendly templates </TD>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TD>1.3 </TD>

<TD>Removed confidentiality markings for public release </TD>

<TD>06/07/2005 </TD>
</TR>
</Table>

<P>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE 
ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND 
CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO 
WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE. USER AGREES TO 
ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE 
GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR 
RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER 
SUCH USE OF THE SPECIFICATION. 
</P>

<P>DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, 
INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST 
PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION 
WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE 
RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. 
</P>

<P>Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: 
RapidIO Trade Association 
Suite 325, 3925 W. Braker Lane 
Austin, TX 78759 
512-305-0070 Tel. 
512-305-0009 FAX. 
</P>

<P>RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their 
respective owners. 
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents 
</P>

<P>
<Link>Chapter 1 Error Management Extensions </Link>
</P>

<P>
<Link>1.1 Introduction............................................................................................................. 7 
</Link>
</P>

<P>
<Link>1.2 Physical Layer Extensions ...................................................................................... 7 
</Link>
</P>

<P>
<Link>1.2.1 Port Error Detect, Enable and Capture CSRs ..................................................... 7 
</Link>
</P>

<P>
<Link>1.2.2 Error Reporting Thresholds ................................................................................ 8 
</Link>
</P>

<P>
<Link>1.2.3 Error Rate Control and Status ............................................................................. 8 
</Link>
</P>

<P>
<Link>1.2.4 Port Behavior When Error Rate Failed Threshold is Reached ........................... 9 
</Link>
</P>

<P>
<Link>1.2.5 Packet Timeout Mechanism in a Switch Device .............................................. 10 
</Link>
</P>

<P>
<Link>1.3 Logical and Transport Layer Extensions .............................................................. 10 
</Link>
</P>

<P>
<Link>1.3.1 Logical/Transport Error Detect, Enable and Capture CSRs ............................. 11 
</Link>
</P>

<P>
<Link>1.3.2 Message Passing Error Detection ..................................................................... 11 
</Link>
</P>

<P>
<Link>1.4 System Software Notification of Error ................................................................. 12 
</Link>
</P>

<P>
<Link>1.5 Mechanisms for Software Debug ......................................................................... 12 
</Link>
</P>

<P>
<Link>Chapter 2 Error Management Registers </Link>
</P>

<P>
<Link>2.1 Introduction........................................................................................................... 15 
</Link>
</P>

<P>
<Link>2.2 Additions to Existing Registers ............................................................................ 15 
</Link>
</P>

<P>
<Link>2.3 New Error Management Registers........................................................................ 16 
</Link>
</P>

<P>
<Link>2.3.1 Register Map..................................................................................................... 17 
</Link>
</P>

<P>
<Link>2.3.2 Command and Status Registers (CSRs) ........................................................... 18 
</Link>
</P>

<P>
<Link>2.3.2.1 Error Management Extensions Block Header (Block Offset 0x0) ............... 19 
</Link>
</P>

<P>
<Link>2.3.2.2 Logical/Transport Layer Error Detect CSR (Block Offset 0x08) ................ 19 
</Link>
</P>

<P>
<Link>2.3.2.3 Logical/Transport Layer Error Enable CSR (Block Offset 0x0C) ............... 20 
</Link>
</P>

<P>
<Link>2.3.2.4 Logical/Transport Layer High Address Capture CSR (Block Offset 0x10). 21 </Link>
</P>

<P>
<Link>2.3.2.5 Logical/Transport Layer Address Capture CSR (Block Offset 0x14).......... 21 
</Link>
</P>

<P>
<Link>2.3.2.6 Logical/Transport Layer Device ID Capture CSR (Block Offset 0x18) ...... 22 </Link>
</P>

<P>
<Link>2.3.2.7 Logical/Transport Layer Control Capture CSR (Block Offset 0x1C) .......... 22 
</Link>
</P>

<P>
<Link>2.3.2.8 Port-write Target deviceID CSR (Block Offset 0x28) ................................. 22 
</Link>
</P>

<P>
<Link>2.3.2.9 Packet Time-to-live CSR (Block Offset 0x2C) ............................................ 23 
</Link>
</P>

<P>
<Link>2.3.2.10 Port n Error Detect CSR (Block Offset 0x40, 80,..., 400) ............................ 23 
</Link>
</P>

<P>
<Link>2.3.2.11 Port n Error Rate Enable CSR (Block Offset 0x44, 84,..., 404) ................... 24 
</Link>
</P>

<P>
<Link>2.3.2.12 Port n Attributes Capture CSR (Block Offset 0x48, 88,..., 408) .................. 25 
</Link>
</P>

<P>
<Link>2.3.2.13 	Port n Packet/Control Symbol Capture 0 CSR (Block Offset 0x4C, 8C,..., 40C) .............................................................. 26 </Link>
</P>

<P>
<Link>2.3.2.14 Port n Packet Capture 1 CSR (Block Offset 0x50, 90,..., 410)..................... 26 
</Link>
</P>

<P>
<Link>2.3.2.15 Port n Packet Capture 2 CSR (Block Offset 0x54, 94,..., 414)..................... 26 
</Link>
</P>

<P>
<Link>2.3.2.16 Port n Packet Capture 3 CSR (Block Offset 0x58, 98,..., 418)..................... 26 
</Link>
</P>

<P>
<Link>2.3.2.17 Port n Error Rate CSR (Block Offset 0x68, A8,..., 428) .............................. 27 
</Link>
</P>

<P>
<Link>2.3.2.18 Port n Error Rate Threshold CSR (Block Offset 0x6C, AC,..., 42C) ........... 27 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Annex A  Error Management Discussion (Informative) </Link>
</P>

<P>
<Link>A.1 Introduction........................................................................................................... 29 
</Link>
</P>

<P>
<Link>A.2 Limitations of Error Management Discussion ...................................................... 29 
</Link>
</P>

<P>
<Link>A.3 Hot-insertion/extraction Discussion ..................................................................... 30 
</Link>
</P>

<P>
<Link>A.4 Port-write Discussion............................................................................................ 31 
</Link>
</P>

<P>
<Link>A.5 Physical Layer Fatal Error Recovery Discussion ................................................. 32 
</Link>
</P>

<P>A.6 
<Link>Persistence of Error Management Registers ......................................................... 33 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables 
</P>

<P>
<Link>1-1 Port Behavior when Error Rate Failed Threshold has been hit ......................................10 
</Link>

<Link>1-2 Port-write Packet Data Payload for Error Reporting ......................................................12 
</Link>

<Link>2-1 Bit Settings for Port n Control CSRs ..............................................................................15 
</Link>

<Link>2-2 Bit Settings for Port n Error and Status CSRs ................................................................16 
</Link>

<Link>2-3 Extended Feature Space Reserved Access Behavior ......................................................16 
</Link>

<Link>2-4 Error Management Extensions Register Map .................................................................17 
</Link>

<Link>2-5 Bit Settings for Error Management Extensions Block Header .......................................19 
</Link>

<Link>2-6 Bit Settings for Logical/Transport Layer Error Detect CSR ..........................................19 
</Link>

<Link>2-7 Bit Settings for Logical/Transport Layer Error Enable CSR..........................................20 
</Link>

<Link>2-8 Bit Settings for Logical/Transport Layer High Address Capture CSR ..........................21 
</Link>

<Link>2-9 Bit Settings for Logical/Transport Layer Address Capture CSR ...................................21 
</Link>

<Link>2-10 Bit Settings for Logical/Transport Layer Device ID Capture CSR ................................22 
</Link>

<Link>2-11 Bit Settings for Logical/Transport Layer Control Capture CSR ....................................22 
</Link>

<Link>2-12 Bit Settings for Port-write Target deviceID CSR ...........................................................22 
</Link>

<Link>2-13 Bit Settings for Packet Time-to-live CSR.......................................................................23 
</Link>

<Link>2-14 Bit Settings for Port n Error Detect CSR ........................................................................23 
</Link>

<Link>2-15 Bit Settings for Port n Error Rate Enable CSR ...............................................................24 
</Link>

<Link>2-16 Bit Settings for Port n Attributes Capture CSR ..............................................................25 
</Link>

<Link>2-17 Bit Settings for Port n Packet/Control Symbol Capture 0 CSR......................................26 
</Link>

<Link>2-18 Bit Settings for Port n Packet Capture 1 CSR ................................................................26 
</Link>

<Link>2-19 Bit Settings for Port n Packet Capture 2 CSR ................................................................26 
</Link>

<Link>2-20 Bit Settings for Port n Packet Capture 3 CSR ................................................................26 
</Link>

<Link>2-21 Bit Settings for Port n Error Rate CSR ...........................................................................27 
</Link>

<Link>2-22 Bit Settings for Port n Error Rate Threshold CSR ..........................................................27 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31029">Chapter 1  Error Management Extensions </P>

<P id="LinkTarget_31030">1.1 Introduction </P>

<P>The error management extensions describe added requirements in all physical and logical layers. These extensions add definitions to bits that were previously reserved in the Port n Control CSR and add new registers that are contained within the Error Management Extended Features Block. This chapter describes the behavior of a device when an error is detected and how the new registers and bits are managed by software and hardware. </P>

<P id="LinkTarget_31031">1.2 Physical Layer Extensions </P>

<P>The following registers and register bit extensions allow software to monitor and control the reporting of transmission errors: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> (Extensions to the) Port n Control CSR defined in 
<Link>Section 2.2 </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> (Extensions to the) Port n Error and Status CSR defined in 
<Link>Section 2.2 </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Port-write Target deviceID CSR defined in Section 2.3.2.8 </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Port n Error Detect CSR defined in 
<Link>Section 2.3.2.10 </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Port n 
<Link>Error Rate Enable CSR defined in Section 2.3.2.11 </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Port n Attributes Capture CSR defined in 
<Link>Section 2.3.2.12 </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Port n 
<Link>Packet/Control Symbol Capture 0 CSR defined in Section 2.3.2.13 </Link>
</LI_Title>
</LI>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Port n 
<Link>Packet Capture 1-3 CSRs defined in Section 2.3.2.14 through Section </Link>
</LI_Title>
</LI>

<LI>
<Link>2.3.2.16 </Link>
</LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Port n Error Rate CSR defined in 
<Link>Section 2.3.2.17 </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Port n Error Rate Threshold CSR defined in 
<Link>Section 2.3.2.18 </Link>
</LI_Title>
</LI>
</L>

<P id="LinkTarget_31032">1.2.1 Port Error Detect, Enable and Capture CSRs </P>

<P>The occurrence of a transmission error shall be logged by hardware by setting the appropriate error indication bit in the Port n Error Detect CSR. Transmission errors that are enabled for error capture and error counting will have the corresponding bit set by software in the Port n Error Rate Enable CSR. When the Capture Valid Info status bit is not set in the Port n Error Capture Attributes CSR, information about the next enabled transmission error shall be saved to the Port n Error Capture CSRs. The Info Type and Error Type fields shall be updated and the Capture Valid Info status </P>

<P>RapidIO Trade Association </P>

<P>bit shall be set by hardware in the Port n Error Capture Attributes CSR to lock the error capture registers. The first 16 bytes of the packet header or the 4 bytes of the control symbol that have a detected error are saved in the capture CSRs. Packets smaller than 16 bytes are captured in their entirety. The Port n Error Capture CSRs and the Port n Error Capture Attributes CSR are not overwritten by hardware with error capture information for subsequent errors until software writes a zero to the Capture Valid Info bit. </P>

<P>The Port n Error Detect CSR does not lock so subsequent error indications shall also be logged there by hardware. By reading the register, software may see the types of transmission errors that have occurred. The Port n Error Detect CSR is cleared by writing it with all logic 0s. </P>

<P id="LinkTarget_31033">1.2.2 Error Reporting Thresholds </P>

<P>Transmission errors are normally hidden from system software since they may be recovered with no loss of data and without software intervention. Two thresholds are defined in the Port n Error Rate Threshold CSR which can be set to force a report to system software when the link error rate reaches a level that is deemed by the system to be either degraded or unacceptable. The two thresholds are respectively the Degraded Threshold and the Failed Threshold. These thresholds are used as follows. </P>

<P>When the error rate counter is incremented, the Error Rate Degraded Threshold Trigger provides a threshold value that, when equal to or exceeded by the value in the Error Rate Counter in the Port n Error Rate register, shall cause the error reporting logic to set the Output Degraded-encountered bit in the Port n Error and Status CSR, and notify the system software as described in 
<Link>Section 1.4. </Link>
</P>

<P>The Error Rate Failed Threshold Trigger, if enabled, shall be larger than the degraded threshold trigger. It provides a threshold value that, when equal to or exceeded by the value in the Error Rate Counter, shall trigger the error reporting logic to set the Output Failed-encountered bit in the Port n Error and Status CSR, 
<Link>and notify system software as described in Section 1.4. </Link>
</P>

<P>No action shall be taken if the Error Rate Counter continues to exceed either threshold value after initial notification when additional errors are detected. No action shall be taken when the Error Rate Counter drops below either threshold. </P>

<P id="LinkTarget_31034">1.2.3 Error Rate Control and Status </P>

<P>The fields in the Port n Error Rate CSR are used to monitor the error rate of the link connected to port n. </P>

<P>The Error Rate Bias field determines the rate at which the Error Rate Counter is decremented and defines the acceptable error rate of the link for error reporting purposes. In the absence of additional counted link errors, this mechanism allows the system to recover from both Failed and Degraded levels of operation without a </P>

<P>RapidIO Trade Association </P>

<P>software reset of the Error Rate Counter. If the link error rate is less than the decrement rate specified in the Error Rate Bias field, the value of the Error Rate counter will rarely be greater than 0x01 or 0x02. </P>

<P>The Error Rate Counter shall increment when a physical layer error is detected whose associated enable bit is set in the Port n Error Rate Enable register. The Error Rate Counter shall decrement at the rate specified by the Error Rate Bias field of the Port n Error Rate CSR. The Error Rate Counter shall not underflow (shall not decrement when equal to 0x00) and shall not overflow (shall not increment when equal to 0xFF). The incrementing and decrementing of the Error Rate Counter are in no way affected by the values in the Degraded and Failed thresholds. Software may reset the Error Rate Counter at any time. </P>

<P>The Error Rate Recovery field defines how far above the Error Rate Failed Threshold Trigger in the Port n Error Rate Threshold Register the Error Rate Counter is allowed to count. In the absence of additional counted errors, this allows software to control the length of time required for the value of the Error Rate Counter to drop below both the Failed and Degraded Thresholds. </P>

<P>The Peak Error Rate field shall contain the largest value encountered by the Error Rate Counter. This field is loaded whenever the current value of the Peak Error Rate field is exceeded by the value of the Error Rate Counter. </P>

<P id="LinkTarget_31035">1.2.4 	Port Behavior When Error Rate Failed Threshold is Reached </P>

<P>The behavior of a port when the Error Rate Counter in the Port n Error Rate CSR reaches the Error Rate Failed Threshold and the threshold is enabled depends upon the values of the Stop on Port Failed-encountered Enable and the Drop Packet Enable bits in the Port n Control CSR. The 
<Link>Table 1-1 below defines the required </Link>
behavior. </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Stop on Port Failed Encountered Enable </TH>

<TH>Drop Packet Enable </TH>

<TH>Port Behavior </TH>

<TH>Comments </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>0 </TD>

<TD>The port shall continue to attempt to transmit packets to the connected device if the Output Failed-encountered bit is set and/or if the Error Rate Failed threshold has been met or exceeded. </TD>

<TD>All devices </TD>
</TR>

<TR>
<TD>0 </TD>

<TD>1 </TD>

<TD>The port shall discard packets that receive a Packet-not-accepted control symbol when the Error Rate Failed Threshold has been met or exceeded. Upon discarding a packet, the port shall set the Output Packet-dropped bit in the Port n Error and Status CSR. If the output port “heals”, the Error Rate Counter falls below the Error Rate Failed Threshold, the output port shall continue to attempt to forward all packets. </TD>

<TD>Switch Device Only </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>0 </TD>

<TD>The port shall stop attempting to send packets to the connected device when the Output Failed-encountered bit is set. The output port will congest. </TD>

<TD>All devices. </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>1 </TD>

<TD>The port shall discard all output packets without attempting to send when the port’s Output Failed-encountered bit is set. Upon discarding a packet, the port shall set Output Packet-dropped bit in the Port n Error and Status CSR. </TD>

<TD>All devices. </TD>
</TR>
</Table>

<P id="LinkTarget_31036">1.2.5 Packet Timeout Mechanism in a Switch Device </P>

<P>In some systems, it is either desirable or necessary to bound the length of time a packet can remain in a switch. To enable this functionality, a switch shall monitor the length of time each packet accepted by one of its ports has been in the switch. The acceptance of a packet by a port is signaled by the port issuing a packet-accepted control symbol for the packet. The timing begins when the port accepts the packet. </P>

<P>If a packet remains in a switch longer than the Time-to-Live time specified by the 
<Link>Time-to-Live field of the Packet Time-to-live CSR as defined in Section 2.3.2.9, the </Link>
packet shall be discarded rather than forwarded, the Output Packet-Dropped bit shall be set in the Port n Error and Status CSR and the system shall be notified as described in 
<Link>Section 1.4</Link>
. </P>

<P id="LinkTarget_31037">1.3 Logical and Transport Layer Extensions </P>

<P>While the RapidIO link may be working properly, an end point processing element may encounter logical or transport layer errors, or other errors unrelated to its RapidIO ports, while trying to complete a transaction. The “ERROR” status response transaction is the mechanism for the target device to indicate to the source that there is a problem completing the request. Experiencing a time-out waiting for a response is also a symptom of an end point or switch fabric with a problem. These </P>

<P>RapidIO Trade Association </P>

<P>types of errors are logged and reporting enabled with a set of registers that are separate from those used for the Physical Layer errors. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Logical/Transport Layer Error Detect CSR defined in Section 2.3.2.2 </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Logical/Transport Layer Error Enable CSR defined in Section 2.3.2.3 </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Logical/Transport Layer Capture CSRs defined in Section 2.3.2.4 to Section </Link>
</LI_Title>
</LI>
</L>

<P>
<Link>2.3.2.7 </Link>
</P>

<P id="LinkTarget_31038">1.3.1 	Logical/Transport Error Detect, Enable and Capture CSRs </P>

<P>When a logical or transport layer error is detected, the appropriate error bit shall be set by the hardware in the Logical/Transport Layer Error Detect CSR. If the corresponding bit is also set in the Logical/Transport Layer Error Enable CSR, the detect register shall lock, the appropriate information is saved in the Logical/Transport Layer Capture registers, all resources held by the transaction are 
<Link>freed, and system software is notified of the error as described in Section 1.4. If </Link>
multiple enabled errors occur during the same clock cycle, multiple bits will be set in the detect register and the contents of the Logical/Transport Layer Capture registers are implementation dependent. Once locked, subsequent errors will not set another error detect bit. The contents of the Logical/Transport Capture CSRs are valid if the bitwise AND of the Logical/Transport Layer Error Detect CSR and the Logical/Transport Layer Error Detect Enable CSR is not equal to zero (0x00000000). </P>

<P>Software shall write the Logical/Transport Detect register with all logic 0s to clear the error detect bits or a corresponding enable bit to unlock the register. Any other recovery actions associated with these types of errors are system dependent and outside the scope of this specification. </P>

<P id="LinkTarget_31039">1.3.2 Message Passing Error Detection </P>

<P>Message passing is a special case of logical layer error recovery requiring error detection at both the source and destination ends of the message. The source of the message has the request-to-response time-out (defined in the Port Response Time-out Control CSR in the RapidIO Physical Layer specifications) to detect lost request or response packets in the switch fabric. However, in order to not hang the recipient mailbox in the case of a lost request packet for a multiple packet message, the recipient mailbox shall have an analogous response-to-request time-out. This time-out is for sending a response packet to receiving the next request packet of a given message operation, and has the same value as the request-to-response time-out that is already specified. The Logical/Transport Layer Control Capture CSR contains the ‘msg info’ field to capture the critical information of the last received (or sent) message segment before time-out. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31040">1.4 System Software Notification of Error </P>

<P>System software is notified of logical, transport, and physical layer errors in two ways. An interrupt is issued to the local system by a device, the method of which is not defined in this specification, or a Maintenance port-write operation is issued by a device. Maintenance port-write operations are sent to a predetermined system host 
<Link>(defined in the Port-write Target deviceID CSR in Section 2.3.2.8). The sending </Link>
device sets the Port-write Pending status bit in the Port n Error and Status CSR. A 16 byte data payload of the Maintenance Port-write packet contains the contents of several CSRs, the port on the device that encountered the error condition (for port-based errors), and some optional implementation specific additional information as shown in 
<Link>Table 1-2. Software indicates that it has seen the port-write </Link>
operation by clearing the Port-write Pending status bit. </P>

<P>The Component Tag CSR is defined in the RapidIO Part 3: Common Transport Specification, and is used to uniquely identify the reporting device within the system. A Port ID field, the Logical/Transport Layer Detect CSR defined in 
<Link>Section </Link>

<Link>2.3.2.2, and the Port</Link>
 n 
<Link>Error Detect CSR defined in Section 2.3.2.10 are used to </Link>
describe the encountered error condition. </P>

<Table>
<Caption>
<P>Table 1-2. Port-write Packet Data Payload for Error Reporting </P>
</Caption>

<TR>
<TH>Data Payload Byte Offset </TH>

<TH>Word </TH>

<TH/>
</TR>

<TR>
<TD>0x0 </TD>

<TD>Component Tag CSR </TD>

<TD/>
</TR>

<TR>
<TD>0x4 </TD>

<TD>Port n Error Detect CSR </TD>

<TD/>
</TR>

<TR>
<TD>0x8 </TD>

<TD>Implementation specific </TD>

<TD>Port ID (byte) </TD>
</TR>

<TR>
<TD>0xC </TD>

<TD>Logical/Transport Layer Error Detect CSR </TD>

<TD/>
</TR>
</Table>

<P id="LinkTarget_31041">1.5 Mechanisms for Software Debug </P>

<P>In most systems, it is difficult to verify the error handling software. The Error management extensions make some registers writable for easier debug. </P>

<P>The Logical/Transport Layer Error Detect register and the Logical/Transport Layer Error Capture registers are writable by software to allow software debug of the system error recovery mechanisms. For software debug, software must write the Logical/Transport Layer Error capture registers with the desired address and device id information then write the Logical/Transport Layer Error Detect register to set an error bit and lock the registers. When an error detect bit is set, the hardware will inform the system software of the error using its standard error reporting mechanism. After the error has been reported, the system software may read and clear registers as necessary to complete its error handling protocol testing. </P>

<P>The Port n Error Detect register and the Port n Error Capture registers are also </P>

<P>RapidIO Trade Association </P>

<P>writable by software to allow software debug of the system error recovery and thresholding mechanism. For debug, software must write the Port n Attributes Error Capture CSR to set the Capture Valid Info bit and then the packet/control symbol information in the other capture registers. Each write of a non-zero value to the Port n Error Detect CSR shall cause the Error Rate Counter to increment if the corresponding error bit is enabled in the Port n Error Rate Enable CSR. When a threshold is reached, the hardware will inform the system software of the error using its standard error reporting mechanism. After the error has been reported, the system software may read and clear registers as necessary to complete its error handling protocol testing. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31042">Chapter 2  Error Management Registers </P>

<P id="LinkTarget_31043">2.1 Introduction </P>

<P>This section describes the Error Management Extended Features block, and adds a number of new bits to the existing standard physical layer registers. ‘End-point only’ and ‘switch only’ register bits shall be considered reserved when the registers are implemented on devices for which these bits are not required. </P>

<P id="LinkTarget_31044">2.2 Additions to Existing Registers </P>

<P>The following bits are added to the parallel and serial logical layer specification Port n Control CSRs. Table 2-1. Bit Settings for Port n Control CSRs </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>28 </TD>

<TD>Stop on Port Failed-encountered Enable </TD>

<TD>0b0 </TD>

<TD>
<Link>This bit is used with the Drop Packet Enable bit to force certain behavior when the Error Rate Failed Threshold has been met or exceeded. See Section 1.2.4 of the Part 8: Error Management Extensions for detailed requirements. </Link>
</TD>
</TR>

<TR>
<TD>29 </TD>

<TD>Drop Packet Enable </TD>

<TD>0b0 </TD>

<TD>
<Link>This bit is used with the Stop on Port Failed-encountered Enable bit to force certain behavior when the Error Rate Failed Threshold has been met or exceeded. See Section 1.2.4 of the Part 8: Error Management Extensions for detailed requirements. </Link>
</TD>
</TR>

<TR>
<TD>30 </TD>

<TD>Port Lockout </TD>

<TD>0b0 </TD>

<TD>When this bit is cleared, the packets that may be received and issued are controlled by the state of the Output Port Enable and Input Port Enable bits in the Port n Control CSR. When this bit is set, this port is stopped and is not enabled to issue or receive any packets; the input port can still follow the training procedure and can still send and respond to link-requests; all received packets return packet-not-accepted control symbols to force an error condition to be signaled by the sending device </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>The following bits are added to the parallel and serial specification Port n Error and Status CSRs. </P>

<Table>
<Caption>
<P>Table 2-2. Bit Settings for Port n Error and Status CSRs </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>5 </TD>

<TD>Output Packet-dropped </TD>

<TD>0b0 </TD>

<TD>Output port has discarded a packet. Once set remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>6 </TD>

<TD>Output Failed-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered a failed condition, meaning that the port’s failed error threshold has been reached in the Port n Error Rate Threshold register. Once set remains set until written with a logic 1 to clear. </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>Output Degraded-encountered </TD>

<TD>0b0 </TD>

<TD>Output port has encountered a degraded condition, meaning that the port’s degraded error threshold has been reached in the Port n Error Rate Threshold register. Once set remains set until written with a logic 1 to clear. </TD>
</TR>
</Table>

<P id="LinkTarget_31045">2.3 New Error Management Registers </P>

<P>This section describes the Extended Features block (EF_ID=0h0007) that allows an external processing element to manage the error status and reporting for a processing element. This chapter only describes registers or register bits defined by this extended features block. All registers are 32-bits and aligned to a 32-bit boundary. </P>

<P>
<Link>Table 2-3 describes the required behavior for accesses to reserved register bits and </Link>
reserved registers for the RapidIO Extended Features register space, </P>

<Table>
<Caption>
<P>Table 2-3. Extended Feature Space Reserved Access Behavior </P>
</Caption>

<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x100– FFFC </TH>

<TD>Extended Features Space </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value1 </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value2 </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write implementation-defined </TD>
</TR>

<TR>
<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write - </TD>

<TD>write - ignored </TD>
</TR>
</Table>

<P>1Do not depend on reserved bits being a particular value; use appropriate masks to extract defined bits from the read value. </P>

<P>2All register writes shall be in the form: read the register to obtain the values of all reserved bits, merge in the desired values for defined bits to be modified, and write the register, thus preserving the value of all reserved bits. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31046">2.3.1 Register Map </P>

<P>
<Link>Table 2-4 shows the register map for the error management registers. This register </Link>
map is currently only defined for devices with up to 16 RapidIO ports, but can be extended or shortened if more or less port definitions are required for a device. For example, a device with four RapidIO ports is only required to use register map space corresponding to offsets [EF_PTR+0x00] through [EF_PTR+0x13C]. Register map offset [EF_PTR+0x140] can be used for another Extended Features block. </P>

<Table>
<Caption>
<P>Table 2-4. Error Management Extensions Register Map </P>
</Caption>

<TR>
<TH/>

<TH>Block Byte Offset </TH>

<TH>Register Name </TH>
</TR>

<TR>
<TH>General </TH>

<TD>0x0 </TD>

<TD>Error Management Extensions Block Header </TD>
</TR>

<TR>
<TD>0x4 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x8 </TD>

<TD>Logical/Transport Layer Error Detect CSR </TD>
</TR>

<TR>
<TD>0xC </TD>

<TD>Logical/Transport Layer Error Enable CSR </TD>
</TR>

<TR>
<TD>0x10 </TD>

<TD>Logical/Transport Layer High Address Capture CSR </TD>
</TR>

<TR>
<TD>0x14 </TD>

<TD>Logical/Transport Layer Address Capture CSR </TD>
</TR>

<TR>
<TD>0x18 </TD>

<TD>Logical/Transport Layer Device ID Capture CSR </TD>
</TR>

<TR>
<TD>0x1C </TD>

<TD>Logical/Transport Layer Control Capture CSR </TD>
</TR>

<TR>
<TD>0x20-24 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x28 </TD>

<TD>Port-write Target deviceID CSR </TD>
</TR>

<TR>
<TD>0x2C </TD>

<TD>Packet Time-to-live CSR </TD>
</TR>

<TR>
<TD>0x30-3C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TH>Port 0 </TH>

<TD>0x40 </TD>

<TD>Port 0 Error Detect CSR </TD>
</TR>

<TR>
<TD>0x44 </TD>

<TD>Port 0 Error Rate Enable CSR </TD>
</TR>

<TR>
<TD>0x48 </TD>

<TD>Port 0 Attributes Capture CSR </TD>
</TR>

<TR>
<TD>0x4C </TD>

<TD>Port 0 Packet/Control Symbol Capture 0 CSR </TD>
</TR>

<TR>
<TD>0x50 </TD>

<TD>Port 0 Packet Capture 1 CSR </TD>
</TR>

<TR>
<TD>0x54 </TD>

<TD>Port 0 Packet Capture 2 CSR </TD>
</TR>

<TR>
<TD>0x58 </TD>

<TD>Port 0 Packet Capture 3 CSR </TD>
</TR>

<TR>
<TD>0x5C-64 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x68 </TD>

<TD>Port 0 Error Rate CSR </TD>
</TR>

<TR>
<TD>0x6C </TD>

<TD>Port 0 Error Rate Threshold CSR </TD>
</TR>

<TR>
<TD>0x70-7C </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH/>

<TH>Block Byte Offset </TH>

<TH>Register Name </TH>
</TR>

<TR>
<TH>Port 1 </TH>

<TD>0x80 </TD>

<TD>Port 1 Error Detect CSR </TD>
</TR>

<TR>
<TD>0x84 </TD>

<TD>Port 1 Error Rate Enable CSR </TD>
</TR>

<TR>
<TD>0x88 </TD>

<TD>Port 1 Attributes Capture CSR </TD>
</TR>

<TR>
<TD>0x8C </TD>

<TD>Port 1 Packet/Control Symbol Capture 0 CSR </TD>
</TR>

<TR>
<TD>0x90 </TD>

<TD>Port 1 Packet Capture 1 CSR </TD>
</TR>

<TR>
<TD>0x94 </TD>

<TD>Port 1 Packet Capture 2 CSR </TD>
</TR>

<TR>
<TD>0x98 </TD>

<TD>Port 1 Packet Capture 3 CSR </TD>
</TR>

<TR>
<TD>0x9C-A4 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0xA8 </TD>

<TD>Port 1 Error Rate CSR </TD>
</TR>

<TR>
<TD>0xAC </TD>

<TD>Port 1 Error Rate Threshold CSR </TD>
</TR>

<TR>
<TD>0xB0-BC </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TH>Ports 2-14</TH>

<TD>0xC0–3FC </TD>

<TD>Assigned to Port 2-14 CSRs </TD>
</TR>

<TR>
<TH>Port 15 </TH>

<TD>0x400 </TD>

<TD>Port 15 Error Detect CSR </TD>
</TR>

<TR>
<TD>0x404 </TD>

<TD>Port 15 Error Rate Enable CSR </TD>
</TR>

<TR>
<TD>0x408 </TD>

<TD>Port 15 Attributes Capture CSR </TD>
</TR>

<TR>
<TD>0x40C </TD>

<TD>Port 15 Packet/Control Symbol Capture 0 CSR </TD>
</TR>

<TR>
<TD>0x410 </TD>

<TD>Port 15 Packet Capture 1 CSR </TD>
</TR>

<TR>
<TD>0x414 </TD>

<TD>Port 15 Packet Capture 2 CSR </TD>
</TR>

<TR>
<TD>0x418 </TD>

<TD>Port 15 Packet Capture 3 CSR </TD>
</TR>

<TR>
<TD>0x41C-424 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x428 </TD>

<TD>Port 15 Error Rate CSR </TD>
</TR>

<TR>
<TD>0x42C </TD>

<TD>Port 15 Error Rate Threshold CSR </TD>
</TR>

<TR>
<TD>0x430-43C </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P id="LinkTarget_31047">2.3.2 Command and Status Registers (CSRs) </P>

<P>Refer to 
<Link>Table 2-3 for the required behavior for access to reserved registers and </Link>
register bits. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31048">2.3.2.1  	Error Management Extensions Block Header(Block Offset 0x0) </P>

<P>The error management extensions block header register contains the EF_PTR to the next EF_BLK and the EF_ID that identifies this as the error management extensions block header. </P>

<Table>
<Caption>
<P>Table 2-5. Bit Settings for Error Management Extensions Block Header </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-15 </TD>

<TD>EF_PTR </TD>

<TD/>

<TD>Hard wired pointer to the next block in the data structure, if one exists </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>EF_ID </TD>

<TD>0x0007 </TD>

<TD>Hard wired Extended Features ID </TD>
</TR>
</Table>

<P id="LinkTarget_31049">2.3.2.2 	Logical/Transport Layer Error Detect CSR(Block Offset 0x08) </P>

<P>This register indicates the error that was detected by the Logical or Transport logic layer. Multiple bits may get set in the register if simultaneous errors are detected during the same clock cycle that the errors are logged. </P>

<Table>
<Caption>
<P>Table 2-6. Bit Settings for Logical/Transport Layer Error Detect CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>IO error response </TD>

<TD>0b0 </TD>

<TD>Received a response of ‘ERROR’ for an IO Logical Layer Request. (end point device only) </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Message error response </TD>

<TD>0b0 </TD>

<TD>Received a response of ‘ERROR’ for an MSG Logical Layer Request. (end point device only) </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>GSM error response </TD>

<TD>0b0 </TD>

<TD>Received a response of ‘ERROR’ for a GSM Logical Layer Request. (end point device only) </TD>
</TR>

<TR>
<TD>3 </TD>

<TD>Message Format Error </TD>

<TD>0b0 </TD>

<TD>Received MESSAGE packet data payload with an invalid size or segment (MSG logical) (end point device only) </TD>
</TR>

<TR>
<TD>4 </TD>

<TD>Illegal transaction decode </TD>

<TD>0b0 </TD>

<TD>Received illegal fields in the request/response packet for a supported transaction (IO/MSG/GSM logical) (switch or endpoint device) </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>Illegal transaction target error </TD>

<TD>0b0 </TD>

<TD>Received a packet that contained a destination ID that is not defined for this end point. End points with multiple ports and a built-in switch function may not report this as an error (Transport) (end point device only) </TD>
</TR>

<TR>
<TD>6 </TD>

<TD>Message Request Time-out </TD>

<TD>0b0 </TD>

<TD>A required message request has not been received within the specified time-out interval (MSG logical) (end point device only) </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>Packet Response Time-out </TD>

<TD>0b0 </TD>

<TD>A required response has not been received within the specified time out interval (IO/MSG/GSM logical) (end point device only) </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>Unsolicited Response </TD>

<TD>0b0 </TD>

<TD>An unsolicited/unexpected Response packet was received (IO/MSG/GSM logical; only Maintenance response for switches) (switch or endpoint device) </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>9 </TD>

<TD>Unsupported Transaction </TD>

<TD>0b0 </TD>

<TD>A transaction is received that is not supported in the Destination Operations CAR (IO/MSG/GSM logical; only Maintenance port-write for switches) (switch or endpoint device) </TD>
</TR>

<TR>
<TD>10-23 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>Implementation Specific error </TD>

<TD>0x00 </TD>

<TD>An implementation specific error has occurred. (switch or end point device) </TD>
</TR>
</Table>

<P id="LinkTarget_31050">2.3.2.3 	Logical/Transport Layer Error Enable CSR(Block Offset 0x0C) </P>

<P>This register contains the bits that control if an error condition locks the Logical/Transport Layer Error Detect and Capture registers and is reported to the system host. </P>

<Table>
<Caption>
<P>Table 2-7. Bit Settings for Logical/Transport Layer Error Enable CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>IO error response enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of an IO error response. Save and lock original request transaction information in all Logical/Transport Layer Capture CSRs. (end point device only) </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Message error response enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of a Message error response. Save and lock original request transaction information in all Logical/Transport Layer Capture CSRs. (end point device only) </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>GSM error response enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of a GSM error response. Save and lock original request transaction capture information in all Logical/Transport Layer Capture CSRs. (end point device only) </TD>
</TR>

<TR>
<TD>3 </TD>

<TD>Message Format Error enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of a message format error. Save and lock transaction capture information in Logical/Transport Layer Device ID and Control Capture CSRs. (end point device only) </TD>
</TR>

<TR>
<TD>4 </TD>

<TD>Illegal transaction decode enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of an illegal transaction decode error Save and lock transaction capture information in Logical/Transport Layer Device ID and Control Capture CSRs. (switch or end-point device) </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>Illegal transaction target error enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of an illegal transaction target error. Save and lock transaction capture information in Logical/Transport Layer Device ID and Control Capture CSRs. (end point device only) </TD>
</TR>

<TR>
<TD>6 </TD>

<TD>Message Request time-out enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of a Message Request time-out error. Save and lock transaction capture information in Logical/Transport Layer Device ID and Control Capture CSRs for the last Message request segment packet received. (end point device only) </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>Packet Response Time-out error enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of a packet response time-out error. Save and lock original request address in Logical/Transport Layer Address Capture CSRs. Save and lock original request Destination ID in Logical/Transport Layer Device ID Capture CSR. (end point device only) </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 8: Error Management Extensions Specification Rev. 1.3 Table 2-7. Bit Settings for Logical/Transport Layer Error Enable CSR </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>8 </TD>

<TD>Unsolicited Response error enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of an unsolicited response error. Save and lock transaction capture information in Logical/Transport Layer Device ID and Control Capture CSRs. (switch or end-point device) </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>Unsupported Transaction error enable </TD>

<TD>0b0 </TD>

<TD>Enable reporting of an unsupported transaction error. Save and lock transaction capture information in Logical/Transport Layer Device ID and Control Capture CSRs. (switch or end-point device) </TD>
</TR>

<TR>
<TD>10-23 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>Implementation Specific error enable </TD>

<TD>0x00 </TD>

<TD>Enable reporting of an implementation specific error has occurred. Save and lock capture information in appropriate Logical/Transport Layer Capture CSRs. </TD>
</TR>
</Table>

<P id="LinkTarget_31051">2.3.2.4 	Logical/Transport Layer High Address Capture CSR(Block Offset 0x10) </P>

<P>This register contains error information. It is locked when a Logical/Transport error is detected and the corresponding enable bit is set. This register is only required for end point devices that support 66 or 50 bit addresses. </P>

<Table>
<Caption>
<P>Table 2-8. Bit Settings for Logical/Transport Layer High Address Capture CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-31 </TD>

<TD>address[0-31] </TD>

<TD>All 0s </TD>

<TD>Most significant 32 bits of the address associated with the error (for requests, for responses if available) </TD>
</TR>
</Table>

<P id="LinkTarget_31052">2.3.2.5 	Logical/Transport Layer Address Capture CSR(Block Offset 0x14) </P>

<P>This register contains error information. It is locked when a Logical/Transport error is detected and the corresponding enable bit is set. </P>

<Table>
<Caption>
<P>Table 2-9. Bit Settings for Logical/Transport Layer Address Capture CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-28 </TD>

<TD>address[32-60] </TD>

<TD>All 0s </TD>

<TD>Least significant 29 bits of the address associated with the error (for requests, for responses if available) </TD>
</TR>

<TR>
<TD>29 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>30-31 </TD>

<TD>xamsbs </TD>

<TD>0b00 </TD>

<TD>Extended address bits of the address associated with the error (for requests, for responses if available) </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31053">2.3.2.6 	Logical/Transport Layer Device ID Capture CSR
(Block Offset 0x18) 
</P>

<P>This register contains error information. It is locked when an error is detected and the corresponding enable bit is set. </P>

<Table>
<Caption>
<P>Table 2-10. Bit Settings for Logical/Transport Layer Device ID Capture CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-7 </TD>

<TD>MSB destinationID </TD>

<TD>0x00 </TD>

<TD>Most significant byte of the destinationID associated with the error (large transport systems only) </TD>
</TR>

<TR>
<TD>8-15 </TD>

<TD>destinationID </TD>

<TD>0x00 </TD>

<TD>The destinationID associated with the error </TD>
</TR>

<TR>
<TD>16-23 </TD>

<TD>MSB sourceID </TD>

<TD>0x00 </TD>

<TD>Most significant byte of the sourceID associated with the error (large transport systems only) </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>sourceID </TD>

<TD>0x00 </TD>

<TD>The sourceID associated with the error </TD>
</TR>
</Table>

<P id="LinkTarget_31054">2.3.2.7 	Logical/Transport Layer Control Capture CSR(Block Offset 0x1C) </P>

<P>This register contains error information. It is locked when a Logical/Transport error is detected and the corresponding enable bit is set. </P>

<Table>
<Caption>
<P>Table 2-11. Bit Settings for Logical/Transport Layer Control Capture CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-3 </TD>

<TD>ftype </TD>

<TD>0x0 </TD>

<TD>Format type associated with the error </TD>
</TR>

<TR>
<TD>4-7 </TD>

<TD>ttype </TD>

<TD>0x0 </TD>

<TD>Transaction type associated with the error </TD>
</TR>

<TR>
<TD>8-15 </TD>

<TD>msg info </TD>

<TD>0x00 </TD>

<TD>letter, mbox, and msgseg for the last Message request received for the mailbox that had an error (Message errors only) </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>Implementation specific </TD>

<TD>0x0000 </TD>

<TD>Implementation specific information associated with the error </TD>
</TR>
</Table>

<P id="LinkTarget_31055">2.3.2.8  	Port-write Target deviceID CSR(Block Offset 0x28) </P>

<P>This register contains the target deviceID to be used when a device generates a Maintenance port-write operation to report errors to a system host. </P>

<Table>
<Caption>
<P>Table 2-12. Bit Settings for Port-write Target deviceID CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-7 </TD>

<TD>deviceID_msb </TD>

<TD>0x00 </TD>

<TD>This is the most significant byte of the port-write target deviceID (large transport systems only) </TD>
</TR>

<TR>
<TD>8-15 </TD>

<TD>deviceID </TD>

<TD>0x00 </TD>

<TD>This is the port-write target deviceID </TD>
</TR>

<TR>
<TD>16 </TD>

<TD>large_transport </TD>

<TD>0b0 </TD>

<TD>deviceID size to use for a port-write 0b0 - use the small transport deviceID 0b1 - use the large transport deviceID </TD>
</TR>

<TR>
<TD>17-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31056">2.3.2.9  	Packet Time-to-live CSR (Block Offset 0x2C) </P>

<P>The Packet Time-to-live register specifies the length of time that a packet is allowed to exist within a switch device. The maximum value of the Time-to-live variable (0xFFFF) shall correspond to 100 msec. +/-34%. The resolution (minimum step size) of the Time-to-live variable shall be (maximum value of Time-to-live)/(216-1). The reset value is all logic 0s, which disables the Time-to-live function so that a packet never times out. This register is not required for devices without switch functionality. </P>

<Table>
<Caption>
<P>Table 2-13. Bit Settings for Packet Time-to-live CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-15 </TD>

<TD>Time-to-live value </TD>

<TD>0x0000 </TD>

<TD>Maximum time that a packet is allowed to exist within a switch device </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P id="LinkTarget_31057">2.3.2.10 	Port n Error Detect CSR (Block Offset 0x40, 80,..., 400) </P>

<P>The Port n Error Detect Register indicates transmission errors that are detected by the hardware. </P>

<Table>
<Caption>
<P>Table 2-14. Bit Settings for Port n Error Detect CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Implementation specific error </TD>

<TD>0b0 </TD>

<TD>An implementation specific error has been detected </TD>
</TR>

<TR>
<TD>1-7 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>Received S-bit error </TD>

<TD>0b0 </TD>

<TD>Received a packet/control symbol with an S-bit parity error (parallel) </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>Received corrupt control symbol </TD>

<TD>0b0 </TD>

<TD>Received a control symbol with a bad CRC value (serial) Received a control symbol with a true/complement mismatch (parallel) </TD>
</TR>

<TR>
<TD>10 </TD>

<TD>Received acknowledge control symbol with unexpected ackID </TD>

<TD>0b0 </TD>

<TD>Received an acknowledge control symbol with an unexpected ackID (packet-accepted or packet_retry) </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Received packet-not-accepted control symbol </TD>

<TD>0b0 </TD>

<TD>Received packet-not-accepted acknowledge control symbol </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Received packet with unexpected ackID </TD>

<TD>0b0 </TD>

<TD>Received packet with unexpected ackID value - out-of-sequence ackID </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Received packet with bad CRC </TD>

<TD>0b0 </TD>

<TD>Received packet with a bad CRC value </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Received packet exceeds 276 Bytes </TD>

<TD>0b0 </TD>

<TD>Received packet which exceeds the maximum allowed size </TD>
</TR>

<TR>
<TD>15-25 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>26 </TD>

<TD>Non-outstanding ackID </TD>

<TD>0b0 </TD>

<TD>Link_response received with an ackID that is not outstanding </TD>
</TR>

<TR>
<TD>27 </TD>

<TD>Protocol error </TD>

<TD>0b0 </TD>

<TD>An unexpected packet or control symbol was received </TD>
</TR>

<TR>
<TD>28 </TD>

<TD>Frame toggle edge error </TD>

<TD>0b0 </TD>

<TD>FRAME signal toggled on falling edge of receive clock (parallel) </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>29 </TD>

<TD>Delineation error </TD>

<TD>0b0 </TD>

<TD>FRAME signal toggled on non-32-bit boundary (parallel) Received unaligned /SC/ or /PD/ or undefined code-group (serial) </TD>
</TR>

<TR>
<TD>30 </TD>

<TD>Unsolicited acknowledge control symbol </TD>

<TD>0b0 </TD>

<TD>An unexpected acknowledge control symbol was received </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Link time-out </TD>

<TD>0b0 </TD>

<TD>An acknowledge or link-response control symbol is not received within the specified time-out interval </TD>
</TR>
</Table>

<P id="LinkTarget_31058">2.3.2.11	 Port n Error Rate Enable CSR (Block Offset 0x44, 84,..., 404) </P>

<P>This register contains the bits that control when an error condition is allowed to increment the error rate counter in the Port n Error Rate Threshold Register and lock the Port n Error Capture registers. </P>

<Table>
<Caption>
<P>Table 2-15. Bit Settings for Port n Error Rate Enable CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Implementation specific error enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of implementation specific errors </TD>
</TR>

<TR>
<TD>1-7 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>Received S-bit error enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of a packet/control symbol with an S-bit parity error (parallel) </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>Received control symbol with bad CRC enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of a corrupt control symbol </TD>
</TR>

<TR>
<TD>10 </TD>

<TD>Received out-of-sequence acknowledge control symbol enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of an acknowledge control symbol with an unexpected ackID </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Received packet-not-accepted control symbol enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of received packet-not-accepted control symbols </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Received packet with unexpected ackID enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of packet with unexpected ackID value - out-of-sequence ackID </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Received packet with Bad CRC enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of packet with a bad CRC value </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Received packet exceeds 276 Bytes enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of packet which exceeds the maximum allowed size </TD>
</TR>

<TR>
<TD>15-25 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>26 </TD>

<TD>Non-outstanding ackID enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of link-responses received with an ackID that is not outstanding </TD>
</TR>

<TR>
<TD>27 </TD>

<TD>Protocol error enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of protocol errors </TD>
</TR>

<TR>
<TD>28 </TD>

<TD>Frame toggle edge error enable </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of frame toggle edge errors </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 8: Error Management Extensions Specification Rev. 1.3 Table 2-15. Bit Settings for Port n Error Rate Enable CSR </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>29 </TD>

<TD>Delineation error </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of delineation errors </TD>
</TR>

<TR>
<TD>30 </TD>

<TD>Unsolicited acknowledge control symbol </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of unsolicited acknowledge control symbol errors </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Link time-out </TD>

<TD>0b0 </TD>

<TD>Enable error rate counting of link time-out errors </TD>
</TR>
</Table>

<P id="LinkTarget_31059">2.3.2.12 	Port n Attributes Capture CSR(Block Offset 0x48, 88,..., 408) </P>

<P>The error capture attribute register indicates the type of information contained in the Port n error capture registers. In the case of multiple detected errors during the same clock cycle one of the errors must be reflected in the Error type field. The error that is reflected is implementation dependent. </P>

<Table>
<Caption>
<P>Table 2-16. Bit Settings for Port n Attributes Capture CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-1 </TD>

<TD>Info type </TD>

<TD>0b00 </TD>

<TD>Type of information logged 00 - packet 01 - control symbol (only error capture register 0 is valid) 10 - implementation specific (capture register contents are implementation specific) 11 - undefined (S-bit error), capture as if a packet (parallel physical layer only) </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>3-7 </TD>

<TD>Error type </TD>

<TD>0x00 </TD>

<TD>The encoded value of the bit in the Port n Error Detect CSR that describes the error captured in the Port n Error Capture CSRs. </TD>
</TR>

<TR>
<TD>8-27 </TD>

<TD>Implementation Dependent </TD>

<TD>All 0s </TD>

<TD>Implementation Dependent Error Information </TD>
</TR>

<TR>
<TD>28-30 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Capture valid info </TD>

<TD>0b0 </TD>

<TD>This bit is set by hardware to indicate that the Packet/control symbol capture registers contain valid information. For control symbols, only capture register 0 will contain meaningful information. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31060">2.3.2.13 	Port n Packet/Control Symbol Capture 0 CSR
(Block Offset 0x4C, 8C,..., 40C) 
</P>

<P>Captured control symbol information includes the true and complement of the control symbol. This is exactly what arrives on the RapidIO interface with bits 0-7 of the capture register containing the least significant byte of the 32-bit quantity. This register contains the first 4 bytes of captured packet symbol information. </P>

<Table>
<Caption>
<P>Table 2-17. Bit Settings for Port n Packet/Control Symbol Capture 0 CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-31 </TD>

<TD>Capture 0 </TD>

<TD>All 0s </TD>

<TD>True and Complement of Control Symbol (parallel) or Control Character and Control Symbol (serial) or Bytes 0 to 3 of Packet Header </TD>
</TR>
</Table>

<P id="LinkTarget_31061">2.3.2.14 	Port n Packet Capture 1 CSR(Block Offset 0x50, 90,..., 410) </P>

<P>Error capture register 1 contains bytes 4 through 7 of the packet header. </P>

<Table>
<Caption>
<P>Table 2-18. Bit Settings for Port n Packet Capture 1 CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-31 </TD>

<TD>Capture 1 </TD>

<TD>All 0s </TD>

<TD>Bytes 4 thru 7 of the packet header. </TD>
</TR>
</Table>

<P id="LinkTarget_31062">2.3.2.15 	Port n Packet Capture 2 CSR(Block Offset 0x54, 94,..., 414) </P>

<P>Error capture register 2 contains bytes 8 through 11 of the packet header. </P>

<Table>
<Caption>
<P>Table 2-19. Bit Settings for Port n Packet Capture 2 CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-31 </TD>

<TD>Capture 2 </TD>

<TD>All 0s </TD>

<TD>Bytes 8 thru 11of the packet header. </TD>
</TR>
</Table>

<P id="LinkTarget_31063">2.3.2.16 	Port n Packet Capture 3 CSR(Block Offset 0x58, 98,..., 418) </P>

<P>Error capture register 3 contains bytes 12 through 15 of the packet header. </P>

<Table>
<Caption>
<P>Table 2-20. Bit Settings for Port n Packet Capture 3 CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-31 </TD>

<TD>Capture 3 </TD>

<TD>All 0s </TD>

<TD>Bytes 12 thru 15 of the packet header. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31064">2.3.2.17 	Port n Error Rate CSR (Block Offset 0x68, A8,..., 428) </P>

<P>The Port n Error Rate register is a 32-bit register used with the Port n Error Rate Threshold register to monitor and control the reporting of transmission errors, shown in 
<Link>Table 2-21. </Link>
</P>

<Table>
<Caption>
<P>Table 2-21. Bit Settings for Port n Error Rate CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-7 </TD>

<TD>Error Rate Bias </TD>

<TD>0x80 </TD>

<TD>These bits provide the error rate bias value 0x00 - do not decrement the error rate counter 0x01 - decrement every 1ms (+/-34%) 0x02 - decrement every 10ms (+/-34%) 0x04 - decrement every 100ms (+/-34%) 0x08 - decrement every 1s (+/-34%) 0x10 - decrement every 10s (+/-34%) 0x20 - decrement every 100s (+/-34%) 0x40 - decrement every 1000s (+/-34%) 0x80 - decrement every 10000s (+/-34%) other values are reserved </TD>
</TR>

<TR>
<TD>8-13 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>

<TR>
<TD>14-15 </TD>

<TD>Error Rate Recovery </TD>

<TD>0b00 </TD>

<TD>These bits limit the incrementing of the error rate counter above the failed threshold trigger. 0b00 - only count 2 errors above 0b01 - only count 4 errors above 0b10 - only count 16 error above 0b11 - do not limit incrementing the error rate count </TD>
</TR>

<TR>
<TD>16-23 </TD>

<TD>Peak Error Rate </TD>

<TD>0x00 </TD>

<TD>This field contains the peak value attained by the error rate counter. </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>Error Rate Counter </TD>

<TD>0x00 </TD>

<TD>These bits maintain a count of the number of transmission errors that have been detected by the port, decremented by the Error Rate Bias mechanism, to create an indication of the link error rate. </TD>
</TR>
</Table>

<P id="LinkTarget_31065">2.3.2.18 	Port n Error Rate Threshold CSR (Block Offset 0x6C, AC,..., 42C) </P>

<P>The Port n Error Rate Threshold register is a 32-bit register used to control the reporting of the link status to the system host. </P>

<Table>
<Caption>
<P>Table 2-22. Bit Settings for Port n Error Rate Threshold CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-7 </TD>

<TD>Error Rate Failed Threshold Trigger </TD>

<TD>0xFF </TD>

<TD>These bits provide the threshold value for reporting an error condition due to a possibly broken link. 0x00 - Disable the Error Rate Failed Threshold Trigger 0x01 - Set the error reporting threshold to 1 0x02 - Set the error reporting threshold to 2 ... 0xFF - Set the error reporting threshold to 255 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>8-15 </TD>

<TD>Error Rate Degraded Threshold Trigger </TD>

<TD>0xFF </TD>

<TD>These bits provide the threshold value for reporting an error condition due to a degrading link. 0x00 - Disable the Error Rate Degraded Threshold Trigger 0x01 - Set the error reporting threshold to 1 0x02 - Set the error reporting threshold to 2 ... 0xFF - Set the error reporting threshold to 255 </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>— </TD>

<TD/>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31066">Annex A Error Management Discussion (Informative) </P>

<P id="LinkTarget_31067">A.1 Introduction </P>

<P>This section is intended to provide useful information/background on the application of the error management capabilities. This section is a guideline, not part of the specification. </P>

<P id="LinkTarget_31068">A.2 Limitations of Error Management Discussion </P>

<P>The RapidIO hardware that implements the Error Management extensions is able to log transmission errors and errors that occur at a higher level. Some error scenarios require no software intervention and recovery procedures are done totally by the hardware. </P>

<P>Some error scenarios detected require fault management software for recovery to be successful. For example, some types of logical layer errors on a Read or Write operation may be recoverable by killing the software process using the affected memory space and removing the memory space from the available system resource pool. It may also be possible for software to retry the operation, possibly through a different path in the switch fabric. Since such fault management software is typically tightly coupled to a particular system and/or implementation, it is considered outside of the scope of this specification. </P>

<P>Another area of fault recovery that requires fault management software to be implemented is correcting of system state after an error during an atomic operation. The swap style Atomic operations are possibly recoverable through software and require software convention to uniquely identify attempts to take locks. For example, if the request is lost and times out, software can examine the current lock value to determine if the request or the associated response was the transaction that was lost in the switch fabric. For all other Atomic operations (such as the Atomic set operation), it is impossible to correct the system state in the presence of a ‘lost packet’ type of error. </P>

<P>The use of RapidIO message packets relies on the use of higher layer protocols for error management. Since end points that communicate via messaging are typically running a variety of higher layer protocols, error reporting of both request and response time-outs is done locally by the message queue management controller. </P>

<P>RapidIO Trade Association </P>

<P>Note that side effect errors can occur, for example, ERROR responses or RETRY responses during an active (partially completed) message, which may complicate the recovery procedure. The recovery strategies for messages lost in this manner are outside of the scope of this specification. </P>

<P>Globally Shared Memory systems that encounter a logical or transport layer error are typically not recoverable by any mechanism as this usually means that the processor caches are no longer coherent with the main memory system. Historically, recovery from such errors requires a complete reboot of the machine after the component that caused the error is repaired or replaced. </P>

<P id="LinkTarget_31069">A.3 Hot-insertion/extraction Discussion </P>

<P>Hot-insertion can be regarded as an error condition in which a new part of the system is detected, therefore, hot-insertion of a Field Replaceable Unit (FRU) can be handled utilizing the above described mechanisms. This section describes two approaches for hot insertion. The first generally applies to high availability systems, or systems where FRUs need to brought into the system in a controlled manner. The second generally applies to systems where availability is less of a concern, for example, a trusted system or a system without a system host. </P>

<P>At system boot time, the system host identifies all of the unattached links in the machine through system discovery and puts them in a locked mode, whereby all incoming packets are to be rejected, leaving the drivers and receivers enabled. This is done by setting the Discovered bit in the Port General Control CSR and the Port Lockout bit in the Port n Control CSR. Note that whenever an FRU is removed, the port lockout bit should be used to ensure that whatever new FRU is inserted cannot access the system until the system host allows it. When a FRU is hot-inserted connecting to a switch device, the now connected link will automatically start the training sequence. When training is complete (the Port OK bit in the Port n Error and Status CSR is now set), the locked port generates a Maintenance port-write operation to notify the system host of the new connection, and sets the Port-write Pending bit. </P>

<P>On receipt of the port-write, the system host is responsible for bringing the inserted FRU into the system in a controlled manner. The system host can communicate with the inserted FRU using Maintenance operations after clearing all error conditions, if any, clearing the Port Lockout bit and clearing the Output and Input Port Enable bits in the Port n Control CSR. This procedure allows the system host to access the inserted FRU safely, without exposing itself to incorrect behavior by the inserted FRU. </P>

<P>In order to issue Maintenance operations to the inserted FRU, the system host must first make sure that the ackID values for both ends are consistent. Since the inserted FRU has just completed a power-up reset sequence, both it’s transmit and receive ackID values are the reset value of 0x00. The system host can set the switch device’s </P>

<P>RapidIO Trade Association </P>

<P>transmit and receive ackID values to also be 0x00 through the Port n Local ackID Status CSR if they are not already in that state, and can then issue packets normally. </P>

<P>The second method for hot insertion would allow the replaced FRU to bring itself into the system, which is necessary for a system in which the FRU is the system host itself. In this approach, the Port Lockout bit is not set and instead the Output and Input Port Enable bits are set for any unconnected port, allowing inserted FRUs free access to the system without reliance on a system host. Also, a port-write operation is not generated when the training sequence completes and the link is active, so a host is not notified of the event. However, this method leaves the system vulnerable to corruption from a misbehaving hot-inserted FRU. </P>

<P>As with the first case, the system host must make the ackID values for both link partners match in order to begin sending packets. In order to accomplish this, the system host generates a link-request/link-status to the attached device to obtain it’s expected receiver value using the Port n Link Maintenance Request and Response CSRs. It can then set its transmit ackID value to match. Next, the system host generates a Maintenance write operation to set the attached device’s Port n Local ackID Status CSR to set the transmit ackID value to match the receive ackID value in the system host. Upon receipt of the maintenance write, the attached device sets it’s transmit ackID value as instructed, and generates the maintenance response using the new value. Packet transmission can now proceed normally. </P>

<P>Hot extraction from a port’s point of view behaves identically to a very rapidly failing link and therefore can utilize the above described error reporting mechanism. Hot extraction is ideally done in a controlled fashion by taking the FRU to be removed out of the system as a usable resource through the system management software so that extraction does not cause switch fabric congestion or result in a loss of data. </P>

<P>The required mechanical aspects of hot-insertion and hot-extraction are not addressed in this specification. </P>

<P id="LinkTarget_31070">A.4 Port-write Discussion </P>

<P>The error management specification includes only one destination for port-write operations, while designers of reliable systems would assume that two is the minimum number. This section explains the rationale for only having one port-write destination. </P>

<P>It is assumed that in the event of an error on a link that both ends of the link will see the error. Thus, there are two parties who can be reporting on any error. In the case that the sole link between an end point and a switch fails completely, the switch is expected to see and report the error. When one of a set of redundant links between an end point and a switch device fails, it is expected that the switch and possibly the end point will report the failure. </P>

<P>RapidIO Trade Association </P>

<P>When a link between two switches fails, it is assumed that there are multiple paths to the controlling entity available for the port-write to travel. The switches will be able to send at least one, and possibly two, reports to the system host. It is assumed that it is possible to set up a switch’s routing parameters such that the traffic to the system host will follow separate paths from each switch. </P>

<P>In some reliable systems, the system host is implemented as multiple redundant subsystems. It is assumed in RapidIO that only one subsystem is actually in control at any one time, and so should be the recipient of all port-writes. If the subsystem that should be in control is detected to be insane, it is the responsibility of the rest of the control subsystem to change the destination for port-writes to be the new subsystem that is in control. </P>

<P id="LinkTarget_31071">A.5 Physical Layer Fatal Error Recovery Discussion </P>

<P>Recovery from a fatal error under software control at the physical layer may be possible under certain circumstances. An example of this would be if the transmitter and receiver have lost synchronization of their ackIDs. This could occur if one end of the link experienced a spurious reset. In this case a loss of packets may occur as there may be outstanding unacknowledged packets between the transmitter and the receiver. </P>

<P>Such an event would cause an error to be detected given the appropriate initial conditions at the transmitter, and, eventually a port-write to the system host to be generated if the system is properly configured: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> The reset state of the Input Port Enable bit in the Port n Control CSR set to disabled throughout the system. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> All defined errors in the Port n Error Detect CSRs are enabled and will increment the error rate counter throughout the system. </LI_Title>
</LI>
</L>

<P>If a device experiences a reset event, numerous errors will be detected by the transmitter over time, and eventually an error threshold is reached as described in 
<Link>Section 1.2.2, “Error Reporting Thresholds”, and the system host is notified as </Link>
described in 
<Link>Section 1.4, “System Software Notification of Error”. The most likely </Link>
errors that will be detected are bits 12 (Received packet-not-accepted control symbol) and 26 (Non-outstanding ackID) in the Port n Error Detect CSRs, but others could be encountered depending upon the state of the link at the time of the reset event. </P>

<P>Re-synchronizing the ackIDs must be done from the transmitter side as it is not possible to communicate with the receiver with maintenance transactions in this situation. This can be done by resetting some of the physical layer state by writing the Port n Local ackID Status CSR with the appropriate ackID values. It may be necessary to have the transmitter drop outstanding packets using that CSR as well, depending upon the situation. It may not be desirable, or it might not be possible, to resend the packets, depending upon the state of the overall system and the </P>

<P>RapidIO Trade Association </P>

<P>transmitter implementation. </P>

<P>Therefore, the following sequence of events occur: </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> The system is configured as described above and is operating. </LI_Title>
</LI>

<LI>
<LI_Label>2.</LI_Label>

<LI_Title> The receiver of a transmitter/receiver pair experiences a reset. </LI_Title>
</LI>

<LI>
<LI_Label>3.</LI_Label>

<LI_Title> The transmitter enters error recovery mode and attempts to re-train the link. </LI_Title>
</LI>

<LI>
<LI_Label>4.</LI_Label>

<LI_Title> Eventually the receiver comes back and link re-training completes. </LI_Title>
</LI>

<LI>
<LI_Label>5.</LI_Label>

<LI_Title> The transmitter starts the error recovery sequence and begins to encounter large numbers of errors due to a bad ackID for a link-response (which may immediately cause a port-write transaction to be sent to the system host to report the condition) or having all packets receive packet-not-accepted control symbols. As noted earlier, other errors may also be detected. </LI_Title>
</LI>

<LI>
<LI_Label>6.</LI_Label>

<LI_Title> At some point, an error threshold is reached and the system host is sent a port-write maintenance transaction to report the condition, if one has not already been sent. </LI_Title>
</LI>

<LI>
<LI_Label>7.</LI_Label>

<LI_Title> The system host cleans up the machine using maintenance transactions, including resetting ackIDs in the transmitter and rediscovering and reconfiguring the lost portion of the machine. This may be a very complex and time-consuming task. </LI_Title>
</LI>
</L>

<P>Note that it may be useful to implement resetting the ackIDs and restarting the link in hardware for lab debug or for applications where frequent resets are expected and software intervention is not required. </P>

<P id="LinkTarget_31072">A.6 Persistence of Error Management Registers </P>

<P>Under some conditions, a device may be unable to accept any packets because it is in an undefined, ‘broken’ condition. It is unable to accept Maintenance packets to access any of its Error Detect and capture registers so it cannot be queried by software. Only a device ‘reset’ is able to bring the device back. The meaning of a link-request/reset condition may be modified for some implementations of the Error Management Extensions to be a ‘soft reset’ condition. A device that supports a soft reset will still cause a hardware reset however the Port n Error Detect register, the Port n Error Capture registers, the Logical/Transport Error Detect register, and the Logical/Transport Error Capture registers may retain their previous values. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31073">Glossary of Terms and Abbreviations 
</P>

<P>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </P>

<P>D Degraded threshold. Bits 8-15 of the Port n Error Rate Threshold CSR. An application-specific level that indicates an unacceptable error rate resulting in degraded throughput, when equal to the error rate count. </P>

<P>Failed threshold.  Bits  0-7  of  the  Port n Error Rate Threshold CSR. An </P>

<P>F </P>

<P>application-specific level  that  indicates  an error rate due to a broken link, when equal to the error rate count. </P>

<P>H Hot-insertion. Hot-insertion is the insertion of a processing element into a powered-up system. </P>

<P>Hot-extraction. Hot-extraction is the removal of a processing element from a powered-up system. </P>

<P>Logical/Transport error. A logical/transport error is one that cannot be resolved using the defined transmission error recovery sequence, results in permanent loss of data or causes system corruption. Recovery may possible under software control. </P>

<P>N Non-reporting  processing  element. A non-reporting processing element depends upon an attached device (usually a switch) to report its logged errors to the system host on its behalf. </P>

<P>O Operation. A set of transactions between end point devices in a RapidIO system (requests and associated responses) such as a read or a write. </P>

<P>Ownership. A processing element has the only valid copy of a coherence granule and is responsible for returning it to home memory. </P>

<P>P Physical error. A physical error occurs only in the physical layer. </P>

<P>RapidIO Trade Association </P>

<P>Port healing. The process whereby software resets the error rate count, or allows it to decrement as required by the error rate bias field of the Port n Error Rate CSR. </P>

<P>R 
</P>

<P>Read operation. An operation used to obtain a globally shared copy of a coherence granule. </P>

<P>Reporting  processing element. A reporting processing element is capable of reporting its logged errors to the system host. </P>

<P>S Switch 	processing  element. One of three processing elements, a switch processing element, or switch, is capable of logging and reporting errors to the host system. </P>

<P>T 
</P>

<P>Transmission  error. A transmission error is one that can be resolved using the defined transmission error recovery sequence, results in no permanent loss of data and does not cause system corruption. Recovery may also be possible under software control using mechanisms outside of the scope of this specification. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31074">RapidIO™ Interconnect SpecificationPart 9: Flow Control Logical LayerExtensions Specification </P>

<P>Rev. 1.3, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_97.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>
</TR>

<TR>
<TD>1.0 </TD>

<TD>First release </TD>

<TD>06/18/2003 </TD>
</TR>

<TR>
<TD>1.3 </TD>

<TD>No technical changes, revision changed for consistancy with other specifications Converted to ISO-friendly templates </TD>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TD>1.3 </TD>

<TD>Removed confidentiality markings for public release </TD>

<TD>06/07/2005 </TD>
</TR>
</Table>

<P>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE 
ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND 
CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO 
WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE. USER AGREES TO 
ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE 
GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR 
RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER 
SUCH USE OF THE SPECIFICATION. 
</P>

<P>DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, 
INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST 
PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION 
WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE 
RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. 
</P>

<P>Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: 
Suite 325, 3925 W. Braker Lane 
Austin, TX 78759 
512-305-0070 Tel. 
512-305-0009 FAX. 
</P>

<P>RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their 
respective owners. 
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 1 Flow Control Overview </Link>
</P>

<P>
<Link>1.1 Introduction............................................................................................................. 9 
</Link>
</P>

<P>
<Link>1.2 Requirements ........................................................................................................ 10 
</Link>
</P>

<P>
<Link>1.3 Problem Illustration .............................................................................................. 10 
</Link>
</P>

<P>
<Link>Chapter 2  Logical Layer Flow Control Operation </Link>
</P>

<P>
<Link>2.1 Introduction........................................................................................................... 13 
</Link>
</P>

<P>
<Link>2.2 Fabric Link Congestion ........................................................................................ 13 
</Link>
</P>

<P>
<Link>2.3 Flow Control Operation ........................................................................................ 13 
</Link>
</P>

<P>
<Link>2.4 Physical Layer Requirements ............................................................................... 14 
</Link>
</P>

<P>
<Link>2.4.1 	Fabric Topology................................................................................................ 14 
</Link>
</P>

<P>
<Link>2.4.2 	Flow Control Transaction Transmission........................................................... 14 
</Link>
</P>

<P>
<Link>2.4.2.1 Orphaned XOFF Mechanism........................................................................ 14 
</Link>
</P>

<P>
<Link>2.4.2.2 Controlled Flow List ..................................................................................... 15 
</Link>
</P>

<P>
<Link>2.4.2.3 XOFF/XON Counters ................................................................................... 15 
</Link>
</P>

<P>
<Link>2.4.3 	Priority to Transaction Request Flow Mapping................................................ 16 
</Link>
</P>

<P>
<Link>2.4.4 	Flow Control Transaction Ordering Rules........................................................ 17 
</Link>
</P>

<P>
<Link>2.4.5 	End Point Flow Control Rules .......................................................................... 17 
</Link>
</P>

<P>
<Link>2.4.6 	Switch Flow Control Rules............................................................................... 18 
</Link>
</P>

<P>
<Link>Chapter 3  Packet Format Descriptions </Link>
</P>

<P>
<Link>3.1 Introduction........................................................................................................... 19 
</Link>
</P>

<P>
<Link>3.2 Logical Layer Packet Format................................................................................ 19 
</Link>
</P>

<P>
<Link>3.3 Transport and Physical Layer Packet Format ....................................................... 20 
</Link>
</P>

<P>
<Link>Chapter 4  Logical Layer Flow Control Extensions Register Bits </Link>
</P>

<P>
<Link>4.1 Introduction........................................................................................................... 23 
</Link>
</P>

<P>
<Link>4.2 	Processing Elements Features CAR (Configuration Space Offset 0x10)................................................................... 23 </Link>
</P>

<P>
<Link>4.3 	Port n Control CSR (Block Offset 0x08) .......................................................................................... 24 </Link>
</P>

<P>
<Link>Annex A   Flow Control Examples (Informative) </Link>
</P>

<P>
<Link>A.1 Congestion Detection and Remediation ............................................................... 25 
</Link>
</P>

<P>
<Link>A.2 Orphaned XOFF Mechanism Description ............................................................ 26 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>
<Link>1-1 Interconnect Fabric Congestion Example .......................................................................11 
</Link>

<Link>2-1 Flow Control Operation ..................................................................................................14 
</Link>

<Link>3-1 Type 7 Packet Bit Stream Logical Layer Format ...........................................................20 
</Link>

<Link>3-2 1x/4x LP-Serial Flow Control Packet .............................................................................21 
</Link>

<Link>3-3 8/16 LP-LVDS Small Transport Flow Control Packet ...................................................21 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>
<Link>2-1 Prio field to flowID Mapping .........................................................................................16 
</Link>

<Link>3-1 Specific Field Definitions and Encodings for Type 7 Packets .......................................19 
</Link>

<Link>4-1 Bit Settings for Processing Elements Features CAR ......................................................23 
</Link>

<Link>4-2 Bit Settings for Port n Control CSR................................................................................24 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31075">Chapter 1  Flow Control Overview </P>

<P id="LinkTarget_31076">1.1 Introduction </P>

<P>A switch fabric based system can encounter several types of congestion, differentiated by the duration of the event: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Ultra short term </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Short term </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Medium term </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Long term </LI_Title>
</LI>
</L>

<P>Congestion can be detected inside a switch, at the connections between the switch, and other switches and end points. Conceptually, the congestion is detected at an output port that is trying to transmit data to the connected device, but is receiving more information than it is able to transmit. This excess data can possibly “pile up” until the switch is out of storage capacity, and then the congestion spreads to other devices that are connected to the switch’s inputs, and so on. Therefore, contention for a particular connection in the fabric can affect the ability of the fabric to transmit data unrelated to the contested connection. This is highly undesirable behavior for many applications. </P>

<P>The length of time that the congestion lasts determines the magnitude of the effect the congestion has upon the system overall. </P>

<P>Ultra short term congestion events are characterized as lasting a very small length of time, perhaps up to 500 or so nanoseconds. In a RapidIO type system these events are adequately handled by a combination of buffering within the devices on either end of a link and the retry based link layer mechanism defined in the RapidIO Part </P>

<P>4: 8/16 LP-LVDS Physical Layer and RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specifications. This combination adds “elasticity” to each link in the system. The impact of ultra short term events on the overall system is minor, if noticeable at all. </P>

<P>Short term congestion events last much longer than ultra short term events, lasting up into the dozens or hundreds of microseconds. These events can be highly disruptive to the performance of the fabric (and the system overall), in both aggregate bandwidth and end to end latency. Managing this type of congestion requires some means of detecting when an ultra short term event has turned into a short term event, and then using some mechanism to reduce the amount of data being </P>

<P>RapidIO Trade Association </P>

<P>injected by the end points into the congested portion of the fabric. If this can be done in time, the congestion stays localized until it clears, and does not adversely affect other parts of the fabric. </P>

<P>Medium term congestion is typically a frequent series of short term congestion events over a long period of time, such as seconds or minutes. This type of event is indicative of an unbalanced data load being sent into the fabric. Alleviating this type of congestion event requires some sort of software based load balancing mechanism to reconfigure the fabric. </P>

<P>Long term congestion is a situation in which a system does not have the raw capacity to handle the demands placed upon it. This situation is corrected by upgrading (or replacing) the system itself. </P>

<P>This specification addresses the problem of short term congestion. </P>

<P id="LinkTarget_31077">1.2 Requirements </P>

<P>The flow control mechanism shall fulfill the following goals: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Simple - excess complexity will not gain acceptance </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> React quickly - otherwise the solution won’t work </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Robust - same level of protection and recovery as the rest of RapidIO </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Scalable - must be able to extend to multi-layer switch systems </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Compatibility with all physical layers </LI_Title>
</LI>
</L>

<P id="LinkTarget_31078">1.3 Problem Illustration </P>

<P>The RapidIO Part 1: Input/Output Logical Specification defines a transaction request flow as a series of packets that have a common source identifier and a common destination identifier at some given priority. On a link, packets of a single transaction request flow can be interleaved with packets from one or more other transaction request flows. </P>

<P>No assumptions are made on the underlying switch architecture for this discussion of the short term congestion problem. Also for the purposes of this discussion, an idealized output queued switch is assumed, which in literature is also used to compare the performance of a particular switch under study. Packet buffers are associated with the output of the switch. An example switch topology showing output buffers is illustrated in 
<Link>Figure 1-1 below. A point of congestion is therefore </Link>
associated with an output buffer of such a switch. </P>

<P>The problem that is to be addressed by this specification is caused by multiple independent transaction request flows, each with burst and spatial locality characteristics that typically do not exceed the bandwidth capacity of links or end points. Due to the statistical combination of such transaction request flows, usually </P>

<P>RapidIO Trade Association </P>

<P>in the middle of multistage topologies, the demand for bandwidth through a particular link exceeds the link’s capacity for some period of time, for example, Data Flows a, b, and c for an output port of Switch 3 as shown in 
<Link>Figure 1-1. As a result, </Link>
the output buffer for this port will fill up, causing the link layer flow control to be activated on the links of the preceding switch stages. The output packet buffers for Switches 1 and 2 then also fill up. Packets for transaction request flows, such as data flow d, in these same output buffers not destined for the output port with the full buffer in Switch 3 are now also waiting, causing additional system performance loss. This phenomenon is known as higher order head of line blocking. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_189.jpg"/>
 Switch #1 EP EP Switch #2 EP EP  Switch #3 Switch #4 Switch #5 EP EP Switch  #6 EP EPLINK LINK LINK LINK a b c d LINK LINK congestion point a+b c d a+b c+d a+b+c d LINK LINK LINK LINK LINK LINK flows a,b,c,d output fifo </Figure>

<P>Figure 1-1. Interconnect Fabric Congestion Example</P>

<P>A second problem, less frequently a contributor to system performance loss, occurs when an end point cannot process the incoming bandwidth and employs link layer flow control to stop packets from coming in. This results in a similar sequence of events as described above. </P>

<P>The problem described in this section is very well known in the literature. The aggregate throughput of the fabric is reduced with increased load when congestion control is not applied (see reference [1]). Such non-linear behavior is known as ‘performance-collapse’. It is the objective of this specification to provide a logical layer flow control mechanism to avoid this collapse. Research also shows that relatively simple “XON/XOFF” controls on transaction request flows can be adequate to control congestion in fabrics of significant size. </P>

<P>The reason for the described non-linear behavior is illustrated with a saturation tree. The point at which a single transaction request flow that causes link bandwidth to be exceeded and causes buffer overflow is referred to as the root of the saturation tree. This tree grows backward towards the sources of all transaction request flows going through these buffers, and all buffers that these transaction request flows pass through in preceding stages, causing even more transaction request flows to be affected. </P>

<P>An important design factor for interconnect fabrics is the latency between a </P>

<P>RapidIO Trade Association </P>

<P>congestion control action being initiated and the transaction request flow source acting in response. This latency determines, among other factors, the required buffer sizes for the switches. To keep such buffers small, the latency of a congestion control mechanism must be minimized. For example, 10 data flows contribute to a buffer overflow (forming what is known as a “hotspot”). If it takes 10 packet transmission times for the congestion notification to reach the sources and the last packets sent from the sources to reach the point of congestion after the sources react to the congestion notification, up to 100 packets could be added to the congested buffer. The number of packets added may be much smaller depending on the rate of oversubscription of the congested port. </P>

<P>Reference </P>

<P>[1] “Tree saturation control in the AC3 velocity cluster interconnect”, W. Vogels et.al., Hot Interconnects 2000, Stanford. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31079">Chapter 2  Logical Layer Flow Control Operation </P>

<P id="LinkTarget_31080">2.1 Introduction </P>

<P>This chapter describes the logical layer flow control mechanism. </P>

<P id="LinkTarget_31081">2.2 Fabric Link Congestion </P>

<P>In compliant devices, logical layer flow control methods shall be employed within a fabric or destination end point for the purpose of short term congestion abatement at the point in time and location at which excessive congestion is detected. This remediation scheme shall be enacted via explicit flow control messages referred to as transmit off (XOFF) and transmit on (XON) congestion control packets (CCPs) which, like any other packet, require link-level packet acknowledgements. The XOFF CCPs are sent to shut off select flows at their source end points. Later, when the congestion event has passed, XON CCPs are sent to the same source end points to restore those flows. </P>

<P>The method used to detect congestion is implementation specific and is heavily dependent upon the internal packet buffering structure and capacity of the particular 
<Link>switch device. In the example output port buffered switch from “Section 1.3, </Link>

<Link>Problem Illustration” on page 10, congestion occurs when some output buffer </Link>
watermark is exceeded, but this is not the only way of detecting congestion. Several possible implementation methods are described in Appendix A. These described methods are purely exemplary and are not intended to be an exhaustive list of possible methods. </P>

<P id="LinkTarget_31082">2.3 Flow Control Operation </P>

<P>The flow control operation consists of a single FLOW CONTROL transaction as shown in 
<Link>Figure 2-1. The FLOW CONTROL transaction is issued by a switch or end </Link>
point to control the flow of data. This mechanism is backward compatible with </P>

<P>RapidIO Trade Association </P>

<P>RapidIO legacy devices in the same system. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_190.jpg"/>
FLOW CONTROL 1 Requestor Destination </Figure>

<P>Figure 2-1. Flow Control Operation </P>

<P id="LinkTarget_31083">2.4 Physical Layer Requirements </P>

<P>This section describes requirements put upon the system physical layers in order to support efficient logical layer flow control. </P>

<P id="LinkTarget_31084">2.4.1 Fabric Topology </P>

<P>The interconnect fabric for a system utilizing the logical layer flow control extensions must have a topology such that a flow control transaction can be sent back to any transaction request flow source. This path through the fabric may be back along the path taken by the transaction request flow to the congestion point or it may be back along a different path, depending upon the requirements of the particular system. </P>

<P id="LinkTarget_31085">2.4.2 Flow Control Transaction Transmission </P>

<P>Flow control transactions are regarded as independent traffic flows. They are the most important traffic flow defined by the system. Flow control transactions are always transmitted at the first opportunity at the expense of all other traffic flows if possible. For the 8/16 LP-LVDS and 1x/4x LP-Serial physical layer specifications, this requires marking flow control packets with a “prio” field value of 0b11, and a “crf” bit value of 0b1, if supported. These transactions use a normal packet format for purposes of error checking and format. </P>

<P>Because an implicit method of flow restoration was simulated and found to be impractical for RapidIO fabrics due to lack of system knowledge in the end point, an explicit restart mechanism using an XON transaction is used. In the CCP flow back to the source end point, XOFF and XON CCPs may be dropped on input ports of downstream elements in the event of insufficient buffer space. </P>

<P id="LinkTarget_31086">2.4.2.1 Orphaned XOFF Mechanism </P>

<P>Due to the possibility of XON flow control packets being lost in the fabric, there shall be an orphaned XOFF mechanism for the purpose of restarting orphaned flows which were XOFF’d but never XON’d in end points. Details of this mechanism are implementation specific, however the end point shall have sufficient means to avoid </P>

<P>RapidIO Trade Association </P>

<P>abandonment of orphaned flows. A typical implementation of such a mechanism would be some sort of counter. A description of a possible implementation is given in Appendix A. The Orphaned XOFF Mechanism is intended to work with the rest of the XON/XOFF CCPs to handle the short term congestion problem as previously described, and so shall operate such that software intervention is not required or inadvertently invoked. </P>

<P id="LinkTarget_31087">2.4.2.2 Controlled Flow List </P>

<P>It is required that elements which send XOFFs keep a list of flows they have stopped, along with whatever flow-specific information is needed to select flows for restart, such as per-flow XON watermark level, or relative shut off order. This information shall be stored along with flow identification information in a “controlled flow list”, a memory structure associated with the controlling element. It shall be permissible in the time following the sending of an XOFF CCP for the flow control -initiating element to re-evaluate system resources and modify the flow restart ordering or expected XON watermark level within the controlled flow list to better reflect current system state. It shall not however be permissible to abandon the controlled flow by “forgetting” it, either due to lack of controlled flow list resources or other factors. In the event that limited controlled flow list resources cause the congested element to have insufficient room to issue another XOFF CCP which is deemed more important than a previously-XOFF’d controlled flow, then that previously-XOFF’d controlled flow may be prematurely XON’d and removed from the controlled flow list. The new, more important flow may be XOFF’d and take its place in the controlled flow list. </P>

<P>Details of the controlled flow list are implementation specific, though at the very least it shall contain entries for each currently XOFF’d flow, including flow identification information. It is likely that some state information will be required, such as expected time of flow restart, or per-flow restart watermark levels. The controlled flow list size is selected to provide coverage for short term congestion events only. Remediation for medium and greater -term congestion events is beyond the scope of logical layer flow control as these events likely indicate systemic under-provisioning in the fabric. </P>

<P id="LinkTarget_31088">2.4.2.3 XOFF/XON Counters </P>

<P>XOFF/XON counters shall be instantiated for some number of output flows at the end point. Since the number of flows may be large or unpredictable, the number of counters and how flows are aggregated to a particular counter is implementation dependant. However, all flows must be associated with a counter. For simplicity, the following behavioral description assumes a single flow associated with a single counter. The counter is initialized to zero at start up or when a new DestinationID and given Priority is initialized. The counter increments by one for each associated XOFF CCP and decrements by one for each associated XON CCP, stopping at zero. Only when this counter is equal to zero is the flow enabled. In no event shall the counter wrap upon terminal count. If the orphaned XOFF mechanism activates, the </P>

<P>RapidIO Trade Association </P>

<P>counter is reset to zero and the flow is restarted. </P>

<P id="LinkTarget_31089">2.4.3 Priority to Transaction Request Flow Mapping </P>

<P>When a switch or end point determines that it is desirable to generate a flow control transaction, it must determine the associated flowID for the (non-maintenance and non-flow control) packet that caused the flow control event to be signalled. Maintenance and flow control transaction request flows must never cause the generation of a flow control transaction. For the 8/16 LP-LVDS and the 1x/4x LP-Serial physical layer specifications, the flowID of a transaction request flow is mapped to the “prio” bits as summarized in Table 1-3 of the 8/16 LP-LVDS specification and Table 5-1 of the 1x/4x LP-Serial specification. Determining the original transaction request flow for the offending packet requires the switch to do a reverse mapping. </P>

<P>It is recognized that mapping a particular response to a particular transmission request may be inaccurate because the end point that generated the response is permitted in the physical layer to promote the response to a priority higher than would normally be assigned. Deadlock avoidance rules permit this promotion. For this reason the choice of which flow to XOFF is preferably made using request packets, not response packets, as responses release system resources, which also may help alleviate system congestion. </P>

<P>Additionally, the crf (critical request flow) bit should also be used in conjunction with flowID to decide whether or not a particular transaction request flow should be targeted with a XOFF flow control transaction. A switch may select for shut off a packet with crf=0 over a packet with crf=1 if there are two different flows of otherwise equal importance. Correspondingly, an end point may choose to ignore a flow control XOFF request for a transaction request flow that it regards as critical. </P>

<P>The reverse mappings from the transaction request flow prio field to the CCP flowID field for the 8/16 LP-LVDS and 1x/4x LP-Serial physical layers are summarized in 
<Link>Table 2-1. </Link>
</P>

<Table>
<Caption>
<P>Table 2-1. Prio field to flowID Mapping </P>
</Caption>

<TR>
<TH>Transaction Request flow prio Field </TH>

<TH>Transaction Type </TH>

<TH>System Priority </TH>

<TH>CCP flowID </TH>
</TR>

<TR>
<TD>0b00 </TD>

<TD>request </TD>

<TD>Lowest </TD>

<TD>A </TD>
</TR>

<TR>
<TD>0b00 </TD>

<TD>response </TD>

<TD>Illegal </TD>

<TD/>
</TR>

<TR>
<TD>0b01 </TD>

<TD>request </TD>

<TD>Next </TD>

<TD>B </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>0b01 </TD>

<TD>response </TD>

<TD>Lowest </TD>

<TD>A </TD>
</TR>

<TR>
<TD>0b10 </TD>

<TD>request </TD>

<TD>Highest </TD>

<TD>C or higher </TD>
</TR>

<TR>
<TD>0b10 </TD>

<TD>response </TD>

<TD>Lowest or Next </TD>

<TD>A or B </TD>
</TR>

<TR>
<TD>0b11 </TD>

<TD>request </TD>

<TD>Illegal </TD>

<TD/>
</TR>

<TR>
<TD>0b11 </TD>

<TD>response </TD>

<TD>Lowest or Next or Highest </TD>

<TD>A, B, C or higher </TD>
</TR>
</Table>

<P id="LinkTarget_31090">2.4.4 Flow Control Transaction Ordering Rules </P>

<P>The ordering rules for flow control transactions within a system are analogous to those for maintenance transactions. </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> Ordering rules apply only between the source (the original issuing switch device or destination end point) of flow control transactions and the destination of flow control transactions. </LI_Title>
</LI>

<LI>
<LI_Label>2.</LI_Label>

<LI_Title> There are no ordering requirements between flow control transactions and maintenance or non-maintenance request transactions. </LI_Title>
</LI>

<LI>
<LI_Label>3.</LI_Label>

<LI_Title> A switch processing element must pass through flow control transactions between an input and output port pair in the order they are received. </LI_Title>
</LI>

<LI>
<LI_Label>4. </LI_Label>

<LI_Title>An end point processing element must process flow control transactions from the same source (the destination of the packet that caused the flow control event) in the order they are received. </LI_Title>
</LI>
</L>
</Div>

<Div>
<P id="LinkTarget_31091">2.4.5 End Point Flow Control Rules </P>

<P>There are a number of rules related to flow control that are required of an end point that supports the logical layer flow control extensions. </P>

<L>
<LI>
<LI_Label>1. </LI_Label>

<LI_Title>An XOFF flow control transaction stops all transaction request flows of the specified priority and lower targeted to the specified destination and increments the XON/XOFF counter associated with the specified flowID. </LI_Title>
</LI>

<LI>
<LI_Label>2. </LI_Label>

<LI_Title>A XON flow control transaction decrements the XON/XOFF counter associated with the specified flowID. If the resulting value is zero, the transaction request flows for that flowID and flowIDs of higher priority are restarted. </LI_Title>
</LI>

<LI>
<LI_Label>3. </LI_Label>

<LI_Title>An end point must be able to identify an orphaned XOFF’d flow and restart it. </LI_Title>
</LI>

<LI>
<LI_Label>4. </LI_Label>

<LI_Title>A destination end point issuing an XOFF Flow Control transaction must maintain the information necessary to restart the flow with an XON flow control transaction when congestion abates. </LI_Title>
</LI>

<LI>
<LI_Label>5. </LI_Label>

<LI_Title>Upon detection of congestion within one of its ports, the destination end point shall send required CCP(s) as quickly as possible to reduce latency back to the source end point. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31092">2.4.6 Switch Flow Control Rules </P>

<P>There are a number of rules related to flow control that are required of a switch that supports the logical layer flow control extensions. </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> Upon detection of congestion within a port, the switch shall send a CCP (XOFF) for each congested flow to their respective end points. </LI_Title>
</LI>

<LI>
<LI_Label>2.</LI_Label>

<LI_Title> If a switch runs out of packet buffer space, it is permitted to drop CCPs. </LI_Title>
</LI>

<LI>
<LI_Label>3.</LI_Label>

<LI_Title> A switch issuing an XOFF Flow Control transaction must maintain the information necessary to restart the flow with an XON flow control transaction when congestion abates. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31093">Chapter 3 Packet Format Descriptions </P>

<P id="LinkTarget_31094">3.1 Introduction </P>

<P>This chapter contains the definitions of the flow control packet format. </P>

<P id="LinkTarget_31095">3.2 Logical Layer Packet Format </P>

<P>The type 7 FLOW CONTROL packet formats (Flow Control Class) are used by a RapidIO switch or end point processing element to stop (XOFF) and start (XON) the flow of traffic to it from a targeted RapidIO end point processing element. A single transaction request flow is targeted with a CCP. Type 7 packets do not have a data payload and do not generate response packets. The origin of a flow control packet shall set the SOC (Source of Congestion) bit to (SOC=0) if it is a switch or (SOC=1) if it is an end point. The SOC bit is informational only but may be useful for system software in identifying a failing end point. </P>

<P>Definitions and encodings of fields specific to type 7 packets are provided in 
<Link>Table 3-1. </Link>
</P>

<Table>
<Caption>
<P>Table 3-1. Specific Field Definitions and Encodings for Type 7 Packets </P>
</Caption>

<TR>
<TH>Type 7 Fields </TH>

<TH>Encoding </TH>

<TH>Definition </TH>
</TR>

<TR>
<TD>XON/XOFF </TD>

<TD>0b0 </TD>

<TD>Stop issuing requests for the specified and lower priority transaction request flows </TD>
</TR>

<TR>
<TD/>

<TD>0b1 </TD>

<TD>Start issuing requests for the specified and higher priority transaction request flows </TD>
</TR>

<TR>
<TD>flowID </TD>

<TD>— </TD>

<TD>Highest priority affected transaction request flow 0b0000000 - transaction request flow A 0b0000001 - transaction request flow B 0b0000010 - transaction request flows C and higher Remaining encodings are reserved for the 8/16 LP-LVDS and the 1x/4x LP-Serial physical layers. </TD>
</TR>

<TR>
<TD>destinationID </TD>

<TD>— </TD>

<TD>Indicates which end point the CCP is destined for (sourceID of the packet which caused the generation of the CCP). </TD>
</TR>

<TR>
<TD>tgtdestinationID </TD>

<TD>— </TD>

<TD>Combined with the flowID field, indicates which transaction request flows need to be acted upon (destinationID field of the packet which caused the generation of the CCP). </TD>
</TR>

<TR>
<TD>SOC </TD>

<TD>0b0 </TD>

<TD>Source Of Congestion is a Switch </TD>
</TR>

<TR>
<TD/>

<TD>0b1 </TD>

<TD>Source Of Congestion is an End Point </TD>
</TR>

<TR>
<TD>rsrv </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>
<Link>Figure 3-1 displays a CCP packet with all its fields. The field value 0b0111 in </Link>

<Link>Figure 3-1 specifies that the packet format is of type 7. Small (tt=0b00) and Large </Link>
(tt=0b01) Transport Formats are shown in the figure. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_191.jpg"/>
0 1 1 1 XON/XOFF tgtdestinationID flowID SOCrsrv </Figure>

<P>4 8(tt=0b00),16(tt=0b01) 1 7 7 1 </P>

<P>Figure 3-1. Type 7 Packet Bit Stream Logical Layer Format </P>

<P id="LinkTarget_31096">3.3 Transport and Physical Layer Packet Format </P>

<P>
<Link>Figure 3-2 shows a complete flow control packet, including all transport and 1x/4x </Link>
LP-Serial physical layer fields except for delineation characters. The destinationID field of the CCP packet is the sourceID field from packets associated with the congestion event, and is the target of the flow control transaction. The tgtdestinationID field is the destinationID field from packets associated with the congestion event, and was the target of those packets. The tgtdestinationID field is used by the target of the flow control packet to identify the transaction request flow that needs to be acted upon. For all undefined flowID encodings, there is no action required and the tgtdestinationID is ignored. Field size differences for 8 bit address Small Transport Format (tt=0b00) vs. 16 bit address Large Transport Format (tt=0b01) are shown. Note: when tt=0b01 there will be a pad after the CRC. </P>

<P>RapidIO Trade Association </P>

<P>time </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_192.jpg"/>
crf=1 1 rsrv=0 0 2 ftype=0 1 1 1 tt=0 m destinationID XON/XOFF flowID CRC Preceding bits 42 rsrv=0 0 0 0 0 0 0 8 (tt=0b00) or 16 (tt=0b01) 7 tgtdestinationID 8 (tt=0b00) or 16 (tt=0b01) 1 7 Following bits prio=1 1 2 SOC 1 ackID 5 </Figure>

<P>16 </P>

<P>Figure 3-2. 1x/4x LP-Serial Flow Control Packet </P>

<P>
<Link>Figure 3-3 shows the corresponding 8/16 LP-LVDS physical layer small transport </Link>
packet. </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_193.jpg"/>
</Figure>

<Table>
<TR>
<TH>0 </TH>

<TH>1 </TH>

<TH>2 </TH>

<TH>3 </TH>

<TH>4 </TH>

<TH>5 </TH>

<TH>6 </TH>

<TH>7 </TH>
</TR>

<TR>
<TD/>

<TD/>

<TD>P</TD>

<TD>recedin</TD>

<TD>g byte </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>S=0 </TD>

<TD/>

<TD>ackID </TD>

<TD/>

<TD>rsrv=0 </TD>

<TD>S=1 </TD>

<TD>rsrv=0 </TD>

<TD>crf=1 </TD>
</TR>

<TR>
<TD>prio</TD>

<TD>=1 1 </TD>

<TD>tt=</TD>

<TD>0 0 </TD>

<TD/>

<TD>ftype=</TD>

<TD>0 1 1 1 </TD>

<TD/>
</TR>

<TR>
<TD/>

<TD/>

<TD/>

<TD>destina</TD>

<TD>tionID </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD/>

<TD/>

<TD>t</TD>

<TD>gtdestin</TD>

<TD>ationID </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>XON/XO</TD>

<TD>F</TD>

<TD>F </TD>

<TD>r</TD>

<TD>srv=0 0 </TD>

<TD>0 0 0 0 </TD>

<TD>0 </TD>

<TD/>

<TD/>
</TR>

<TR>
<TD/>

<TD/>

<TD/>

<TD>flow</TD>

<TD>ID </TD>

<TD/>

<TD/>

<TD>SOC </TD>
</TR>

<TR>
<TD/>

<TD/>

<TD/>

<TD>CRC[</TD>

<TD>0–7] </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD/>

<TD/>

<TD/>

<TD>CRC[</TD>

<TD>8–15] </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD/>

<TD/>

<TD/>

<TD>Following b</TD>

<TD>yte </TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>0 </TD>

<TD>1 </TD>

<TD>2 </TD>

<TD>3 </TD>

<TD>4 </TD>

<TD>5 </TD>

<TD>6 </TD>

<TD>7 </TD>
</TR>
</Table>
Time Port bit numbers </P>

<P>32-bit boundary, framing signal toggles </P>

<P>framing signal toggles 32-bit boundary, </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_194.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_195.jpg"/>
</Figure>

<P>Figure 3-3. 8/16 LP-LVDS Small Transport Flow Control Packet </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31097">Chapter 4  Logical Layer Flow Control Extensions Register Bits </P>

<P id="LinkTarget_31098">4.1 	Introduction </P>

<P>This section describes the Logical Layer Flow Control Extensions CAR and CSR bits that allow an external processing element to determine if a switch or end point device supports the flow control extensions defined in this specification, and to manage the transmission of flow control transactions for a switch processing element. This chapter only describes registers or register bits defined by this specification. Refer to the other RapidIO logical, transport, physical, and extension specifications of interest to determine a complete list of registers and bit definitions for a device. All registers are 32-bits and aligned to a 32-bit boundary. </P>

<P id="LinkTarget_31099">4.2 	Processing Elements Features CAR 
(Configuration Space Offset 0x10) 
</P>

<P>The Processing Elements Features CAR contains 31 processing elements features bits defined in various RapidIO specifications, as well as the Flow Control Support bit, defined here. </P>

<Table>
<Caption>
<P>Table 4-1. Bit Settings for Processing Elements Features CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-23 </TD>

<TD>-</TD>

<TD/>

<TD>Reserved (defined elsewhere) </TD>
</TR>

<TR>
<TD>24 </TD>

<TD>Flow Control Support </TD>

<TD/>

<TD>* Support for flow control extensions 0b0 - Does not support flow control extensions 0b1 - Supports flow control extensions </TD>
</TR>

<TR>
<TD>25-31 </TD>

<TD>-</TD>

<TD/>

<TD>Reserved (defined elsewhere) </TD>
</TR>
</Table>

<P>* Implementation dependant </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31100">4.3 	Port n Control CSR 
(Block Offset 0x08) 
</P>

<P>The Port n Control CSR contains 31 bits specifying individual port controls defined in various RapidIO specifications, as well as the Flow Control Participant bit, defined here. </P>

<Table>
<Caption>
<P>Table 4-2. Bit Settings for Port n Control CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-9 (parallel) 0-12 (serial) </TD>

<TD>-</TD>

<TD/>

<TD>Reserved (defined elsewhere) </TD>
</TR>

<TR>
<TD>10 (parallel) 13 (serial) </TD>

<TD>Flow Control Participant </TD>

<TD>0b0 </TD>

<TD>Enable flow control transactions 0b0 - Do not route or issue flow control transactions to this port 0b1 - Route or issue flow control transactions to this port </TD>
</TR>

<TR>
<TD>11-31 (parallel) 14-31 (serial </TD>

<TD>-</TD>

<TD/>

<TD>Reserved (defined elsewhere) </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31101">Annex A Flow Control Examples (Informative) </P>

<P id="LinkTarget_31102">A.1 Congestion Detection and Remediation </P>

<P>The method used to detect congestion is implementation specific and is heavily dependent upon the internal packet buffering structure and capacity of the particular 
<Link>switch device. In the example output port buffered switch from “Section 1.3, </Link>

<Link>Problem Illustration” on page 10, congestion occurs when some output buffer </Link>
watermark is exceeded. As long as the watermark is exceeded the output port is said to be in a congested state. The watermark can have different levels when entering the congested state and leaving the congested state. </P>

<P>Fabric elements should monitor their internal packet buffer levels, comparing them on a packet by packet basis to pre-established, locally-defined watermark levels. These levels likely would be configurable depending upon the local element's position within the fabric relative to source endpoints and its particular architecture. On the high watermark side, a level should be selected which is low enough that the remaining buffer space is adequate to provide ample storage for packets in-flight, given a worse-case latency for XOFF CCPs to travel back to the source endpoint and shut off the flow in the endpoint. On the low watermark side (if a watermark is used for XON), a yet-lower level should be selected which meets the following criteria; </P>

<P>a ) Provides sufficient hysteresis. When considered in context with the high watermark, it should not be so close as to provide a high flow of XON/XOFF CCP traffic back to the source endpoint. </P>

<P>b ) Is set high enough that the switch output buffer does not run dry (underflow) in the typical live-flow case (one or more packets are present in the source endpoint output buffer waiting to be sent when the flow is restarted), given the latency of XON CCP travel back to the source endpoint and restoration of the shut-off flow in the endpoint. </P>

<P>The following two examples are provided to show possible methods for detecting and reacting to congestion: </P>

<P>1. Histogram analysis: </P>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> The switch keeps track of packet quantities for the different transaction request flows for which packets are stored in its output buffer. </LI_Title>
</LI>

<LI>
<LI_Label>— </LI_Label>

<LI_Title>The switch sorts the transaction request flows according to the number of packets. </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> The switch selects the 1 to 5 transaction request flows with the most </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P>25 </P>

<P>packets stored in the buffers. </P>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> The switch sends an XOFF flow control request to those transaction request flow sources when the watermark threshold is exceeded, as long as flow control transaction routing is enabled on that switch port. Handling of system critical flows intending to bypass the flow control operation is outside the scope of this document. </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> The CCP-targeted sources stop transmitting packets for the indicated transaction request flow and all lower priority transaction request flows. </LI_Title>
</LI>

<LI>
<LI_Label>— </LI_Label>

<LI_Title>The switch sends a flow control XON request to those transaction request flow sources when the watermark drops below the threshold. </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> The CCP-targeted sources begin to transmit packets for the indicated transaction request flow and all higher priority transaction request flows. </LI_Title>
</LI>
</L>

<P>2. Simple threshold: </P>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> The switch sends an XOFF flow control to the source of every new transaction flow it receives as long as the watermark is exceeded, provided flow control transaction routing is enabled on that switch port. Handling of system critical flows intending to bypass the flow control operation is outside the scope of this document. </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> The CCP-targeted sources stop transmitting packets for the indicated transaction request flow and all lower priority transaction request flows. </LI_Title>
</LI>

<LI>
<LI_Label>— </LI_Label>

<LI_Title>The switch sends a flow control XON request to those transaction request flow sources when the watermark drops below the threshold. </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> The CCP-targeted sources begin to transmit packets for the indicated transaction request flow and all higher priority transaction request flows. </LI_Title>
</LI>
</L>

<P>Note that the first method is reasonably fair in that it targets the source of the data flows that are consuming most of the link bandwidth, and that the second method is unfair in that it indiscriminately targets any source unfortunate enough to have a packet be transmitted while the link is congested. </P>

<P id="LinkTarget_31103">A.2 Orphaned XOFF Mechanism Description </P>

<P>This timer may take the form of a low precision counter in the end point which monitors the oldest XOFF’d flow at any given time. When a flow first becomes the oldest flow (reaches top of an XOFF’d flow FIFO list within the end point) the timer is reset to its programmed value and begins to count down with time. If it is allowed to elapse without a change to the oldest XOFF’d flow, that flow will be presumed to be orphaned due to lost XON CCP and be restarted as if an XON CCP had been received, with the orphaned flow entry removed from the top of the list and the counter reset to count down for the next oldest XOFF’d flow. The length of the count should be long enough to insure that significant degradation of the flow control function does not occur, on the order of several times the width of the fabric expressed in terms of packet transit time, yet not so large that it would fail to elapse </P>

<P>RapidIO Trade Association </P>

<P>between uncorrelated congestion events. The length of this count shall be programmable through an implementation-dependent register in the end point. The orphaned XOFF mechanism is intended solely as a last-resort mechanism for restarting orphaned flows. It will not be adequate for the purpose of implicit controlled flow reinstatement owing to inherent fairness issues as well as burstyness due to uncontrolled simultaneous multi-flow restart. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Glossary of Terms and Abbreviations 
</P>

<Table>
<TR>
<TH>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </TH>
</TR>

<TR>
<TH>C </TH>

<TD>Congestion. A condition found in output ports of switch and bridge elements characterized by excessive packet buildup in the buffer, when packet entry rate into the buffer exceeds packet exit rate for a long enough period of time. CCP (Congestion Control Packet). A packet sent from the point of congestion in the fabric back to the source endpoint of particular flows instructing the source to either turn on or off the flow. Controlled Flow List. A memory structure associated with controlling elements which holds a list of currently controlled flows, used by the element to turn back on controlled flows. crf. Critical Request Flow. For packets or packets of a given priority, this bit further defines which packet or notice should be moved first from the input queue to the output queue (see RapidIO Part 4: 8/16 LP-LVDS Physical Layer Specification, Section 1.2.2 and RapidIO Part 6: 1x/4x LP-Serial Physical Layer Specification, Section 5.3.3). </TD>
</TR>

<TR>
<TH>F </TH>

<TD>flowID. Transaction request flow indicator (see RapidIO Part 1: Input/Output Logical Specification, Section 1.2.1). </TD>
</TR>

<TR>
<TH>L </TH>

<TD>Long Term Congestion. A severe congestion event in which a system does not have the raw capacity to handle the demands placed upon it in actual use. </TD>
</TR>

<TR>
<TH>M </TH>

<TD>Medium Term Congestion. A congestion event in which a frequent series of short term congestion events occur over a long period of time such as seconds or minutes, handled in RapidIO systems by reconfiguration of the fabric by system-level software. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>Orphaned XOFF Mechanism. A mechanism in an end point which is used </P>

<P>O </P>

<P>to restart the oldest controlled flow within the end point after a certain period of time has elapsed without the flow being XON’d. </P>

<P>P Performance Collapse. Non-linear behavior found in non- congestion controlled fabrics, whereby reduced aggregate throughput is exhibited with increased load. </P>

<P>S 
</P>

<P>Saturation Tree. A pattern of congestion identified within the fabric which grows backward from the root buffer overflow towards the sources of all transaction request flows passing through this buffer. </P>

<P>Short Term Congestion. A congestion event lasting up into the dozens or hundreds of microseconds, handled in RapidIO by Logical Layer Flow Control. </P>

<P>T 
</P>

<P>Topology. The structure represented by the physical interconnections of a switch fabric. </P>

<P>Transaction Request Flow. A series of packets that have a common source identifier and a common destination identifier at some given priority. </P>

<P>U 
</P>

<P>Ultra Short Term Congestion. A congestion event lasting from dozens to hundreds of nanoseconds, handled in RapidIO by Link Level Flow Control. </P>

<P>Underflow. A condition within output buffers of switches in which the buffer runs dry. </P>

<P>W Watermark. A predetermined buffer occupancy level indicating either congestion (high watermark) or abatement of congestion (low watermark). </P>

<P>XOFF (Transmit Off). A congestion control packet sent from the point of congestion back to the source of a particular flow, telling the source endpoint to shut off the flow. </P>

<P>XON (Transmit On). A congestion control packet sent from the point of congestion back to the source of a particular flow, telling the source endpoint to restart a controlled flow. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31104">RapidIO™ Interconnect SpecificationPart 10: Data Streaming LogicalSpecification </P>

<P>Rev. 1.3.a, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_97.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>
</TR>

<TR>
<TD>1.3 </TD>

<TD>First release </TD>

<TD>06/09/2004 </TD>
</TR>

<TR>
<TD>1.3.a </TD>

<TD>No technical changes Converted to ISO-friendly templates </TD>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TD>1.3.a </TD>

<TD>Removed confidentiality markings for public release </TD>

<TD>06/07/2005 </TD>
</TR>
</Table>

<P>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE 
ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND 
CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO 
WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE. USER AGREES TO 
ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE 
GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR 
RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER 
SUCH USE OF THE SPECIFICATION. 
</P>

<P>DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, 
INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST 
PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION 
WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE 
RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. 
</P>

<P>Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: 
Suite 325, 3925 W. Braker Lane 
Austin, TX 78759 
512-305-0070 Tel. 
512-305-0009 FAX. 
</P>

<P>RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their 
respective owners. 
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 1 Overview </Link>
</P>

<P>
<Link>1.1 Introduction............................................................................................................. 9 
</Link>
</P>

<P>
<Link>1.2 Overview................................................................................................................. 9 
</Link>
</P>

<P>
<Link>1.3 Features of the Data Streaming Specification....................................................... 10 
</Link>
</P>

<P>
<Link>1.3.1 Functional Features........................................................................................... 10 
</Link>
</P>

<P>
<Link>1.3.2 Physical Features .............................................................................................. 10 
</Link>
</P>

<P>
<Link>1.3.3 Performance Features ....................................................................................... 11 
</Link>
</P>

<P>
<Link>1.4 Contents ................................................................................................................ 11 
</Link>
</P>

<P>
<Link>1.5 Terminology.......................................................................................................... 12 
</Link>
</P>

<P>
<Link>1.6 Conventions .......................................................................................................... 12 
</Link>
</P>

<P>
<Link>1.7 Useful References ................................................................................................. 13 
</Link>
</P>

<P>
<Link>Chapter 2 Data Streaming Systems </Link>
</P>

<P>
<Link>2.1 Introduction........................................................................................................... 15 
</Link>
</P>

<P>
<Link>2.2 System Example ................................................................................................... 15 
</Link>
</P>

<P>
<Link>2.3 Traffic Streams ..................................................................................................... 16 
</Link>
</P>

<P>
<Link>2.4 Operation Ordering ............................................................................................... 17 
</Link>
</P>

<P>
<Link>2.5 Class of Service and Virtual Queues .................................................................... 19 
</Link>
</P>

<P>
<Link>2.6 Deadlock Considerations ...................................................................................... 20 
</Link>
</P>

<P>
<Link>Chapter 3 Operation Descriptions </Link>
</P>

<P>
<Link>3.1 Introduction........................................................................................................... 21 
</Link>
</P>

<P>
<Link>3.2 Data Streaming Protocol ....................................................................................... 21 
</Link>
</P>

<P>
<Link>3.2.1 Data Streaming Operation ................................................................................ 21 
</Link>
</P>

<P>
<Link>3.2.2 Virtual Streams ................................................................................................. 22 
</Link>
</P>

<P>
<Link>3.2.3 PDU Sequences Within Streams....................................................................... 23 
</Link>
</P>

<P>
<Link>3.2.4 Segments within a PDU .................................................................................... 23 
</Link>
</P>

<P>
<Link>3.2.5 Rules for Segmentation and Reassembly.......................................................... 26 
</Link>
</P>

<P>
<Link>3.3 Class of Service and Traffic Streams.................................................................... 27 
</Link>
</P>

<P>
<Link>Chapter 4  Packet Format Descriptions </Link>
</P>

<P>
<Link>4.1 Introduction........................................................................................................... 29 
</Link>
</P>

<P>
<Link>4.2 Type 9 Packet Format (Data-Streaming Class) .................................................... 29 
</Link>
</P>

<P>
<Link>4.3 Type 9 Extended Packet Format (Extended Data-Streaming Class) .................... 32 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 5 Data Streaming Registers </Link>
</P>

<P>
<Link>5.1 Introduction........................................................................................................... 33 
</Link>
</P>

<P>
<Link>5.2 Register Summary................................................................................................. 33 
</Link>
</P>

<P>
<Link>5.3 Reserved Register and Bit Behavior ..................................................................... 34 
</Link>
</P>

<P>
<Link>5.4 Capability Registers (CARs) ................................................................................ 36 
</Link>
</P>

<P>
<Link>5.4.1 Source Operations CAR (Configuration Space Offset 0x18) ........................... 36 
</Link>
</P>

<P>
<Link>5.4.2 Destination Operations CAR (Configuration Space Offset 0x1C) ................... 36 
</Link>
</P>

<P>
<Link>5.4.3 Data Streaming Information CAR (Configuration Space Offset 0x3C)........... 37 
</Link>
</P>

<P>
<Link>5.5 Command and Status Registers (CSRs)................................................................ 38 
</Link>
</P>

<P>
<Link>5.5.1 	Data Streaming Logical Layer Control CSR (Configuration Space Offset 0x48)............................................................... 38 </Link>
</P>

<P>
<Link>Annex A VSID Usage Examples </Link>
</P>

<P>
<Link>A.1 Introduction........................................................................................................... 39 
</Link>
</P>

<P>
<Link>A.2 Background ........................................................................................................... 39 
</Link>
</P>

<P>
<Link>A.3 Packet Classification ............................................................................................. 39 
</Link>
</P>

<P>
<Link>A.3.1 Sub-port Addressing at the Destination ............................................................ 40 
</Link>
</P>

<P>
<Link>A.3.1.1 	DSLAM application...................................................................................... 40 
</Link>
</P>

<P>
<Link>A.3.1.2 	VOIP application .......................................................................................... 40 
</Link>
</P>

<P>
<Link>A.3.2 Virtual Output Queuing - Fabric On-ramp ....................................................... 40 
</Link>
</P>

<P>
<Link>A.4 System Requirements ........................................................................................... 41 
</Link>
</P>

<P>
<Link>A.4.1 UTOPIA to RapidIO ATM bridge.................................................................... 41 
</Link>
</P>

<P>
<Link>A.4.2 Network processor ............................................................................................ 41 
</Link>
</P>

<P>
<Link>A.4.3 CSIX to RapidIO interface ............................................................................... 41 
</Link>
</P>

<P>A.4.4 
<Link>10Gb Metropolitan Area Network interface ..................................................... 42 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures 
</P>

<P>
<Link>1-1 End to End Communication Circuit................................................................................10 
</Link>

<Link>2-1 Example of a RapidIO-Based Networking System ........................................................15 
</Link>

<Link>2-2 Mapping Virtual Streams at the System Ingress.............................................................19 
</Link>

<Link>2-3 Mapping Virtual Streams at the System Egress..............................................................20 
</Link>

<Link>3-1 Data Streaming Operation ..............................................................................................22 
</Link>

<Link>3-2 Virtual Streams ...............................................................................................................22 
</Link>

<Link>3-3 PDU Segmentation and Reassembly Example 1 ............................................................25 
</Link>

<Link>3-4 PDU Segmentation and Reassembly Example 2 ............................................................25 
</Link>

<Link>3-5 Traffic Sorting Based on CoS ID....................................................................................27 
</Link>

<Link>4-1 Single Segment Type 9 Packet Bit Stream Format Example .........................................30 
</Link>

<Link>4-2 Start Segment Type 9 Packet Bit Stream Format Example ............................................31 
</Link>

<Link>4-3 Continuation Segment Type 9 Packet Bit Stream Format Example...............................31 
</Link>

<Link>4-4 End Segment Type 9 Packet Bit Stream Format ............................................................32 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>
<Link>4-1 Specific Field Definitions and Encodings for Type 9 Packets .......................................29 
</Link>

<Link>4-2 Specific Field Definitions and Encodings for Type 9 Packets .......................................30 
</Link>

<Link>5-1 Data Streaming Register Map .........................................................................................33 
</Link>

<Link>5-2 Configuration Space Reserved Access Behavior............................................................34 
</Link>

<Link>5-3 Bit Settings for Source Operations CAR ........................................................................36 
</Link>

<Link>5-4 Bit Settings for Destination Operations CAR .................................................................36 
</Link>

<Link>5-5 Bit Settings for Data Streaming Information CAR.........................................................37 
</Link>

<Link>5-6 Bit Settings for Data Streaming Logical Layer Control CSR.........................................38 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31105">Chapter 1 Overview </P>

<P id="LinkTarget_31106">1.1 Introduction </P>

<P>This chapter provides an overview of the RapidIO Part 10: Data Streaming Logical Specification. The goal of the specification is to combine the need for efficiency, flexibility, and protocol independence in order to minimize the resources necessary to support a data plane interconnect fabric, and to maintain compatibility and fully inter-operate with the rest of the RapidIO specifications. </P>

<P>The rationale for this optimization is based upon the assumption that platforms are expected to produce many times more revenue than the initial cost of the platform. For example, a platform is expected to produce 10 times the revenue vs. its initial capital costs. If that same platform could cost 10% more but allow 10% more resources for producing revenue rather than doing fabric support, the result would be a significant net gain on the investment. Therefore, enabling more intelligence within the system fabric and relieving the system processing resources to produce revenue, even if that fabric is more expensive, is believed to be a good trade-off. </P>

<P>The features of the data streaming specification define virtual mechanisms in simple forms for building cost sensitive systems and also provides for complex high functioning fabrics for more demanding applications. </P>

<P>It is assumed that the reader has a thorough understanding of the other RapidIO specifications and of data plane equipment and applications in general. </P>

<P id="LinkTarget_31107">1.2 Overview </P>

<P>Standard encapsulation schemes have been developed for the transmission of datagrams over most popular LANs. A number of different proposals currently exist for the encapsulation of one protocol over another protocol [RFC1226, RFC1234, RFC1701]. The data streaming logical specification defines a mechanism for transporting an arbitrary protocol over a standard RapidIO interface, and addresses interconnection between elements in an end-to-end data communications circuit. The protocol has been carefully designed to provide complete compatibility and inter-operability with existing RapidIO specifications. </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_196.jpg"/>
</Figure>

<P>Figure 1-1. End to End Communication Circuit </P>

<P>The defined encapsulation methodology provides for the multiplexing of different network-layer protocols simultaneously over the same link and provides a common solution for easy connection of a wide variety of hosts, bridges and switches. It is envisioned that a RapidIO system will be capable of carrying a wide variety of data types, supporting a diverse set of protocol regimens concurrently. </P>

<P id="LinkTarget_31108">1.3 Features of the Data Streaming Specification </P>

<P>The following are features of the RapidIO data streaming specification designed to satisfy the needs of various applications and systems: </P>

<P id="LinkTarget_31109">1.3.1 Functional Features </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Protocol encapsulation, independent of the protocol being encapsulated. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for Protocol Data Units (PDUs) of up to 64k bytes through Segmentation and Reassembly (SAR). </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for hundreds of traffic classes. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for thousands of data streams between end points. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Support for concurrent interleaved PDUs between end points. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Seamless inter-operability with other RapidIO specifications. </LI_Title>
</LI>
</L>

<P id="LinkTarget_31110">1.3.2 Physical Features </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Packet definition is independent of the choice of physical layer interconnection to other devices on the interconnect fabric. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>The protocols and packet formats are independent of the physical interconnect topology. The protocols work whether the physical fabric is a point-to-point ring, a bus, a switched multi-dimensional network, a duplex serial connection, and so forth. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> No dependencies exist on the bandwidth or latency of the physical fabric. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>The protocol requires in-order packet transmission and reception; out-of-order packet delivery is not tolerated. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Certain devices have bandwidth and latency requirements for proper operation. The data streaming logical layer specification does not preclude an implementation from imposing these constraints within the system. </LI_Title>
</LI>
</L>

<P id="LinkTarget_31111">1.3.3 Performance Features </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Packet headers are small to minimize the control overhead and be organized for fast, efficient assembly and disassembly. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Multiple transactions are allowed concurrently in the system, otherwise a majority of the potential system throughput is wasted. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Multiple end point to end point concurrent data streams are supported for high fabric utilization. </LI_Title>
</LI>
</L>

<P id="LinkTarget_31112">1.4 Contents </P>

<P>Following are the contents of the RapidIO Part 10: Data Streaming Logical Specification: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 1, “Overview,” is an overview of the data streaming logical </Link>
specification. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 2, “Data Streaming Systems,” introduces system issues such as </Link>
transaction ordering and deadlock prevention. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 3, “Operation Descriptions,” describes the set of operations and </Link>
transactions supported by the RapidIO data streaming protocol. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 4, “Packet Format Descriptions,” contains the packet format </Link>
definitions for the data streaming specification. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title>
<Link> Chapter 5, “Data Streaming Registers,” describes the visible register set that </Link>
allows an external processing element to determine the data streaming capabilities, configuration, and status of a processing element using this logical specification. Only registers or register bits specific to the data streaming logical specification are explained. Refer to the other RapidIO logical, transport, and physical specifications of interest to determine a complete list of registers and bit definitions. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>
<Link>Annex A, “VSID Usage Examples,” contains a number of examples of how the </Link>
virtual stream identifier can be used in a system. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31113">1.5 Terminology </P>

<P>The data streaming logical specification introduces some new terms: </P>

<P>Protocol Data Unit - (PDU) A self contained unit of data transfer comprised of data and protocol information that defines the treatment of that data. </P>

<P>Virtual Stream ID - (VSID) an identifier comprised of several fields in the protocol to identify individual data streams. </P>

<P>Virtual input Queue (ViQ), Virtual output Queue (VoQ) - an intermediate point in the system where one or more virtual streams may be concentrated. </P>

<P>Class of service - (cos) a term used to describe different treatment (quality of service) for different data streams. Support for class of service is provided by a class of service field in the data streaming protocol. The class of service field is used in the virtual stream ID and in identifying a virtual queue. </P>

<P>StreamID - a specific field in the data streaming protocol that is combined with the data streams’s transaction request flow ID and the source ID or destination ID from the underlying packet transport fabric to form the virtual stream ID. </P>

<P>Segment - A portion of a PDU. </P>

<P>Segmentation - a process by which a PDU is transferred as a series of smaller segments. </P>

<P>Segmentation context - Information that allows a receiver to associate a particular packet with the correct PDU. </P>

<P>Ingress - Ingress is the device or node where traffic enters the system. The ingress node also becomes the source for traffic into the RapidIO fabric. The terms ingress and source may or may not be used interchangeably when considering a single end to end connection. </P>

<P>Egress - Egress is the device or node where traffic exits the system. The egress node also becomes the destination for traffic out of the RapidIO fabric. The terms egress and destination may or may not be used interchangeably when considering a single end to end connection. </P>

<P>Refer to the Glossary at the back of this document for additional definitions. </P>

<P id="LinkTarget_31114">1.6 Conventions </P>

<P>|| Concatenation, used to indicate that two fields are physically associated as consecutive bits </P>

<P>ACTIVE_HIGHNames of active high signals are shown in uppercase text with no overbar. Active-high signals are asserted when high and not asserted when low. </P>

<P>ACTIVE_LOWNames of active low signals are shown in uppercase text with an </P>

<P>RapidIO Trade Association </P>

<P>overbar. Active low signals are asserted when low and not asserted when high. </P>

<P>italics Book titles in text are set in italics. </P>

<P>REG[FIELD] Abbreviations or acronyms for registers are shown in uppercase text. Specific bits, fields, or ranges appear in brackets. </P>

<P>TRANSACTIONTransaction types are expressed in all caps. </P>

<P>operation Device operation types are expressed in plain text. </P>

<P>n A decimal value. </P>

<P>[n-m] Used to express a numerical range from n to m. </P>

<P>0bnn A binary value, the number of bits is determined by the number of digits. </P>

<P>0xnn A hexadecimal value, the number of bits is determined by the number of digits or from the surrounding context; for example, 0xnn may be a 5, 6, 7, or 8 bit value. </P>

<P>x This value is a don’t care. </P>

<P id="LinkTarget_31115">1.7 Useful References </P>

<P>[RFC791] Postel, J., &quot;Internet Protocol&quot;, STD 5, RFC791, September 1981 </P>

<P>[RFC1226] Kantor, B. &quot;Internet Protocol Encapsulation of AX.25 Frames&quot;, RFC1226, University of California, San Diego, May 1991. </P>

<P>[RFC1234] Provan, D. &quot;Tunneling IPX Traffic through IP Networks&quot;, RFC 1234, Novell, Inc., June 1991. </P>

<P>[RFC1700] J. Reynolds and J. Postel, &quot;Assigned Numbers&quot;, RFC1700, October 1994. </P>

<P>[RFC2460] S. Deering, R. Hinden, &quot;Internet Protocol, Version 6 (IPv6)&quot;, RFC2460, December 1998. </P>

<P>[RFC1884] Hinden, R., and S. Deering, Editors, &quot;IP Version 6 Addressing Architecture&quot;, RFC1884, Ipsilon Networks, Xerox PARC, December 1995. </P>

<P>[RFC2004] C. Perkins, &quot;Minimal Encapsulation within IP&quot;, RFC2004, October 1996. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31116">Chapter 2  Data Streaming Systems </P>

<P id="LinkTarget_31117">2.1 Introduction </P>

<P>This overview introduces the role of the data streaming logical layer in an overall 
<Link>system. It provides some possible use examples. See Annex A, “VSID Usage </Link>

<Link>Examples”, for more example details. </Link>
</P>

<P id="LinkTarget_31118">2.2 System Example </P>

<P>
<Link>Figure 2-1 shows a block diagram of an example RapidIO-based networking system </Link>
in which protocol encapsulation is required. A number of typical data path type devices are connected with a variety of proprietary and/or somewhat standard interfaces and the entire system is tied together with a RapidIO switching fabric of some topology. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_197.jpg"/>
MAC Traffic Manager XAUI xMII Framer Network Processor Fabric InterfaceSFIx SPIx Framer Comm Processor Traffic Manager SFIx SPIx CSIX, NPSI Utopia,xMII, RapidIO, R a p i d I O I n t e r c o n n e c t F a b r i c </Figure>

<P>xMII </P>

<P>Comm 
Processor 
</P>

<P>Proprietary</P>

<P>Figure 2-1. Example of a RapidIO-Based Networking System </P>

<P>RapidIO Trade Association </P>

<P>Data “streams” represent logical connections between an ingress port and an egress port. A connection spans the transfer of multiple PDUs. The transfer of PDUs may be separated by discrete intervals of time, based on the arrival of data at the ingress. Transfer between an ingress process and an egress process is unidirectional. An I/O device may be bi-directional, containing both an ingress process and an egress process. These processes are usually completely independent consisting of separate streams in each direction. </P>

<P>A given ingress may service hundreds, thousands, even millions of streams at any given time depending on how specifically a PDU is classified. Traffic may be lumped into a single stream, or classified by user and application to form millions of data streams. </P>

<P>Data streaming transactions differ from most other RapidIO transactions in two ways: they must accommodate larger variably sized data transfers, and the transactions are not acknowledged with a response packet. The data streaming logical layer is intended to support data from a variety of hardware and processing devices. These devices have a variety of different interfaces, protocols, and degrees of sophistication. This specification is intended to enable these kinds of devices to exist on the RapidIO interconnect. </P>

<P id="LinkTarget_31119">2.3 Traffic Streams </P>

<P>A stream identifier identifies independent streams of traffic between the end producer (for example, a web server) and end consumer (for example, a home personal computer) of the encapsulated data. Stream identifiers vary with protocol and may include multiple fields from the various networking layers included in the protocol. A unit of data that contains a discrete identifier is called a Protocol Data Unit, or PDU. A PDU may or may not have an ordering relationship with another PDU being transmitted between that same producer and consumer, depending upon the higher layer protocol being carried. A traffic stream is a series of PDUs that have an ordering relationship between each other. A PDU has no ordering relationship with a PDU from different producers and consumers pairs. </P>

<P>The data streaming logical layer uses a virtual stream identifier (VSID) to allow multiple end to end traffic streams of PDUs to be uniquely identified and managed concurrently within the RapidIO system. Creation of a VSID is done by performing a protocol specific classification process on a PDU. The complexity of the classification process is directly proportional to the sophistication of the system as required by the application. The VSID allows the traffic to be reassociated with an appropriate application at the egress without having to perform a second protocol-specific classification. A VSID is comprised of fields from the data streaming protocol: source or destination ID from the underlying packet transport fabric, class of service, and streamID. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31120">2.4 Operation Ordering </P>

<P>A transaction request flow is defined as an ordered sequence of request transactions comprising a specific PDU from a given source (as indicated by the transaction source identifier from the underlying packet transport fabric) to a given destination (as indicated by the transaction destination identifier). Each packet in a transaction request flow has the same source identifier and the same destination identifier. All traffic streams are mapped onto transaction request flows. These flows may also be shared with other RapidIO logical layers transactions, and therefore the relationship between streams, traffic classes, virtual queues, and all RapidIO transaction request flows are implementation specific. </P>

<P>There may be multiple transaction request flows between a given source and destination pair. When multiple flows exist between a source and destination pair, the flows are distinguished by a flow indicator referred to as a “flowID”, introduced in the RapidIO Part 1: Input/Output Logical Specification. RapidIO allows multiple transaction request flows between any source and destination pair. Any number of transaction request flows may exist between the two end points. The flowID represents the lowest level of traffic management in a RapidIO system as that is the construct mapped directly on to the switch fabric itself. </P>

<P>The transaction request flows between each source and destination end point pair may be allocated to different virtual channels in the underlying fabric and may also be prioritized within a channel. The flows are labeled and identified alphabetically as in the other logical layer specifications, and the channels labeled and identified numerically with channel then priority, starting with 0 as first channel or lowest priority, then 1 as second channel or next lowest priority, etc. For example, flowID 0A is channel 0 flow A, flowID 1C is channel 1 flow C, flowID 3E is channel 3 flow E, and so on. This flow information provides class of service information when mapped by the application to the switch fabric. </P>

<P>Allocation of transaction request flows to virtual channels and the relative priority within each channel is application dependent. A special case is a single virtual channel application which must follow the same prioritization of flows and labeling as the other logical layers (flowID A, flowID B, flowID C, etc.). The channel label </P>

<P>(0) is dropped. This channel may include traffic from the other logical layers. </P>

<P>At the link level, when multiple transaction request flows within the same virtual channel exist between a given connected source and destination pair, transactions of a higher priority flow may pass transactions of a lower priority flow, but transactions of a lower priority flow may not pass transactions of a higher priority flow. There are no ordering rules for flows in different channels. A traffic stream being transmitted between a source and a destination end point pair must utilize the same flowID value so that the ordering of the traffic stream is maintained. As a class of service indicator, the flowID is used by the underlying RapidIO fabric to determine how to treat a packet with respect to other packets with respect to priority and </P>

<P>RapidIO Trade Association </P>

<P>ordering. It is expected that in a mixed control and data plane application that both I/O logical and data streaming transaction request flows will exist in a RapidIO system simultaneously, possibly between the same end point devices. </P>

<P>To support transaction request flows, all devices that support the RapidIO data streaming logical specification shall comply as applicable with the following Fabric Delivering Ordering and End point Completion Ordering rules. Note that these rules are very similar and complementary to the rules specified in RapidIO Part 1: Input/Output Logical Specification. </P>

<P>Fabric Delivery Ordering Rules </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> Transactions within a transaction request flow (same source identifier, same destination identifier, same flowID, same PDU) shall be delivered to the logical layer of the destination in the same order that they were issued by the logical layer of the source. </LI_Title>
</LI>

<L>
<LI>
<LI_Label>2.</LI_Label>

<LI_Title> Request transactions that have the same source (same source identifier) and the same destination (same destination identifier) within the same virtual channel but with different flowIDs shall be delivered to the logical layer of the destination as follows. </LI_Title>
</LI>

<L>
<LI>
<LI_Label>– </LI_Label>

<LI_Title>A transaction of a higher priority transaction request flow that was issued by the logical layer of the source before a transaction of a lower priority transaction request flow shall be delivered to the logical layer of the destination before the lower priority transaction. </LI_Title>
</LI>

<LI>
<LI_Label>– </LI_Label>

<LI_Title>A transaction of a higher priority transaction request flow that was issued by the logical layer of the source after a transaction of a lower priority transaction request flow may be delivered to the logical layer of the destination before the lower priority transaction. </LI_Title>
</LI>
</L>
</L>

<LI>
<LI_Label>3.</LI_Label>

<LI_Title> Request transactions that have different sources (different source identifiers) or different destinations (different destination identifiers) or different virtual channels are unordered with respect to each other. </LI_Title>
</LI>
</L>

<P>End point Completion Ordering Rules </P>

<P>1. Request transactions in a transaction request flow shall be completed at the logical layer of the destination in the same order that the transactions were delivered to the logical layer of the destination. </P>

<P>It may be necessary to impose additional rules in order to provide for inter-operability with other interface standards or programming models. However, such additional rules are beyond the scope of this specification. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31121">2.5 Class of Service and Virtual Queues </P>

<P>Data streaming systems may support thousands, even millions of active data streams. These streams are eventually interleaved onto the single underlying packet transport fabric. The process for deciding which streams may share common resources is sometimes referred to as virtual queuing. To facilitate virtual queuing at the ingress and/or egress of the fabric, and to provide for more sophisticated management of traffic streams, the data streaming logical layer provides a class of service (cos) identifier. The cos field exists to provide a common semantic as to how the traffic stream is to be treated. The relationship between the ingress/egress cos and the end to end flowID assigned to the traffic stream is implementation specific. </P>

<P>At the ingress to the fabric, thousands of streams may be combined into fewer virtual output queues (VoQs) using just the destination ID and the class of service portions of the VSID as shown in 
<Link>Figure 2-2. The cos field defined by this specification is </Link>
comprised of one byte. The number of bits utilized by a particular device depends upon the number of data buffering structures implemented, but are always from the most significant bit of the cos field to the least significant bit. For example, a device with two buffering structures (or “bins”) maps a packet to a bin using bit 0, a device with four bins maps a packet to a bin using bits 0 and 1, and so on. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_198.jpg"/>
Data Streaming Logical Layer Other Logical Layers Flow A Flow B Flow C Transport Fabric Scheduling Virtual Streams VoQs VSID = dest. ID+cos+streamID VoQ = dest. ID+cos Flow = dest. ID+transport </Figure>

<P>Figure 2-2. Mapping Virtual Streams at the System Ingress </P>

<P>As shown in 
<Link>Figure 2-2, as the virtual output queues are mapped on to the flowIDs </Link>
and then on to the underlying packet transport fabric, they may be intermingled with other logical layer transactions. The use of the transport fabric must account for the needs of the total environment and is application and implementation specific. End points designed to support a wide variety of applications for data streaming should offer some flexibility in how virtual queues are mapped down on to the transport fabric in the implementation. </P>

<P>A reverse process (virtual input queueing) may or may not occur at the destination. If there is a critical resource needed to process traffic on egress from the fabric, the system designer may choose to fan the traffic back out into virtual queues. This allows the fabric egress processing to re-prioritize utilization of the critical resource. </P>

<P>RapidIO Trade Association </P>

<P>This is illustrated in 
<Link>Figure 2-3. 
</Link>
VSID = src. ID+cos+streamID 
</P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_199.jpg"/>
Data Streaming Logical Layer Other Logical Layers Scheduling Virtual Streams ViQs Flow A Flow B Flow C Transport Fabric ViQ = src. ID+cos Flow = src. ID+transport </Figure>

<P>Figure 2-3. Mapping Virtual Streams at the System Egress </P>

<P>A switch device may choose to utilize the information carried in the cos field by acting as a “virtual” end point, removing the traffic streams from the underlying packet transport fabric, reassembling the individual PDUs, and fanning the streams back out into some larger number of queues. It then re-injects the traffic streams back into the underlying transport fabric re-ordering the traffic using the cos. This permits intervening devices to participate in the overall assurance of quality of service in the system. </P>

<P id="LinkTarget_31122">2.6 Deadlock Considerations </P>

<P>A deadlock can occur if a dependency loop exists. A dependency loop is a situation where a loop of buffering devices is formed, in which forward progress at each device is dependent upon progress at the next device. If no device in the loop can make progress then the system is deadlocked. </P>

<P>The data streaming logical specification does not have any dependency loops since the defined operations do not require responses. However, a real RapidIO system is required to support the I/O logical maintenance operation, and will very likely require the use of other logical operations for control functions. Support for these other logical operations may have significant deadlock considerations for processing element and system designs. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31123">Chapter 3 Operation Descriptions </P>

<P id="LinkTarget_31124">3.1 Introduction </P>

<P>This chapter describes the RapidIO data streaming protocol. The field encodings and packet formats are described in 
<Link>Chapter 4, “Packet Format Descriptions.” </Link>
</P>

<P>Data path data movement through a machine has requirements that are significantly different than those for control path and traditional DMA functions. Many times this data is encapsulated data, which also many times contains further encapsulated data. For example, the data moving through the system may be encapsulated Ethernet packets, which may in turn be encapsulating TCP/IP packets. </P>

<P>This style of data movement is typically not address-based as with DMA type I/O, and consequently follows a queue based message passing paradigm. Data path data movement also has much more complex requirements in the area of class (or quality) of service than control path communications, and generally requires managing a number of queues at the egress of the system. There is also a need to be able to identify and manage many thousands of data traffic streams that pass through a RapidIO based data path system. The data being passed through the RapidIO system may not be directly generated or consumed by the device connected to the RapidIO portion of the machine, but instead by a distant end user, such as a personal computer attached to a LAN. This necessitates the addition of a new protocol to the RapidIO logical layers, the data streaming protocol. </P>

<P>The RapidIO data streaming protocol uses request transactions through the interconnect fabric as with other RapidIO operation protocols. Since many data movement protocols guarantee data delivery in an upper layer protocol, the generation of responses indicating completion are not needed. Such upper layer protocols may also allow data to be discarded if necessary, for example, under error or fabric congestion conditions. </P>

<P id="LinkTarget_31125">3.2 Data Streaming Protocol </P>

<P>This section describes the RapidIO data streaming protocol. </P>

<P id="LinkTarget_31126">3.2.1 Data Streaming Operation </P>

<P>A data stream represents a logical connection between a source and a destination pair. A stream may consist of multiple transactions and requires the allocation of </P>

<P>RapidIO Trade Association </P>

<P>resources at both the source and the destination. This may be done in advance of any data transfer, or in response to receiving a new transaction. Since streams are virtual constructs between source and destination pairs, they may be reused for different data transfers at any time as long as the source and destination pair are both synchronized as to the stream usage. </P>

<P>A data streaming operation consists of individual data streaming transactions, as shown in 
<Link>Figure 3-1. A series of transactions is used to send PDUs between two end </Link>
points. The data streaming protocol is completely independent of the PDU’s native protocol. </P>

<P>Data streaming transactions do not receive responses, so there is no notification to the sender when the transaction has completed at the destination. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_200.jpg"/>
DATA STREAMING, data 1 Source Destination </Figure>

<P>Figure 3-1. Data Streaming Operation </P>

<P id="LinkTarget_31127">3.2.2 Virtual Streams </P>

<P>A stream is represented by a unique virtual stream indentifier, or VSID. This identifier represents the handling of all PDUs within the stream for the duration of a PDU’s transit of the RapidIO fabric. The identifier is created by performing some form of protocol specific classification of the PDU. The classification can be as complex or as simple as the application warrants. The VSID allows this protocol specific classification to take place one time at the ingress to the fabric. After that, the handling of the PDU is protocol independent. </P>

<P>Protocol Type A FABRIC Destination </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_201.jpg"/>
Classification VSID PDU </Figure>

<P>Protocol Type B </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_202.jpg"/>
Classification VSID PDU </Figure>

<P>Demux </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_203.jpg"/>
</Figure>

<P>Figure 3-2. Virtual Streams </P>

<P>The VSID is used at the destination to “reclassify” the PDU. This sorts the data back into contexts that can now be protocol specific again. This virtual addressing model eliminates the need for the source and the destination to align the use of buffers and other resources. Therefore, the VSID can be used to carry a wide variety of information about a stream through the system, such as the protocol being encapsulated, demultiplexing exit port IDs instructions, very fine grained buffer </P>

<P>RapidIO Trade Association </P>

<P>management, etc., as required for a specific application. </P>

<P>The VSID is a “key” comprised of multiple fields. These fields are the 
source/destination ID, cos, and streamID. 
From the source’s viewpoint: destination ID+cos+streamID represents a unique 
stream. 
From the destination’s viewpoint: source ID+cos+streamID represents a unique 
stream. 
</P>

<P>By using the complete key, each source and destination pair is free to allocate the use of these fields independently. Some examples of how the VSID may be applied 
<Link>in a system are described in Appendix  A, “VSID Usage Examples,” on page 39</Link>
. </P>

<P id="LinkTarget_31128">3.2.3 PDU Sequences Within Streams </P>

<P>As described earlier, a traffic stream may consist of a sequence of related PDUs that have ordering requirements between each other. A stream of PDUs is transmitted one PDU at a time to preserve the required ordering. PDUs that do not have an ordering relationship may be separated into different streams or may be interleaved in common streams. A stream is identified by the interconnect fabric by the combination of the destination ID and either the cos field or the flowID, depending upon the complexity of the fabric, as described in 
<Link>“Section 2.5, Class of Service and </Link>

<Link>Virtual Queues” on page 19. </Link>
</P>

<P>Only one PDU from any given stream will be transmitted at a time at the source, but fabric conditions may result in multiple PDUs in transit. The fabric must guarantee that delivery of PDUs (and segments of PDUs as described below) remain in order. A fabric may load balance traffic through multiple paths on a stream by stream basis. </P>

<P id="LinkTarget_31129">3.2.4 Segments within a PDU </P>

<P>The basic mechanism of segmentation defines a general methodology to provide for larger PDUs than are accommodated by the standard 256 byte limit on a RapidIO data payload. The standard industry term for this function is “Segmentation and Reassembly”, or SAR. A PDU that is to be transmitted from the initial producer to the final consumer is broken up (segmented) into a series of blocks of data. The consumer “reassembles” that data back into the original PDU. The maximum size of 
<Link>a PDU that a particular destination can accept is specified in a CAR (see Chapter 5, </Link>

<Link>“Data Streaming Registers</Link>
”). The system must be configured with in accordance to these limitations. </P>

<P>The block size used for the segmentation process is specified by the Maximum 
<Link>Transmission Unit, or MTU, parameter. The MTU is defined in Chapter 5, “Data </Link>

<Link>Streaming Registers</Link>
”. The MTU is a system-wide parameter agreed to by all processing elements participating in the SAR process. By managing the MTU size for the system, the variability in latency for the system can be controlled. </P>

<P>RapidIO Trade Association </P>

<P>A data streaming transaction is also referred to as a segment. The transmission of a PDU for any given stream may result in one or more transactions (segments). A typical sequence is made up of three types of transactions, a start segment, some number of continuation segments, and an end segment. Start segments and continuation segments are always filled to the MTU size. End segments are variable in size containing the remainder of the PDU. If a PDU is equal to or less than the MTU size, it is carried in a single segment. A single segment may also be variable in size, matching the PDU payload. Since flowIDs and the cos are assigned on a PDU basis, all segments of a PDU must also have that same flowID and cos assignments. </P>

<P>A start segment contains the necessary fields to identify the VSID and “open” a segmentation context. The segmentation context for a stream is defined as the combination of the source ID and the flowID, and is used by a receiver to reassociate the segments of a particular PDU. Using source ID+flowID allows each source and destination pair to have one PDU for each flowID that is explicitly supported by the system interleaved in the fabric at any one point in time. The VSID is used when opening a segmentation process at the destination to associate the PDU with its stream since the continuation and end segments do not carry that information. After the receipt of the end segment, the segmentation context is “closed” (the sending processing element has an analogous definition for open and closed). The stream and PDU associated with a segmentation context is not permitted to change during the time that the context is open. </P>

<P>Since there may be a large number of PDU sources and concurrent contexts per source, the amount of context state that a destination may have to handle can potentially get very large. The number of contexts that can be supported by a 
<Link>particular destination end point is specified in a CAR (see Chapter 5, “Data </Link>

<Link>Streaming Registers</Link>
”). These segmentation contexts must be allocated to sources by system software. </P>

<P>For efficiency, information as to which block of the PDU is contained in a specific packet is not included in the header. This requires that the transmitter issue the sequence starting with the first block of the PDU and proceeding sequentially through the PDU, and requires the underlying transport fabric to deliver the sequence to the data streaming logical layer in the issued order. </P>

<P>
<Link>Figure 3-3 shows a 24 byte PDU that is to be segmented for transmission, with an </Link>
eight byte MTU (note that an eight byte MTU is not permitted in this specification; it is used to simplify the illustration). Since the PDU is divisible by the size specified as the MTU, all data payloads are exactly that size and no padding is necessary. The sender takes byte 0 (the first byte of the PDU) through byte 7 as the data payload to transmit in the start segment. The second data payload consists of bytes 8 through 15, which is transmitted in a continuation segment. The last data payload consists of bytes 16 through 23, which is transmitted in the end segment. Since the data payloads are required to be delivered to the receiver’s data management hardware in </P>

<P>RapidIO Trade Association </P>

<P>order of transmission, the receiver can correctly reassemble the original PDU when all three packets have arrived. </P>

<P>To guarantee the packet ordering, all packets making up an individual PDU and all PDUs in a stream must be in the same transaction request flow, as described in 
<Link>“Section 2.4, Operation Ordering” on page 17. </Link>
</P>

<P>First </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_204.jpg"/>
Byte of PDU Last byte 0 byte 1 byte 2 byte 3 byte 4 byte 5 byte 6 byte 7 byte 8 byte 10 byte 11 byte 9 byte 12 byte 13 byte 14 byte 15 byte 16 byte 18 byte 21 byte 20byte 19 byte 22 byte 23byte 17 Bytes for the start segment data payload Bytes 8 through 15 are the continuation Bytes 16 through 23 are the end segment segment data payload data payload </Figure>

<P>Byte of PDU </P>

<P>Figure 3-3. PDU Segmentation and Reassembly Example 1 </P>

<P>
<Link>Figure 3-4 shows an example of a similar situation, except that this time the PDU is </Link>
21 bytes. In this case, the end segment has a data payload that is less than the specified MTU, and also has a pad byte to round out the data payload to be a multiple of half-words. A bit in the end segment (the “P” bit) indicates the presence of the pad byte. An additional bit (the “O” bit) indicates that the data payload has an odd number of half-words and is therefore oddly aligned. The number of half-words in the data payload as well as the presence of a pad byte can be determined from a PDU length field contained in the end segment header. </P>

<P>First 
Byte 
of PDU 
</P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_205.jpg"/>
Last Byte of PDU byte 0 byte 1 byte 2 byte 3 byte 4 byte 5 byte 6 byte 7 byte 8 byte 10 byte 11 byte 9 byte 12 byte 13 byte 14 byte 15 byte 16 byte 18 padbyte 20byte 19 byte 17 </Figure>
Bytes for the start segment data payload Bytes 8 through 15 are the continuation segment data payload </P>

<P>Bytes 16 through 20 plus the pad byte is the end segment data payload </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31130">3.2.5 Rules for Segmentation and Reassembly </P>

<P>Segmentation (source) </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> In order to limit implementation complexity due to possible PDU ordering issues, only one PDU from a given stream may be segmented at a time. </LI_Title>
</LI>

<LI>
<LI_Label>2.</LI_Label>

<LI_Title>
<Link> Segments are filled with bytes from the PDU in order as shown in Figure 3-3 </Link>
and 
<Link>Figure 3-4. </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>3.</LI_Label>

<LI_Title> The first segment is marked as start segment (see section 4). </LI_Title>
</LI>

<LI>
<LI_Label>4. </LI_Label>

<LI_Title>The start segment is filled to the end of the PDU data or to the MTU size. </LI_Title>
</LI>

<LI>
<LI_Label>5. </LI_Label>

<LI_Title>If the end of the PDU data is encountered, the start segment then re-marked as a single segment. </LI_Title>
</LI>

<LI>
<LI_Label>6. </LI_Label>

<LI_Title>If the start segment reaches MTU size (and there is remaining PDU data), the start segment is encapsulated, and a continuation segment is opened. </LI_Title>
</LI>

<LI>
<LI_Label>7.</LI_Label>

<LI_Title> Continuation segments are filled to MTU size from the PDU data, in order. </LI_Title>
</LI>

<LI>
<LI_Label>8.</LI_Label>

<LI_Title> When the end of PDU data is encountered, the segment is marked as the end segment. The end segment data payload size may be less than or equal to the MTU size. </LI_Title>
</LI>

<LI>
<LI_Label>9. </LI_Label>

<LI_Title>If the source wishes to abort a PDU transmission, it sends an end segment with no data payload and with the length field set to zero. </LI_Title>
</LI>
</L>

<P>Reassembly (destination) </P>

<L>
<LI>
<LI_Label>1. </LI_Label>

<LI_Title>Upon receiving a segment with a start bit, the reassembly unit opens a “context” containing the virtual stream ID and associates it with the segmentation context (consisting of the source ID and the flowID). </LI_Title>
</LI>

<LI>
<LI_Label>2. </LI_Label>

<LI_Title>The reassembly process transfers the entire payload into the reassembly buffer in order. The amount of data transferred is counted for comparison to the length field. </LI_Title>
</LI>

<LI>
<LI_Label>3. </LI_Label>

<LI_Title>If the packet is a single segment, the amount of payload data must be equal to or less than the MTU size or the PDU is defective. </LI_Title>
</LI>

<LI>
<LI_Label>4. </LI_Label>

<LI_Title>If the packet is a start segment and the payload data does not match the MTU size the PDU is defective. </LI_Title>
</LI>

<LI>
<LI_Label>5.</LI_Label>

<LI_Title> Reassembly continues with continuation packets. All continuation packets must match the MTU size or the PDU is defective. All data transferred to the reassembly buffer is counted. </LI_Title>
</LI>

<LI>
<LI_Label>6. </LI_Label>

<LI_Title>An end segment terminates the reassembly process. An end segment may be received immediately after a start segment. The data payload size must be less than or equal to the MTU size or the PDU is defective. The data from the end segment is transferred according to the data payload size and counted. </LI_Title>
</LI>

<LI>
<LI_Label>7.</LI_Label>

<LI_Title> Once all the data has been reassembled, the length (provided by the end segment packet header) is checked against the received data count. A mismatch indicates a lost continuation segment and the PDU is defective. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<L>
<LI>
<LI_Label>8.</LI_Label>

<LI_Title> Receiving a continuation or end segment on a closed context indicates a lost start segment and the PDU is defective. </LI_Title>
</LI>

<LI>
<LI_Label>9.</LI_Label>

<LI_Title> Receiving a start or single segment on an open context indicates a lost end segment and the PDU is defective. The existing context is closed, and the new context is opened. </LI_Title>
</LI>
</L>

<P>In all cases, a defective PDU results in discarding the entire PDU. The method used for reporting the discard event is beyond the scope of this specification. It may be desirable for a destination to have a time-out as part of the lost packet detection mechanism, but the definition and time interval are also outside of the scope of this specification. </P>

<P id="LinkTarget_31131">3.3 Class of Service and Traffic Streams </P>

<P>A virtual stream ID is partitioned into three pieces as previously discussed: port (identified by the source/destination ID), class (the cos field), and the stream identifier (the streamID field). These fields form a specific hierarchy for transitioning packets from highly individualized streams to coarser groupings of traffic. At the fabric ingress, egress, and potentially at interim points (where competition for resources may occur) the traffic may be resegregated and queued by class. In the packet transport fabric, switching is done by destination ID and the 
<Link>mapped flowID, as described in Section 2.4. The full class of service identifier (CoS </Link>
ID) is a subset of the VSID. It consists of the source/destination ID (or ingress/egress port) plus the cos field. Ingress queuing should be based on: destination ID+cos Egress queuing should be based on: source ID+cos as shown in 
<Link>Figure 3-5. </Link>
</P>

<P>Including the source or destination ID in the CoS ID allows the class of service to be specific to the source and destination pairing.  </P>

<Table>
<TR>
<TD>Streams </TD>

<TD>Queues Ingress </TD>

<TD>Fabric </TD>

<TD/>
</TR>

<TR>
<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_206.jpg"/>
</Figure>
</TD>

<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_207.jpg"/>
</Figure>
</TD>

<TD>Port 2 </TD>

<TD/>
</TR>

<TR>
<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_208.jpg"/>
</Figure>
</TD>

<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_209.jpg"/>
</Figure>
</TD>

<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_210.jpg"/>
</Figure>
</TD>

<TD>Egress Traffic </TD>
</TR>

<TR>
<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_211.jpg"/>
</Figure>
</TD>

<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_212.jpg"/>
</Figure>
</TD>

<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_213.jpg"/>
</Figure>
</TD>

<TD>Prioritized </TD>
</TR>

<TR>
<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_214.jpg"/>
</Figure>
</TD>

<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_215.jpg"/>
</Figure>
</TD>

<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_216.jpg"/>
</Figure>
</TD>

<TD>by Class </TD>
</TR>

<TR>
<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_217.jpg"/>
</Figure>
</TD>

<TD><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_218.jpg"/>
</Figure>
</TD>

<TD>Port 4 </TD>

<TD/>
</TR>

<TR>
<TD/>

<TD/>

<TD>Figure 3-5. Traffic Sorting Based on CoS ID Queues </TD>

<TD/>
</TR>
</Table>

<P>The cos field shall be used beginning with the MSB (bit 0) using the necessary number of bits for the number of classes supported. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_219.jpg"/>
Class </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_220.jpg"/>
Egress </Figure>

<P>RapidIO Trade Association </P>

<P>Bit 0 - 2 Classes of Service Bits 0, 1 - 4 Classes of Service Bits 0, 1, 2 - 8 Classes of Service supported etc. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31132">Chapter 4 Packet Format Descriptions </P>

<P id="LinkTarget_31133">4.1 Introduction </P>

<P>This chapter contains the definition of the data streaming packet format. </P>

<P id="LinkTarget_31134">4.2 Type 9 Packet Format (Data-Streaming Class) </P>

<P>The type 9 packet format is the DATA STREAMING transaction format. Type 9 packets always have a data payload, unless terminating the PDU. Unlike other RapidIO logical specifications, the data payload length is defined as a multiple of half-words rather than double-words. A pad bit allows a sender to transmit an odd number of bytes in a packet. An odd bit indicates that the data payload has an odd number of half-words. This bit makes it possible for the destination to determine the end of a data payload if packet padding is done by the underlying transport. An extended header bit allows future expansion of the functionality of the type 9 packet format. </P>

<P>Definitions and encodings of fields specific to type 9 packets are provided in 
<Link>Table 4-1. </Link>
</P>

<Table>
<Caption>
<P>Table 4-1. Specific Field Definitions and Encodings for Type 9 Packets </P>
</Caption>

<TR>
<TD>Field </TD>

<TD>Definition </TD>
</TR>

<TR>
<TD>cos </TD>

<TD>class of service - This field defines the class of service to be applied by the destination end point (and possibly intervening switch processing elements) to the specified traffic stream. </TD>
</TR>

<TR>
<TD>S </TD>

<TD>Start - If set, this packet is the first segment of a new PDU that is being transmitted. The new PDU is identified by the combination of the source of the packet and the flowID. </TD>
</TR>

<TR>
<TD>E </TD>

<TD>End - If set, this packet is the last segment of a PDU that is being transmitted. Both S and E set indicates that the PDU is fully contained in a single packet. </TD>
</TR>

<TR>
<TD>rsrv </TD>

<TD>Reserved - Assigned to logic 0s by the sender, ignored by the receiver </TD>
</TR>

<TR>
<TD>xh </TD>

<TD>Extended header -There is an extended header on this packet. Currently there are no defined extended header formats. It is always assigned to 0b0 for type 9 packets. </TD>
</TR>

<TR>
<TD>O </TD>

<TD>Odd - If set, the data payload has an odd number of half-words </TD>
</TR>

<TR>
<TD>P </TD>

<TD>Pad - If set, a pad byte was used to pad to a half-word boundary </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Field </TD>

<TD>Definition </TD>
</TR>

<TR>
<TD>streamID </TD>

<TD>traffic stream identifier - This is an end to end (producer to consumer) traffic stream identifier. </TD>
</TR>

<TR>
<TD>length </TD>

<TD>PDU length - This is the length in bytes of the segmented PDU. 0x0000 - 64kbytes 0x0001 - 1 byte 0x0002 - 2 bytes 0x0003 - 3 bytes ... 0xFFFF - 64kbytes - 1 </TD>
</TR>

<Caption>
<P>
<Link>Table 4-1 details the O and P bit combinations.  </Link>
</P>
</Caption>
</Table>

<P>Table 4-2. Specific Field Definitions and Encodings for Type 9 Packets </P>

<Table>
<TR>
<TH>O bit </TH>

<TH>P bit </TH>

<TH>Definition </TH>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b0 </TD>

<TD>Even number of half-words and no pad byte </TD>
</TR>

<TR>
<TD>0b0 </TD>

<TD>0b1 </TD>

<TD>Even number of half-words and a pad byte </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b0 </TD>

<TD>Odd number of half-words and no pad byte </TD>
</TR>

<TR>
<TD>0b1 </TD>

<TD>0b1 </TD>

<TD>Odd number of half-words and a pad byte </TD>
</TR>
</Table>

<P>There are three type 9 packet headers, determined by the value of the Start and End bits, which determine if the header is a Start/Single header, a Continuation header, or an End header. The following set of figures shows examples of type 9 packets. Field sizes are specified in bits. </P>

<P>
<Link>Figure 4-1 is an example of a Single Segment type 9 packet with all of its fields. The </Link>
data payload size may or may not match the MTU size, so n and m are determined by the size of the PDU itself. In this example, the data payload is un-padded and there are an even number of half-words. The value 0b1001 in 
<Link>Figure 4-1 specifies </Link>
that the packet format is of type 9. This is the only type 9 packet that has the xh field. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_221.jpg"/>
• • • 1 0 0 1 4 3 rsrv 1 1 S=1 E=1cos 8 streamID 161 xh=0 half-word 0 (byte 0 || byte 1) 16 half-word 1 (byte 2 || byte 3) 16 1 1 O=0 P=0 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_222.jpg"/>
</Figure>

<P>half-word n (byte m-1 || byte m) </P>

<P>16 </P>

<P>Figure 4-1. Single Segment Type 9 Packet Bit Stream Format Example </P>

<P>
<Link>Figure 4-2</Link>
 is an example of a Start Segment type 9 packet with all of its fields. The data payload that matches the MTU, so n and m are determined by the MTU size. The value 0b1001 in 
<Link>Figure 4-2 specifies that the packet format is of type 9. </Link>
</P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_223.jpg"/>
1 0 0 1 4 3 rsrv 1 1 S=1 E=0 streamID 162 rsrv cos 8 • • • half-word 0 (byte 0 || byte 1) 16 half-word 1 (byte 2 || byte 3) 16 1 0 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_224.jpg"/>
</Figure>

<P>half-word n (byte m-1 || byte m) </P>

<P>16 </P>

<P>Figure 4-2. Start Segment Type 9 Packet Bit Stream Format Example </P>

<P>
<Link>Figure 4-3</Link>
 is an example of a Continuation Segment type 9 packet with all of its fields. The size of the data payload must match the MTU size. The half-words (and correspondingly, bytes) are contiguous in the manner shown in the preceding examples. The value 0b1001 in 
<Link>Figure 4-3 specifies that the packet format is of type </Link>
</P>

<P>9. </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_225.jpg"/>
1 0 0 1 4 3 rsrv 1 1 S=0 E=0cos 8 • • • half-word 16 half-word 16 2 rsrv 1 0 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_226.jpg"/>
</Figure>

<P>half-word </P>

<P>16 </P>

<P>Figure 4-3. Continuation Segment Type 9 Packet Bit Stream Format Example </P>

<P>
<Link>Figure 4-4</Link>
 is an example of an End Segment type 9 packet with all of its fields. The size of the data payload is determined by the remainder of the size of the PDU (the length field) divided by the size of the MTU. For convenience at the destination, the O and P bits are used as they are for a single segment. In this example, the data payload size does not match the PDU size, has a pad byte, and is an odd number of half-words. The half-words (and correspondingly, bytes) are contiguous in the manner shown in the preceding examples. A length value of 0 and no data payload 
<Link>can be used to force the PDU to be discarded. The value 0b1001 in Figure 4-4 </Link>
specifies that the packet format is of type 9. </P>

<P>RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_227.jpg"/>
1 0 0 1 4 3 rsrv 1 1 S=0 E=1cos 8 • • • length 16 half-word 16 half-word 16 1 0 1 1 O=1 P=1 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_228.jpg"/>
</Figure>

<P>half-word (last byte || pad=0x00) </P>

<P>16 </P>

<P>Figure 4-4. End Segment Type 9 Packet Bit Stream Format </P>

<P id="LinkTarget_31135">4.3 	Type 9 Extended Packet Format (Extended Data-Streaming Class) </P>

<P>The type 9 extended packet format is intended to be used for advanced traffic management and other possible future features of the data streaming specification. The format is undefined. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31136">Chapter 5  Data Streaming Registers </P>

<P id="LinkTarget_31137">5.1 Introduction </P>

<P>This chapter describes the visible register set that allows an external processing element to determine the capabilities, configuration, and status of a processing element using this logical specification. This chapter only describes registers or register bits defined by this specification. Refer to the other RapidIO logical, transport, physical, and extension specifications of interest to determine a complete list of registers and bit definitions. All registers are 32 bits and aligned to a 32 bit boundary. </P>

<P id="LinkTarget_31138">5.2 Register Summary </P>

<P>
<Link>Table 5-1 shows the register map for this RapidIO specification. These capability </Link>
registers (CARs) and command and status registers (CSRs) can be accessed using RapidIO Part 1: Input/Output Logical Specification maintenance operations. Any register offsets not defined are considered reserved for this specification unless otherwise stated. Other registers required for a processing element are defined in other applicable RapidIO specifications and by the requirements of the specific device and are beyond the scope of this specification. Read and write accesses to reserved register offsets shall terminate normally and not cause an error condition in the target device. Writes to CAR (read-only) space shall terminate normally and not cause an error condition in the target device. </P>

<P>Register bits defined as reserved are considered reserved for this specification only. Bits that are reserved in this specification may be defined in another RapidIO specification. </P>

<Table>
<Caption>
<P>Table 5-1. Data Streaming Register Map </P>
</Caption>

<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x0-14 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x18 </TD>

<TD>Source Operations CAR </TD>
</TR>

<TR>
<TD>0x1C </TD>

<TD>Destination Operations CAR </TD>
</TR>

<TR>
<TD>0x20–38 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x3C </TD>

<TD>Data Streaming Information CAR </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x40–44 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x48 </TD>

<TD>Data Streaming Logical Layer Control CSR </TD>
</TR>

<TR>
<TD>0x4C–FC </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x100– FFFC </TD>

<TD>Extended Features Space </TD>
</TR>

<TR>
<TD>0x10000– FFFFFC </TD>

<TD>Implementation-defined Space </TD>
</TR>
</Table>

<P id="LinkTarget_31139">5.3 Reserved Register and Bit Behavior </P>

<P>
<Link>Table 5-2 describes the required behavior for accesses to reserved register bits and </Link>
reserved registers for the RapidIO register space, </P>

<Table>
<Caption>
<P>Table 5-2. Configuration Space Reserved Access Behavior </P>
</Caption>

<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x0–3C </TH>

<TD>Capability Register Space (CAR Space - this space is read-only) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value1 </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - </TD>

<TD>write - ignored</TD>
</TR>

<TR>
<TD> Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write - </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x40–FC </TH>

<TD>Command and Status Register Space (CSR Space) </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value2 </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write implementation-defined </TD>
</TR>

<TR>
<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TD>write - </TD>

<TD>write - ignored </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 10: Data Streaming Logical Specification Rev. 1.3.a Table 5-2. Configuration Space Reserved Access Behavior (Continued) </P>

<Table>
<TR>
<TH>Byte Offset </TH>

<TH>Space Name </TH>

<TH>Item </TH>

<TH>Initiator behavior </TH>

<TH>Target behavior </TH>
</TR>

<TR>
<TH>0x100– FFFC </TH>

<TD>Extended Features Space </TD>

<TD>Reserved bit </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0 </TD>
</TR>

<TR>
<TD>write - preserve current value </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>Implementation-defined bit </TD>

<TD>read - ignore returned value unless implementation-defined function understood </TD>

<TD>read - return implementation-defined value </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD/>

<TD>write - preserve current value if implementation-defined function not understood </TD>

<TD>write implementation-defined </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD>Reserved register </TD>

<TD>read - ignore returned value </TD>

<TD>read - return logic 0s </TD>
</TR>

<TR>
<TH/>

<TD/>

<TD/>

<TD>write - </TD>

<TD>write - ignored </TD>
</TR>

<TR>
<TH>0x10000– FFFFFC </TH>

<TD>Implementation-defined Space </TD>

<TD>Reserved bit and register </TD>

<TD>All behavior implementation-defined </TD>
</TR>
</Table>

<P>1Do not depend on reserved bits being a particular value; use appropriate masks to extract defined bits from the read value. </P>

<P>2All register writes shall be in the form: read the register to obtain the values of all reserved bits, merge in the desired values for defined bits to be modified, and write the register, thus preserving the value of all reserved bits. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31140">5.4 	Capability Registers (CARs) </P>

<P>Every processing element shall contain a set of registers that allows an external processing element to determine its capabilities through maintenance read operations. All registers are 32 bits wide and are organized and accessed in 32 bit (4 byte) quantities, although some processing elements may optionally allow larger 
<Link>accesses. CARs are read-only. Refer to Table 5-2 for the required behavior for </Link>
accesses to reserved registers and register bits. </P>

<P>CARs are big-endian with bit 0 and Word 0 respectively the most significant bit and word. </P>

<P id="LinkTarget_31141">5.4.1 	Source Operations CAR 
(Configuration Space Offset 0x18) 
</P>

<P>This register defines the set of RapidIO data streaming logical operations that can be issued by this processing element; see 
<Link>Table 5-3. It is assumed that a processing </Link>
element can generate I/O logical maintenance read and write requests if it is required to access CARs and CSRs in other processing elements. The Source Operations CAR is applicable for end point devices only. RapidIO switches shall be able to route any packet. </P>

<Table>
<Caption>
<P>Table 5-3. Bit Settings for Source Operations CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–12 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Data-streaming </TD>

<TD>PE can support a data streaming operation </TD>
</TR>

<TR>
<TD>14–15 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>

<TR>
<TD>16-29 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>30–31 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>
</Table>

<P id="LinkTarget_31142">5.4.2 	Destination Operations CAR (Configuration Space Offset 0x1C) </P>

<P>This register defines the set of RapidIO data streaming operations that can be supported by this processing element; see 
<Link>Table 5-4. It is required that all processing </Link>
elements can respond to maintenance read and write requests in order to access these registers. The Destination Operations CAR is applicable for end point devices only. RapidIO switches shall be able to route any packet. </P>

<Table>
<Caption>
<P>Table 5-4. Bit Settings for Destination Operations CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-12 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Data-streaming </TD>

<TD>PE can support a data streaming operation </TD>
</TR>

<TR>
<TD>14-15 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>RapidIO Part 10: Data Streaming Logical Specification Rev. 1.3.a Table 5-4. Bit Settings for Destination Operations CAR (Continued) </P>

<Table>
<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>16-29 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>30-31 </TD>

<TD>Implementation Defined </TD>

<TD>Defined by the device implementation </TD>
</TR>
</Table>

<P id="LinkTarget_31143">5.4.3 	Data Streaming Information CAR (Configuration Space Offset 0x3C) </P>

<P>This register defines the data streaming capabilities of a processing element. It is required for destination end point devices. </P>

<Table>
<Caption>
<P>Table 5-5. Bit Settings for Data Streaming Information CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0–15 </TD>

<TD>MaxPDU </TD>

<TD>Maximum PDU - The maximum PDU size in bytes supported by the destination end point 0x0000 - 64kbytes 0x0001 - 1 byte 0x0002 - 2 bytes ... 0xFFFF - 64kbytes - 1 </TD>
</TR>

<TR>
<TD>16–31 </TD>

<TD>SegSupport </TD>

<TD>Segmentation Support - The number of segmentation contexts supported by the destination end point 0x0000 - 64k segmentation contexts 0x0001 - 1 segmentation context 0x0002 - 2 segmentation contexts ... 0xFFFF - 64k - 1 segmentation contexts </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31144">5.5 	Command and Status Registers (CSRs) </P>

<P>A processing element shall contain a set of command and status registers (CSRs) that allows an external processing element to control and determine the status of its internal hardware. All registers are 32 bits wide and are organized and accessed in 
<Link>the same way as the CARs. Refer to Table 5-2 for the required behavior for accesses </Link>
to reserved registers and register bits. </P>

<P id="LinkTarget_31145">5.5.1 	Data Streaming Logical Layer Control CSR 
(Configuration Space Offset 0x48) 
</P>

<P>The Data Streaming Logical Layer Control CSR is used for general command and status information for the logical interface. </P>

<Table>
<Caption>
<P>Table 5-6. Bit Settings for Data Streaming Logical Layer Control CSR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Field Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-23 </TD>

<TD>— </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>24-31 </TD>

<TD>MTU </TD>

<TD>Maximum Transmission Unit -controls the data payload size for segments of an encapsulated PDU. Only single segment PDUs and end segments are permitted to have a data payload that is less this value. The MTU can be specified in increments of 4 bytes. Support for the entire range is required. 0b0000_0000 - reserved ... 0b0000_0111 - reserved 0b0000_1000 - 32 byte block size 0b0000_1001 - 36 byte block size 0b0000_1010 - 40 byte block size ... 0b0100_0000 - 256 byte block size 0b0100_0001 - Reserved ... 0b1111_1111 - Reserved All other encodings reserved </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31146">Annex A VSID Usage Examples </P>

<P id="LinkTarget_31147">A.1 Introduction </P>

<P>The virtual stream identification (VSID) mechanism provides multiple features condensed in a single 32 bit key. These features include: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> A mechanism to manage traffic for ingress to the fabric </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A mechanism to manage traffic in transit within the fabric </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A protocol independent tag to reclassify packets on fabric egress </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> A flexible &quot;sub-port&quot; addressing mechanism </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Independence in buffer management </LI_Title>
</LI>
</L>

<P id="LinkTarget_31148">A.2 Background </P>

<P>The VSID is a composite of the port, class, and streamID fields as described in 
<Link>Section 3.2.2. The port address used in the VSID is either the destination ID or the </Link>
source ID depending on which side of the fabric the packet is on. At the ingress to the fabric (source) the destination IDs are unique. At the egress from the fabric, the source IDs are unique. </P>

<P>By including the source/destination IDs in the VSID, these keys are unique for each source and destination pairing. This allows the other fields (class and streamID) to be set up independently without consideration of how these fields are used with any other port pairings. </P>

<P>The usage of the VSID can vary depending on the sophistication of the fabric and the demands of the application, from very simplistic port or queue steering to conveying significant amounts of information (requiring intensive computation) as to the content of the PDU. </P>

<P id="LinkTarget_31149">A.3 Packet Classification </P>

<P>All PDUs require some form of classification for ingress to the fabric. Fields in the PDU specific to the protocol are examined and routing information is produced. The VSID produced is a 32 bit tag as opposed to just a port address. At the destination, this 32 bit tag can be used to re-associate the PDU with a target buffer. This can be done by direct addressing, or using a single key table lookup. </P>

<P>RapidIO Trade Association </P>

<P>This mechanism provides a finely grained and protocol independent way to sort traffic, and a virtual mechanism for buffer pool management. Without a virtual tag, the packet would have to undergo a re-classification based on the protocol specific portion of the PDU. In multi-service platforms, this could involve numerous and elaborate processes, duplicating what was already done at the source. </P>

<P>The following sections illustrate in degrees of increasing complexity, the versatility of the VSID scheme. </P>

<P id="LinkTarget_31150">A.3.1 Sub-port Addressing at the Destination </P>

<P>The simplest use of the VSID is to de-multiplex the traffic into coarse sub-ports at the destination. These may be to separate traffic by protocol, or into multiple sub-ports of the same protocol. </P>

<P id="LinkTarget_31151">A.3.1.1 DSLAM application </P>

<P>Assume that each line card contain 128 user ports. The system could expose each of these as independent destinations to the RapidIO fabric, requiring the use of an excessively large number of destination IDs in the system, and imposing the associated cost in overhead. Alternatively the ATM traffic can be encapsulated into 128 VSIDs, one for each port. The line card would then expose a single port to the RapidIO fabric. The VSID would be used as the address to fan out the traffic on various UTOPIA busses to the user ports. This also has an advantage for fault recovery. Should a line card fail, a single port entry in routing tables in the fabric needs to be updated rather than all 128 sub-ports. </P>

<P id="LinkTarget_31152">A.3.1.2 VOIP application </P>

<P>The VSID can be used to separate the traffic into just 2 channels, one destined for a control processor to handle control messages and one channel that goes to a network processor to be distributed to DSPs. The VSID could contain the address of the target DSP, to further off-load the network processor on distribution. The VSID could also contain the user channel within the DSP de-multiplexing the traffic even further. </P>

<P id="LinkTarget_31153">A.3.2 Virtual Output Queuing - Fabric On-ramp </P>

<P>Applications involving larger numbers of flows can use the class field to regulate the ingress to the fabric (known as virtual output queuing). For example, the RapidIO fabric interface could contain 256 queues for 64 destination ports with 4 traffic classes. Traffic for each destination of the same class is fairly weighted. The weighting between classes can be application unique. </P>

<P>The traffic is kept sorted by destination. If traffic was just dumped into 4 queues, and a destination port was to fail, the traffic could head of line block the traffic to the other ports, or it would have to be discarded while the port is being recovered or </P>

<P>RapidIO Trade Association </P>

<P>re-routed. By keeping the traffic sorted by destination at the fabric ingress, that destination can be re-routed with minimal traffic loss. </P>

<P>Virtual output queuing can be expanded to 2K or even 16K buffers depending on how large the fabric is, and how many different traffic classes are involved. This fabric ingress management can be a simple mechanism to add some quality of service to a system using the destination ID and the class portion of the VSID. Note that this can be done separately from the use of the streamID at the destination for de-multiplexing. </P>

<P id="LinkTarget_31154">A.4 System Requirements </P>

<P>The use of the VSID is determined by all three elements in a system, the source, the fabric, and the destination. This section contains descriptions of some example source devices. </P>

<P id="LinkTarget_31155">A.4.1 UTOPIA to RapidIO ATM bridge </P>

<P>The UTOPIA to RapidIO ATM bridge classifies traffic using the VPI field as the destination port, and the VCI as a sub-port address. It maps all (type 9) traffic to a single RapidIO flow, setting the class to 0 and the streamID to the VCI. The fabric switches on flows. The destination uses the streamID portion of the VSID as a hard-wired sub-port address. </P>

<P id="LinkTarget_31156">A.4.2 Network processor </P>

<P>The network processor (NP) contains a OC-48 link aggregating traffic to and from multiple 1MB/s ports distributed on line cards. The NP classifies traffic for each user into two classes: high priority for voice (using RTP) and low priority for all others. It sets the class field to 0 or 1, the port to the proper line card, and the streamID to the desired sub-port. </P>

<P id="LinkTarget_31157">A.4.3 CSIX to RapidIO interface </P>

<P>The CSIX packet contains the destination and class fields (the source is a preset parameter in the interface chip). The streamID is the first 16 bits of the CSIX payload. The RapidIO packet is easily constructed from this information. The fabric interface contains multiple virtual output queues, 2 per destination port. Since the CSIX to NP interface is also a segmented interface, PDUs are reassembled in the virtual queues until enough information is available to form the required MTU on the RapidIO fabric. </P>

<P>The fabric maps the class to a higher or lower priority flow. The destination uses the streamID to map the traffic to the correct user sub-port. Each sub-port contains two class queues to collect traffic as it is reassembled. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31158">A.4.4 10Gb Metropolitan Area Network interface </P>

<P>A specialized classification processor creates the 32 bit VSID based on IP, TCP/UDP, and application information. The tag is prepended to a SPI4.2 packet. The interface to the fabric is a SPI4.2 to RapidIO bridge, which contains virtual output queues. </P>

<P>The destination is a processor that only supports memory and IO logical transactions. The RapidIO to processor interface bridge contains the segmentation and reassembly buffers and look up tables and associated engines that maps the VSID to a DMA buffer address (and vice-versa). </P>

<P>The system contains multiple of these processing cards to support address translation, encryption, or firewall processing. The source classifies traffic based on which of these applications applies. A connection is created by allocating a buffer address in the destination, and assigning a streamID. The source table is created with the search tree requirements for the protocol, and setting up the VSID result. </P>

<P>Destinations may use the VSID in a hard-wired method, or it may be a flexible mapping to virtual buffers. In either case, the source must be flexible to assign the VSID according the destination's needs. This is normally not an issue as the source needs to classify the packet to determine the destination anyway. The use of the VSID can be to separate the traffic by protocol, sub-port, service class, or into as many virtual queues as necessary. If the destination is managing a large number of buffers, the VSID allows the destination to use a single protocol independent key to re-map the traffic and completely abstract any buffer management. </P>

<P>RapidIO Trade Association </P>

<P>Glossary of Terms and Abbreviations 
</P>

<P>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </P>

<P>B Bridge. A processing element that connects one computer bus to another, allowing a processing element on one bus to access an processing element on the other. </P>

<P>Capability registers (CARs). A set of read-only registers that allows a processing element to determine another processing element’s capabilities. </P>

<P>Class of service - (cos) a term used to describe different treatment (quality of service) for different data streams. Support for class of service is provided by a class of service field in the data streaming protocol. The class of service field is used in the virtual stream ID and in identifying a virtual queue. </P>

<P>Command and status registers (CSRs). A set of registers that allows a processing element to control and determine the status of another processing element’s internal hardware. </P>

<P>D Deadlock. A situation in which two processing elements that are sharing resources prevent each other from accessing the resources, resulting in a halt of system operation. </P>

<P>Destination. The termination point of a packet on the RapidIO interconnect, also referred to as a target. </P>

<P>Device. A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a processing element. </P>

<P>Direct Memory Access (DMA). The process of accessing memory in a device by specifying the memory address directly. </P>

<P>Double-word. An eight byte or 64 bit quantity, aligned on eight byte boundaries. </P>

<P>RapidIO Trade Association </P>

<P>E 
</P>

<P>Egress - Egress is the device or node where traffic exits the system. The egress node also becomes the destination for traffic out of the RapidIO fabric. The terms egress and destination may or may not be used interchangeably when considering a single end to end connection. </P>

<P>End point. A processing element which is the source or destination of transactions through a RapidIO fabric. </P>

<P>End point device. A processing element which contains end point functionality. </P>

<P>Ethernet. A common local area network (LAN) technology. </P>

<P>External processing element. A processing element other than the processing element in question. </P>

<Table>
<TR>
<TD>F </TD>

<TD>Field or Field name. A sub-unit of a register, where bits in the register are named and defined. </TD>
</TR>

<TR>
<TD>H </TD>

<TD>Half-word. A two byte or 16 bit quantity, aligned on two byte boundaries. Host. A processing element responsible for exploring and initializing all or a portion of a RapidIO based system. </TD>
</TR>
</Table>

<P>Ingress - Ingress is the device or node where traffic enters the system. The ingress node also becomes the source for traffic into the RapidIO fabric. The terms ingress and source may or may not be used interchangeably when considering a single end to end connection. </P>

<P>Initiator. The origin of a packet on the RapidIO interconnect, also referred to as a source. </P>

<P>I/O. Input-output. </P>

<P>O Operation. A set of transactions between end point devices in a RapidIO system (requests and associated responses) such as a read or a write. </P>

<P>P 
</P>

<P>Packet. A set of information transmitted between devices in a RapidIO system. </P>

<P>PDU. Protocol Data Unit, the OSI term for a packet. </P>

<P>Priority. The relative importance of a transaction or packet; in most systems a higher priority transaction or packet will be serviced or transmitted before one of lower priority. </P>

<P>RapidIO Trade Association </P>

<P>Processing Element (PE). A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a device. </P>

<P>Processor. The logic circuitry that responds to and processes the basic instructions that drive a computer. </P>

<P>R Receiver. The RapidIO interface input port on a processing element. </P>

<P>S 
</P>

<P>SAR. Segmentation and Reassembly, a mechanism for encapsulating a PDU within multiple packets. </P>

<P>Segmentation. A process by which a PDU is transferred as a series of smaller segments. </P>

<P>Segmentation Context. Information that allows a receiver to associate a particular packet with the correct PDU. </P>

<P>Sender. The RapidIO interface output port on a processing element. </P>

<P>Sequence. Sequentially ordered, uni-directional group of messages that constitute the basic unit of data delivered from one end point to another. </P>

<P>StreamID. A specific field in the data streaming protocol that is combined with the data stream’s transaction request flow ID and the sourceID or destinationID from the underlying packet transport fabric to form the virtual stream ID. </P>

<P>Source. The origin of a packet on the RapidIO interconnect, also referred to as an initiator. </P>

<P>Switch. A multiple port processing element that directs a packet received on one of its input ports to one of its output ports. </P>

<P>T 
</P>

<P>Target. The termination point of a packet on the RapidIO interconnect, also referred to as a destination. </P>

<P>Transaction. A specific request or response packet transmitted between end point devices in a RapidIO system. </P>

<P>Transaction request flow. A sequence of transactions between two processing elements that have a required completion order at the destination processing element. There are no ordering requirements between transaction request flows. </P>

<P>Virtual Stream ID (VSID). An identifier comprised of several fields in the </P>

<P>V </P>

<P>protocol to identify individual data streams. </P>

<P>RapidIO Trade Association 45 </P>

<P>Virtual input Queue (ViQ), Virtual output Queue (VoQ). An intermediate point in the system where one or more virtual streams may be concentrated. </P>

<P>Word. A four byte or 32 bit quantity, aligned on four byte boundaries. </P>

<P>W </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31159">RapidIO™ Interconnect SpecificationPart 11: Multicast Extensions Specification </P>

<P>Rev. 1.3.1, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_97.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>
</TR>

<TR>
<TD>1.3 </TD>

<TD>First release </TD>

<TD>06/09/2004 </TD>
</TR>

<TR>
<TD>1.3.1 </TD>

<TD>Technical changes: the following new features showings: 04-08-00015.003 Converted to ISO-friendly templates </TD>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TD>1.3.1 </TD>

<TD>Removed confidentiality markings for public release </TD>

<TD>06/07/2005 </TD>
</TR>
</Table>

<P>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE 
ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND 
CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO 
WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE. USER AGREES TO 
ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE 
GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR 
RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER 
SUCH USE OF THE SPECIFICATION. 
</P>

<P>DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, 
INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST 
PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION 
WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE 
RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. 
</P>

<P>Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: 
Suite 325, 3925 W. Braker Lane 
Austin, TX 78759 
512-305-0070 Tel. 
512-305-0009 FAX. 
</P>

<P>RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their 
respective owners. 
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 1 Overview </Link>
</P>

<P>
<Link>1.1 Introduction............................................................................................................. 9 
</Link>
</P>

<P>
<Link>1.2 Overview................................................................................................................. 9 
</Link>
</P>

<P>
<Link>1.3 Requirements ........................................................................................................ 10 
</Link>
</P>

<P>
<Link>Chapter 2 Multicast Extensions Behavior </Link>
</P>

<P>
<Link>2.1 Introduction........................................................................................................... 11 
</Link>
</P>

<P>
<Link>2.2 Packet Replication ................................................................................................ 11 
</Link>
</P>

<P>
<Link>2.3 Multicast Operation .............................................................................................. 11 
</Link>
</P>

<P>
<Link>2.4 Multicast Transaction Ordering Requirements ..................................................... 15 
</Link>
</P>

<P>
<Link>Chapter 3 Multicast Extensions Registers </Link>
</P>

<P>
<Link>3.1 Introduction........................................................................................................... 17 
</Link>
</P>

<P>
<Link>3.2 Processing Elements Features CAR (Configuration Space Offset 0x10) ............. 18 
</Link>
</P>

<P>
<Link>3.3 Switch Multicast Support CAR (Configuration Space Offset 0x30).................... 19 
</Link>
</P>

<P>
<Link>3.4 Switch Multicast Information CAR (Configuration Space Offset 0x38) ............. 20 
</Link>
</P>

<P>
<Link>3.5 Multicast Mask Port CSR (Configuration Space Offset 0x80)............................. 21 
</Link>
</P>

<P>
<Link>3.6 Multicast Associate Select CSR (Configuration Space Offset 0x84) ................... 22 
</Link>
</P>

<P>
<Link>3.7 Multicast Associate Operation CSR (Configuration Space Offset 0x88)............. 23 
</Link>
</P>

<P>
<Link>Chapter 4  Configuration Examples </Link>
</P>

<P>
<Link>4.1 Introduction........................................................................................................... 25 
</Link>
</P>

<P>
<Link>4.2 Configuring Multicast Masks ............................................................................... 25 
</Link>
</P>

<P>
<Link>4.2.1 Clearing Multicast Masks ................................................................................. 25 
</Link>
</P>

<P>
<Link>4.2.2 Assigning Ports to Multicast Masks ................................................................. 26 
</Link>
</P>

<P>
<Link>4.2.3 Removing a Port from a Multicast Mask.......................................................... 26 
</Link>
</P>

<P>
<Link>4.2.4 Querying a Multicast Mask............................................................................... 26 
</Link>
</P>

<P>
<Link>4.3 Simple Association ............................................................................................... 27 
</Link>
</P>

<P>
<Link>4.3.1 Restrictions on Block Size ................................................................................ 27 
</Link>
</P>

<P>
<Link>4.3.2 Restrictions on Block Associate ....................................................................... 28 
</Link>
</P>

<P>
<Link>4.3.3 Restrictions on Associations ............................................................................. 28 
</Link>
</P>

<P>
<Link>4.4 Configuring Associations ..................................................................................... 28 
</Link>
</P>

<P>
<Link>4.4.1 Basic Association.............................................................................................. 28 
</Link>
</P>

<P>
<Link>4.4.2 Using Per-Ingress Port Association .................................................................. 29 
</Link>
</P>

<P>
<Link>4.4.3 Using Block Association .................................................................................. 30 
</Link>
</P>

<P>
<Link>4.4.4 Using Per-Ingress Port and Block Association................................................. 31 
</Link>
</P>

<P>
<Link>4.4.5 Removing a Destination ID to Multicast Mask Association ............................ 32 
</Link>
</P>

<P>
<Link>4.4.6 Querying an Association................................................................................... 32 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Annex A   End Point Considerations (Informative) </Link>
</P>

<P>
<Link>A.1 Introduction........................................................................................................... 37 
</Link>
</P>

<P>
<Link>A.2 Multicast Destination ID....................................................................................... 37 
</Link>
</P>

<P>
<Link>A.3 End Point Multicast Channels............................................................................... 37 
</Link>
</P>

<P>
<Link>Annex B   Multicast Applications (Informative) </Link>
</P>

<P>
<Link>B.1 Introduction........................................................................................................... 39 
</Link>
</P>

<P>
<Link>B.2 Example 1 - Static Multicast Masks ..................................................................... 40 
</Link>
</P>

<P>B.3 
<Link>Example 2 - Linking Multicast Masks to Destination IDs ................................... 47 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>
<Link>2-1 Multicast System Example .............................................................................................12 
</Link>

<Link>2-2 Multicast Association Example ......................................................................................13 
</Link>

<Link>2-3 Multicast Configuration Example...................................................................................14 
</Link>

<Link>4-1 Example System using Multicast....................................................................................39 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>
<Link>3-1 Multicast Register Map...................................................................................................17 
</Link>

<Link>3-2 Bit Settings for Processing Elements Features CAR ......................................................18 
</Link>

<Link>3-3 Bit Settings for Switch Multicast Support CAR .............................................................19 
</Link>

<Link>3-4 Bit Settings for Switch Multicast Information CAR ......................................................20 
</Link>

<Link>3-5 Bit Settings for Multicast Mask Port CSR ......................................................................21 
</Link>

<Link>3-6 Bit Settings for Multicast Associate Select CSR ............................................................22 
</Link>

<Link>3-7 Bit Settings for Multicast Associate Operation CSR ......................................................23 
</Link>

<Link>4-1 Multicast Masks for Switch A1 ......................................................................................40 
</Link>

<Link>4-2 Multicast Masks for Switch B1 ......................................................................................41 
</Link>

<Link>4-3 Multicast Masks for Switch B2 ......................................................................................43 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Tables </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31160">Chapter 1 Overview </P>

<P id="LinkTarget_31161">1.1 Introduction </P>

<P>This chapter provides an overview of the RapidIO Part 11: Multicast Extensions Specification. The goal of this specification is to add a simple mechanism to the existing RapidIO specifications that provides multicast functionality to a system. This specification assumes that the reader has a working understanding of the other RapidIO specifications. </P>

<P id="LinkTarget_31162">1.1 Overview </P>

<P>The concept of duplicating a single message and sending it to multiple selected destinations is known as ‘multicast’, and is found to be useful in many computing systems. This can be accomplished by a variety of means. The most efficient and highest performance method is to have hardware support for the duplication of messages. </P>

<P>Within a RapidIO system, the ability to duplicate messages should scale with the number of end points in a system. Since the number of end points scales with the number of switches in the system, the multicast extensions are defined for switches only and end points are largely unaffected. Possible end point design considerations are described in 
<Link>Annex A. </Link>
</P>

<P>The multicast specification is limited to request transactions that do not require responses, for example, RapidIO Part 1: Input/Output Logical Specification SWRITE transactions. This is because implementing support for collecting the response transactions within a switch device, which are typically not aware of RapidIO logical layer protocols, is problematic and complex. </P>

<P>The ability for a switch to send a single message to a variety of destinations can be implemented in a wide variety of ways, depending on system needs. There are two reasons, however, that motivate definition of a common interface and behavior for multicast in a system. Without a standard interface and behavioral definition, the wide variety of possible implementations would not allow a common multicast software driver to exist. The second reason is that without a standard definition for interface and behavior it is impossible to guarantee inter-operability of different components which support multicast. </P>

<P>In defining a common interface for a wide variety of implementations, it is necessary </P>

<P>RapidIO Trade Association </P>

<P>to define the standard interface with some level of abstraction in order to avoid limiting implementation flexibility. Therefore, several examples of the use of the interface have been included. </P>

<P id="LinkTarget_31163">1.2 Requirements </P>

<P>The multicast mechanism shall fulfill the following goals: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Simple - excess complexity will not gain acceptance </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Compact - Does not cost excessive silicon area in a switch </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Robust - same level of protection and recovery as the rest of RapidIO </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Scalable - must be able to extend to multi-layer switch systems </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Compatibility with all physical layers </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31164">Chapter 2 Multicast Extensions Behavior </P>

<P id="LinkTarget_31165">2.1 Introduction </P>

<P>This chapter describes the multicast extensions rules of operation in a RapidIO system. A RapidIO switch which does not support multicast can co-exist in a RapidIO fabric with other switches that do support multicast. The only requirement is that the switch be capable of routing the destination IDs used for multicast transactions. </P>

<P id="LinkTarget_31166">2.2 Packet Replication </P>

<P>A RapidIO multicast operation consists of the replication of a single packet so that it can be received by multiple end points. This replication is performed by the switch devices in the fabric rather than by the end point itself, so that the capability to replicate packets expands with the number of switches (and hence possible end points) in a system. Each switch may be individually programmed to control which egress ports of the switch the replicated packets are sent to, and thus indirectly which specific set of end point devices receive the replicated packet. The packets themselves are not modified by the replication process, merely transmitted out through the appropriate ports. </P>

<P>This specification only addresses multicasting request packets for transactions which do not require responses. This greatly simplifies multicast support for RapidIO switches, which will therefore have no need to aggregate responses from other types of RapidIO operations. Examples of transactions which can be multicast are I/O logical specification NWRITE and SWRITE transactions. Multicasting transactions which require responses have implementation defined behavior. </P>

<P id="LinkTarget_31167">2.3 Multicast Operation </P>

<P>Multicast operations have two control value types - multicast masks and multicast groups. The set of target end points which all receive a particular multicast packet is known as a multicast group. Each multicast group is associated with a unique destination ID. The destination ID of a received packet allows a RapidIO switch device to determine that a packet is to be replicated for a multicast. </P>

<P>A multicast mask is a value that controls which egress ports one or more multicast groups are associated with. Conceptually, a multicast mask is a register with one </P>

<P>RapidIO Trade Association </P>

<P>enable bit for each possible switch egress port. There is one set of multicast masks for the entire switch. All multicast masks in a switch are assigned unique sequential 
<Link>ID numbers beginning with 0. Figure 2-1 shows an example of the use of multicast </Link>
in a RapidIO system. </P>

<P>End point </P>

<P>End point dest. ID=0x10 </P>

<P>dest. ID=0x15 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_229.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_230.jpg"/>
</Figure>

<P>Switch M </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_231.jpg"/>
</Figure>
Switch N </P>

<P>Port 1 </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_232.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_233.jpg"/>
Port 2 Port 1 Port 0 Port 3 </Figure>
End point </P>

<P>End point </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_234.jpg"/>
</Figure>
Port 0 Port 2 </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_235.jpg"/>
</Figure>
dest. ID=0x16 dest. ID=0x0 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_236.jpg"/>
</Figure>

<P>Port 3 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_237.jpg"/>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_238.jpg"/>
End point dest. ID=0x12 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_239.jpg"/>
End point dest. ID=0x17 </Figure>

<P>Figure 2-1. Multicast System Example </P>

<P>In this example, the end point assigned destination ID 0x0 uses destination ID 0x80 to perform multicast operations to the multicast group comprised of end points 0x10, 0x15, 0x16, and 0x17, arbitrarily called group A. Software configures the switch devices in the fabric to associate the destination IDs that represent multicast groups 
<Link>with multicast masks. For Figure 2-1 switch M associates destination ID 0x80 with </Link>
egress ports 1 and 2, and switch N associates destination ID 0x80 with ports 1, 2, and 3. 
<Link>Figure 2-2 shows a possible relationship between the multicast group, the </Link>
multicast masks for the switches, and the global system address map. </P>

<P>RapidIO Trade Association </P>

<P>Switch M dest. ID look-up table System address map </P>

<P>dest. ID=0x80 Group A </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_240.jpg"/>
Port 1 Port 2 </Figure>

<P>dest. ID=0x10 </P>

<P>dest. ID=0x15-17 </P>

<P>Switch N dest. ID look-up table System address map </P>

<P>Port 1 </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_241.jpg"/>
</Figure>
dest. ID=0x15 Port 2 </P>

<P>dest. ID=0x16 Port 3 </P>

<P>dest. ID=0x17 </P>

<P>Group Adest. ID=0x80 </P>

<P>Figure 2-2. Multicast Association Example </P>

<P>Configuring a RapidIO switch to replicate packets for a multicast group is a two-step process. First, a list of egress ports is set in a multicast mask list. Second, one or more destination IDs which represent the multicast groups are associated with the multicast mask in the switch. During normal system operation, any time a switch receives a packet with a destination ID which has been associated with a multicast mask it will send that packet to all egress ports enabled by that multicast mask. </P>

<P>RapidIO Trade Association </P>

<P>Multicast Group </P>

<P>Control Unit Port 0 </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_242.jpg"/>
Switch dest. ID=0x80 Destination A, Port 1 Destination B, Port 2 Destination C, Port 3 Destination D, Port 4 
<Caption>
<P>Multicast Mask 2 Port 0 excluded Port 1,2,3,4 included </P>
</Caption>
</Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_243.jpg"/>
</Figure>

<P>Associated to dest. ID 0x80 </P>

<P>Figure 2-3. Multicast Configuration Example </P>

<P>
<Link>Figure 2-3 shows a control unit connected to switch port 0 which needs to multicast </Link>
to destinations A, B, C and D. A multicast mask, in this case arbitrarily picked as multicast mask 2, is set up to select which ports in the switch are part of the multicast group of destinations A, B, C, and D. A destination ID, in this case arbitrarily assigned 0x80, is associated with multicast mask 2 as the destination ID that the control unit should use to multicast to the multicast group. The associate operation is done using the CSRs defined in 
<Link>Chapter 3, “Multicast Extensions Registers”. </Link>
</P>

<P>The defined CSRs allow a switch to associate destination IDs with multicast masks using a small number of maintenance write operations. The number of unique destination IDs that can be associated with a multicast mask is also defined in a CSR. </P>

<P>While each destination ID is associated with a unique multicast group, the programming model allows a destination ID to be mapped to a different multicast mask for each port on the switch. However, for each port a destination ID can be associated with at most one multicast mask. The last association operation performed for a specific port and destination ID dictates which multicast mask the destination ID is associated with. It is also possible to map a given destination ID to the same multicast mask for all ports. </P>

<P>A RapidIO switch may be capable of supporting large numbers of multicast groups by dedicating a sequential range of destination ID’s to an equal number of sequentially numbered multicast masks. A switch may also be designed which does not require all multicast destination IDs to be sequential. The programming model supports both of these implementations. </P>

<P>A packet will never be multicast back out of the port it was received on even if it is included in the multicast mask for that destination ID. This allows a group of end points which need to multicast to each other to share the same multicast mask. Packets using a multicast mask which has no egress ports selected will be dropped without error notification. A device may have implementation specific error notification in this situation, depending on system requirements. </P>

<P>RapidIO Trade Association </P>

<P>The default state after a reset for multicast masks is that all multicast masks have no ports selected. Additionally, after reset no associations exist between any multicast group/destination ID and the multicast masks. However, implementation specific capabilities may modify the multicast mask values and associations after reset without software intervention. </P>

<P>For more information and examples on the use of the programming model for multicast refer to 
<Link>Annex B, “Multicast Applications (Informative)”. </Link>
</P>

<P id="LinkTarget_31168">2.4 Multicast Transaction Ordering Requirements </P>

<P>RapidIO packets which are in the same multicast group (the same destination ID) with the same flowID and are received on the same ingress port must be multicast on the egress ports in the same order that they were received. There are no ordering requirements between multicast packets and non-multicast packets, or between multicast packets in different multicast groups. Maintaining ordering between transactions in the same transaction request flow for a multicast group allows an application to multicast a completion flag at the end of a potentially large data transfer which was sent to the same multicast group. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31169">Chapter 3 Multicast Extensions Registers </P>

<P id="LinkTarget_31170">3.1 Introduction </P>

<P>This section describes the Multicast Extensions CAR and CSR registers that allow an external processing element to determine if a switch supports the multicast extensions defined in this specification, and to manage the configuration of multicast groups for a switch processing element. This chapter only describes registers or register bits defined by this specification. Refer to the other RapidIO logical, transport, physical, and extension specifications of interest to determine a complete list of registers and bit definitions for a device. All registers are 32-bits and aligned to a 32-bit boundary. The behavior of reserved register bits and register offsets and access rules and requirements are described in the RapidIO Part 1: Input/Output Logical Specification. </P>

<Table>
<Caption>
<P>Table 3-1. Multicast Register Map </P>
</Caption>

<TR>
<TD>Configuration Space Byte Offset </TD>

<TD>Register Name </TD>
</TR>

<TR>
<TD>0x0-C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x10 </TD>

<TD>Processing Element Features CAR </TD>
</TR>

<TR>
<TD>0x14-2C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x30 </TD>

<TD>Switch Multicast Support CAR </TD>
</TR>

<TR>
<TD>0x34 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x38 </TD>

<TD>Switch Multicast Information CAR </TD>
</TR>

<TR>
<TD>0x3C-7C </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x80 </TD>

<TD>Multicast Mask Port CSR </TD>
</TR>

<TR>
<TD>0x84 </TD>

<TD>Multicast Associate Select CSR </TD>
</TR>

<TR>
<TD>0x88 </TD>

<TD>Multicast Associate Operation CSR </TD>
</TR>

<TR>
<TD>0x8C–FC </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>0x100– FFFC </TD>

<TD>Extended Features Space </TD>
</TR>

<TR>
<TD>0x10000– FFFFFC </TD>

<TD>Implementation-defined Space </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31171">3.2 	Processing Elements Features CAR 
(Configuration Space Offset 0x10) 
</P>

<P>The Processing Elements Features CAR contains 31 processing elements features bits defined in various RapidIO specifications, as well as the Multicast Support bit, defined here. </P>

<Table>
<Caption>
<P>Table 3-2. Bit Settings for Processing Elements Features CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-20 </TD>

<TD>-</TD>

<TD/>

<TD>Reserved (defined elsewhere) </TD>
</TR>

<TR>
<TD>21 </TD>

<TD>Multicast Support </TD>

<TD>* </TD>

<TD>Support for multicast extensions 0b0 - Does not support multicast extensions 0b1 - Supports multicast extensions </TD>
</TR>

<TR>
<TD>22-31 </TD>

<TD>-</TD>

<TD/>

<TD>Reserved (defined elsewhere) </TD>
</TR>
</Table>

<P>* Implementation dependant </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31172">3.3 	Switch Multicast Support CAR (Configuration Space Offset 0x30) </P>

<P>The Switch Multicast Support CAR defines support for a simple multicast model and the additional limits on multicast mask resources. </P>

<Table>
<Caption>
<P>Table 3-3. Bit Settings for Switch Multicast Support CAR </P>
</Caption>

<TR>
<TH>Bit </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Simple_Assoc </TD>

<TD>* </TD>

<TD>Support for a simple multicast association model 0b0 - Does not support simple association 0b1 - Supports simple association If this bit is set, the Block_Assoc bit in the Switch Multicast Information CAR must also be set. </TD>
</TR>

<TR>
<TD>1-31 </TD>

<TD>-</TD>

<TD/>

<TD>Reserved (defined elsewhere) </TD>
</TR>
</Table>

<P>* Implementation dependant </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31173">3.4 	Switch Multicast Information CAR 
(Configuration Space Offset 0x38) 
</P>

<P>The Switch Multicast Information CAR defines the methods for associating destination IDs with multicast masks supported by a RapidIO switch device. It also defines the limits on multicast mask resources. </P>

<Table>
<Caption>
<P>Table 3-4. Bit Settings for Switch Multicast Information CAR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>Block_Assoc </TD>

<TD>Block association support - allows equal sized blocks of destination IDs and multicast masks to be associated with each other with a single operation rather than one at a time. 0b0 - block association is not supported 0b1 - block association is supported If the Simple_Assoc bit in the Switch Multicast Support CAR is set, this bit must also be set. </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Per_Port_Assoc </TD>

<TD>Per ingress port association support - allows a destination ID to be associated with a multicast mask on a per-ingress port basis rather than a single association for the entire switch. 0b0 - per port association is not supported 0b1 - per port association is supported </TD>
</TR>

<TR>
<TD>2-15 </TD>

<TD>MaxDestIDAssoc </TD>

<TD>The maximum number of destination IDs associations per multicast mask 0x0000 - 1 destination ID 0x0001 - 2 destination IDs ... 0x3FFF - 16384 destination IDs </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>MaxMcastMasks </TD>

<TD>The number of multicast egress port masks available. This field also defines the largest block of destination IDs that can be block associated. 0x0000 - [reserved] 0x0001 - 1 multicast mask 0x0002 - 2 multicast masks ... 0xFFFF - 65535 multicast masks </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31174">3.5 	Multicast Mask Port CSR (Configuration Space Offset 0x80) </P>

<P>The Multicast Mask Port CSR allows configuration of the egress port list for each of the switch’s multicast masks. </P>

<P>Writing the Write_to_Verify command sets up a Mcast_Mask and Egress_Port_Num pair to verify. The presence of the specified egress port in the specified multicast mask is indicated by the Port_Present bit on a subsequent read of the register. </P>

<P>Writing the Add_Port or Delete_Port commands adds or deletes the specified egress port to or from the specified multicast mask. </P>

<P>Writing the Add_All_Ports or Delete_All_Ports commands adds or deletes all of the egress ports in the specified multicast mask. </P>

<P>The result of illegal values or combinations for an operation is implementation dependent. For examples of how to use this register, refer to 
<Link>Section 4.2, </Link>

<Link>“Configuring Multicast Masks”. </Link>
</P>

<Table>
<Caption>
<P>Table 3-5. Bit Settings for Multicast Mask Port CSR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-15 </TD>

<TD>Mcast_Mask </TD>

<TD>0x0000 </TD>

<TD>Specifies the multicast mask which is to be modified or queried as determined by the Mask_Cmd field. </TD>
</TR>

<TR>
<TD>16-23 </TD>

<TD>Egress_Port_Num </TD>

<TD>0x00 </TD>

<TD>Specifies the port number to be added, deleted, or queried with the Mask_Cmd field. </TD>
</TR>

<TR>
<TD>24 </TD>

<TD>-</TD>

<TD>0b0 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>25-27 </TD>

<TD>Mask_Cmd </TD>

<TD>0b000 </TD>

<TD>Specifies the mask action on a write. 0b000 - Write_to_Verify 0b001 - Add_Port 0b010 - Delete_Port 0b011 - reserved 0b100 - Delete_All_Ports 0b101 - Add_All_Ports 0b110 - reserved 0b111 - reserved </TD>
</TR>

<TR>
<TD>28–30 </TD>

<TD>-</TD>

<TD>0b000 </TD>

<TD>Reserved </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Port_Present </TD>

<TD>0b0 </TD>

<TD>Indicates the existence of the egress port and multicast mask pair as a result of the last preceding Write_to_Verify command. 0b0 - Port was not enabled as an egress port in the specified multicast mask 0b1 - Port was enabled as an egress port in the specified multicast mask. This bit is reserved on a write. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31175">3.6 	Multicast Associate Select CSR 
(Configuration Space Offset 0x84) 
</P>

<P>This register specifies the destination ID and multicast mask number for a subsequent associate operation controlled with the Multicast Associate Operation CSR. If block association is supported, this register specifies the start of the block to 
<Link>associate. For examples of how this register is used, refer to Section 4.4, </Link>

<Link>“Configuring Associations”. </Link>
</P>

<Table>
<Caption>
<P>Table 3-6. Bit Settings for Multicast Associate Select CSR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-7 </TD>

<TD>Large_DestID </TD>

<TD>0x00 </TD>

<TD>Selects the most significant byte of a large transport destination ID for an association operation </TD>
</TR>

<TR>
<TD>8-15 </TD>

<TD>DestID </TD>

<TD>0x00 </TD>

<TD>Selects the destination ID for an association operation </TD>
</TR>

<TR>
<TD>16-31 </TD>

<TD>Mcast_Mask_Num </TD>

<TD>0x0000 </TD>

<TD>Selects the multicast mask number for an association operation </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31176">3.7 	Multicast Associate Operation CSR (Configuration Space Offset 0x88) </P>

<P>The Multicast Associate Operation CSR specifies three operations for associating destination IDs with multicast masks. The affected destination ID and multicast mask is specified in the Multicast Associate Select CSR. The specified operation is executed when this register is written. When this register is read and the Assoc_Cmd field it set to Write_to_Verify the specified operation is executed and the updated register state is returned. If this register is read and the Assoc_Cmd field is not set to Write_to_Verify the resulting behavior is implementation dependent. Block association operations assign associations sequentially starting with the destination ID and multicast mask specified in the Multicast Associate Select CSR. </P>

<P>Writing the Write_To_Verify command checks for an association between the destination ID and multicast mask specified in the Multicast Associate Select CSR. The result of the check is indicated by the state of the Assoc_Present bit on a read of this register. This command cannot be executed on a block. </P>

<P>Writing the Add_Assoc or Delete_Assoc command adds or deletes the association between the destination ID and the multicast mask (or block of associations, if block association is supported) specified in the Multicast Associate Select CSR. </P>

<P>The result of illegal values or field combinations for an association operation is implementation dependent. For examples of how this register is used, refer to 
<Link>Section 4.4, “Configuring Associations. </Link>
</P>

<Table>
<Caption>
<P>Table 3-7. Bit Settings for Multicast Associate Operation CSR </P>
</Caption>

<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0-15 </TD>

<TD>Assoc_Blksize </TD>

<TD>0x0000 </TD>

<TD>This field specifies the number of sequential DestinationIDs to be associated with an equal number of sequential multicast mask numbers if block association is supported. This field is ignored on a Write_to_Verify command. 0x0000 - one association 0x0001 - two sequential associations ... 0xFFFF - 65536 sequential associations </TD>
</TR>

<TR>
<TD>16-23 </TD>

<TD>Ingress_Port </TD>

<TD>0x00 </TD>

<TD>This field specifies the ingress port association to affect if per-port ingress association is supported </TD>
</TR>

<TR>
<TD>24 </TD>

<TD>Large_Transport </TD>

<TD>0b0 </TD>

<TD>0b0 - the association is for small transport destination IDs 0b1 - the association is for large transport destination IDs </TD>
</TR>

<TR>
<TD>25-26 </TD>

<TD>Assoc_Cmd </TD>

<TD>0b00 </TD>

<TD>This field specifies the command to execute when this register is written. 0b00 - Write_To_Verify 0b01 - reserved 0b10 - Delete_Assoc 0b11 - Add_Assoc </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Bits </TH>

<TH>Name </TH>

<TH>Reset Value </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>27-30 </TD>

<TD>-</TD>

<TD>0b0000 </TD>

<TD>reserved </TD>
</TR>

<TR>
<TD>31 </TD>

<TD>Assoc_Present </TD>

<TD>0b0 </TD>

<TD>This bit contains the result of the last Write_to_Verify command executed. 0b0 - no association present 0b1 - association present This bit is reserved on write. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31177">Chapter 4 Configuration Examples </P>

<P id="LinkTarget_31178">4.1 Introduction </P>

<P>This chapter provides several examples of how to use the multicast programming interface. The given examples build upon each other while proceeding through the sections. References to the order of operations within the examples run from the top of a list to the bottom unless otherwise stated. </P>

<P>Initially assume a switch with 8 ports which supports 4 or more multicast masks with two or more destination IDs allowed per multicast group so that a total of 8 destination IDs minimum can be associated with the multicast masks. The system has the following requirements: </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Three sources of traffic (ports 0, 1, and 2) must be multicast to two destinations (ports 6 and 7). </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Three ports (ports 3, 4 and 5) need to multicast signals between each other. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> All ports occasionally need to multicast to every other port. </LI_Title>
</LI>
</L>

<P>Assume that the switch does not require any other multicast functions and therefore multicast masks 0, 1, and 2 will be used. </P>

<P id="LinkTarget_31179">4.2 Configuring Multicast Masks </P>

<P>This section discusses assigning an egress port list to a multicast mask. </P>

<P id="LinkTarget_31180">4.2.1 Clearing Multicast Masks </P>

<P>Suppose that the state of the multicast masks is unknown, and therefore the masks must be cleared before being configured. In order to clear the masks the following register accesses are made. (The accesses to the Multicast Mask Port CSR can be performed in any order.) </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Remove all ports from multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0x0000_0040 to the Multicast Mask Port CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Remove all ports from multicast mask 1 </LI_Title>
</LI>

<LI>— Write the value 0x0001_0040 to the Multicast Mask Port CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Remove all ports from multicast mask 2 </LI_Title>
</LI>
</L>

<P>— Write the value 0x0002_0040 to the Multicast Mask Port CSR </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31181">4.2.2 Assigning Ports to Multicast Masks </P>

<P>To configure mask 0 to multicast to ports 6 and 7, mask 1 to multicast to ports 3, 4 and 5, and mask 2 to multicast to every port, requires the following series of register accesses. (The accesses to the Multicast Mask Port CSR can be performed in any order.) </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Add port 6 to multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0x0000_0610 to the Multicast Mask Port CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Add port 7 to multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0x0000_0710 to the Multicast Mask Port CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Add port 3 to multicast mask 1 </LI_Title>
</LI>

<LI>— Write the value 0x0001_0310 to the Multicast Mask Port CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Add port 4 to multicast mask 1 </LI_Title>
</LI>

<LI>— Write the value 0x0001_0410 to the Multicast Mask Port CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Add port 5 to multicast mask 1 </LI_Title>
</LI>

<LI>— Write the value 0x0001_0510 to the Multicast Mask Port CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Add all ports to multicast mask 2 </LI_Title>
</LI>
</L>

<P>— Write the value 0x0002_0050 to the Multicast Mask Port CSR </P>

<P id="LinkTarget_31182">4.2.3 Removing a Port from a Multicast Mask </P>

<P>Suppose that the device attached to port 4 needs to be removed from the system. The following register accesses are used to modify multicast masks 1 and 2 to stop port 4 from being a multicast destination. (The accesses may be performed in any order.) </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Remove port 4 from multicast mask 1 </LI_Title>
</LI>

<LI>— Write the value 0x0001_0420 to the Multicast Mask Port CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Remove port 4 from multicast mask 2 </LI_Title>
</LI>
</L>

<P>— Write the value 0x0002_0420 to the Multicast Mask Port CSR </P>

<P id="LinkTarget_31183">4.2.4 Querying a Multicast Mask </P>

<P>In this section suppose that a system designer needs to determine which of the 8 ports are included in multicast mask 2. The following accesses are to be performed to provide this information. (In each case, the write operation setting up the ‘Write to Verify’ operation must be performed before the subsequent read to check the Port Present bit status. The individual multicast masks may be queried in any order.) </P>

<P>• Verify that port 0 is included in mask 2 </P>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0002_0000 to the Multicast Mask Port CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0002_0001 from the Multicast Mask Port CSR </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that port 1 is included in mask 2 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0002_0100 to the Multicast Mask Port CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0002_0101 from the Multicast Mask Port CSR. </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that port 2 is included in mask 2 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0002_0200 to the Multicast Mask Port CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0002_0201 from the Multicast Mask Port CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that port 3 is included in mask 2 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0002_0300 to the Multicast Mask Port CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0002_0301 from the Multicast Mask Port CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that port 4 is not included in mask 2 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0002_0400 to the Multicast Mask Port CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0002_0400 from the Multicast Mask Port CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that port 5 is included in mask 2 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0002_0500 to the Multicast Mask Port CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0002_0501 from the Multicast Mask Port CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that port 6 is included in mask 2 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0002_0600 to the Multicast Mask Port CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0002_0601 from the Multicast Mask Port CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that port 7 is included in mask 2 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0002_0700 to the Multicast Mask Port CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0002_0701 from the Multicast Mask Port CSR </LI_Title>
</LI>
</L>
</L>
</L>

<P id="LinkTarget_31184">4.3 Simple Association </P>

<P>If the Simple_Assoc bit is set in the Switch Multicast Support CAR, the device supports the simple multicast programming model. This model allows for basic multicast support for devices with a limited number of multicast masks, and requires a fixed relationship between those masks and sequential multicast groups. </P>

<P id="LinkTarget_31185">4.3.1 Restrictions on Block Size </P>

<P>If the Simple_Assoc bit is set the device has a limited number of masks. Therefore, the number of sequential associations equals the maximum number of masks. </P>

<P>The Assoc_BlkSize field in the Multicast Associate Operation CSR must be set to the value of (MaxMCastMasks - 1). The MaxMCastMasks field is in the Switch Multicast Information CAR. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31186">4.3.2 Restrictions on Block Associate </P>

<P>If the Simple_Assoc bit is set, non-block associations are precluded. </P>

<P id="LinkTarget_31187">4.3.3 Restrictions on Associations </P>

<P>If the Simple_Assoc bit is set the device requires a fixed relationship between the sequential mask numbers and sequential destination IDs. This must be taken into account when the masks are associated. </P>

<P>The Multicast Associate Select CSR is set with the Mcast_Mask_num value set to 0x0000 and the Large_DestID and DestID fields set to an integer multiple of the MaxMCastMasks value. </P>

<P>Hardware that sets the new Simple_Assoc CAR bit could implement a single block associate for all of the masks that it supports with the requirement that they all be sequential destination IDs. </P>

<P id="LinkTarget_31188">4.4 Configuring Associations </P>

<P>This section describes how to associate destination IDs with multicast masks, including examples of how to use the block association and per-port association functions. </P>

<P id="LinkTarget_31189">4.4.1 Basic Association </P>

<P>For the assumed system it is now necessary to associate a destination ID with each multicast mask from the preceding examples. How this can be accomplished may vary depending on the capabilities of the switch. For this section, assume that neither block association nor per-ingress-port association is supported by the switch. </P>

<P>Following upon the previous example, assume the following additional system requirements. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> the 16 bit destination ID 0x1234 needs to be associated with multicast mask 0. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> the 8 bit destination ID 0x44 needs to be associated with multicast mask 1. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>the 16 bit destination ID 0xFEED needs to be associated with multicast mask 2. </LI_Title>
</LI>
</L>

<P>In order to accomplished the desired associations, the following register accesses are required. (The individual association operations can be performed in any order.) </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Set up the operation to associate destination ID 0x1234 with multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0x1234_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0x1234 with multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0x0000_00E0 to the Multicast Associate Operation CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Set up the operation to associate destination ID 0x44 with multicast mask 1 </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P>— Write the value 0x0044_0001 to the Multicast Associate Select CSR </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0x44 with multicast mask 1 </LI_Title>
</LI>

<LI>— Write the value 0x0000_0060 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the operation to associate destination ID 0xFEED with multicast mask 2 </LI_Title>
</LI>

<LI>— Write the value 0xFEED_0002 to the Multicast Associate Select CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0xFEED with multicast mask 2 </LI_Title>
</LI>
</L>

<P>— Write the value 0x0000_00E0 to the Multicast Associate Operation CSR </P>

<P id="LinkTarget_31190">4.4.2 Using Per-Ingress Port Association </P>

<P>For the associations discussed in the preceding section, if the switch supports per-ingress-port association (destination IDs are associated with multicast masks on a per ingress port basis), the required programming operations change. The associations for each multicast mask are grouped into a write to the Multicast Associate Select CSR, followed by a write to the Multicast Associate Operation CSR for each ingress port that must be aware of the association. (The writes to the Multicast Associate Operation CSR can occur in any order but must occur after the related writes to the Multicast Associate Select CSR. The individual association operations can be performed in any order.) </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Set up the operation to associate destination ID 0x1234 with multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0x1234_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0x1234 with multicast mask 0 on ingress port 0 </LI_Title>
</LI>

<LI>— Write the value 0x0000_00E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0x1234 with multicast mask 0 on ingress port 1 </LI_Title>
</LI>

<LI>— Write the value 0x0000_01E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0x1234 with multicast mask 0 on ingress port 2 </LI_Title>
</LI>

<LI>— Write the value 0x0000_02E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Set up the operation to associate destination ID 0x44 with multicast mask 1 </LI_Title>
</LI>

<LI>— Write the value 0x0044_0001 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0x44 with multicast mask 1 on ingress port 3 </LI_Title>
</LI>

<LI>— Write the value 0x0000_0360 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0x44 with multicast mask 1 on ingress port 4 </LI_Title>
</LI>

<LI>— Write the value 0x0000_0460 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0x44 with multicast mask 1 on ingress port 5 </LI_Title>
</LI>

<LI>— Write the value 0x0000_0560 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the operation to associate destination ID 0xFEED with multicast mask 2 </LI_Title>
</LI>

<LI>— Write the value 0xFEED_0002 to the Multicast Associate Select CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0xFEED with multicast mask 2 on ingress port 0 </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P>— Write the value 0x0000_00E0 to the Multicast Associate Operation CSR </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0xFEED with multicast mask 2 on ingress port 1 </LI_Title>
</LI>

<LI>— Write the value 0x0000_01E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0xFEED with multicast mask 2 on ingress port 2 </LI_Title>
</LI>

<LI>— Write the value 0x0000_02E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0xFEED with multicast mask 2 on ingress port 3 </LI_Title>
</LI>

<LI>— Write the value 0x0000_03E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0xFEED with multicast mask 2 on ingress port 4 </LI_Title>
</LI>

<LI>— Write the value 0x0000_04E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0xFEED with multicast mask 2 on ingress port 5 </LI_Title>
</LI>

<LI>— Write the value 0x0000_05E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0xFEED with multicast mask 2 on ingress port 6 </LI_Title>
</LI>

<LI>— Write the value 0x0000_06E0 to the Multicast Associate Operation CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate destination ID 0xFEED with multicast mask 2 on ingress port 7 </LI_Title>
</LI>
</L>

<P>— Write the value 0x0000_07E0 to the Multicast Associate Operation CSR </P>

<P id="LinkTarget_31191">4.4.3 Using Block Association </P>

<P>In this section assume that the switch supports block association rather than per-ingress-port association. With this feature sequential destination IDs can be quickly associated to sequential multicast masks. In order to take advantage of this feature, different destination IDs assignments are required for the system than for the preceding examples. The starting destination 0xFF00 is arbitrarily selected. </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> the 16 bit destination ID 0xFF00 is used to multicast from ports 0, 1 and 2 to ports 6 and 7, so destination ID 0xFF00 needs to be associated with multicast mask 0. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>the 16 bit destination ID 0xFF01 identifies the multicast group including ports 3, 4 and 5, so destination ID 0xFF01 needs to be associated with multicast mask 1. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>the 16 bit destination ID 0xFF02 identifies the multicast group that includes all ports, so destination ID 0xFF02 needs to be associated with multicast mask 2. </LI_Title>
</LI>
</L>

<P>Note that the number of accesses needed to accomplish the desired associations is reduced to two. (The accesses must be performed in the order given.) </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Set up the associate operation starting with destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF00_0000 to the Multicast Associate Select CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs starting at 0xFF00 with three sequential multicast masks starting at 0 </LI_Title>
</LI>
</L>

<P>— Write the value 0x0002_00E0 to the Multicast Associate Operation CSR </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31192">4.4.4 Using Per-Ingress Port and Block Association </P>

<P>Next, if both block association and per-ingress port association are supported by the switch, then the following sequence of operations is required. (The write to the Multicast Associate Select CSR must occur before the corresponding write to the Multicast Associate Operation CSR. The individual association operations can be performed in any order.) </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Set up the associate operations starting with destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF00_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs with three sequential multicast masks for ingress port 0 </LI_Title>
</LI>

<LI>— Write the value 0x0002_00E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs with three sequential multicast masks for ingress port 1 </LI_Title>
</LI>

<LI>— Write the value 0x0002_01E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs with three sequential multicast masks for ingress port 2 </LI_Title>
</LI>

<LI>— Write the value 0x0002_02E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs with three sequential multicast masks for ingress port 3 </LI_Title>
</LI>

<LI>— Write the value 0x0002_03E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs with three sequential multicast masks for ingress port 4 </LI_Title>
</LI>

<LI>— Write the value 0x0002_04E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs with three sequential multicast masks for ingress port 5 </LI_Title>
</LI>

<LI>— Write the value 0x0002_05E0 to the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs with three sequential multicast masks for ingress port 6 </LI_Title>
</LI>

<LI>— Write the value 0x0002_06E0 to the Multicast Associate Operation CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs with three sequential multicast masks for ingress port 7 </LI_Title>
</LI>
</L>

<P>— Write the value 0x0002_07E0 to the Multicast Associate Operation CSR </P>

<P>For this example, suppose that ingress port 4 needs a second destination ID to be mapped to each of the three multicast masks and the switch also has this capability. The second destination would be added to port 4 with the following association operation. (The write to the Multicast Associate Select CSR must occur before the write to the Multicast Associate Operation CSR. </P>

<P>RapidIO Trade Association </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Set up the associate operations starting with destination ID 0xFF03 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF03_0000 to the Multicast Associate Select CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Associate three sequential destination IDs with three sequential multicast masks for ingress port 4 </LI_Title>
</LI>
</L>

<P>— Write the value 0x0002_04E0 to the Multicast Associate Operation CSR </P>

<P id="LinkTarget_31193">4.4.5 Removing a Destination ID to Multicast Mask Association </P>

<P>Now assume that packets from destination ID 0xFF02 on port 4 should no longer be allowed to multicast to all nodes (multicast mask 2). To remove destination ID 0xFF02 from being associated with multicast mask 2 on port 4, the following register accesses need to be performed in order. </P>

<L>
<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the operation to remove the association between destination ID 0xFF02 and multicast mask 2 </LI_Title>
</LI>

<LI>— Write the value 0xFF02_0002 to the Multicast Associate Select CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Remove the association between destination ID 0xFF02 and multicast mask 2 on ingress port 4 </LI_Title>
</LI>
</L>

<P>— Write the value 0x0000_04C0 to the Multicast Associate Operation CSR </P>

<P id="LinkTarget_31194">4.4.6 Querying an Association </P>

<P>There are three scenarios for querying destination ID to multicast mask associations in a switch. For the first scenario assume that a system designer wants to know which multicast masks are associated with destination ID 0xFF01 on port 4. Note that since a read of the Multicast Associate Operation CSR causes the last command written to be executed, that register is only written at the beginning of the sequence. (The individual associations can be queried in any order.) </P>

<L>
<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF01 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF01_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF01 is not associated with multicast mask 0 for port 4 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0480 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0480 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF01 and multicast mask 1 </LI_Title>
</LI>

<LI>— Write the value 0xFF01_0001 to the Multicast Associate Select CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF01 is not associated with multicast mask 1 for port 4 </LI_Title>
</LI>
</L>

<P>— Read the value 0x0000_0480 from the Multicast Associate Operation CSR </P>

<P>RapidIO Trade Association </P>

<L>
<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF01 and multicast mask 2 </LI_Title>
</LI>

<LI>— Write the value 0xFF01_0002 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Verify that destination ID 0xFF01 is associated with multicast mask 2 for port 4 </LI_Title>
</LI>

<LI>— Read the value 0x0000_0481 from the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF01 and multicast mask 3 </LI_Title>
</LI>

<LI>— Write the value 0xFF01_0003 to the Multicast Associate Select CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF01 is not associated with multicast mask 3 for port 4 </LI_Title>
</LI>
</L>

<P>— Read the value 0x0000_0480 from the Multicast Associate Operation CSR </P>

<P>For the second scenario assume that the system designer wants to know which destination IDs from 0xFF00 through 0xFF07 are associated with multicast mask 0 on Port 4. (The individual associations may be queried in any order.) </P>

<L>
<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF00_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Verify that destination ID 0xFF00 is associated with multicast mask 0 for port 4 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0480 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0480 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF01_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF01 is not associated with multicast mask 0 for port 4 </LI_Title>
</LI>

<LI>— Read the value 0x0000_0480 from the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF02_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF02 is not associated with multicast mask 0 for port 4 </LI_Title>
</LI>

<LI>— Read the value 0x0000_0480 from the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF03_0000 to the Multicast Associate Select CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF03 is not associated with multicast mask 0 for port 4 </LI_Title>
</LI>
</L>

<P>— Read the value 0x0000_0480 from the Multicast Associate Operation CSR </P>

<P>RapidIO Trade Association </P>

<L>
<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF04_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF04 is not associated with multicast mask 0 for port 4 </LI_Title>
</LI>

<LI>— Read the value 0x0000_0480 from the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF05_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Verify that destination ID 0xFF05 is associated with multicast mask 0 for port 4 </LI_Title>
</LI>

<LI>— Read the value 0x0000_0481 from the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF06_0000 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF06 is not associated with multicast mask 0 for port 4 </LI_Title>
</LI>

<LI>— Read the value 0x0000_0480 from the Multicast Associate Operation CSR </LI>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF00 and multicast mask 0 </LI_Title>
</LI>

<LI>— Write the value 0xFF07_0000 to the Multicast Associate Select CSR </LI>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF07 is not associated with multicast mask 0 for port 4 </LI_Title>
</LI>
</L>

<P>— Read the value 0x0000_0480 from the Multicast Associate Operation CSR </P>

<P>For the last scenario assume that the system designer now wants to know whether or not destination ID 0xFF03 is mapped to multicast mask 3 on all ports. (The individual associations may be queried in any order.) </P>

<L>
<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Set up the associate operations for destination ID 0xFF03 and multicast mask 3 </LI_Title>
</LI>

<LI>— Write the value 0xFF03_0003 to the Multicast Associate Select CSR </LI>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF03 is not associated with multicast mask 3 for port 0 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0080 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0080 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF03 is not associated with multicast mask 3 for port 1 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0180 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0180 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>
</L>

<P>RapidIO Trade Association </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF03 is not associated with multicast mask 3 for port 2 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0280 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0280 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>Verify that destination ID 0xFF03 is associated with multicast mask 3 for port 3 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0380 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0381 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF03 is not associated with multicast mask 3 for port 4 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0480 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0480 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF03 is not associated with multicast mask 3 for port 5 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0580 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0580 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF03 is not associated with multicast mask 3 for port 6 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0680 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0680 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Verify that destination ID 0xFF03 is not associated with multicast mask 3 for port 7 </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Write the value 0x0000_0780 to the Multicast Associate Operation CSR </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Read the value 0x0000_0780 from the Multicast Associate Operation CSR </LI_Title>
</LI>
</L>
</L>
</L>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31195">Annex A End Point Considerations (Informative) </P>

<P id="LinkTarget_31196">A.1 Introduction </P>

<P>This appendix provides implementation considerations for end points that are intended to be used in a multicast RapidIO system. </P>

<P id="LinkTarget_31197">A.2 Multicast Destination ID </P>

<P>If an end point does validation of the destination ID of a received packet against it’s own deviceID or IDs, then that end point must be able to disable the comparison or have a deviceID assignment that allows validation of the multicast packet. </P>

<P id="LinkTarget_31198">A.3 End Point Multicast Channels </P>

<P>It may be valuable for an end point to have support for one or more multicast channels. Multicast channels are address ranges in RapidIO address space for which an end point may accept a multicast packet and possibly translate the RapidIO write address to another local address region. This is necessary if the recipient of a multicast transaction does not have valid address space at the address received. The size and quantity of multicast channels depend on the requirements of the application. It may also be necessary to link multicast channels to particular multicast groups. </P>

<P>A multicast channel valid bit can be implemented to control whether an address out-of-range error occurs for a received address which falls inside a multicast channel address range. A multicast channel enable bit can control whether an end point silently ignores the packet when an address is received which falls inside the channel address range. The enable bit allows software finer control over which end points for a particular multicast ID will actually process the multicast write without modifying switch settings in the fabric. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31199">Annex B Multicast Applications (Informative) </P>

<P id="LinkTarget_31200">B.1 Introduction </P>

<P>In a multi-switch RapidIO fabric, each switch which supports multicast in the fabric will have it’s own set of multicast masks. The particular multicast mask in each switch device associated with a multicast group is very likely to have a different egress port pattern enabled, depending upon where that switch is in the switch fabric topology. </P>

<P>As an example, refer to the following system, where data streams entering switch A1 need to be sent to a set of destinations. There are several possible approaches to implementing this system. The first example is based on the number of different multicast groups that must be supported. Destinations are linked to a destination ID which in turn is associated with static multicast mask values. In the second example, a specific multicast mask in each switch is associated with each possible destination. The destinations are linked statically to destination IDs. </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_244.jpg"/>
</Figure>
Port 0 - dest. A <Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_245.jpg"/>
</Figure>
Switch </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_246.jpg"/>
</Figure>
Port 1 - dest. B B1 </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_247.jpg"/>
</Figure>
Port 2 - dest. C </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_248.jpg"/>
</Figure>
Port 3 - dest. D Port 0</P>

<P>Switch 
A1 
</P>

<P>Port 1 </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_249.jpg"/>
</Figure>
Port 0 - dest. E </P>

<P>Switch </P>

<P><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_250.jpg"/>
</Figure>
Port 1 - dest. F </P>

<P>B2 </P>

<L>
<LI><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_251.jpg"/>
</Figure>

<LI_Title>Port 2 - dest. G </LI_Title>
</LI>

<LI><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_252.jpg"/>
</Figure>

<LI_Title>Port 3 - dest. H </LI_Title>
</LI>
</L>

<P>Figure 4-1. Example System using Multicast </P>
</Div>

<Div>
<P>RapidIO Trade Association </P>

<P>39 </P>

<P id="LinkTarget_31201">B.2 Example 1 - Static Multicast Masks </P>

<P>If there are 256 combinations of destinations to receive a data stream, multicast requires 256 multicast groups, associated with 256 destination IDs. This means that an 8 bit destination ID could be used, but then there would be no destination IDs left over for control traffic in the system. As a result, this example assumes that the system needs to use 16 bit destination IDs in order to support multicast. </P>

<P>It is possible to use the least significant 4 bits of the 16 bit destination ID to identify which ports in Switch B1 need to be multicast to, and the next most significant 4 bits for the ports on B2. Arbitrarily selecting the value of 0x04 for the upper byte of the destination ID, then all multicast destination IDs have a format of 0x04XY, where X selects the ports in switch B2 and Y selects the ports in switch B1. </P>

<P>Switch A1 therefore needs two multicast masks as shown in 
<Link>Table 4-1. </Link>
</P>

<Table>
<Caption>
<P>Table 4-1. Multicast Masks for Switch A1 </P>
</Caption>

<TR>
<TH>Multicast Mask Index </TH>

<TH>Egress Ports </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>None </TD>

<TD>Associated with destination ID 0x0400, indicating that no destination is to receive this data stream. Packets multicast with destination ID of 0x0400 are dropped without notification. </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Port 0 and port 1 </TD>

<TD>Associated with destination IDs 0x04XY, where both X and Y is not 0. These represent all destination IDs which need only be multicast to both Switch B1 and switch B2. </TD>
</TR>
</Table>

<P>Destination IDs of the form 0x040Y, where Y is non-zero, or 0x04X0, where X is non zero, do not have to be replicated. They can be routed directly to either port 0 (for 0x040Y) or port 1 (0x04X0) using the standard switch routing tables since there is only a single egress port. </P>

<P>Because Multicast Mask 1 must have 223 ((256 total) - (16 for X) - (16 for Y) - (1 for none)) destination IDs associated with it, the Switch Multicast Information CAR MaxDestIDAssociations field must contain a value of at least 222. In this particular case, the easiest internal implementation for the selection of packets to be multicast may be the use of a non-existent port in the routing table. For example, since Switch A1 has three ports, make use of a non-existent port value in the routing table to signify that the packet is subject to multicast. </P>

<P>Switches B1 and B2 must have 16 multicast masks, each associated with a particular combination of their egress ports 0 through 3. Each multicast mask may have 16 destination IDs associated with it, so the Switch Multicast Information CAR MaxDestIDAssociations field must contain a value of at least 15. </P>

<P>
<Link>Table 4-2 describes which destination IDs must be associated with each multicast </Link>
group for Switches B1. Note that for index 0, if the routing tables in Switch A1 are set up correctly, no packets with those multicast groups should reach switch B1. </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Multicast Mask Index </TH>

<TH>Egress Ports </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>None </TD>

<TD>Associated with the following destination IDs: 0x0400 0x0410 0x0420 ... 0x04E0 0x04F0 </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Port 0 </TD>

<TD>Associated with the following destination IDs: 0x0401 0x0411 0x0421 ... 0x04E1 0x04F1 </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>Port 1 </TD>

<TD>Associated with the following destination IDs: 0x0402 0x0412 0x0422 ... 0x04E2 0x04F2 </TD>
</TR>

<TR>
<TD>3 </TD>

<TD>Ports 1and 0 </TD>

<TD>Associated with the following destination IDs: 0x0403 0x0413 ... 0x04E3 0x04F3 </TD>
</TR>

<TR>
<TD>4 </TD>

<TD>Port 2 </TD>

<TD>Associated with the following destination IDs: 0x0404 0x0414 0x0424 ... 0x04E4 0x04F4 </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>Ports2 and 0 </TD>

<TD>Associated with the following destination IDs: 0x0405 0x0415 0x0425 ... 0x04E5 0x04F5 </TD>
</TR>

<TR>
<TD>6 </TD>

<TD>Ports2 and 1 </TD>

<TD>Associated with the following destination IDs: 0x0406 0x0416 0x0426 ... 0x04E6 0x04F6 </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Multicast Mask Index </TH>

<TH>Egress Ports </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>7 </TD>

<TD>Ports 2, 1 and 0 </TD>

<TD>Associated with the following destination IDs: 0x0407 0x0417 0x0427 ... 0x04E7 0x04F7 </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>Port 3 </TD>

<TD>Associated with the following destination IDs: 0x0408 0x0418 0x0428 ... 0x04E8 0x04F8 </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>Ports 3 and 0 </TD>

<TD>Associated with the following destination IDs: 0x0409 0x0419 0x0429 ... 0x04E9 0x04F9 </TD>
</TR>

<TR>
<TD>10 </TD>

<TD>Ports 3 and 1 </TD>

<TD>Associated with the following destination IDs: 0x040A 0x041A 0x042A ... 0x04EA 0x04FA </TD>
</TR>

<TR>
<TD>11 </TD>

<TD>Ports 3, 1 and 0 </TD>

<TD>Associated with the following destination IDs: 0x040B 0x041B 0x042B ... 0x04EB 0x04FB </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Ports3 and2 </TD>

<TD>Associated with the following destination IDs: 0x040C 0x041C 0x042C ... 0x04EC 0x04FC </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Ports 3, 2 and 0 </TD>

<TD>Associated with the following destination IDs: 0x040D 0x041D 0x042D ... 0x04ED 0x04FD </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Multicast Mask Index </TH>

<TH>Egress Ports </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>14 </TD>

<TD>Ports 3, 2 and 1 </TD>

<TD>Associated with the following destination IDs: 0x040E 0x041E 0x042E ... 0x04EE 0x04FE </TD>
</TR>

<TR>
<TD>15 </TD>

<TD>Ports 3, 2, 1 and 0 </TD>

<TD>Associated with the following destination IDs: 0x040F 0x041F 0x042F ... 0x04EF 0x04FF </TD>
</TR>

<Caption>
<P>
<Link>Table 4-2 describes which destination IDs must be associated with each multicast </Link>
group for Switches B1. Note that for index 0, if the routing tables in Switch A1 are set up correctly, no packets with those multicast groups should reach switch B2. </P>
</Caption>
</Table>

<Table>
<Caption>
<P>Table 4-3. Multicast Masks for Switch B2 </P>
</Caption>

<TR>
<TH>Multicast Mask Index </TH>

<TH>Egress Ports </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>0 </TD>

<TD>None </TD>

<TD>Associated with the following destination IDs: 0x0400 0x0401 0x0402 ... 0x040E 0x040F </TD>
</TR>

<TR>
<TD>1 </TD>

<TD>Port 0 </TD>

<TD>Associated with the following destination IDs: 0x0410 0x0411 0x0412 ... 0x041E 0x041F </TD>
</TR>

<TR>
<TD>2 </TD>

<TD>Port 1 </TD>

<TD>Associated with the following destination IDs: 0x0420 0x0421 0x0422 ... 0x042E 0x042F </TD>
</TR>

<TR>
<TD>3 </TD>

<TD>Ports 1and 0 </TD>

<TD>Associated with the following destination IDs: 0x0430 0x0431 0x0432 ... 0x043E 0x043F </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Multicast Mask Index </TH>

<TH>Egress Ports </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>4 </TD>

<TD>Port 2 </TD>

<TD>Associated with the following destination IDs: 0x0440 0x0441 0x0442 ... 0x044E 0x044F </TD>
</TR>

<TR>
<TD>5 </TD>

<TD>Ports2 and 0 </TD>

<TD>Associated with the following destination IDs: 0x0450 0x0451 0x0452 ... 0x045E 0x045F </TD>
</TR>

<TR>
<TD>6 </TD>

<TD>Ports2 and 1 </TD>

<TD>Associated with the following destination IDs: 0x0460 0x0461 0x0462 ... 0x046E 0x046F </TD>
</TR>

<TR>
<TD>7 </TD>

<TD>Ports 2, 1 and 0 </TD>

<TD>Associated with the following destination IDs: 0x0470 0x0471 0x0472 ... 0x047E 0x047F </TD>
</TR>

<TR>
<TD>8 </TD>

<TD>Port 3 </TD>

<TD>Associated with the following destination IDs: 0x0480 0x0481 0x0482 ... 0x048E 0x048F </TD>
</TR>

<TR>
<TD>9 </TD>

<TD>Ports 3 and 0 </TD>

<TD>Associated with the following destination IDs: 0x0490 0x0491 0x0492 ... 0x049E 0x049F </TD>
</TR>

<TR>
<TD>10 </TD>

<TD>Ports 3 and 1 </TD>

<TD>Associated with the following destination IDs: 0x04A0 0x04A1 0x04A2 ... 0x04AE 0x04AF </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>Multicast Mask Index </TH>

<TH>Egress Ports </TH>

<TH>Description </TH>
</TR>

<TR>
<TD>11 </TD>

<TD>Ports 3, 1 and 0 </TD>

<TD>Associated with the following destination IDs: 0x04B0 0x04B1 0x04B2 ... 0x04BE 0x04BF </TD>
</TR>

<TR>
<TD>12 </TD>

<TD>Ports3 and2 </TD>

<TD>Associated with the following destination IDs: 0x04C0 0x04C1 0x04C2 ... 0x04CE 0x04CF </TD>
</TR>

<TR>
<TD>13 </TD>

<TD>Ports 3, 2 and 0 </TD>

<TD>Associated with the following destination IDs: 0x04D0 0x04D1 0x04D2 ... 0x04DE 0x04DF </TD>
</TR>

<TR>
<TD>14 </TD>

<TD>Ports 3, 2 and 1 </TD>

<TD>Associated with the following destination IDs: 0x04E0 0x04E1 0x04E2 ... 0x04EE 0x04EF </TD>
</TR>

<TR>
<TD>15 </TD>

<TD>Ports 3, 2, 1 and 0 </TD>

<TD>Associated with the following destination IDs: 0x04F0 0x04F1 0x04F2 ... 0x04FE 0x04FF </TD>
</TR>
</Table>

<P>It is up to the application whether either of the switch routing tables should be used for the destination IDs associated with multicast masks 1, 2, 4, and 8, as packets for these destination IDs do not have to be replicated. </P>

<P>Configuring each of the 16 multicast masks for switches B1 and B2 should require a maximum of 2 writes to the Multicast Mask Load CSR. Multicast masks with one or two ports require a number of register writes equal to the number of ports. Multicast masks with three egress ports to be selected should add all of the ports and then remove the port which doesn’t belong in the multicast mask, thus requiring a maximum of two register writes. The multicast mask with all ports selected requires 1 register write. Thus, to configure all 16 of the multicast masks requires a maximum of (0 + (5*1) + (10*2))=25 register write operations. </P>

<P>For the destination ID to multicast mask association operations for Switch B1, it </P>

<P>RapidIO Trade Association </P>

<P>would make sense to implement block association operations since this would greatly reduce the amount of effort required to associate destination IDs with multicast masks. This feature makes possible in this example to associate a sequential block of 16 destination IDs with the 16 multicast masks with only 32 register writes. Refer to 
<Link>Table 4.4.3, “Using Block Association,” on page 30 for </Link>
details of the pair of writes required for each block of 16 destination IDs. </P>

<P>For the destination ID to multicast mask association operations for Switch B2 there is no pattern that leverages the programming model to speed the association of destination IDs to multicast masks. In Switch B2, it would make sense to use the regular switch routing tables rather than a multicast mask for the destination IDs associated with multicast masks 1, 2, 4 and 8 in order to minimize the number of writes required. The remaining 12 multicast groups each require 32 register write operations to complete their associations with the appropriate destination IDs, for a total of 384 writes. Designers who prefer speed of initialization over reliability may reduce this to 352 register writes by ignoring the destination IDs associated with multicast mask 0. </P>

<P>For switch B2, it may make sense in some systems to implement application specific configuration registers to reduce the number of operations required for configuration. </P>

<P>There can be significant limitations to using static multicast masks. Assume, of the 8 destinations, destinations A, B, C, D, and E are receiving one data stream using destination ID 0x041F, and destinations F, G, and H are receiving a second data stream using destination ID 0x0420. </P>

<P>If destination E switches wishes to change to the second data stream, two things must happen. The destination ID for the first data stream must change from 0x041F to 0x040F in order to have the proper multicast mask for switches B1 and B2, and the destination ID for the second data stream must correspondingly change from 0x0420 to 0x0430. </P>

<P>Because the destination IDs have changed, the switches are now allowed to reorder packets sent to destination IDs 0x041F, 0x040F, 0x0420 and 0x0430, which may change the behavior of the system in unexpected or undesirable ways. </P>

<P>Another issue with static multicast masks is that the latency difference for a data stream between different destinations depends upon whether the data stream is routed using the regular switch routing table or multicast through a particular switch. The different destinations will see different performance characteristics. </P>

<P>These characteristics could have undesirable side effects for latency and jitter sensitive applications like Voice over Internet Protocol (VoIP). </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31202">B.3 	Example 2 - Linking Multicast Masks to Destination IDs </P>

<P>As an alternative implementation, again suppose that there are 256 possible destinations which need to be multicast, numbered 0 through 255. Each destination has a number of data streams it can receive, up to 256, which is always associated with a 16 bit destination ID of the form 0x04&lt;destination stream&gt;. This requires 256 multicast masks in switches A1, B1, and B2. </P>

<P>When a destination changes the data stream it wants to receive, the multicast masks for that data stream need to be changed. First, the multicast mask in each switch associated with the stream currently being received needs to be modified to stop multicasting to this destination. Next, the multicast mask for the new data stream needs to be modified in each switch to enable multicast to that destination. </P>

<P>Depending on system requirements, there are many ways to implement the multicast capabilities in this system. For example, switch A1 could always multicast all data streams to both switch B1 and switch B2. In this case, switch A1 would require 1 multicast mask that could have all 256 destination IDs associated with it. Switch B1 and B2 may receive a lot of undesired traffic in this case. </P>

<P>Initial programming of the multicast masks is not a requirement as with example 1. No ports should be selected in any mask after reset. Multicast masks will be modified during system operation as destinations request to receive a particular data stream. Removing the data streams from one multicast mask and adding a data stream to a multicast mask can be performed in two register writes for each switch. </P>

<P>The destination ID associations with multicast masks can be done far more effectively in this example if the switch devices support block associate operations. Refer to 
<Link>Section 3.4, “Switch Multicast Information CAR (Configuration Space </Link>

<Link>Offset 0x38)</Link>
”, and the programming examples in 
<Link>Section 4.4, “Configuring </Link>

<Link>Associations</Link>
” for more information and examples. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Glossary of Terms and Abbreviations </P>

<P>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </P>

<Table>
<TR>
<TH>A </TH>

<TD>Associate, Association. A defined relationship between a destination ID and a group of end point devices, or, in a switch, a defined relationship between a destination ID and a multicast mask. </TD>
</TR>

<TR>
<TH>M </TH>

<TD>Multicast. The concept of sending a single message to multiple destinations in a system. </TD>
</TR>

<TR>
<TH/>

<TD>Multicast group. The group of end point devices in a system that is the target of a multicast operation. </TD>
</TR>

<TR>
<TH/>

<TD>Multicast mask. The group of egress ports in a switch that are the targets of a replicated multicast packet. </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31203">RapidIO™ Interconnect SpecificationAnnex 1: Software/System Bring UpSpecification </P>

<P>Rev. 1.3, 06/2005 </P>

<P>© Copyright RapidIO Trade Association </P>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_97.jpg"/>
</Figure>

<P>RapidIO Trade Association </P>

<P>Revision History 
</P>

<Table>
<TR>
<TH>Revision </TH>

<TH>Description </TH>

<TH>Date </TH>
</TR>

<TR>
<TD>1.0 </TD>

<TD>First release </TD>

<TD>12/17/2003 </TD>
</TR>

<TR>
<TD>1.3 </TD>

<TD>Technical changes: the following errata showings: 04-09-00020.001, 04-09-00023.001 Converted to ISO-friendly templates Revision bumped to align with the rest of the specification stack </TD>

<TD>02/23/2005 </TD>
</TR>

<TR>
<TD>1.3 </TD>

<TD>Removed confidentiality markings for public release </TD>

<TD>06/07/2005 </TD>
</TR>
</Table>

<P>NO WARRANTY.THE RAPIDIO TRADE ASSOCIATION PUBLISHES THE SPECIFICATION “AS IS”. THE RAPIDIO TRADE 
ASSOCIATION MAKES NO WARRANTY, REPRESENTATION OR COVENANT, EXPRESS OR IMPLIED, OF ANY KIND 
CONCERNING THE SPECIFICATION, INCLUDING, WITHOUT LIMITATION, NO WARRANTY OF NON INFRINGEMENT, NO 
WARRANTY OF MERCHANTABILITY AND NO WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE. USER AGREES TO 
ASSUME ALL OF THE RISKS ASSOCIATED WITH ANY USE WHATSOEVER OF THE SPECIFICATION.  WITHOUT LIMITING THE 
GENERALITY OF THE FOREGOING, USER IS RESPONSIBLE FOR SECURING ANY INTELLECTUAL PROPERTY LICENSES OR 
RIGHTS WHICH MAY BE NECESSARY TO IMPLEMENT OR BUILD PRODUCTS COMPLYING WITH OR MAKING ANY OTHER 
SUCH USE OF THE SPECIFICATION. 
</P>

<P>DISCLAIMER OF LIABILITY.  THE RAPIDIO TRADE ASSOCIATION SHALL NOT BE LIABLE OR RESPONSIBLE FOR ACTUAL, 
INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, WITHOUT LIMITATION, LOST 
PROFITS) RESULTING FROM USE OR INABILITY TO USE THE SPECIFICATION, ARISING FROM ANY CAUSE OF ACTION 
WHATSOEVER, INCLUDING, WHETHER IN CONTRACT, WARRANTY, STRICT LIABILITY, OR NEGLIGENCE, EVEN IF THE 
RAPIDIO TRADE ASSOCIATION HAS BEEN NOTIFIED OF THE POSSIBILITY OF SUCH DAMAGES. 
</P>

<P>Questions regarding the RapidIO Trade Association, specifications, or membership should be forwarded to: 
RapidIO Trade Association 
Suite 325, 3925 W. Braker Lane 
Austin, TX 78759 
512-305-0070 Tel. 
512-305-0009 FAX. 
</P>

<P>RapidIO and the RapidIO logo are trademarks and service marks of the RapidIO Trade Association. All other trademarks are the property of their 
respective owners. 
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>Chapter 1 Overview </Link>
</P>

<P>
<Link>1.1 Introduction............................................................................................................. 7 
</Link>
</P>

<P>
<Link>1.2 Overview................................................................................................................. 7 
</Link>
</P>

<P>
<Link>1.3 Scope....................................................................................................................... 7 
</Link>
</P>

<P>
<Link>1.4 System Enumeration API........................................................................................ 8 
</Link>
</P>

<P>
<Link>1.5 Terminology............................................................................................................ 8 
</Link>
</P>

<P>
<Link>1.6 Software Conventions ............................................................................................. 8 
</Link>
</P>

<P>
<Link>Chapter 2  Requirements for System Bring Up </Link>
</P>

<P>
<Link>2.1 Introduction............................................................................................................. 9 
</Link>
</P>

<P>
<Link>2.2 Boot Requirements ................................................................................................. 9 
</Link>
</P>

<P>
<Link>2.3 Enumeration Completion ...................................................................................... 10 
</Link>
</P>

<P>
<Link>2.4 Enumeration Time-Out ......................................................................................... 10 
</Link>
</P>

<P>
<Link>2.5 Function Return Codes ......................................................................................... 11 
</Link>
</P>

<P>
<Link>Chapter 3 Hardware Abstraction Layer </Link>
</P>

<P>
<Link>3.1 Introduction........................................................................................................... 13 
</Link>
</P>

<P>
<Link>3.2 Device Addressing ................................................................................................ 13 
</Link>
</P>

<P>
<Link>3.3 HAL Functions ..................................................................................................... 14 
</Link>
</P>

<P>
<Link>3.3.1 Types and Definitions ....................................................................................... 14 
</Link>
</P>

<P>
<Link>3.3.2 rioGetNumLocalPorts ....................................................................................... 14 
</Link>
</P>

<P>
<Link>3.3.3 rioConfigurationRead ....................................................................................... 14 
</Link>
</P>

<P>
<Link>3.3.4 rioConfigurationWrite ...................................................................................... 15 
</Link>
</P>

<P>
<Link>Chapter 4  Standard Bring Up Functions </Link>
</P>

<P>
<Link>4.1 Introduction........................................................................................................... 17 
</Link>
</P>

<P>
<Link>4.2 bring up Functions ................................................................................................ 17 
</Link>
</P>

<P>
<Link>4.3 Data Structures...................................................................................................... 17 
</Link>
</P>

<P>
<Link>4.3.1 rioInitLib ........................................................................................................... 17 
</Link>
</P>

<P>
<Link>4.3.2 rioGetFeatures................................................................................................... 18 
</Link>
</P>

<P>
<Link>4.3.3 rioGetSwitchPortInfo........................................................................................ 18 
</Link>
</P>

<P>
<Link>4.3.4 rioGetExtFeaturesPtr ........................................................................................ 19 
</Link>
</P>

<P>
<Link>4.3.5 rioGetNextExtFeaturesPtr................................................................................. 20 
</Link>
</P>

<P>
<Link>4.3.6 rioGetSourceOps............................................................................................... 21 
</Link>
</P>

<P>
<Link>4.3.7 rioGetDestOps .................................................................................................. 21 
</Link>
</P>

<P>
<Link>4.3.8 rioGetAddressMode.......................................................................................... 22 
</Link>
</P>

<P>
<Link>4.3.9 rioGetBaseDeviceId .......................................................................................... 23 
</Link>
</P>

<P>
<Link>4.3.10 rioSetBaseDeviceId .......................................................................................... 23 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>Table of Contents </P>

<P>
<Link>4.3.11 rioAcquireDeviceLock...................................................................................... 24 
</Link>
</P>

<P>
<Link>4.3.12 rioReleaseDeviceLock ...................................................................................... 25 
</Link>
</P>

<P>
<Link>4.3.13 rioGetComponentTag ....................................................................................... 26 
</Link>
</P>

<P>
<Link>4.3.14 rioSetComponentTag ........................................................................................ 26 
</Link>
</P>

<P>
<Link>4.3.15 rioGetPortErrStatus........................................................................................... 27 
</Link>
</P>

<P>
<Link>Chapter 5  Routing-Table Manipulation Functions </Link>
</P>

<P>
<Link>5.1 Introduction........................................................................................................... 29 
</Link>
</P>

<P>
<Link>5.2 Routing Table Functions....................................................................................... 29 
</Link>
</P>

<P>
<Link>5.2.1 rioRouteAddEntry............................................................................................. 29 
</Link>
</P>

<P>
<Link>5.2.2 rioRouteGetEntry .............................................................................................. 30 
</Link>
</P>

<P>
<Link>Chapter 6  Device Access Routine Interface </Link>
</P>

<P>
<Link>6.1 Introduction........................................................................................................... 33 
</Link>
</P>

<P>
<Link>6.2 DAR Packaging .................................................................................................... 33 
</Link>
</P>

<P>
<Link>6.3 Execution Environment ........................................................................................ 33 
</Link>
</P>

<P>
<Link>6.4 Type Definitions ................................................................................................... 33 
</Link>
</P>

<P>
<Link>6.5 DAR Functions ..................................................................................................... 34 
</Link>
</P>

<P>6.5.1 
<Link>rioDar_nameGetFunctionTable........................................................................ 34 
</Link>
</P>

<P>
<Link>6.5.2 rioDarInitialize.................................................................................................. 35 
</Link>
</P>

<P>
<Link>6.5.3 rioDarTerminate................................................................................................ 35 
</Link>
</P>

<P>
<Link>6.5.4 rioDarTestMatch ............................................................................................... 36 
</Link>
</P>

<P>
<Link>6.5.5 rioDarRegister................................................................................................... 36 
</Link>
</P>

<P>
<Link>6.5.6 rioDarGetMemorySize...................................................................................... 37 
</Link>
</P>

<P>
<Link>6.5.7 rioDarGetSwitchInfo ........................................................................................ 38 
</Link>
</P>

<P>
<Link>6.5.8 rioDarSetPortRoute........................................................................................... 39 
</Link>
</P>

<P>
<Link>6.5.9 rioDarGetPortRoute .......................................................................................... 40 
</Link>
</P>

<P>
<Link>Annex A   System Bring Up Guidelines </Link>
</P>

<P>
<Link>A.1 Introduction........................................................................................................... 41 
</Link>
</P>

<P>
<Link>A.2 Overview of the System Bring Up Process .......................................................... 41 
</Link>
</P>

<P>
<Link>A.3 System Enumeration Algorithm ........................................................................... 42 
</Link>
</P>

<P>
<Link>A.3.1 Data Structures, Constants, and Global Variables ............................................ 43 
</Link>
</P>

<P>
<Link>A.3.2 Pseudocode ....................................................................................................... 44 
</Link>
</P>

<P>A.4 
<Link>System Bring Up Example ................................................................................... 48 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>
<Link>A-1 Example System .............................................................................................................49 
</Link>
</P>

<P>RapidIO Trade Association </P>

<P>List of Figures </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31204">Chapter 1 Overview </P>

<P id="LinkTarget_31205">1.1 Introduction </P>

<P>This chapter provides an overview of the RapidIO Annex 1: Software/System Bring Up Specification Rev. 1.3 document. This document assumes that the reader is familiar with the RapidIO specifications, conventions, and terminology. </P>

<P id="LinkTarget_31206">1.2 Overview </P>

<P>The RapidIO Architectural specifications establish a framework that enables a wide variety of implementations. The RapidIO Part 7: System and Device Inter-operability Specification provides a standard set of device and system design solutions to support inter-operability. This document builds upon the inter-operability specification to define a standard set of software API functions for use in system bring up. </P>

<P>Each chapter addresses a different bring up topic. This revision of the RapidIO Annex 1: Software/System Bring Up Specification Rev. 1.3 document covers the following issues: </P>

<P>
<Link>Chapter 2, “Requirements for System Bring Up” </Link>
</P>

<P>
<Link>Chapter 3, “Hardware Abstraction Layer” </Link>
</P>

<P>
<Link>Chapter 4, “Standard Bring Up Functions” </Link>
</P>

<P>
<Link>Chapter 5, “Routing-Table Manipulation Functions” </Link>
</P>

<P>
<Link>Chapter 6, “Device Access Routine Interface” </Link>
</P>

<P>
<Link>Annex A, “System Bring Up Guidelines” </Link>
</P>

<P id="LinkTarget_31207">1.3 Scope </P>

<P>Although RapidIO networks provide many features and capabilities, there are a few assumptions and restrictions that this specification relies on to simplify the bring up process and narrow the specification scope. These assumptions and restrictions are: </P>

<P>• Only two hosts may simultaneously enumerate a network. Two hosts may be needed on a network for fault tolerance purposes. System integrators must determine which hosts can perform this function. </P>

<P>RapidIO Trade Association </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Only one host actually completes the network enumeration (this is referred to as the winning host). The second host must retreat and wait for the enumeration to complete or, assuming the winning host has failed, for enumeration to time out. If a time out occurs, the second host re-enumerates the network. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> After enumeration, other hosts in the system must passively discover the network to gather topology information such as routing tables and memory maps. </LI_Title>
</LI>
</L>

<P id="LinkTarget_31208">1.4 System Enumeration API </P>

<P>System enumeration API functions may be divided into two categories: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> Standard RapidIO functions that use hardware resources defined by the RapidIO specifications. These functions should rely on the support functions provided by the Hardware Abstraction Layer (HAL) to ensure portability between different platforms. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Device-specific (vendor-specific) functions defined by a device manufacturer that use hardware resources outside of the scope of the RapidIO specifications. The main purpose of these functions is to provide Hardware Abstraction Layer (HAL) support to the standard RapidIO functions. </LI_Title>
</LI>
</L>

<P>An important goal of this software API specification is to minimize the number of device-specific functions required for enumeration so that the portability of the API across hardware platforms is maximized. </P>

<P id="LinkTarget_31209">1.5 Terminology </P>

<P>This document uses terms such as local port, local configuration registers, etc. to refer to hardware resources associated with a RapidIO end point device attached to (or combined with) the host processor that performs RapidIO system enumeration and initialization. </P>

<P id="LinkTarget_31210">1.6 Software Conventions </P>

<P>To describe the software API functions, this document uses syntactic and notational conventions consistent with the C programming language. The conventions for naming functions and variables used by these APIs are outside of scope of this document. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31211">Chapter 2  Requirements for System Bring Up </P>

<P id="LinkTarget_31212">2.1 Introduction </P>

<P>This section describes basic requirements for system bring up and discovery. An overview of the system bring up process, including a system bring up example, is presented in 
<Link>Annex A, “System Bring Up Guidelines”. </Link>
</P>

<P id="LinkTarget_31213">2.2 Boot Requirements </P>

<P>The following system state is required for proper system bring up: </P>

<P>After the system is powered on, the state necessary for system enumeration to occur using multiple host processors is automatically initialized as follows (These initial state requirements are specified in the RapidIO Part 7: System and Device Inter-operability Specification): </P>

<L>
<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> System devices are initialized with the following Base Device IDs: </LI_Title>
</LI>

<L>
<LI>
<LI_Label>—</LI_Label>

<LI_Title> Non-boot-code and non-host device IDs are set to 0xFF (0xFFFF for 16-bit deviceID systems). </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Boot code device IDs are set to 0xFE (0x00FE for 16-bit deviceID systems). </LI_Title>
</LI>

<LI>
<LI_Label>—</LI_Label>

<LI_Title> Host device IDs are set to 0x00 (0x0000 for 16-bit deviceID systems). </LI_Title>
</LI>
</L>
</L>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Physical layer link initialization of end points is complete. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> The default routing state of all switches between the boot code device and the host device is set to route all requests for device ID 0xFE (0x00FE for 16-bit deviceID systems) to the appropriate boot code device. All response packets are routed back to the host from the boot code device. </LI_Title>
</LI>

<LI>
<LI_Label>•</LI_Label>

<LI_Title> Any host that participates in discovery must change its destination ID to a unique ID value before starting the system initialization process. This value is used by a device’s Host Base Device ID Lock CSR to ensure only one host can manipulate a device at a time. The allowed ID values for a discovering host are 0x00 (0x0000) and 0x01 (0x0001). A host with an ID of 0x00 (0x0000) has a lower priority than a host with an ID of 0x01 (0x0001). Host devices must be configured to accept maintenance packets with a destination ID of 0xFF (0xFFFF for 16-bit deviceID systems) as well as the unique host ID. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<P>9 </P>

<P>• All host devices have their Master Enable bit (Port General Control CSR) set to 1. Switch devices do not have a Master enable bit. </P>

<P id="LinkTarget_31214">2.3 Enumeration Completion </P>

<P>One or two hosts can perform system enumeration in a RapidIO network. If two hosts are present, an algorithm is needed to determine which host has the priority to proceed with enumeration. The host with the higher priority is the winning host and the other host is the losing host. The enumeration algorithm suggested in 
<Link>Appendix </Link>

<Link>A, “System Bring Up Guidelines,” on page 41 sets priority based on the value of the </Link>
power-on device ID. </P>

<P>Enumeration is complete when the winning host releases the lock on the losing host. It is the losing host’s responsibility to detect that it has been locked by the winning host and to later detect that the lock has been released by the winning host. The methods used to release locks on nodes other than the host nodes is outside the scope of this document. </P>

<P id="LinkTarget_31215">2.4 Enumeration Time-Out </P>

<P>As mentioned in the previous section, two hosts can be used to enumerate the RapidIO network. The algorithm in 
<Link>Appendix A</Link>
 assumes the host with the higher power-on host device ID has priority over the other host. Because of this pre-defined priority, only one host (the one with higher priority) can win the enumeration task. In this case, the losing host enters a wait state. </P>

<P>If the winning host fails to enumerate the entire network, the losing host’s wait state times out. When this occurs, the losing host attempts to enumerate the network. In an open 8-bit deviceID system, the losing host must wait 15 seconds before timing out and restarting the enumeration task. The length of the time-out period in a closed or a 16-bit deviceID system may differ from that of an open system. </P>

<P>To develop the 15 second timeout value, the following assumptions are made about the network maximal size: </P>

<P>NUMDEV = 256 devices </P>

<P>NUMSWITCHES = 256 switches </P>

<P>NUMFTE = 256 routing table entries per switch </P>

<P>It is assumed that a separate maintenance write packet is required to program each routing table entry for each switch. Since we need to establish a time base for operations, we assume: </P>

<P>CWTime = 100 microseconds per configuration write packet </P>

<P>Now we can estimate that the number of configuration writes it takes to program all </P>

<P>RapidIO Trade Association </P>

<P>of the switch routing table entries is (256 switches)*(256 routing table entries), or; </P>

<P>=&gt; 256*256*CWTIME microsecs = </P>

<P>=&gt; ~6.6 seconds. </P>

<P>Given these rough approximations, a 15 second timeout value is seen as appropriate and conservative for open systems. The chosen value must be such that if a timeout were to occur, it must be guaranteed that failure HAS occured, and hence choosing a conservative value is necessary. </P>

<P id="LinkTarget_31216">2.5 Function Return Codes </P>

<P>The following return codes and their constant values are defined for use by the system bring up functions. </P>

<P>typedef unsigned int STATUS; </P>

<P>#define RIO_SUCCESS 0x0 	// Success status code </P>

<P>#define RIO_WARN_INCONSISTENT 0x1 	// Used by// rioRouteGetEntry—indicates// that the routeportno returned is// not the same for all ports </P>

<P>#define RIO_ERR_SLAVE 0x1001 	// Another host has a higher// priority </P>

<P>#define RIO_ERR_INVALID_PARAMETER 0x1002 	// One or more input parameters// had an invalid value </P>

<P>#define RIO_ERR_RIO 0x1003 	// The RapidIO fabric returned a// Response Packet with ERROR// status reported </P>

<P>#define RIO_ERR_ACCESS 0x1004 	// A device-specific hardware// interface was unable to generate// a maintenance transaction and// reported an error </P>

<P>#define RIO_ERR_LOCK 0x1005 	// Another host already acquired// the specified processor element </P>

<P>#define RIO_ERR_NO_DEVICE_SUPPORT 0x1006 	// Device Access Routine does not// provide services for this device </P>

<P>#define RIO_ERR_INSUFFICIENT_RESOURCES 0x1007 	// Insufficient storage available in// Device Access Routine private// storage area </P>

<P>#define RIO_ERR_ROUTE_ERROR 0x1008 	// Switch cannot support</P>

<P>// requested routing </P>

<P>#define RIO_ERR_NO_SWITCH 0x1009 	// Target device is not a switch </P>

<P>#define RIO_ERR_FEATURE_NOT_SUPPORTED 0x100A 	// Target device is not capable of</P>

<P>// per-input-port routing </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31217">Chapter 3  Hardware Abstraction Layer </P>

<P id="LinkTarget_31218">3.1 Introduction </P>

<P>The Hardware Abstraction Layer (HAL) provides a standard software interface to the device-specific hardware resources needed to support RapidIO system configuration transactions. Configuration read and write operations are used by the HAL functions to access RapidIO device registers. The HAL functions are accessed by the RapidIO enumeration API during system bring up. </P>

<P>This section describes the HAL functions and how they can be used to access local and remote RapidIO device registers. These functions must be implemented by every new device-specific host-processing element to support RapidIO system enumeration and initialization. The HAL functions assume the following: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> All configuration read and write operations support only single word (4-byte) accesses. </LI_Title>
</LI>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> As required by the device, the size of the 8-bit or 16-bit deviceID field is considered by the device implementation (see section 2.4 of the RapidIO Part </LI_Title>
</LI>

<LI>3: Common Transport Specification for more information). </LI>
</L>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>An enumerating processor device may have more than one RapidIO end point (local port). </LI_Title>
</LI>
</L>

<P id="LinkTarget_31219">3.2 Device Addressing </P>

<P>One purpose of the HAL is to provide a unified software interface to configuration registers in both local and remote RapidIO processing elements. This is done using a universal device-addressing scheme. Such a scheme enables HAL functions to distinguish between accesses to local and remote RapidIO end points without requiring an additional parameter. The result is that only one set of HAL functions must be implemented to support local and remote configuration operations. </P>

<P>All HAL functions use the destid and hopcount parameters to address a RapidIO device. The HAL reserves destid=0xFFFFFFFF and hopcount of 0 for addressing configuration registers within the local RapidIO end point. A destid= 0xFFFFFFFF and hopcount of 0 value must be used to address the local processing end point regardless of the actual destination ID value. This reserved combination does not conflict with the address of other RapidIO devices. The localport parameter is used by the HAL functions to identify a specific local port within RapidIO devices containing multiple ports. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31220">3.3 HAL Functions </P>

<P>The functions that form the RapidIO initialization HAL are described in the following sections. </P>

<P id="LinkTarget_31221">3.3.1 Types and Definitions </P>

<P>/* The HOST_REGS value below is a destination ID used to specify that the registers of the processor/platform on which the code is running are to be accessed. */ </P>

<P>#define HOST_REGS 0xFFFFFFFF </P>

<P id="LinkTarget_31222">3.3.2 rioGetNumLocalPorts </P>

<P>Prototype: 
INT32 rioGetNumLocalPorts (
void 
) 
Arguments: 
None 
</P>

<P>Return Value: 
0 Error 
n Number of RapidIO ports supported 
</P>

<P>Synopsis: rioGetNumLocalPorts() returns the total number of local RapidIO ports supported by the HAL functions. The number n returned by this function should be equal to or greater than 1. A returned value of 0 indicates an error. </P>

<P id="LinkTarget_31223">3.3.3 rioConfigurationRead </P>

<P>Prototype: 
STATUS rioConfigurationRead (
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
UINT32 offset, 
UINT32 *readdata 
) 
</P>

<P>Arguments: localport Local port number [IN] destid Destination ID of the target device [IN] hopcount Hop count [IN] offset Word-aligned (four byte boundary) offset—in</P>

<P>bytes—of the CAR or CSR [IN] *readdata Pointer to storage for received data [OUT] Return Value: </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>RIO_SUCCESS </TD>

<TD>The read operation completed successfully and validdata was placed into the specified location. </TD>
</TR>

<TR>
<TD>RIO_ERR_INVALID_PARAMETER </TD>

<TD>One or more input parameters had an invalid value. </TD>
</TR>

<TR>
<TD>RIO_ERR_RIO </TD>

<TD>The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </TD>
</TR>

<TR>
<TD>RIO_ERR_ACCESS </TD>

<TD>A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </TD>
</TR>

<TR>
<TD>Synopsis: </TD>

<TD/>
</TR>
</Table>

<P>rioConfigurationRead() performs a configuration read transaction from CAR and/or CSR register(s) belonging to a local or remote RapidIO device. The function uses a device-specific hardware interface to generate maintenance transactions to remote devices. This hardware sends a configuration read request to the remote device (specified bydestid and/or hopcount) and waits for a corresponding configuration read response. After the function receives aconfiguration read response it returns data and/or status to the caller. The method for accessing registers in a local deviceis device-specific. </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31224">3.3.4 rioConfigurationWrite </P>

<P>Prototype: </P>

<P>STATUS rioConfigurationWrite (UINT8 UINT32 UINT8 UINT32 UINT32 </P>

<P>) </P>

<P>Arguments: </P>

<P>localport </P>

<P>destid </P>

<P>hopcount </P>

<P>offset </P>

<P>*writedata </P>

<P>Return Value: RIO_SUCCESS RIO_ERR_INVALID_PARAMETER RIO_ERR_RIO </P>

<P>RIO_ERR_ACCESS </P>

<P>localport, destid, hopcount, offset, *writedata </P>

<P>Local port number [IN] </P>

<P>Destination ID of the target device [IN] </P>

<P>Hop count [IN] </P>

<P>Word-aligned (four byte boundary) offset—inbytes—of the CAR or CSR [IN] </P>

<P>Pointer to storage for data to be written [IN] </P>

<P>The write operation completed successfully. </P>

<P>One or more input parameters had an invalid value. </P>

<P>The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>Synopsis: </P>

<P>rioConfigurationWrite() performs a configuration write transaction to CAR and/or CSR register(s) belonging to a local or remote RapidIO device. The function uses a device-specific hardware interface to generate maintenance transactions to remote devices. This hardware sends a configuration write request to the remote device (specified by </P>

<P>RapidIO Trade Association </P>

<P>destid and/or hopcount) and waits for a corresponding configuration write response. After the function receives a configuration write response it returns status to the caller. The method for accessing registers in a local device is device-specific. </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31225">Chapter 4  Standard Bring Up Functions </P>

<P id="LinkTarget_31226">4.1 Introduction </P>

<P>This section describes the RapidIO functions that must be implemented to support system bring up. Functions are defined only for device registers used during the RapidIO enumeration and initialization process, not for all possible RapidIO device registers. These functions can be implemented using the HAL functions. Many of the functions can also be implemented as macros that specify predefined parameters for the HAL functions. The standard RapidIO bring up functions can be combined into a library if they are implemented as a set of subroutines. </P>

<P id="LinkTarget_31227">4.2 bring up Functions </P>

<P>The functions defined for the RapidIO enumeration and initialization process are described in the following sections. </P>

<P id="LinkTarget_31228">4.3 Data Structures </P>

<P>typedef ADDR_MODE UINT32; </P>

<P>#define ADDR_MODE_34BIT_SUPPORT 0x1 </P>

<P>#define ADDR_MODE_50_34BIT_SUPPORT 0x3 </P>

<P>#define ADDR_MODE_66_34BIT_SUPPORT 0x5 </P>

<P>#define ADDR_MODE_66_50_34BIT_SUPPORT 0x7 </P>

<Table>
<TR>
<TH id="LinkTarget_31229">4.3.1 rioInitLib </TH>
</TR>

<TR>
<TH>Prototype: </TH>
</TR>

<TR>
<TH>STATUS rioInitLib (void </TH>
</TR>

<TR>
<TH>) </TH>
</TR>

<TR>
<TH>Arguments: </TH>
</TR>

<TR>
<TH>None </TH>
</TR>

<TR>
<TH>Return Value: </TH>
</TR>

<TR>
<TH>RIO_SUCCESS </TH>

<TD>Initialization completed successfully. </TD>
</TR>

<TR>
<TH>RIO_ERROR </TH>

<TD>Generic error report. Unable to initialize library. </TD>
</TR>

<TR>
<TH>Synopsis: </TH>

<TD/>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>rioInitLib() initializes the RapidIO API library. No routines defined in this chapter may be called unless and untile rioInitLib has been invoked. If rioInitLib returns RIO_ERROR, no routines defined in this chapter may be called. </P>

<P id="LinkTarget_31230">4.3.2 rioGetFeatures </P>

<P>Prototype: </P>

<P>STATUS rioGetFeatures (
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
UINT32 *features 
</P>

<P>) </P>

<P>Arguments: </P>

<P>localport 	Local port number [IN] </P>

<P>destid 	Destination ID of the processing element [IN] </P>

<P>hopcount 	Hop count [IN] </P>

<P>*features 	Pointer to storage containing the received features[OUT] </P>

<P>Return Value: </P>

<P>RIO_SUCCESS 	The features were retrieved successfully and placedinto the location specified by *features. </P>

<P>RIO_ERR_INVALID_PARAMETER 	One or more input parameters had an invalid value. </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>Synopsis: </P>

<P>rioGetFeatures() uses the HAL rioConfigurationRead() function to read from the Processing Element FeaturesCAR of the specified processing element. Values read are placed into the location referenced by the *features pointer. Reported status is similar to rioConfigurationRead() </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31231">4.3.3 rioGetSwitchPortInfo </P>

<P>Prototype: </P>

<P>STATUS rioGetSwitchPortInfo (
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
UINT32 *portinfo 
</P>

<P>) </P>

<P>Arguments: </P>

<P>localport 	Local port number [IN] </P>

<P>destid 	Destination ID of the processing element [IN] </P>

<P>hopcount 	Hop count [IN] </P>

<P>RapidIO Trade Association </P>

<P>*portinfo 	Pointer to storage containing the received portinformation [OUT] </P>

<P>Return Value: </P>

<P>RIO_SUCCESS 	The port information was retrieved successfully andplaced into the location specified by *portinfo. </P>

<P>RIO_ERR_INVALID_PARAMETER One or more input parameters had aninvalid value. </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>Synopsis: </P>

<P>rioGetSwitchPortInfo() uses the HAL rioConfigurationRead() function to read from the Switch Port Information CAR of the specified processing element. Values read are placed into the location referenced by the *portinfo pointer. Reported status is similar to rioConfigurationRead(). </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31232">4.3.4 rioGetExtFeaturesPtr </P>

<P>Prototype: </P>

<P>STATUS rioGetExtFeaturesPtr (
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
UINT32 *extfptr 
</P>

<P>) </P>

<P>Arguments: </P>

<P>localport 	Local port number [IN] </P>

<P>destid 	Destination ID of the processing element [IN] </P>

<P>hopcount 	Hop count [IN] </P>

<P>*extfptr Pointer to storage containing the received extended feature information [OUT] </P>

<P>Return Value: </P>

<P>RIO_SUCCESS 	The extended feature information was retrieved successfully and placed into the location specified by*extfptr. </P>

<P>RIO_ERR_INVALID_PARAMETER 	One or more input parameters had an invalid value. </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>RapidIO Trade Association </P>

<P>Synopsis: </P>

<P>rioGetExtFeaturesPtr() uses the HAL rioConfigurationRead() function to read the pointer to the first entry in the extended features list from the Assembly Information CAR of the specified processing element. That pointer is placed into the location referenced by the *extfptr pointer. Reported status is similar to rioConfigurationRead(). </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P>Note that if the EF_PTR field of *extfptr is 0, no extended features are available. </P>

<P id="LinkTarget_31233">4.3.5 rioGetNextExtFeaturesPtr </P>

<P>Prototype: </P>

<P>STATUS rioGetNextExtFeaturesPtr (
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
UINT32 currfptr, 
UINT32 *extfptr 
</P>

<P>) </P>

<P>Arguments: </P>

<P>localport 	Local port number [IN] </P>

<P>destid 	Destination ID of the processing element [IN] </P>

<P>hopcount 	Hop count [IN] </P>

<P>currfptr 	Pointer to the last reported extended feature [IN] </P>

<P>*extfptr Pointer to storage containing the received extended feature information [OUT] </P>

<P>Return Value: </P>

<P>RIO_SUCCESS 	The extended feature information was retrieved successfully and placed into the location specified by*extfptr. </P>

<P>RIO_ERR_INVALID_PARAMETER 	One or more input parameters had an invalid value. </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>Synopsis: </P>

<P>rioGetNextExtFeaturesPtr() uses the HAL rioConfigurationRead() function to read the pointer to the next entry in the extended features. That pointer is placed into the location referenced by the *extfptr pointer. Reported status is similar to rioConfigurationRead(). </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P>Note that if the EF_PTR field of *extfptr is 0, no further extended features are available. Invoking rioGetNextExtFeaturesPtr when currfptr has an EF_PTR field value of 0 will result in a return code ofRIO_ERR_INVALID_PARAMETER. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31234">4.3.6 rioGetSourceOps </P>

<P>Prototype: STATUS rioGetSourceOps (UINT8 UINT32 UINT8 UINT32 ) </P>

<P>Arguments: 
localport 
destid 
hopcount 
*srcops 
</P>

<P>Return Value: 
RIO_SUCCESS 
</P>

<P>RIO_ERR_INVALID_PARAMETERRIO_ERR_RIO </P>

<P>RIO_ERR_ACCESS </P>

<P>Synopsis: localport, destid, hopcount, *srcops </P>

<P>Local port number [IN] </P>

<P>Destination ID of the processing element [IN] </P>

<P>Hop count [IN] </P>

<P>Pointer to storage containing the received sourceoperation information [OUT] </P>

<P>The source operation information was retrievedsuccessfully and placed into the location specified by*srcops. </P>

<P> One or more input parameters had an invalid value. </P>

<P>The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>rioGetSourceOps() uses the HAL rioConfigurationRead() function to read from the Source Operations CAR ofthe specified processing element. Values read are placed into the location referenced by the *srcops pointer. Reported status is similar to rioConfigurationRead(). </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31235">4.3.7 rioGetDestOps </P>

<P>Prototype: STATUS rioGetDestOps (UINT8 UINT32 UINT8 UINT32 ) </P>

<P>Arguments: 
localport 
destid 
hopcount 
*dstops 
</P>

<P>localport, destid, hopcount, *dstops </P>

<P>Local port number [IN] </P>

<P>Destination ID of the processing element [IN] </P>

<P>Hop count [IN] </P>

<P>Pointer to storage containing the received destinationoperation information [OUT] </P>

<P>RapidIO Trade Association </P>

<P>Return Value: </P>

<P>RIO_SUCCESS 	The destination operation information was retrievedsuccessfully and placed into the location specified by*dstops. </P>

<P>RIO_ERR_INVALID_PARAMETER 	One or more input parameters had an invalid value. </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>Synopsis: </P>

<P>rioGetDestOps() uses the HAL rioConfigurationRead() function to read from the Destination Operations CAR of the specified processing element. Values read are placed into the location referenced by the *dstops pointer. Reported status is similar to rioConfigurationRead(). </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31236">4.3.8 rioGetAddressMode </P>

<P>Prototype: </P>

<P>STATUS rioGetAddressMode (UINT8 localport, UINT32 destid, UINT8 hopcount, ADDR_MODE *amode </P>

<P>) </P>

<P>Arguments: </P>

<P>localport 	Local port number [IN] </P>

<P>destid 	Destination ID of the processing element [IN] </P>

<P>hopcount 	Hop count [IN] </P>

<P>*amode 	Pointer to storage containing the received addressmode (34-bit, 50-bit, or 66-bit address) information[OUT] </P>

<P>Return Value: </P>

<P>RIO_SUCCESS 	The address mode information was retrieved successfully and placed into the location specified by*amode. </P>

<P>RIO_ERR_INVALID_PARAMETER 	One or more input parameters had an invalid value. </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>Synopsis: </P>

<P>rioGetAddressMode() uses the HAL rioConfigurationRead() function to read from the PE Logical Layer CSR of the specified processing element. The number of address bits generated by the PE (as the source of an operation) and </P>

<P>RapidIO Trade Association </P>

<P>processed by the PE (as the target of an operation) are placed into the location referenced by the *amode pointer. 
Reported status is similar to rioConfigurationRead(). 
A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. 
</P>

<P id="LinkTarget_31237">4.3.9 rioGetBaseDeviceId </P>

<P>Prototype: STATUS rioGetBaseDeviceId (</P>

<Table>
<TR>
<TD>UINT8 UINT32 </TD>

<TD>localport, *deviceid </TD>
</TR>

<TR>
<TD>) </TD>

<TD/>
</TR>

<TR>
<TD>Arguments: </TD>

<TD/>
</TR>

<TR>
<TD>localport </TD>

<TD>Local port number [IN] </TD>
</TR>

<TR>
<TD>*deviceid </TD>

<TD>Pointer to storage containing the base device ID[OUT] </TD>
</TR>

<TR>
<TD>Return Value: </TD>

<TD/>
</TR>

<TR>
<TD>RIO_SUCCESS </TD>

<TD>The base device ID information was retrieved </TD>
</TR>

<TR>
<TD/>

<TD>successfully and placed into thelocation specified by *deviceid. </TD>
</TR>

<TR>
<TD>RIO_ERR_INVALID_PARAMETER </TD>

<TD>One or more input parameters had an invalid value. </TD>
</TR>

<TR>
<TD>RIO_ERR_RIO </TD>

<TD>The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </TD>
</TR>

<TR>
<TD>RIO_ERR_ACCESS </TD>

<TD>A device-specific hardware interface was unable togenerate a maintenance transaction and reported an </TD>
</TR>

<TR>
<TD/>

<TD>error. </TD>
</TR>

<TR>
<TD>Synopsis: </TD>

<TD/>
</TR>
</Table>

<P>rioGetBaseDeviceId() uses the HAL rioConfigurationRead() function to read from the Base Device ID CSR of the local processing element (the destid and hopcount parameters used by rioConfigurationRead() must be set to HOST_REGS and zero, respectively). Values read are placed into the location referenced by the *deviceid pointer. Reported status is similar to rioConfigurationRead(). This function is useful only for local end-point devices. </P>

<P id="LinkTarget_31238">4.3.10 rioSetBaseDeviceId </P>

<P>Prototype: STATUS rioSetBaseDeviceId (UINT8 localport, UINT32 destid, UINT8 hopcount, UINT32 newdeviceid ) </P>

<P>Arguments: localport Local port number [IN] destid Destination ID of the processing element [IN] hopcount Hop count [IN] newdeviceid New base device ID to be set [IN] </P>

<P>Return Value: </P>

<P>RapidIO Trade Association </P>

<P>RIO_SUCCESS 	The base device ID was updated successfully. </P>

<P>RIO_ERR_INVALID_PARAMETER 	One or more input parameters had an invalid value. </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>Synopsis: </P>

<P>rioSetBaseDeviceId() uses the HAL rioConfigurationWrite() function to write the base device ID in the Base Device ID CSR of the specified processing element (end point devices only). Reported status is similar to rioConfigurationWrite(). </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31239">4.3.11  rioAcquireDeviceLock </P>

<P>Prototype: </P>

<P>STATUS rioAcquireDeviceLock (
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
UINT16 hostdeviceid, 
UINT16 *hostlockid 
</P>

<P>) </P>

<P>Arguments: </P>

<P>localport 	Local port number [IN] </P>

<P>destid 	Destination ID of the processing element [IN] </P>

<P>hopcount 	Hop count [IN] </P>

<P>hostdeviceid 	Host base device ID for the local processing element[IN] </P>

<P>*hostlockid 	Device ID of the host holding the lock if ERR_LOCKis returned [OUT] </P>

<P>Return Value: </P>

<P>RIO_SUCCESS 	The device lock was acquired successfully. </P>

<P>RIO_ERR_LOCK 	Another host already acquired the specified processorelement. ID of the device holding the lock is containedin the location referenced by the *hostlockid parameter. </P>

<P>RIO_ERR_INVALID_PARAMETER 	One or more input parameters had an invalid value </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>RapidIO Trade Association </P>

<P>Synopsis: </P>

<P>rioAcquireDeviceLock() tries to acquire the hardware device lock for the specified processing element on behalf ofthe requesting host. The function uses the HAL rioConfigurationWrite() function to write the requesting host device ID into the Host Base Lock Device ID CSR of the specified processing element. After the write completes, this function uses the HAL rioConfigurationRead() function to read the value back from the Host Base Lock Device ID CSR. The written and read values are compared. If they are equal, the lock was acquired successfully. Otherwise, another hostacquired this lock and the device ID for that host is reported. </P>

<P>This function assumes unique host-based device identifiers are assigned to discovering hosts. For more details, refer to 
<Link>Annex A, “System Bring Up Guidelines”. </Link>
</P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31240">4.3.12 rioReleaseDeviceLock </P>

<P>Prototype: </P>

<P>STATUS rioReleaseDeviceLock (UINT8 UINT32 UINT8 UINT16 UINT16 </P>

<P>) </P>

<P>Arguments: </P>

<P>localport </P>

<P>destid </P>

<P>hopcount </P>

<P>hostdeviceid </P>

<P>*hostlockid </P>

<P>Return Value: 
RIO_SUCCESS 
RIO_ERR_LOCK 
</P>

<P>RIO_ERR_INVALID_PARAMETER RIO_ERR_RIO </P>

<P>RIO_ERR_ACCESS </P>

<P>Synopsis: localport, destid, hopcount, hostdeviceid, *hostlockid </P>

<P>Local port number [IN] </P>

<P>Destination ID of the processing element [IN] </P>

<P>Hop count [IN] </P>

<P>Host base device ID for the local processing element[IN] </P>

<P>Device ID of the host holding the lock if ERR_LOCKis returned [OUT] </P>

<P>The device lock was released successfully. </P>

<P>Another host already acquired the specified processorelement. </P>

<P>One or more input parameters had an invalid value </P>

<P>The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>rioReleaseDeviceLock() tries to release the hardware device lock for the specified processing element on behalf ofthe requesting host. The function uses the HAL rioConfigurationWrite() function to write the requesting host device ID into the Host Base Lock Device ID CSR of the specified processing element. After the write completes, this function uses the HAL rioConfigurationRead() function to read the value back from the Host Base Lock Device ID CSR. The written and read values are compared. If they are equal, the lock was acquired successfully. Otherwise, another hostacquired this lock and the device ID for that host is reported. </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31241">4.3.13 rioGetComponentTag </P>

<P>Prototype: </P>

<P>STATUS rioGetComponentTag (
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
UINT32 *componenttag 
</P>

<P>) </P>

<P>Arguments: </P>

<P>localport 	Local port number [IN] </P>

<P>destid 	Destination ID of the processing element [IN] </P>

<P>hopcount 	Hop count [IN] </P>

<P>*componenttag 	Pointer to storage containing the received componenttag information [OUT] </P>

<P>Return Value: </P>

<P>RIO_SUCCESS 	The component tag information was retrievedsuccessfully and placed into the location specified by*componenttag. </P>

<P>RIO_ERR_INVALID_PARAMETER 	One or more input parameters had an invalid value. </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>Synopsis: </P>

<P>rioGetComponentTag() uses the HAL rioConfigurationRead() function to read from the Component Tag CSR of the specified processing element. Values read are placed into the location referenced by the *componenttag pointer. Reported status is similar to rioConfigurationRead(). </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31242">4.3.14 rioSetComponentTag </P>

<P>Prototype: 
STATUS rioSetComponentTag (
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
UINT32 componenttag 
) 
</P>

<P>Arguments: localport Local port number [IN] destid Destination ID of the processing element [IN] hopcount Hop count [IN] componenttag Component tag value to be set [IN] </P>

<P>Return Value: </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>RIO_SUCCESS </TD>

<TD>The component tag was updated successfully. </TD>
</TR>

<TR>
<TD>RIO_ERR_INVALID_PARAMETER </TD>

<TD>One or more input parameters had an invalid value. </TD>
</TR>

<TR>
<TD>RIO_ERR_RIO </TD>

<TD>The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </TD>
</TR>

<TR>
<TD>RIO_ERR_ACCESS </TD>

<TD>A device-specific hardware interface was unable togenerate a maintenance transaction and reported an </TD>
</TR>

<TR>
<TD/>

<TD>error. </TD>
</TR>

<TR>
<TD>Synopsis: </TD>

<TD/>
</TR>
</Table>

<P>rioSetComponentTag() uses the HAL rioConfigurationWrite() function to write the component tag into the Component Tag CSR of the specified processing element. Reported status is similar to rioConfigurationWrite(). </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31243">4.3.15 rioGetPortErrStatus </P>

<P>Prototype: </P>

<P>STATUS rioGetPortErrStatus (UINT8 UINT32 UINT8 UINT16 UINT8 UINT32 </P>

<P>) </P>

<P>Arguments: </P>

<P>localport </P>

<P>destid </P>

<P>hopcount </P>

<P>extfoffset </P>

<P>portnum 
*porterrorstatus 
Return Value: 
RIO_SUCCESS 
</P>

<P>RIO_ERR_INVALID_PARAMETER RIO_ERR_RIO </P>

<P>RIO_ERR_ACCESS </P>

<P>Synopsis: localport, destid, hopcount, extfoffset, portnum, *porterrorstatus </P>

<P>Local port number [IN] </P>

<P>Destination ID of the processing element [IN] </P>

<P>Hop count [IN] </P>

<P>Offset from the previously reported extended featurespointer [IN] </P>

<P>Port number to be accessed [IN] </P>

<P>Pointer to storage for the returned value [OUT] </P>

<P>The read completed successfully and valid data wasplaced into the location specified by *porterrorstatus. </P>

<P>One or more input parameters had aninvalid value. </P>

<P>The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>rioGetPortErrStatus() uses the HAL rioConfigurationRead() function to read the contents of the Port n Error and Status CSR of the specified processing element. Reported status is similar to rioConfigurationRead(). </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31244">Chapter 5  Routing-Table Manipulation Functions </P>

<P id="LinkTarget_31245">5.1 Introduction </P>

<P>This section describes the RapidIO functions that must be provided to support routing tables used within the switch fabric. The RapidIO common transport specification requires implementing device-identifier-based packet routing. The detailed implementation of routing tables is beyond the scope of this specification. </P>

<P>The routing-table manipulation functions assume the following: </P>

<L>
<LI>
<LI_Label>•</LI_Label>

<LI_Title> The destination ID of the device that receives a packet routed by the switch is the route destination ID. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>The specific port at the route destination ID that receives a packet routed by the switch is the route port number. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>The software paradigm used for routing tables is a linear routing table indexed by the route destination ID. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>Switches may implement a global routing table, “per port” routing tables, or a combination of both. </LI_Title>
</LI>
</L>

<P id="LinkTarget_31246">5.2 Routing Table Functions </P>

<P>The functions defined for RapidIO routing-table manipulation are described in the </P>

<P>following sections. </P>

<P id="LinkTarget_31247">5.2.1 rioRouteAddEntry </P>

<P>Prototype: </P>

<P>STATUS rioRouteAddEntry (</P>

<P>UINT8 </P>

<P>UINT32 </P>

<P>UINT8 </P>

<P>UINT8 </P>

<P>UINT16 </P>

<P>UINT8 </P>

<P>) </P>

<P>Arguments: </P>

<P>localport </P>

<P>destid </P>

<P>localport, destid, hopcount, tableidx, routedestid, routeportno </P>

<P>Local port number (RapidIO switch) [IN] </P>

<P>Destination ID of the processing element (RapidIO </P>

<P>RapidIO Trade Association </P>

<P>switch) [IN] </P>

<P>hopcount 	Hop count [IN] </P>

<P>tableidx 	Routing table index for per-port switchimplementations [IN] </P>

<P>routedestid 	Route destination ID—used to select an entry into thespecified routing table [IN] </P>

<P>routeportno 	Route port number—value written to the selectedrouting table entry [IN] </P>

<P>Return Value: </P>

<P>RIO_SUCCESS 	The routing table entry was added successfully. </P>

<P>RIO_ERR_INVALID_PARAMETER 	One or more input parameters had an invalid value. </P>

<P>RIO_ERR_RIO 	The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by thisfunction may contain additional information from theResponse Packet. </P>

<P>RIO_ERR_ACCESS 	A device-specific hardware interface was unable togenerate a maintenance transaction and reported an error. </P>

<P>RIO_WARN_INCONSISTENT 	Used by rioRouteGetEntry—indicates that therouteportno returned is not the same for all ports. </P>

<P>Synopsis: </P>

<P>rioRouteAddEntry() adds an entry to a routing table for the RapidIO switch specified by the destid and hopcountparameters. The tableidx parameter is used to select a specific routing table in the case of implementations with “per port” routing tables. A value of tableidx=0xFFFFFFFF specifies a global routing table for the RapidIO switch. The routeportno parameter is written to the routing table entry selected by the routedestid parameter. </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31248">5.2.2 rioRouteGetEntry </P>

<P>Prototype: </P>

<P>STATUS rioRouteGetEntry (
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
UINT8 tableidx, 
UINT16 routedestid, 
UINT8 *routeportno 
</P>

<P>) </P>

<P>Arguments: </P>

<P>localport 	Local port number (RapidIO switch) [IN] </P>

<P>destid 	Destination ID of the processing element (RapidIOswitch) [IN] </P>

<P>hopcount 	Hop count [IN] </P>

<P>tableidx 	Routing table index for per-port switchimplementations [IN] </P>

<P>routedestid 	Route destination ID—used to select an entry into thespecified routing table [IN] </P>

<P>*routeportno 	Route port number—pointer to value read from theselected routing table entry [OUT] </P>

<P>RapidIO Trade Association </P>

<P>Return Value: </P>

<Table>
<TR>
<TD>RIO_SUCCESS </TD>

<TD>The routing table entry was added successfully. </TD>
</TR>

<TR>
<TD>RIO_ERR_INVALID_PARAMETER </TD>

<TD>One or more input parameters had an invalid value. </TD>
</TR>

<TR>
<TD>RIO_ERR_RIO </TD>

<TD>The RapidIO fabric returned a Response Packet withERROR status reported. Error status returned by this function may containadditional information from the Response Packet. </TD>
</TR>

<TR>
<TD>RIO_ERR_ACCESS </TD>

<TD>A device-specific hardware interface was unable togenerate a maintenance transaction and reported an </TD>
</TR>

<TR>
<TD/>

<TD>error. </TD>
</TR>

<TR>
<TD>RIO_WARN_INCONSISTENT </TD>

<TD>Used by rioRouteGetEntry—indicates that therouteportno returned is not the same for all ports. </TD>
</TR>

<TR>
<TD>Synopsis: </TD>

<TD/>
</TR>
</Table>

<P>rioRouteGetEntry() reads an entry from a routing table for the RapidIO switch specified by the destid and hopcount parameters. The tableidx parameter is used to select a specific routing table in the case of implementationswith “per port” routing tables. A value of tableidx=0xFF specifies a global routing table for the RapidIO switch. The value in the routing table entry selected by the routedestid parameter is read from the table and placed into the location referenced by the *routeportno pointer. </P>

<P>Reads from the global routing table may be undefined in the case where per-port routing tables exist. </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31249">Chapter 6 Device Access Routine Interface </P>

<P id="LinkTarget_31250">6.1 Introduction </P>

<P>This section defines the device access routine (DAR) interface that must be provided for RapidIO device configuration. The client for this interface is the boot loader responsible for RapidIO network enumeration and initialization. By using a standard DAR interface, the firmware does not need to include knowledge of device-specific configuration operations. Thus, enumeration and initialization firmware can operate transparently with devices from many component vendors. </P>

<P id="LinkTarget_31251">6.2 DAR Packaging </P>

<P>For each processor type supported by a DAR provider, linkable object files for DARs shall be supplied using ELF format. Device-specific configuration DARs shall be supplied using C-language source code format. </P>

<P id="LinkTarget_31252">6.3 Execution Environment </P>

<P>The functions provided by device-specific configuration DARs must be able to link and execute within a minimal execution context (e.g., a system-boot monitor or firmware). In general, configuration DARs should not call an external function that is not implemented by the DAR, unless the external function is passed to the configuration DAR by the initialization function. Also, configuration DAR functions may not call standard C-language I/O functions (e.g., printf) or standard C-language library functions that might manipulate the execution environment (e.g., malloc or exit). </P>

<P id="LinkTarget_31253">6.4 Type Definitions </P>

<P>
<Link>The following type definitions are to be used by the DAR functions in Section 6.5. </Link>
</P>

<P>typedef struct RDCDAR_PLAT_OPS_STRUCT {</P>

<Table>
<TR>
<TD>UINT32 specversion;</TD>

<TD/>

<TD/>

<TD/>
</TR>

<TR>
<TD>UINT32 (*rioConfigurationRead) </TD>

<TD>( </TD>

<TD>UINT8 </TD>

<TD>localport, </TD>
</TR>

<TR>
<TD/>

<TD/>

<TD>UINT16 </TD>

<TD>destid, </TD>
</TR>

<TR>
<TD/>

<TD/>

<TD>UINT8 </TD>

<TD>hopcount, </TD>
</TR>

<TR>
<TD/>

<TD/>

<TD>UINT32 </TD>

<TD>offset, </TD>
</TR>

<TR>
<TD/>

<TD/>

<TD>UINT32 </TD>

<TD>*readdata); </TD>
</TR>

<TR>
<TD>UINT32 (*rioConfigurationWrite) </TD>

<TD>( </TD>

<TD>UINT8 </TD>

<TD>localport, </TD>
</TR>

<TR>
<TD/>

<TD/>

<TD>UINT16 </TD>

<TD>destid, </TD>
</TR>

<TR>
<TD/>

<TD/>

<TD>UINT8 </TD>

<TD>hopcount, </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>UINT32 offset, UINT32 *writedata); } RDCDAR_PLAT_OPS; </P>

<P>typedef struct RDCDAR_OPS_STRUCT {
UINT32 specversion;
UINT32 (*rioDarInitialize) (...); 
UINT32 (*rioDarTerminate) (...);
UINT32 (*rioDarTestMatch) (...); 
UINT32 (*rioDarRegister) (...); 
UINT32 (*rioDarGetSwitchInfo) (...);
UINT32 (*rioDarSetPortRoute) (...); 
UINT32 (*rioDarGetPortRoute) (...);
UINT32 (*rioDarGetMemorySize) (...);
</P>

<P>} RDCDAR_OPS </P>

<P>typedef struct RDCDAR_DATA_STRUCT {
UINT32 databytesallocated;
CHAR *data; 
</P>

<P>} RDCDAR_DATA </P>

<P>typedef struct RDCDAR_SWITCH_INFO_STRUCT {
BOOL useslutmodel; 
BOOL separatelutperinputport;
UINT32 maxlutentries; 
</P>

<P>} RDCDAR_SWITCH_INFO </P>

<P id="LinkTarget_31254">6.5 DAR Functions </P>

<P>The functions that must be provided for a RapidIO device-specific configuration DAR are described in the following sections. For the rioDar_nameGetFunctionTable functions, the rioDar_name portion of the function name shall be replaced by an appropriate name for the implemented driver. </P>

<P id="LinkTarget_31255">6.5.1 rioDar_nameGetFunctionTable </P>

<P>Prototype: </P>

<P>UINT32 rioDar_nameGetFunctionTable( UINT32 specversion, RDCDAR_OPS_STRUCT *darops, UINT32 maxdevices, UINT32 *darspecificdatabytes </P>

<P>) </P>

<P>Arguments: </P>

<P>specversion 	Version number of the DAR interface specificationindicating the caller’s implementation of the typedefinition structures [IN] </P>

<P>*darops 	Pointer to a structure of DAR functions that are allocated by the caller and filled in by the called
<Link>function (see Section 6.4) [OUT] </Link>
</P>

<P>maxdevices 	Maximum expected number of RapidIO devices thatmust be serviced by thisconfiguration DAR [IN] </P>

<P>*darspecificdatabytes 	Number of bytes needed by the DAR for the DARprivate data storage area [OUT] </P>

<P>Return value: </P>

<P>RIO_SUCCESS 	On successful completion </P>

<P>RapidIO Trade Association </P>

<P>Synopsis: </P>

<P>rioDar_nameGetFunctionTable() is called by a client to obtain the list of functions implemented by a RapidIO device-specific configuration DAR module. It shall be called once before enumerating the RapidIO network. </P>

<P>The specversion parameter is the version number defined by the revision level of the specification from which the 
<Link>DAR type definition structures are taken (see Section 6.4). </Link>
</P>

<P>The maxdevices parameter is an estimate of the maximum number of RapidIO devices in the network that this DAR must service. The DAR uses this estimate to determine the size required for the DAR private data storage area. The storage size is returned to the location referenced by the *darspecificdatabytes pointer. After the client calls this function, the client shall allocate a DAR private data storage area of a size no less than that indicated by*darspecificdatabytes. The client shall provide that private data storage area to rioDarInitialize(). </P>

<P id="LinkTarget_31256">6.5.2 rioDarInitialize </P>

<P>Prototype: </P>

<P>UINT32 rioDarInitialize (
UINT32 specversion, 
UINT32 maxdevices, 
RDCDAR_PLAT_OPS *platops, 
RDCDAR_DATA *privdata 
</P>

<P>) </P>

<P>Arguments: </P>

<P>specversion 	Version number of the DAR interface specificationindicating the caller’s implementation of the typedefinition structures [IN] </P>

<P>maxdevices 	Maximum expected number of RapidIO devices thatmust be serviced by this configuration DAR [IN] </P>

<P>*platops 	Pointer to a structure of platform functions for use by
<Link>the DAR (see Section 6.4) [IN] </Link>
</P>

<P>*privdata 	Pointer to structure containing DAR private data area
<Link>(see Section 6.4) [IN/OUT] </Link>
</P>

<P>Return value: </P>

<P>RIO_SUCCESS 	On successful completion </P>

<P>Synopsis: </P>

<P>rioDarInitialize() is called by a client to initialize a RapidIO device-specific configuration DAR module. This function shall be called once after calling the rioDar_nameGetFunctionTable() functions and before enumerating the RapidIO network. </P>

<P>The specversion parameter is the version number defined by the revision level of the specification from which the 
<Link>DAR type definition structures are taken (see Section 6.4). </Link>
</P>

<P>The maxdevices parameter is an estimate of the maximum number of RapidIO devices in the network that this DAR must service. The maxdevices value must be equal to the value used in the corresponding rioDar_nameGetFunctionTable() function call. The client is responsible for allocating the structure referenced by *privdata. The client is also responsible for allocating a DAR private data storage area at least as large as that specified by the rioDar_nameGetFunctionTable() call. The client must initialize the structure referenced by *privdata with the number of bytes allocated to the DAR private data storage area and with the pointer to the storage area. After calling rioDarInitialize(), the client may not deallocate the DAR private data storage area until after the rioDarTerminate() function has been called. </P>

<P id="LinkTarget_31257">6.5.3 rioDarTerminate </P>

<P>Prototype: </P>

<P>UINT32 rioDarTerminate (RDCDAR_DATA *privdata </P>

<P>RapidIO Trade Association </P>

<P>) Arguments: *privdata Pointer to structure containing DAR private data area
<Link>(see Section 6.4) [IN/OUT] </Link>
Return value: RIO_SUCCESS On successful completion Synopsis: rioDarTerminate() is invoked by a client to terminate a RapidIO device-specific configuration DAR module. This function shall be called once after all use of the DAR services is completed. After calling this function, the client may deallocate the DAR private data storage area in the structure referenced by *privdata. </P>

<P id="LinkTarget_31258">6.5.4 rioDarTestMatch </P>

<P>Prototype: UINT32 rioDarTestMatch (RDCDAR_DATA *privdata, UINT8 localport, UINT32 destid, UINT8 hopcount ) Arguments: *privdata Pointer to structure containing DAR private data area</P>

<P>
<Link>(see Section 6.4) [IN/OUT] </Link>
localport Local port number used to access the network [IN] destid Destination device ID for the target device [IN] hopcount Number of switch hops needed to reach the target</P>

<P>device [IN] </P>

<P>Return value: RIO_SUCCESS Device DAR does provide services for this device RIO_ERR_NO_DEVICE_SUPPORT Device DAR does not provide services for this device. </P>

<P>Synopsis: rioDarTestMatch() is invoked by a client to determine whether or not a RapidIO device-specific configuration DAR module provides services for the device specified by destid. The DAR interrogates the device (using the platform</P>

<P>functions supplied during DAR initialization), examines the device identity and any necessary device registers, anddetermines whether or not the device is handled by the DAR. The DAR does not assume that a positive match (return value of 0) means the DAR will actually provide services for the </P>

<P>device. The client must explicitly register the device with rioDARregister() if the client will be requesting services. A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31259">6.5.5 rioDarRegister </P>

<P>Prototype: </P>

<P>UINT32 rioDarRegister (
RDCDAR_DATA *privdata, 
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
</P>

<P>) </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TD>Arguments: </TD>

<TD/>
</TR>

<TR>
<TD>*privdata </TD>

<TD>
<Link>Pointer to structure containing DAR private data area(see Section 6.4) [IN/OUT] </Link>
</TD>
</TR>

<TR>
<TD>localport </TD>

<TD>Local port number used to access the network [IN] </TD>
</TR>

<TR>
<TD>destid </TD>

<TD>Destination device ID for the target device [IN] </TD>
</TR>

<TR>
<TD>hopcount </TD>

<TD>Number of switch hops needed to reach the targetdevice [IN] </TD>
</TR>

<TR>
<TD>Return value: </TD>

<TD/>
</TR>

<TR>
<TD>RIO_SUCCESS </TD>

<TD>Device DAR successfully registered this device. </TD>
</TR>
</Table>

<P>RIO_ERR_NO_DEVICE_SUPPORT Device DAR does not provide services for this device. RIO_ERR_INSUFFICIENT_RESOURCES Insufficient storage available in DAR private storage area Synopsis: rioDarRegister() is invoked by a client to register a target device with a RapidIO device-specific configuration DAR. </P>

<P>The client must call this function once for each device serviced by the DAR. The client should first use the 
rioDarTestMatch() function to verify that the DAR is capable of providing services to the device. 
A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. 
</P>

<P id="LinkTarget_31260">6.5.6 rioDarGetMemorySize </P>

<P>Prototype: </P>

<P>UINT32 rioDarGetMemorySize (RDCDAR_DATA UINT8 UINT32 UINT8 UINT32 UINT32 UINT32 UINT32 </P>

<P>) </P>

<P>Arguments: </P>

<P>*privdata </P>

<P>localport </P>

<P>destid </P>

<P>hopcount </P>

<P>regionix </P>

<P>*nregions </P>

<P>*regbytes </P>

<P>*startoffset </P>

<P>Return value: </P>

<P>RIO_SUCCESS *privdata, localport, destid, hopcount, regionix, *nregions, *regbytes[2], *startoffset[2] </P>

<P>Pointer to structure containing DAR private data area
<Link>(see Section 6.4) [IN/OUT] </Link>
</P>

<P>Local port number used to access the network [IN] </P>

<P>Destination device ID for the target device [IN] </P>

<P>Number of switch hops needed to reach the targetdevice [IN] </P>

<P>Index of the memory region being queried (0, 1, 2, 3,...) [IN] </P>

<P>Number of memory regions provided by the targetdevice [OUT] </P>

<P>Size (in bytes) of the queried memory region [OUT] </P>

<P>Starting address offset for the queried memory region[OUT] </P>

<P>Device DAR successfully returned memory size </P>

<P>RapidIO Trade Association </P>

<P>information for the target device. </P>

<P>RIO_ERR_NO_DEVICE_SUPPORT Device DAR could not determine memory sizeinformation for the target device. </P>

<P>Synopsis: </P>

<P>rioDarGetMemorySize() is invoked by a client to determine the number of, the sizes of, and the offsets for the memory regions supported by a RapidIO target device. The function is intended to support the mapping of PCI or other address windows to RapidIO devices. If the regionix parameter is greater than the number of regions provided by the device (*nregions), the DAR should return a value of zero for the *regbytes and *startoffset parameters, and indicate a “successful” (0) return code. </P>

<P>rioDarGetMemorySize always returns at least one region. The first index, index 0, always refers to the region controlled by the Local Configuration Space Base Address Registers. </P>

<P>The client must register the target device with the RapidIO device-specific configuration DAR before calling this function. </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P id="LinkTarget_31261">6.5.7 rioDarGetSwitchInfo </P>

<P>Prototype: </P>

<P>UINT32 rioDarGetSwitchInfo (
RDCDAR_DATA *privdata, 
UINT8 localport, 
UINT32 destid, 
UINT8 hopcount, 
RDCDAR_SWITCH_INFO *info 
</P>

<P>) </P>

<P>Arguments: </P>

<P>*privdata 	Pointer to structure containing DAR private data area
<Link>(see Section 6.4) [IN/OUT] </Link>
</P>

<P>localport 	Local port number to be used to access network [IN] </P>

<P>destid 	Destination device ID to reach target switch device[IN] </P>

<P>hopcount 	Number of switch hops to reach target switch device[IN] </P>

<P>*info 	Pointer to switch information data structure (see
<Link>Section 6.4) [OUT] </Link>
</P>

<P>Return value: </P>

<P>RIO_SUCCESS 	Device DAR successfully retrieved the informationfor RDCDAR_PLAT_OPS_STRUCT. </P>

<P>RIO_ERR_NO_DEVICE_SUPPORT	 Insufficient switch routing resources available. </P>

<P>RIO_ERR_NO_SWITCH 	Target device is not a switch. </P>

<P>Synopsis: </P>

<P>rioDarGetSwitchInfo() is invoked by a client to retrieve the data necessary to initialize the 
RDCDAR_SWITCH_INFO structure. 
</P>

<P>The client must register the target device with the RapidIO device-specific configuration DAR before calling this function. </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31262">6.5.8 rioDarSetPortRoute </P>

<P>Prototype: </P>

<P>UINT32 rioDarSetPortRoute (RDCDAR_DATA UINT8 UINT32 UINT8 UINT8 UINT16 UINT8 </P>

<P>) </P>

<P>Arguments: </P>

<P>*privdata </P>

<P>localport 
destid 
</P>

<P>hopcount </P>

<P>inport 
tableidx 
</P>

<P>routedestid </P>

<P>routeportno </P>

<P>Return value: 
RIO_SUCCESS 
</P>

<P>RIO_ERR_NO_DEVICE_SUPPORTRIO_ERR_ROUTE_ERROR RIO_ERR_NO_SWITCH </P>

<P>*privdata, localport, destid, hopcount, tableidx, routedestid, routeportno </P>

<P>Pointer to structure containing DAR private data area
<Link>(see Section 6.4) [IN/OUT] </Link>
</P>

<P>Local port number to be used to access network [IN] </P>

<P>Destination device ID to reach target switch device[IN] </P>

<P>Number of switch hops to reach target switch device[IN] </P>

<P>Target switch device input port [IN] </P>

<P>Routing table index for per-port switchimplementations [IN] </P>

<P>Route destination ID—used to select an entry into thespecified routing table [IN] </P>

<P>Route port number—value written to the selectedrouting table entry [IN] </P>

<P>Device DAR successfully modified the packet routingconfiguration for the target switch device. </P>

<P> Insufficient switch routing resources available. </P>

<P>Switch cannot support requested routing. </P>

<P>Target device is not a switch. </P>

<P>RIO_ERR_FEATURE_NOT_SUPPORTED Target device is not capable of per-input-port routing. Synopsis: </P>

<P>rioDarSetPortRoute() is invoked by a client to modify the packet routing configuration for a RapidIO target switch device. The client must register the target device with the RapidIO device-specific configuration DAR before calling this </P>

<P>function. </P>

<P>A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. </P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31263">6.5.9 rioDarGetPortRoute </P>

<P>Prototype: UINT32 rioDarGetPortRoute (RDCDAR_DATA *privdata, UINT8 localport, UINT32 destid, UINT8 hopcount, UINT8 tableidx, UINT16 routedestid, UINT8 *routeportno ) Arguments: *privdata Pointer to structure containing DAR private data area</P>

<P>
<Link>(see Section 6.4) [IN/OUT] </Link>
localport Local port number to be used to access network [IN] destid Destination device ID to reach target switch device</P>

<P>[IN] hopcount Number of switch hops to reach target switch device[IN] tableidx Routing table index for per-port switchimplementations [IN] routedestid Route destination ID—used to select an entry into thespecified routing table [IN] *routeportno Route port number—pointer to value read from theselected routing table entry [OUT] Return value: RIO_SUCCESS Device DAR successfully modified the packet routing</P>

<P>configuration for the target switch device. RIO_ERR_NO_DEVICE_SUPPORT Insufficient switch routing resources available. RIO_ERR_ROUTE_ERROR Switch cannot support requested routing. RIO_ERR_NO_SWITCH Target device is not a switch. </P>

<P>Synopsis: </P>

<P>rioDarGetPortRoute() is invoked by a client to read the packet routing configuration for a RapidIO target switch 
device. 
The client must register the target device with the RapidIO device-specific configuration DAR before calling this 
</P>

<P>function. 
A destid value of HOST_REGS and hopcount of 0 results in accesses to the local hosts RapidIO registers. 
</P>

<P>RapidIO Trade Association </P>

<P id="LinkTarget_31264">Annex A System Bring Up Guidelines </P>

<P id="LinkTarget_31265">A.1 Introduction </P>

<P>The RapidIO Annex 1: Software/System Bring Up Specification Rev. 1.3 defines a standard set of software API functions for use in system enumeration and initialization. These API functions enable up to two RapidIO hosts to cooperatively enumerate and configure a RapidIO network. </P>

<P>This appendix is provided as a reference model for the system bring up process. An algorithm is presented that enables up to two cooperating host processors in a Rapid IO system to enumerate the entire network, set up a route to every system node, and enable the booting software to start the next boot-process phase. The actual implementation of the algorithm used to bring up a RapidIO network can vary greatly from this model in both capability and complexity. </P>

<P id="LinkTarget_31266">A.2 Overview of the System Bring Up Process </P>

<P>This section presents a high-level overview of the system bring up process. </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title>
<Link> The system is powered on. Refer to Chapter 2, “Requirements for System </Link>

<Link>Bring Up</Link>
” for the system power-on requirements. </LI_Title>
</LI>

<LI>
<LI_Label>2.</LI_Label>

<LI_Title> The host processor fetches the initial boot code (if necessary). If two processors are present, both can fetch the initial boot code. </LI_Title>
</LI>

<LI>
<LI_Label>3.</LI_Label>

<LI_Title> The system exploration and enumeration algorithm is started. The algorithm 
<Link>for this process is outlined in Section A.3 on page 42. </Link>
</LI_Title>
</LI>

<LI>
<LI_Label>4.</LI_Label>

<LI_Title> All devices have been enumerated and stored in the device database, and routes have been set up between the host device and all end point devices. The enumeration process may optionally choose to do the following: </LI_Title>
</LI>
</L>

<P>a) Compute and configure optimal routes between the host device and end point devices, and between different end point devices. </P>

<P>b) Configure the switch devices with the optimal route information. c) Store the optimal route and alternate route information in the device database. </P>

<P>5. The address space is mapped. The host may access the network across a host-RapidIO bridge or host-PCI bridge. The address-space mapping across this bridge must be done when devices are enumerated and stored in the device database. This allows the address of a found device to be retrieved later </P>

<P>and presented to the device access routines during operating system (OS) initialization. The pseudocode for this process is as follows: </P>

<P>1 ACQUIRE the host bridge address-space requirement 
2 MAP the address space into a host address partition X 
3 FOR every device in the database 
</P>

<P>RapidIO Trade Association </P>

<P>41 </P>

<P>4 IF the component is a RapidIO device 5 ACQUIRE the device’s address-space requirement 6 MAP the address space into a new host address partition 7 EXPAND the partition X window to cover the new partition 8 UPDATE the device database with the new host address 9 ELSE IF the component is a PCI bridge 10 ACQUIRE the bridge’s PCI bus ID 11 ACQUIRE the bridge’s address-space requirement 12 // All devices that appear behind this PCI bridge must have their address spaces </P>

<P>// mapped within the region specified for this bridge. 
13 MAP the address space into a new host address partition 
14 EXPAND the partition X window to cover the new partition 
15 UPDATE the device database with the new host address 
16 ENDIF 
17 ENDFOR 
</P>

<P>After discovery has been concluded, it is expected that the majority of systems will then attempt to load in a software image from a boot device. </P>

<P id="LinkTarget_31267">A.3 System Enumeration Algorithm </P>

<P>The system enumeration algorithm is designed for use by one or two host processors. The outline of the algorithm is as follows: </P>

<L>
<LI>
<LI_Label>1.</LI_Label>

<LI_Title> Access the RapidIO network. This step may involve generating special transaction cycles to ensure that the RapidIO network is accessible. </LI_Title>
</LI>

<LI>
<LI_Label>2. </LI_Label>

<LI_Title>Discover the host and assign a device ID to it. </LI_Title>
</LI>

<LI>
<LI_Label>3.</LI_Label>

<LI_Title> Discover the neighbor, if present. </LI_Title>
</LI>

<LI>
<LI_Label>4.</LI_Label>

<LI_Title> If necessary, repeat the previous step recursively to discover additional devices. </LI_Title>
</LI>

<LI>
<LI_Label>5.</LI_Label>

<LI_Title> Clear up. </LI_Title>
</LI>
</L>

<P>When a host begins exploring, it must acquire the Host Base Device ID Lock before it can proceed. Once acquired, it can set its device ID and discover its neighbor (if necessary). </P>

<P>If two hosts are used, both can execute the enumeration algorithm. However, only one host (the one with higher priority) can win the enumeration task. The losing host enters a wait state. The guidelines for prioritizing hosts to enumerate the network and restarting enumeration should the winning host fail to complete the task are described in 
<Link>Chapter 2, “Requirements for System Bring Up,” on page 9. </Link>
</P>

<P>The enumeration algorithm described below sets priority based on the value of the power-on device ID. The winning host is the device with the higher power-on host device ID. The losing host has the lower power-on host device ID. The losing host enters a wait state until the winning host completes enumeration or until the wait state times out. </P>

<P>The prioritization mechanism never results in a deadlock if the priorities of both host </P>

<P>RapidIO Trade Association </P>

<P>processors are unique. The enumeration process is initially performed in parallel by both hosts until they meet at a device. When a meeting occurs, prioritization guarantees one winning host—the other host retreats (enters a wait state). </P>

<P>The enumeration algorithm described below uses a recursive, depth-first graph traversal to discover the network. It may be possible to improve the algorithm using non-recursive or breadth-first graph traversal. However, those improvements and optimizations are implementation dependent and beyond the scope of this document. </P>

<P id="LinkTarget_31268">A.3.1 Data Structures, Constants, and Global Variables </P>

<P>This section outlines the data structures, constants, and global variables used by the system enumeration algorithm pseudocode. </P>

<P>The example system is composed of only 8 bit capable devices. </P>

<P>Data Structures </P>

<P>struct rioRouteTable { </P>

<P>// The switch routing table is implemented as a linear routing table for destination IDs. The table is// indexed using the destination ID and the table index range is equal to the maximum destination ID// value. The value of a table entry indicates the output port number used to route messages for the// destination ID. The table entry default value is implementation dependent. Table entries must be// initialized to support FLASH memory accesses. The algorithm pseudocode described in this// document assumes the device ID is equal to the RapidIO protocols destination ID. This assignment// is not a general requirement. </P>

<P>UINT8 LFT[MAX_DEVICEID]; } </P>

<P>struct rioSwitch { </P>

<Table>
<TR>
<TH/>

<TH>… </TH>
</TR>

<TR>
<TD/>

<TD>UINT16 SwitchIdentity; UINT16 hopCount; UINT16 DeviceID; struct rioRouteTable RouteTable; </TD>

<TD>// Switch Identity// Hop Count to reach this switch // Associated Device ID in the path to this switch // Switch Routing Table </TD>
</TR>

<TR>
<TD/>

<TD>… </TD>

<TD/>
</TR>

<TR>
<TD>} </TD>

<TD/>

<TD/>
</TR>
</Table>

<P>Constants </P>

<P>RIO_GEN_DFLT_DID 0x00FFFFFF 	// RIO_GEN_DFLT_DID is the general default device// ID assigned to non-host and non-boot code end// points</P>

<P>RIO_BOOT_DFLT_DID 0x0000FFFE // RIO_BOOT_DFLT_DID is the default device ID// assigned to boot code devices RIO_HOST_DFLT_DID 0x00000000 // RIO_HOST_DFLT_DID is the default device ID// assigned to host devices </P>

<P>Global Variables </P>

<P>UINT16 DeviceID = 0; 	// Currently available Device ID to be assigned to the// end point device </P>

<P>UINT16 SwitchID = 0; 	// Currently available Switch ID. This is used// internally by the to index// switches that have been discovered. </P>

<P>RapidIO Trade Association </P>

<P>// The following global arrays are used to store device// information// collected from rioGetFeatures and // rioGetSwitchPortInfo. They are// also used to store the hopCount and DeviceID// assigned to switches. </P>

<P>struct rioSwitch Switches[MAX_SWITCHES]; </P>

<P id="LinkTarget_31269">A.3.2 Pseudocode </P>

<P>This section outlines the detailed pseudocode for the system enumeration algorithm. </P>

<P>1 //********************************************************************** 2 // System enumeration and initialization using the power-on device ID as the hostDeviceID 3 // —Discover the host first 4 // —Discover the host’s neighbor recursively 5 6 STATUS rioSystemEnumerate (hostDeviceID) 7 { 8 // Discover the host first. 9 status = rioEnumerateHost (hostDeviceID); 10 11 if (status == ERR_SLAVE) { 12 rioClearUp (hostDeviceID); 13 return ERR_SLAVE; 14 } 15 16 // Discover the host neighbor 17 status = rioEnumerateNeighbor (hostDeviceID, hopCount = 1); 18 19 if (status == ERR_SLAVE) { 20 rioClearUp (hostDeviceID); 21 return ERR_SLAVE; 22 } 23 24 // If the code advances to this point successfully, the host must acquire the 25 // HostBaseDeviceIdLock for all devices in the system. When this is done, the Discovered bit 26 // Master Enable bit, etc. can be set for all devices. 27 28 } // end rioSystemEnumerate 29 30 //********************************************************************** 31 // System Delay 32 // —Wait for other host to release the lock 33 34 rioDelay () { 35 } // end rioDelay 36 37 //********************************************************************** 38 // Host enumeration and initialization 39 40 STATUS rioEnumerateHost (hostDeviceID) 41 { 42 // Try to acquire the lock 43 rioAcquireDeviceLock (0, hostDeviceID, 0, hostDeviceID); 44 </P>

<P>RapidIO Trade Association </P>

<Table>
<TR>
<TH>RapidIO Annex 1: Software/System Bring Up Specification Rev. 1.3 </TH>
</TR>

<TR>
<TH>45</TH>

<TD> while (HostBaseDeviceIdLockCSR.HostBaseDeviceID &lt; hostDeviceID) { </TD>
</TR>

<TR>
<TH>46 </TH>

<TD>// Delay for a while </TD>
</TR>

<TR>
<TH>47</TH>

<TD> rioDelay (); </TD>
</TR>

<TR>
<TH>48 </TH>

<TD/>
</TR>

<TR>
<TH>49 </TH>

<TD>// Retry lock acquisition </TD>
</TR>

<TR>
<TH>50 </TH>

<TD>rioAcquireDeviceLock (0, hostDeviceID, 0, hostDeviceID, &amp;lockingHost); </TD>
</TR>

<TR>
<TH>51</TH>

<TD> } </TD>
</TR>

<TR>
<TH>52 </TH>

<TD/>
</TR>

<TR>
<TH>53 </TH>

<TD>// Check to see if there is a master with a larger host device ID </TD>
</TR>

<TR>
<TH>54 </TH>

<TD>if (HostBaseDeviceIdLock.HostBaseDeviceID &gt; hostDeviceID) { </TD>
</TR>

<TR>
<TH>55 </TH>

<TD>// Release the current lock </TD>
</TR>

<TR>
<TH>56 </TH>

<TD>rioReleaseDeviceLock (0, hostDeviceID, 0, hostDeviceID); </TD>
</TR>

<TR>
<TH>57 </TH>

<TD/>
</TR>

<TR>
<TH>58</TH>

<TD> return ERR_SLAVE; </TD>
</TR>

<TR>
<TH>59</TH>

<TD> } </TD>
</TR>

<TR>
<TH>60 </TH>

<TD/>
</TR>

<TR>
<TH>61 </TH>

<TD>// Lock has been acquired so enumeration can begin </TD>
</TR>

<TR>
<TH>62 </TH>

<TD/>
</TR>

<TR>
<TH>63 </TH>

<TD>// Assign the default host ID to the host </TD>
</TR>

<TR>
<TH>64 </TH>

<TD>rioSetBaseDeviceId (0, hostDeviceID, hostDeviceID); </TD>
</TR>

<TR>
<TH>65 </TH>

<TD/>
</TR>

<TR>
<TH>66 </TH>

<TD>// Increment the available device ID </TD>
</TR>

<TR>
<TH>67 </TH>

<TD>if (DeviceID == hostDeviceID) { </TD>
</TR>

<TR>
<TH>68</TH>

<TD> DeviceID ++; </TD>
</TR>

<TR>
<TH>69</TH>

<TD> } </TD>
</TR>

<TR>
<TH>70 </TH>

<TD/>
</TR>

<TR>
<TH>71</TH>

<TD> return RIO_SUCCESS; </TD>
</TR>

<TR>
<TH>72</TH>

<TD> } // end rioEnumerateHost </TD>
</TR>

<TR>
<TH>73 </TH>

<TD/>
</TR>

<TR>
<TH>74</TH>

<TD> //********************************************************************** </TD>
</TR>

<TR>
<TH>75</TH>

<TD> // Neighbor enumeration </TD>
</TR>

<TR>
<TH>76 </TH>

<TD/>
</TR>

<TR>
<TH>77</TH>

<TD> STATUS rioEnumerateNeighbor (hostDeviceID, hopCount) </TD>
</TR>

<TR>
<TH>78</TH>

<TD> { </TD>
</TR>

<TR>
<TH>79 </TH>

<TD>// The host has already discovered this node if it currently owns the lock </TD>
</TR>

<TR>
<TH>80 </TH>

<TD>rioGetCurHostLock (0, 0, 0, &amp;owner_device_id); </TD>
</TR>

<TR>
<TH>81 </TH>

<TD>if (owner_device_id == hostDeviceID) { </TD>
</TR>

<TR>
<TH>82</TH>

<TD> return RIO_SUCCESS; </TD>
</TR>

<TR>
<TH>83</TH>

<TD> } </TD>
</TR>

<TR>
<TH>84 </TH>

<TD/>
</TR>

<TR>
<TH>85 </TH>

<TD>// Try to acquire the lock </TD>
</TR>

<TR>
<TH>86</TH>

<TD> rioAcquireDeviceLock (0, RIO_GEN_DFLT_DID, hopCount, hostDeviceID, &amp;lockingHost); </TD>
</TR>

<TR>
<TH>87 </TH>

<TD/>
</TR>

<TR>
<TH>88</TH>

<TD> while (HostBaseDeviceIdLockCSR.HostBaseDeviceID &lt; hostDeviceID) { </TD>
</TR>

<TR>
<TH>89 </TH>

<TD>// Delay for a while </TD>
</TR>

<TR>
<TH>90</TH>

<TD> rioDelay (); </TD>
</TR>

<TR>
<TH>91 </TH>

<TD/>
</TR>

<TR>
<TH>92 </TH>

<TD>// Retry lock acquisition </TD>
</TR>

<TR>
<TH>93 </TH>

<TD>rioAcquireDeviceLock(0, RIO_GEN_DFLT_DID, hopCount, hostDeviceID, </TD>
</TR>

<TR>
<TH/>

<TD>&amp;lockingHost); </TD>
</TR>

<TR>
<TH>94</TH>

<TD> } </TD>
</TR>

<TR>
<TH>95 </TH>

<TD/>
</TR>

<TR>
<TH>96 </TH>

<TD>// Check to see if there is a master with a larger host device ID </TD>
</TR>

<TR>
<TH>97 </TH>

<TD>if (HostBaseDeviceIdLock.HostBaseDeviceID &gt; hostDeviceID) { </TD>
</TR>

<TR>
<TH>98</TH>

<TD> return ERR_SLAVE; </TD>
</TR>

<TR>
<TH>99</TH>

<TD> } </TD>
</TR>
</Table>

<P>RapidIO Trade Association </P>

<P>100 101 // Lock has been acquired so enumeration can begin 102 103 // Check Source Operation CAR and Destination Operation CAR to see if a Device ID can be 104 // assigned 105 106 rioGetSourceOps (0, RIO_GEN_DFLT_DID, hopCount, &amp;SourceOperationCAR); 107 rioGetDestOps (0, RIO_GEN_DFLT_DID, hopCount, &amp;DestinationOperationCAR); 108 109 if ( (SourceOperationCAR.Read || Write || Atomic) &amp;&amp; 110 (DestinationOperationCAR.Read || Write || Atomic)) { 111 112 // Set the device ID 113 rioSetBaseDeviceId (0, RIO_GEN_DFLT_DID, DeviceID); 114 115 // Increment the available device ID 116 DeviceID ++; 117 if (DeviceID == hostDeviceID) { 118 DeviceID ++; 119 } 120 } 121 122 // Check to see if the device is a switch 123 rioGetFeatures (0, RIO_GEN_DFLT_DID, hopCount, &amp;ProcessingElementFeatureCAR); 124 if (ProcessingElementFeatureCAR.Switch == TRUE) { 125 126 // Read the switch information 127 rioGetSwitchPortInfo (0, RIO_GEN_DFLT_DID, hopCount, </P>

<P>&amp;SwitchPortInformationCAR); 128 129 // Record the switch device identity 130 Switches[SwitchID].SwitchIdentity = DeviceIdentityCAR.DeviceIdentity; 131 132 // Bookkeeping for the current switch ID 133 curSwitchID = SwitchID; 134 135 // Increment the available switch ID 136 SwitchID ++; 137 138 // Initialize the current switch routing table to add entries for all previously discovered 139 // devices so that they are routed correctly. Start with the host device ID (0x00) and end with 140 // DeviceID-1. 141 for (each deviceID in [0..DeviceID-1]) { 142 rioRouteAddEntry (0, RIO_GEN_DFLT_DID, hopCount, RIO_GEN_DFLT_DID, </P>

<P>deviceID, 143 SwitchPortInformationCAR.PortNumber, NULL); 144 } 145 146 // Synchronize the current switch routing table with the global table 147 for (each deviceID in [0.. DeviceID-1]) { 148 Switches[curSwitchID].RouteTable.LFT[deviceID] = 149 SwitchPortInformationCAR.PortNumber; 150 } 151 152 // Update the hopCount to reach the current switch 153 Switches[curSwitchID].HopCount = hopCount; </P>

<P>RapidIO Trade Association </P>

<P>154 
155 for (each portNum in SwitchPortInformationCAR.PortTotal) { 
156 if (SwitchPortInformationCAR.PortNumber == portNum) { 
157 continue; 
158 } 
159 
160 // Bookkeeping for the current available device ID 
161 curDeviceID = DeviceID; 
162 
163 rioGetPortErrStatus (0, RIO_GEN_DFLT_DID, hopCount, 
</P>

<P>&amp;PortErrorStatusCSR[portNum]); 164 165 // Check if it is possible to have a neighbor 166 if (PortErrorStatusCSR[portNum].PortUninitialized == TRUE) { 167 continue; 168 } 169 170 else if (PortErrorStatusCSR[portNum].PortOK == TRUE) { 171 172 // Check if it is an enumeration boundary port 173 if (PortControlCSR[portNum].PortEnumerationBoundary == TRUE) { 174 continue; 175 } 176 rioRouteAddEntry(0, RIO_GEN_DFLT_DID, hopCount, RIO_GEN_DFLT_DID, 0, </P>

<P>portNumber, NULL); 177 178 // Discover the neighbor recursively 179 if (status = rioEnumerateNeighbor(hopCount + 1) != RIO_SUCCESS) { 180 return status; 181 } 182 183 // If more than one end point device was found, update the current switch routing table 184 // entries beginning with the curDeviceID entry and ending with the DeviceID-1 185 // entry. 186 if (DeviceID &gt; curDeviceID) { 187 for (each deviceID in [curDeviceID..DeviceID-1]) { 188 rioRouteAddEntry(0, RIO_GEN_DFLT_DID, hopCount, deviceID, </P>

<P>portNumber); 189 } 190 191 // Synchronize the current switch routing table with the global table 192 for (each deviceID in [curDeviceID..DeviceID-1]) { 193 Switches[curSwitchID].RouteTable.LFT[deviceID] = portNumber; 194 } 195 196 // Update the associated Device ID in the path. 197 Switches[curSwitchID].DeviceID = curDeviceID; 198 } // end if 199 } // end else if 200 } // end for 201 } // end if (ProcessingElementFeatureCAR.Switch == TRUE) 202 203 return RIO_SUCCESS; 204 </P>

<P>205 } // end rioEnumerateNeighbor 206 </P>

<P>RapidIO Trade Association </P>

<P>207 // ********************************************************************** 
208 // System clear up 
209 // —Reset the previously acquired lock because a master exists elsewhere. Use hostDeviceID to 
210 // reset the lock 
211 
212 STATUS rioClearUp (hostDeviceID) { 
213 
214 // Clear the host lock 
215 if (hostDeviceID &gt; DeviceID –1) { 
216 rioReleaseDeviceLock (0, hostDeviceID, 0, hostDeviceID); 
217 } 
218 
219 // Clear the discovered end point device lock 
220 while (DeviceID &gt;= 1) { 
221 rioReleaseDeviceLock (0, DeviceID-1, 0, hostDeviceID); 
222 DeviceID --; 
223 } 
224 
225 // Clear the discovered switch device lock 
226 while (SwitchID &gt;= 1) { 
227 rioReleaseDeviceLock (0, Switches[SwitchID–1].DeviceID, 
228 Switches[SwitchID-1].hopCount, hostDeviceID); 
229 SwitchID --; 
230 } 
231 
232 return RIO_SUCCESS; 
233 } // end rioClearUp 
</P>

<P id="LinkTarget_31270">A.4 System Bring Up Example </P>

<P>This section walks-through a system bring up example. The system described in this example is shown in 
<Link>Figure A-1. </Link>
</P>

<P>RapidIO Trade Association </P>

<Link><Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_253.jpg"/>
Figure A-1. Example System Referring to Figure A-1, system Host A is preloaded with device ID 0x00 and system Host B is preloaded with device ID 0x01. Host A is configured to accept maintenance packets with destination IDs of 0x00 and 0xFF. Host B is configured to accept maintenance packets with destination IDs of 0x01 and 0xFF. System Bring Up advances through time slots along the following timeline: T+0 T+1 T+2 T+3 T+4 T+5 T+6 T+7 System Host A Microprocessor Host RapidO Bridge Board Switch System Host BMicroprocessor Host RapidO Bridge Board Switch High-Speed I/O Card Ethernet RapidIo to RapidO to PCI/X Bridge PCI/X Bridge ATM DSP DSP RapidIo to PCI/X Bridge DSP Farm DSP DSP Board Interconnect Switch (Midplane Switch) 0 12 3 4 </Figure>
<Figure>

<ImageData src="images/RapidIO 1.3 Specification Stack_img_254.jpg"/>
</Figure>
</Link>

<P>The time slots shown above are defined as follows: </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>T+0: Host A begins RapidIO enumeration. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>T+1: Host B begins RapidIO enumeration and Host A continues RapidIO enumeration. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>T+2: Host B discovers another host in the system (Host A) and waits. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>T+3: Host A discovers a higher priority host in the system (Host B) and retreats. </LI_Title>
</LI>
</L>

<P>RapidIO Trade Association </P>

<L>
<LI>
<LI_Label>• </LI_Label>

<LI_Title>T+4: Host B assumes sole enumeration of the system. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>T+5: Host B enumerates the PE on switch port 1. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>T+6: Host B enumerates the PEs on switch ports 2, 3 and 4. </LI_Title>
</LI>

<LI>
<LI_Label>• </LI_Label>

<LI_Title>T+7: System enumeration is complete. </LI_Title>
</LI>
</L>

<P>The following describes the actions taken during each time slot in more detail: </P>

<P>Time T+0 </P>

<P>Host A attempts to acquire the lock from its Host Base Device ID Lock CSR by writing 0x00 to the CSR. Host A confirms it has acquired the lock when it reads the value of 0x00 (the host device ID) from the Lock CSR. Host A continues by reading the Processing Element Features CAR and adding the information from the CAR to its RapidIO device database. Host A updates its Base Device ID CSR with the host device ID (0x00). </P>

<P>Time T+1 </P>

<P>Host B attempts to acquire the lock from its Host Base Device ID Lock CSR by writing 0x01 to the CSR. Host B confirms it has acquired the lock when it reads the value of 0x01 (the host device ID) from the Lock CSR. Host B continues by reading the Processing Element Features CAR and adding the information from the CAR to its RapidIO device database. Host B updates its Base Device ID CSR with the host device ID (0x01). </P>

<P>Host A begins neighbor enumeration. It attempts to acquire the lock from the Host Base Device ID Lock CSR of the Board Interconnect Switch. A maintenance write of the host device ID (0x00), the destination device ID (0xFF), and the hop count (0) is issued for the Lock CSR. Host A confirms it has acquired the lock when it reads the value of 0x00 (the host device ID) from the Lock CSR. </P>

<P>Time T+2 </P>

<P>Host B begins neighbor enumeration. It attempts to acquire the lock from the Host Base Device ID Lock CSR of the Board Interconnect Switch. A maintenance write of the host device ID (0x01), the destination device ID (0xFF), and the hop count (0) is issued for the Lock CSR. However, after Host B issues a maintenance read from the Lock CSR it finds that the device was already locked by host device ID 0x00. Because Host B has a higher priority than the current lock holder (0x01 is greater than 0x00), Host B spins in a delay loop and repeatedly attempts to acquire the lock. </P>

<P>Time T+3 </P>

<P>Host A continues neighbor enumeration. It issues a maintenance read cycle to the Device Identity CAR of the Board Interconnect Switch and looks for a matching entry in the device database. Device configuration continues because no match is found (Host A has not enumerated the device). Host A reads the Source Operations and Destination Operations CARs for the device. It is determined that the device </P>

<P>RapidIO Trade Association </P>

<P>does not support read/write/atomic operations and does not require a device ID. Host A reads the Processing Element Feature CAR for the device and determines that it is a switch element. </P>

<P>Because the device is a switch, Host A reads the Switch Port Information CAR and records the device identity in the switch database. Next, Host A adds a set of entries to the switch's routing table. For each previously discovered device ID, an entry is created containing a target ID (0xFF), hop count (0), and the route port number (from the Switch Port Information CAR). The switch database is updated with the same routing information. Host A reads the Port Error Status CSR for switch port 0, verifying that it is possible for the port to have a neighbor PE. An entry is created in the switch’s routing table containing target ID (0xFF), hop count (0), and the route port number (0). </P>

<P>Host A continues neighbor enumeration using a hop count of 1. It attempts to acquire the lock from the Host Base Device ID Lock CSR of the neighbor PE on port </P>

<P>0. A maintenance write of the host device ID (0x00), the destination device ID (0xFF), and the hop count (1) is issued for the Lock CSR. However, after Host B issues a maintenance read from the Lock CSR it finds that the device was already locked by host device ID 0x01. Because Host A has a lower priority than the current lock holder (0x00 is less than 0x01), Host A retreats. It begins the process of backing out all enumeration and configuration changes it has made. </P>

<P>Host A checks its device and switch databases to find all host locks it obtained within the system (System Host A and the Board Interconnect Switch). It issues a maintenance write transaction to their Host Base Device ID Lock CSRs to release the locks. </P>

<P>Time T+4 </P>

<P>As Host B spins in its delay loop, it attempts to acquire the lock from the Host Base Device ID Lock CSR of the Board Interconnect Switch. A maintenance write of the host device ID (0x01), the destination device ID (0xFF), and the hop count (0) is issued for the Lock CSR. Because Host A released the lock, Host B is able to confirm it has acquired the lock when it reads the value of 0x01 from the Lock CSR. </P>

<P>Host B continues neighbor enumeration. It issues a maintenance read cycle to the Device Identity CAR of the Board Interconnect Switch and looks for a matching entry in the device database. Device configuration continues because no match is found (Host B has not enumerated the device). Host B reads the Source Operations and Destination Operations CARs for the device. It is determined that the device does not support read/write/atomic operations and does not require a device ID. Host B reads the Processing Element Feature CAR for the device and determines that it is a switch element. </P>

<P>Because the device is a switch, Host B reads the Switch Port Information CAR and records the device identity in the switch database. Next, Host B adds a set of entries to the switch's routing table. For each previously discovered device ID, an entry is </P>

<P>RapidIO Trade Association </P>

<P>created containing a target ID (0xFF), hop count (0), and the route port number (from the Switch Port Information CAR). The switch database is updated with the same routing information. Host B reads the Port Error Status CSR for switch port 0, verifying that it is possible for the port to have a neighbor PE. An entry is created in the switch’s routing table containing target ID (0xFF), hop count (0), and the route port number (0). Host B detects that it is attached to port 0. Because Host B has already been enumerated, neighbor enumeration continues on the next port. </P>

<P>Time T+5 </P>

<P>Host B reads the Port Error Status CSR for switch port 1, verifying that it is possible for the port to have a neighbor PE. An entry is created in the switch’s routing table containing target ID (0xFF), hop count (0), and the route port number (1). </P>

<P>Host B continues neighbor enumeration using a hop count of 1. It attempts to acquire the lock from the Host Base Device ID Lock CSR of the neighbor PE on port 1. A maintenance write of the host device ID (0x01), the destination device ID (0xFF), and the hop count (1) is issued for the Lock CSR. Host B confirms it has acquired the lock when it reads the value of 0x01 from the Lock CSR. </P>

<P>Host B issues a maintenance read cycle to the Device Identity CAR of the DSP Farm and looks for a matching entry in the device database. Device configuration continues because no match is found (Host B has not enumerated the device). Host B reads the Source Operations and Destination Operations CARs for the device. It is determined that the device supports read/write/atomic operations. A maintenance write is used to update the Base Device ID CSR with the value of 0x00 (the first available device ID). DeviceID is incremented and compared with the Host B device ID. Because they are equal, deviceID is assigned the next available device ID. </P>

<P>Time T+6 </P>

<P>The process described in the previous step (Time T+5) is repeated on switch ports 2–4. Device IDs 0x02, 0x03, and 0x04 are assigned to the PEs on switch ports 2, 3 and 4, respectively. </P>

<P>Time T+7 </P>

<P>Host A detects that its Host Base Device Lock CSR has been acquired by another host device, indicating it has been enumerated. Host A can initiate passive discovery to build a local system database. </P>

<P>RapidIO Trade Association </P>

<P>Glossary of Terms and Abbreviations 
</P>

<P>The glossary contains an alphabetical list of terms, phrases, and abbreviations used in this book. </P>

<P>Application programming interface (API.). A standard software interface</P>

<P>A </P>

<P>that promotes portability of application programs across multiple devices. </P>

<P>Capability registers (CARs). High-speed memory containing recently accessed data and/or instructions (subset of main memory) associated with a processor. </P>

<P>Command and status registers (CSRs). A set of registers that allows a processing element to control and determine the status of another processing element’s internal hardware. </P>

<P>D Destination. The termination point of a packet on the RapidIO interconnect, also referred to as a target. </P>

<P>Device. A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a processing element. </P>

<P>Device ID. The identifier of an end point processing element connected to the RapidIO interconnect. </P>

<P>Discovery. The passive exploration of a RapidIO network fabric.  This process involves walking an already enumerated RapidIO fabric to determine network topology and resource allocations. </P>

<P>Double-word. An eight byte quantity, aligned on eight byte boundaries. </P>

<P>End point. A processing element which is the source or destination of </P>

<P>E </P>

<P>transactions through a RapidIO fabric. </P>

<P>End point device. A processing element which contains end point functionality. </P>

<P>RapidIO Trade Association </P>

<P>Enumeration. The active exploration of a RapidIO network fabric. This process involves configuring device identifiers and maintaining proper host locking. </P>

<Table>
<TR>
<TH>H </TH>

<TD>Hardware abstraction layer (HAL). A a standard software interface to device-specific hardware resources. </TD>
</TR>

<TR>
<TH>I </TH>

<TD>Initiator. The origin of a packet on the RapidIO interconnect, also referred to as a source. </TD>
</TR>

<TR>
<TH>O </TH>

<TD>Operation. A set of transactions between end point devices in a RapidIO system (requests and associated responses) such as a read or a write. </TD>
</TR>
</Table>

<P>P 
</P>

<P>Packet. A set of information transmitted between devices in a RapidIO system. </P>

<P>Processing Element (PE). A generic participant on the RapidIO interconnect that sends or receives RapidIO transactions, also called a device. </P>

<P>Processor. The logic circuitry that responds to and processes the basic instructions that drive a computer. </P>

<P>S 
</P>

<P>Sender. The RapidIO interface output port on a processing element. </P>

<P>Source. The origin of a packet on the RapidIO interconnect, also referred to as an initiator. </P>

<P>Switch. A multiple port processing element that directs a packet received on one of its input ports to one of its output ports. </P>

<P>T 
</P>

<P>Target. The termination point of a packet on the RapidIO interconnect, also referred to as a destination. </P>

<P>Transaction. A specific request or response packet transmitted between end point devices in a RapidIO system. </P>

<P>W Word. A four byte or 32 bit quantity, aligned on four byte boundaries. </P>

<P>Write port. Hardware within a processing element that is the target of a portwrite operation. </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>

<P>Blank page </P>

<P>RapidIO Trade Association </P>
</Div>
</Sect>
</Sect>
</Part>
</TaggedPDF-doc>
