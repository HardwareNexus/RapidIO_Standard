#!/usr/bin/env python
# -*- coding: latin-1 -*-
"""
    Read in a text file and create an XLSX spreadsheet.

    Assumes that the first line of the file that contains a
    comma is a header line.

    Strips off leading and ending "'" delimiters for items in each line,
    if they exist.
"""

from optparse import OptionParser
from collections import OrderedDict
import operator
import re
import sys
import os
import logging
import copy
import glob
import time
from difflib import Differ
from constants import *
from create_translation import *
from docx import Document
from docx.shared import Inches
import codecs
import subprocess
import datetime

class bit_field(object):
    def __init__(self):
        self.bit_range = ""
        self.bit_name = ""
        self.spec_part = ""
        self.spec_section = ""

class register_summary(object):
    def __init__(self):
        self.block = ""
        self.offset = ""
        self.name = ""
        self.bits = []
    
class WordEditor(object):
    def __init__(self, text, word):
        self.text_filepath = text
        self.word_filepath = word
        self.regs = []
        self.lines = []
        self._read_text()
        self.doc = None

    def print_regs(self):
        for reg in self.regs:
            print ('\n%s' % "', '".join([reg.block, reg.offset, reg.name]))
            for bit in reg.bits:
                print ('%s' % "', '".join(
                [bit.bit_range, bit.bit_name, bit.spec_part, bit.spec_section]))

    def create_document(self):
        document = Document()

        document.add_heading('Registers Summary First Cut', 0)

        p = document.add_paragraph('Autogenerated register summary from file ')
        p.add_run(self.text_filepath).bold = True
        p.add_run('.  Generated ').bold = True
        now = datetime.datetime.now()
        p.add_run(now.strftime("%Y-%m-%d %H:%M:%S"))

        for reg in self.regs:
            document.add_page_break()
            document.add_heading(reg.name, level=1)
            document.add_paragraph(
                'Block: %s' % reg.block, style='List Bullet'
            )
            document.add_paragraph(
                'Offset: %s' % reg.offset, style='List Bullet'
            )
            document.add_paragraph(
                'Bit field table:'
            )

            table = document.add_table(rows=1, cols=4)
            hdr_cells = table.rows[0].cells
            hdr_cells[0].text = 'Bits'
            hdr_cells[1].text = 'Name'
            hdr_cells[2].text = 'Part'
            hdr_cells[3].text = 'Section'
            for bit in reg.bits:
                row_cells = table.add_row().cells
                row_cells[0].text = bit.bit_range
                row_cells[1].text = bit.bit_name
                row_cells[2].text = bit.spec_part
                row_cells[3].text = bit.spec_section
            table = None
        self.doc = document
    
    def _strip_line(self, line):
        toks = []
        if len(line):
            toks = [tok.strip() for tok in line[1:-1].split("', '")]
        return toks

    def _read_text(self):
        logging.info("Reading text file '%s'." % self.text_filepath)
        with open(self.text_filepath, 'r') as text_file:
            self.lines = [l.strip() for l in text_file.readlines()]
        col_warning = False
        reg = None

        for num, l in enumerate(self.lines):
            toks = self._strip_line(l)

            if len(toks) == 3:
                if reg is not None:
                    self.regs.append(reg)
                reg = register_summary()
                reg.block = toks[0]
                reg.offset = toks[1]
                reg.name = toks[2]
            elif len(toks) == 4:
                if reg is None:
                    raise ValueError("Missing reg header at %d!" % num);
                bit = bit_field()
                bit.bit_range = toks[0]
                bit.bit_name = toks[1]
                bit.spec_part = toks[2]
                bit.spec_section = toks[3]
                reg.bits.append(bit)
            else:
                raise ValueError("Unknown line %d %s!" % (num, l));
        if reg is not None:
            self.regs.append(reg)

    def write_document(self, file_path):
        self.doc.save(file_path)

def create_parser():
    parser = OptionParser(description="Create Excel spreadsheet based on text file.")
    parser.add_option('-t', '--textfile',
            dest = 'text_filepath',
            action = 'store', type = 'string', default = None,
            help = 'File path to text file.',
            metavar = 'FILE')
    parser.add_option('-w', '--word',
            dest = 'word_filepath',
            action = 'store', type = 'string', default = None,
            help = 'File path to new Word file.',
            metavar = 'FILE')
    return parser

def validate_options(options):
    if not os.path.isfile(options.text_filepath):
        raise ValueError("Text file '%s' does not exist." %
                         options.text_filepath)
    #if os.path.isfile(options.word_filepath):
    #    raise ValueError("File '%s' will be overwritten!" %
    #                     options.word_filepath)

def main(argv = None):
    logging.basicConfig(level=logging.WARN)
    parser = create_parser()
    if argv is None:
        argv = sys.argv[1:]

    (options, argv) = parser.parse_args(argv)
    if len(argv) != 0:
        print('Invalid argument!')
        print
        parser.print_help()
        return -1

    try:
        validate_options(options)
    except ValueError as e:
        print(e)
        sys.exit(-1)

    word = WordEditor(options.text_filepath, options.word_filepath)
    word.print_regs()
    word.create_document()
    word.write_document(options.word_filepath)

if __name__ == '__main__':
    sys.exit(main())
